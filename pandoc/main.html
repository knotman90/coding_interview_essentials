<!DOCTYPE html>
<!--
==============================================================================
           "GitHub HTML5 Pandoc Template" v2.2 — by Tristano Ajmone
==============================================================================
Copyright © Tristano Ajmone, 2017-2020, MIT License (MIT). Project's home:

- https://github.com/tajmone/pandoc-goodies

The CSS in this template reuses source code taken from the following projects:

- GitHub Markdown CSS: Copyright © Sindre Sorhus, MIT License (MIT):
  https://github.com/sindresorhus/github-markdown-css

- Primer CSS: Copyright © 2016-2017 GitHub Inc., MIT License (MIT):
  http://primercss.io/

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The MIT License

Copyright (c) Tristano Ajmone, 2017-2020 (github.com/tajmone/pandoc-goodies)
Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
Copyright (c) 2017 GitHub Inc.

"GitHub Pandoc HTML5 Template" is Copyright (c) Tristano Ajmone, 2017-2020,
released under the MIT License (MIT); it contains readaptations of substantial
portions of the following third party softwares:

(1) "GitHub Markdown CSS", Copyright (c) Sindre Sorhus, MIT License (MIT).
(2) "Primer CSS", Copyright (c) 2016 GitHub Inc., MIT License (MIT).

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
==============================================================================-->
<html>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>main</title>
  <style type="text/css">
@charset "UTF-8";.markdown-body{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;color:#24292e;font-family:-apple-system,system-ui,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";font-size:16px;line-height:1.5;word-wrap:break-word;box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto;padding:45px}.markdown-body a{color:#0366d6;background-color:transparent;text-decoration:none;-webkit-text-decoration-skip:objects}.markdown-body a:active,.markdown-body a:hover{outline-width:0}.markdown-body a:hover{text-decoration:underline}.markdown-body a:not([href]){color:inherit;text-decoration:none}.markdown-body strong{font-weight:600}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin-top:24px;margin-bottom:16px;font-weight:600;line-height:1.25}.markdown-body h1{font-size:2em;margin:.67em 0;padding-bottom:.3em;border-bottom:1px solid #eaecef}.markdown-body h2{padding-bottom:.3em;font-size:1.5em;border-bottom:1px solid #eaecef}.markdown-body h3{font-size:1.25em}.markdown-body h4{font-size:1em}.markdown-body h5{font-size:.875em}.markdown-body h6{font-size:.85em;color:#6a737d}.markdown-body img{border-style:none}.markdown-body svg:not(:root){overflow:hidden}.markdown-body hr{box-sizing:content-box;height:.25em;margin:24px 0;padding:0;overflow:hidden;background-color:#e1e4e8;border:0}.markdown-body hr::before{display:table;content:""}.markdown-body hr::after{display:table;clear:both;content:""}.markdown-body input{margin:0;overflow:visible;font:inherit;font-family:inherit;font-size:inherit;line-height:inherit}.markdown-body [type=checkbox]{box-sizing:border-box;padding:0}.markdown-body *{box-sizing:border-box}.markdown-body blockquote{margin:0}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol ol,.markdown-body ul ol{list-style-type:lower-roman}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:0;margin-bottom:0}.markdown-body ol ol ol,.markdown-body ol ul ol,.markdown-body ul ol ol,.markdown-body ul ul ol{list-style-type:lower-alpha}.markdown-body li>p{margin-top:16px}.markdown-body li+li{margin-top:.25em}.markdown-body dd{margin-left:0}.markdown-body dl{padding:0}.markdown-body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:600}.markdown-body dl dd{padding:0 16px;margin-bottom:16px}.markdown-body code{font-family:SFMono-Regular,Consolas,"Liberation Mono",Menlo,Courier,monospace}.markdown-body pre{font:12px SFMono-Regular,Consolas,"Liberation Mono",Menlo,Courier,monospace;word-wrap:normal}.markdown-body blockquote,.markdown-body dl,.markdown-body ol,.markdown-body p,.markdown-body pre,.markdown-body table,.markdown-body ul{margin-top:0;margin-bottom:16px}.markdown-body blockquote{padding:0 1em;color:#6a737d;border-left:.25em solid #dfe2e5}.markdown-body blockquote>:first-child{margin-top:0}.markdown-body blockquote>:last-child{margin-bottom:0}.markdown-body table{display:block;width:100%;overflow:auto;border-spacing:0;border-collapse:collapse}.markdown-body table th{font-weight:600}.markdown-body table td,.markdown-body table th{padding:6px 13px;border:1px solid #dfe2e5}.markdown-body table tr{background-color:#fff;border-top:1px solid #c6cbd1}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}.markdown-body img{max-width:100%;box-sizing:content-box;background-color:#fff}.markdown-body code{padding:.2em 0;margin:0;font-size:85%;background-color:rgba(27,31,35,.05);border-radius:3px}.markdown-body code::after,.markdown-body code::before{letter-spacing:-.2em;content:" "}.markdown-body pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:0 0;border:0}.markdown-body .highlight{margin-bottom:16px}.markdown-body .highlight pre{margin-bottom:0;word-break:normal}.markdown-body .highlight pre,.markdown-body pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f6f8fa;border-radius:3px}.markdown-body pre code{display:inline;max-width:auto;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}.markdown-body pre code::after,.markdown-body pre code::before{content:normal}.markdown-body .full-commit .btn-outline:not(:disabled):hover{color:#005cc5;border-color:#005cc5}.markdown-body kbd{box-shadow:inset 0 -1px 0 #959da5;display:inline-block;padding:3px 5px;font:11px/10px SFMono-Regular,Consolas,"Liberation Mono",Menlo,Courier,monospace;color:#444d56;vertical-align:middle;background-color:#fcfcfc;border:1px solid #c6cbd1;border-bottom-color:#959da5;border-radius:3px;box-shadow:inset 0 -1px 0 #959da5}.markdown-body :checked+.radio-label{position:relative;z-index:1;border-color:#0366d6}.markdown-body .task-list-item{list-style-type:none}.markdown-body .task-list-item+.task-list-item{margin-top:3px}.markdown-body .task-list-item input{margin:0 .2em .25em -1.6em;vertical-align:middle}.markdown-body::before{display:table;content:""}.markdown-body::after{display:table;clear:both;content:""}.markdown-body>:first-child{margin-top:0!important}.markdown-body>:last-child{margin-bottom:0!important}.Alert,.Error,.Note,.Success,.Warning{padding:11px;margin-bottom:24px;border-style:solid;border-width:1px;border-radius:4px}.Alert p,.Error p,.Note p,.Success p,.Warning p{margin-top:0}.Alert p:last-child,.Error p:last-child,.Note p:last-child,.Success p:last-child,.Warning p:last-child{margin-bottom:0}.Alert{color:#246;background-color:#e2eef9;border-color:#bac6d3}.Warning{color:#4c4a42;background-color:#fff9ea;border-color:#dfd8c2}.Error{color:#911;background-color:#fcdede;border-color:#d2b2b2}.Success{color:#22662c;background-color:#e2f9e5;border-color:#bad3be}.Note{color:#2f363d;background-color:#f6f8fa;border-color:#d5d8da}.Alert h1,.Alert h2,.Alert h3,.Alert h4,.Alert h5,.Alert h6{color:#246;margin-bottom:0}.Warning h1,.Warning h2,.Warning h3,.Warning h4,.Warning h5,.Warning h6{color:#4c4a42;margin-bottom:0}.Error h1,.Error h2,.Error h3,.Error h4,.Error h5,.Error h6{color:#911;margin-bottom:0}.Success h1,.Success h2,.Success h3,.Success h4,.Success h5,.Success h6{color:#22662c;margin-bottom:0}.Note h1,.Note h2,.Note h3,.Note h4,.Note h5,.Note h6{color:#2f363d;margin-bottom:0}.Alert h1:first-child,.Alert h2:first-child,.Alert h3:first-child,.Alert h4:first-child,.Alert h5:first-child,.Alert h6:first-child,.Error h1:first-child,.Error h2:first-child,.Error h3:first-child,.Error h4:first-child,.Error h5:first-child,.Error h6:first-child,.Note h1:first-child,.Note h2:first-child,.Note h3:first-child,.Note h4:first-child,.Note h5:first-child,.Note h6:first-child,.Success h1:first-child,.Success h2:first-child,.Success h3:first-child,.Success h4:first-child,.Success h5:first-child,.Success h6:first-child,.Warning h1:first-child,.Warning h2:first-child,.Warning h3:first-child,.Warning h4:first-child,.Warning h5:first-child,.Warning h6:first-child{margin-top:0}h1.title,p.subtitle{text-align:center}h1.title.followed-by-subtitle{margin-bottom:0}p.subtitle{font-size:1.5em;font-weight:600;line-height:1.25;margin-top:0;margin-bottom:16px;padding-bottom:.3em}div.line-block{white-space:pre-line}
  </style>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<article class="markdown-body">
<hr>
<nav id="TOC">
<h1 class="toc-title">Contents</h1>
<ul>
<li><a href="#ch:power_set">Power set generation</a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#problem-statement">Problem statement</a></li>
<li><a href="#clarification-questions">Clarification Questions</a></li>
<li><a href="#sec:powerset:discussion">Discussion</a>
<ul>
<li><a href="#bruteforce---backtracking-like-approach">Bruteforce - Backtracking-like approach</a></li>
<li><a href="#bit-manipulation">Bit Manipulation</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:square_root">Square root of an integer</a>
<ul>
<li><a href="#introduction-1">Introduction</a></li>
<li><a href="#problem-statement-1">Problem statement</a></li>
<li><a href="#clarification-questions-1">Clarification Questions</a></li>
<li><a href="#discussion">Discussion</a>
<ul>
<li><a href="#brute-force">Brute-Force</a></li>
<li><a href="#logarithmic-solution">Logarithmic Solution</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:two_string_anagram">Two string anagram</a>
<ul>
<li><a href="#introduction-2">Introduction</a></li>
<li><a href="#problem-statement-2">Problem statement</a></li>
<li><a href="#clarification-questions-2">Clarification Questions</a></li>
<li><a href="#discussion-1">Discussion</a>
<ul>
<li><a href="#sec:anagrams:bruteforce">Brute-Force</a></li>
<li><a href="#sec:anagrams:sorting">Sorting</a></li>
<li><a href="#sec:anagrams:histograms">Histograms</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:two_numbers_sum">Two numbers sum problem</a>
<ul>
<li><a href="#introduction-3">Introduction</a></li>
<li><a href="#problem-statement-3">Problem statement</a></li>
<li><a href="#clarification-questions-3">Clarification Questions</a></li>
<li><a href="#discussion-2">Discussion</a>
<ul>
<li><a href="#sec:two_numbers:bruteforce">Brute-force</a></li>
<li><a href="#sec:two_numbers:hashing">Hashing</a></li>
<li><a href="#sect:two_number_problem_binary_search">Sorting and binary search</a></li>
<li><a href="#sec:two_numbers:twopointers">Sorting and two pointers technique</a></li>
</ul></li>
<li><a href="#common-variations">Common Variations</a>
<ul>
<li><a href="#sec:four_number">Four numbers sum problem</a></li>
<li><a href="#problem-statement-4">Problem statement</a></li>
<li><a href="#naïve-on4-solution">Naïve <span class="math inline">\(O(n^4)\)</span> solution</a></li>
<li><a href="#on3-solution"><span class="math inline">\(O(n^3)\)</span> solution</a></li>
<li><a href="#on2-solution-using-hashing"><span class="math inline">\(O(n^2)\)</span> solution using hashing</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:unique_elements">Unique Elements in a collection</a>
<ul>
<li><a href="#introduction-4">Introduction</a></li>
<li><a href="#problem-statement-5">Problem statement</a></li>
<li><a href="#clarification-questions-4">Clarification Questions</a></li>
<li><a href="#discussion-3">Discussion</a>
<ul>
<li><a href="#brute-force-1">Brute Force</a></li>
<li><a href="#linear-time---hashset">Linear time - Hashset</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:greatest_right">Greatest element on the right side</a>
<ul>
<li><a href="#introduction-5">Introduction</a></li>
<li><a href="#problem-statement-6">Problem statement</a></li>
<li><a href="#clarification-questions-5">Clarification Questions</a></li>
<li><a href="#discussion-4">Discussion</a>
<ul>
<li><a href="#brute-force-2">Brute Force</a></li>
<li><a href="#sec:greatest_right:linear">Linear solution</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:string_to_int">String to Integer</a>
<ul>
<li><a href="#introduction-6">Introduction</a></li>
<li><a href="#problem-statement-7">Problem statement</a></li>
<li><a href="#clarification-questions-6">Clarification Questions</a></li>
<li><a href="#string_to_int:sec:discussion">Discussion</a>
<ul>
<li><a href="#common-variation">Common Variation</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:stairs_climbing">Climb the Stairs</a>
<ul>
<li><a href="#introduction-7">Introduction</a></li>
<li><a href="#sec:stairs_climbing_statement_easy">Problem statement</a></li>
<li><a href="#clarification-questions-7">Clarification Questions</a></li>
<li><a href="#stairs_climbing:sec:discussion">Discussion</a></li>
<li><a href="#common-variation-1">Common Variation </a>
<ul>
<li><a href="#stairs_climbing:sec:arbitrary_steps">Arbitrary step lengths</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:wave_array">Wave Array</a>
<ul>
<li><a href="#introduction-8">Introduction</a></li>
<li><a href="#problem-statement-8">Problem statement</a></li>
<li><a href="#clarification-questions-8">Clarification Questions</a></li>
<li><a href="#wave_array:sec:discussion">Discussion</a>
<ul>
<li><a href="#wave_array:sec:bruteforce">Brute-force</a></li>
<li><a href="#wave_array:sec:sorting">Sorting solution</a></li>
<li><a href="#linear-time-solution">Linear time solution</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:first_positive_missing">First positive missing</a>
<ul>
<li><a href="#introduction-9">Introduction</a></li>
<li><a href="#problem-statement-9">Problem statement</a></li>
<li><a href="#clarification-questions-9">Clarification Questions</a></li>
<li><a href="#first_positive_missing:sec:discussion">Discussion</a>
<ul>
<li><a href="#bruteforce">Bruteforce</a></li>
<li><a href="#first_positive_missing:sec:sorting">Sorting</a></li>
<li><a href="#first_positive_missing:sec:linear_space">Linear time and space solution</a></li>
<li><a href="#first_positive_missing:sec:linear_space">Linear time and constant space solution</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:exponentiation">Exponentiation</a>
<ul>
<li><a href="#introduction-10">Introduction</a></li>
<li><a href="#problem-statement-10">Problem statement</a></li>
<li><a href="#clarification-questions-10">Clarification Questions</a></li>
<li><a href="#exponentiation:sec:discussion">Discussion</a>
<ul>
<li><a href="#exponentiation:sec:fast_exponentiation">Binary fast exponentiation</a></li>
<li><a href="#iterative-implementation">Iterative implementation</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:max_sum_continguous_subarray">Max sum contiguous subarray</a>
<ul>
<li><a href="#introduction-11">Introduction</a></li>
<li><a href="#problem-statement-11">Problem statement</a></li>
<li><a href="#clarification-questions-11">Clarification Questions</a></li>
<li><a href="#max_sum_continguous_subarray:sec:discussion">Discussion</a>
<ul>
<li><a href="#sec:max_sum_continguous_subarray_bruteforce">Brute-force</a></li>
<li><a href="#max_sum_continguous_subarray:sec:bruteforce_improved">Brute-force improved</a></li>
<li><a href="#sec:kadane_algorithm">Kadane’s Algorithm</a></li>
</ul></li>
<li><a href="#common-variations-1">Common Variations</a>
<ul>
<li><a href="#minium-sum-contiguous-subarray">Minium sum contiguous subarray</a></li>
<li><a href="#longest-positivenegative-contiguous-subarray">Longest positive/negative contiguous subarray</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:string_reverse">String Reverse</a>
<ul>
<li><a href="#introduction-12">Introduction</a></li>
<li><a href="#problem-statement-12">Problem statement</a></li>
<li><a href="#clarification-questions-12">Clarification Questions</a></li>
<li><a href="#string_reverse:sec:discussion">Discussion</a></li>
<li><a href="#string_reverse:sec:variations">Common Variation</a>
<ul>
<li><a href="#out-of-place-solution">Out-of-place solution</a></li>
<li><a href="#recursive-solution">Recursive solution</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:find_odd_occurring_element">Find the odd occurring element</a>
<ul>
<li><a href="#introduction-13">Introduction</a></li>
<li><a href="#problem-statement-13">Problem statement</a></li>
<li><a href="#clarification-questions-13">Clarification Questions</a></li>
<li><a href="#discussion-5">Discussion</a>
<ul>
<li><a href="#find_odd_occurring_element:sec:bruteforce">Brute-force</a></li>
<li><a href="#find_odd_occurring_element:sec:map">Linear time and space solution</a></li>
<li><a href="#find_odd_occurring_element:sec:constant_space">Linear time and constant space solution</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:capitalize_words_first_letter">Capitalize the first letters of every words</a>
<ul>
<li><a href="#introduction-14">Introduction</a></li>
<li><a href="#problem-statement-14">Problem statement</a></li>
<li><a href="#capitalize_words_first_letter:sec:discussion">Discussion</a></li>
<li><a href="#solution-using-stdadjacent_find">Solution using <code>std::adjacent_find</code></a></li>
<li><a href="#capitalize_words_first_letter:sec:variation">Common Variations</a>
<ul>
<li><a href="#user-provided-function">User provided function</a></li>
<li><a href="#modify-the-every-kth-character-of-every-word">Modify the every <span class="math inline">\(k^{th}\)</span> character of every word</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:trapping_water">Trapping Water</a>
<ul>
<li><a href="#introduction-15">Introduction</a></li>
<li><a href="#problem-statement-15">Problem statement</a></li>
<li><a href="#trapping_water:sec:discussion">Discussion</a>
<ul>
<li><a href="#trapping_water:sec:bruteforce">Brute-force</a></li>
<li><a href="#trapping_water:sec:dp">Dynamic Programming</a></li>
<li><a href="#trapping_water:sec:two_pointers">Two pointers solution</a></li>
<li><a href="#trapping_water:sec:stack">Stack based solution</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:min_rotated_array">Minimum element in rotated sorted array</a>
<ul>
<li><a href="#introduction-16">Introduction</a></li>
<li><a href="#problem-statement-16">Problem statement</a></li>
<li><a href="#clarification-questions-14">Clarification Questions</a></li>
<li><a href="#min_rotated_array:sec:discussion">Discussion</a>
<ul>
<li><a href="#min_rotated_array:sec:bruteforce">Brute-force</a></li>
<li><a href="#min_rotated_array:sec:log">Logarithmic solution</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:search_sorted_rotated_array">Search in sorted and rotated array</a>
<ul>
<li><a href="#introduction-17">Introduction</a></li>
<li><a href="#problem-statement-17">Problem statement</a></li>
<li><a href="#clarification-questions-15">Clarification Questions</a></li>
<li><a href="#search_sorted_rotated_array:sec:discussion">Discussion</a>
<ul>
<li><a href="#search_sorted_rotated_array:sec:bruteforce">Brute-force</a></li>
<li><a href="#search_sorted_rotated_array:sec:log">Logarithmic time solution</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:verify_BST">Verify BST property</a>
<ul>
<li><a href="#introduction-18">Introduction</a></li>
<li><a href="#problem-statement-18">Problem statement</a></li>
<li><a href="#clarification-questions-16">Clarification Questions</a></li>
<li><a href="#verify_BST:sec:discussion">Discussion</a>
<ul>
<li><a href="#a-common-mistake">A common mistake</a></li>
<li><a href="#verify_BST:sec:topdown">Top Down approach</a></li>
<li><a href="#brute-force-3">Brute force</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:clone_list_random_pointer">Clone a linked list with random pointer</a>
<ul>
<li><a href="#introduction-19">Introduction</a></li>
<li><a href="#problem-statement-19">Problem statement</a></li>
<li><a href="#clarification-questions-17">Clarification Questions</a></li>
<li><a href="#clone_list_random_pointer:sec:discussion">Discussion</a>
<ul>
<li><a href="#clone_list_random_pointer:sec:bruteforce">Linear memory solution</a></li>
<li><a href="#clone_list_random_pointer:sec:interleaved_lists">Constant memory solution</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:delete_duplicates_list">Delete duplicates from Linked List</a>
<ul>
<li><a href="#introduction-20">Introduction</a></li>
<li><a href="#problem-statement-20">Problem statement</a></li>
<li><a href="#clarification-questions-18">Clarification Questions</a></li>
<li><a href="#delete_duplicates_list:sec:discussion">Discussion</a>
<ul>
<li><a href="#delete_duplicates_list:sec:bruteforce">Brute-force</a></li>
<li><a href="#delete_duplicates_list:sec:linear_space">In-place <span class="math inline">\(O(1)\)</span> space solution</a></li>
</ul></li>
<li><a href="#common-variations-and-follow-up-questions">Common Variations and follow-up questions</a></li>
</ul></li>
<li><a href="#ch:random_points_in_circle">Generate points in circle uniformly</a>
<ul>
<li><a href="#introduction-21">Introduction</a></li>
<li><a href="#problem-statement-21">Problem statement</a></li>
<li><a href="#clarification-questions-19">Clarification Questions</a></li>
<li><a href="#random_points_in_circle:sec:discussion">Discussion</a>
<ul>
<li><a href="#random_points_in_circle:sec:buggy">Polar Coordinates - The wrong approach</a></li>
<li><a href="#random_points_in_circle:sec:loop">Loop approach</a></li>
<li><a href="#random_points_in_circle:sec:polar_sqrt">Polar Coordinates - The right approach</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:buy_sell_stocks">Best time to buy and sell stock</a>
<ul>
<li><a href="#introduction-22">Introduction</a></li>
<li><a href="#sec:buy_sell_stocks:statement1">Problem statement</a></li>
<li><a href="#clarification-questions-20">Clarification Questions</a></li>
<li><a href="#buy_sell_stocks:sec:discussion">Discussion</a>
<ul>
<li><a href="#buy_sell_stocks:sec:bruteforce">Brute-force</a></li>
<li><a href="#buy_sell_stocks:sec:linear">Linear time solution</a></li>
</ul></li>
<li><a href="#sec:buy_sell_stocks:multiple_transaction">Common Variations - Multiple Transactions</a>
<ul>
<li><a href="#problem-statement-22">Problem statement</a></li>
</ul></li>
<li><a href="#buy_sell_stocks_2:sec:discussion">Discussion</a></li>
<li><a href="#buy_sell_stocks_2:sec:bruteforce">Brute force solution</a></li>
<li><a href="#buy_sell_stocks_2:sec:linear">Linear time solution</a></li>
</ul></li>
<li><a href="#ch:cycle_in_list">Find the cycle in a Linked list</a>
<ul>
<li><a href="#introduction-23">Introduction</a></li>
<li><a href="#problem-statement-23">Problem statement</a></li>
<li><a href="#cycle_in_list:sec:discussion">Discussion</a>
<ul>
<li><a href="#cycle_in_list:sec:bruteforce">Linear time and space solution</a></li>
<li><a href="#cycle_in_list:sec:slowfast">Slow and fast pointer solution - Floyd’s algorithm </a></li>
</ul></li>
</ul></li>
<li><a href="#ch:list_reverse">Reverse a singly linked list</a>
<ul>
<li><a href="#introduction-24">Introduction</a></li>
<li><a href="#problem-statement-24">Problem statement</a></li>
<li><a href="#clarification-questions-21">Clarification Questions</a></li>
<li><a href="#list_reverse:sec:discussion">Discussion</a>
<ul>
<li><a href="#constant-space">Constant space</a></li>
</ul></li>
<li><a href="#conclusion-1">Conclusion</a></li>
<li><a href="#common-variation---reserve-a-sublist">Common variation - Reserve a sublist</a>
<ul>
<li><a href="#problem-statement-25">Problem statement</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:min_stack">Min stack</a>
<ul>
<li><a href="#introduction-25">Introduction</a></li>
<li><a href="#problem-statement-26">Problem statement</a></li>
<li><a href="#clarification-questions-22">Clarification Questions</a></li>
<li><a href="#min_stack:sec:discussion">Discussion</a>
<ul>
<li><a href="#min_stack:sec:double_stack">Linear Space solutions</a></li>
<li><a href="#min_stack:sec:constantspace">Constant space</a></li>
<li><a href="#common-variations-2">Common Variations</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:majority_element">Find the majority element</a>
<ul>
<li><a href="#introduction-26">Introduction</a></li>
<li><a href="#problem-statement-27">Problem statement</a></li>
<li><a href="#clarification-questions-23">Clarification Questions</a></li>
<li><a href="#majority_element:sec:discussion">Discussion</a>
<ul>
<li><a href="#majority_element:sec:bruteforce">Brute-force</a></li>
<li><a href="#majority_element:sec:hashmap">Hash-map approach</a></li>
<li><a href="#majority_element:sec:sorting">Sorting - Counting</a></li>
<li><a href="#majority_element:sec:median">Sorting - Median</a></li>
<li><a href="#majority_element:sec:linear">Boyer-Moore algorithm</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:node_from_the_end"><span class="math inline">\(n^{th}\)</span> node from the end</a>
<ul>
<li><a href="#introduction-27">Introduction</a></li>
<li><a href="#problem-statement-28">Problem statement</a></li>
<li><a href="#clarification-questions-24">Clarification Questions</a></li>
<li><a href="#node_from_the_end:sec:discussion">Discussion</a>
<ul>
<li><a href="#node_from_the_end:sec:bruteforce">Brute-force</a></li>
<li><a href="#node_from_the_end:sec:twopointers">Two pointers</a></li>
<li><a href="#common-variation-2">Common Variation</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:valid_parenthesis">Validate Parenthesized String</a>
<ul>
<li><a href="#problem-statement-29">Problem statement</a></li>
<li><a href="#clarification-questions-25">Clarification Questions</a></li>
<li><a href="#valid_parenthesis:sec:discussion">Discussion</a>
<ul>
<li><a href="#valid_parenthesis:sec:bruteforce">Brute-force</a></li>
<li><a href="#valid_parenthesis:sec:dp">Dynamic Programming</a></li>
<li><a href="#valid_parenthesis:sec:linear">Greedy - Linear time</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:tree_diameter">Tree Diameter</a>
<ul>
<li><a href="#introduction-28">Introduction</a></li>
<li><a href="#problem-statement-30">Problem statement</a></li>
<li><a href="#tree_diameter:sec:discussion">Discussion</a>
<ul>
<li><a href="#tree_diameter:sec:bruteforce">Brute-force</a></li>
<li><a href="#tree_diameter:sec:linear">Linear time and space</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:square_in_matrix">Largest square in a binary matrix</a>
<ul>
<li><a href="#introduction-29">Introduction</a></li>
<li><a href="#problem-statement-31">Problem statement</a></li>
<li><a href="#square_in_matrix:sec:discussion">Discussion</a>
<ul>
<li><a href="#brute-force-4">Brute-force</a></li>
<li><a href="#dynamic-programming">Dynamic programming</a></li>
</ul></li>
<li><a href="#conclusion-2">Conclusion</a></li>
</ul></li>
<li><a href="#ch:sudoku">Sudoku</a>
<ul>
<li><a href="#introduction-30">Introduction</a></li>
<li><a href="#problem-statement-32">Problem statement</a></li>
<li><a href="#clarification-questions-26">Clarification Questions</a></li>
<li><a href="#sudoku:sec:discussion">Discussion</a>
<ul>
<li><a href="#sudoku:sec:bruteforce">Backtacking</a></li>
</ul></li>
<li><a href="#conclusion-3">Conclusion</a></li>
</ul></li>
<li><a href="#ch:can_jump">Jump Game</a>
<ul>
<li><a href="#introduction-31">Introduction</a></li>
<li><a href="#problem-statement-33">Problem statement</a></li>
<li><a href="#can_jump:sec:backtracking">Backtracking</a></li>
<li><a href="#can_jump:sec:DFS">DFS</a></li>
<li><a href="#can_jump:sec:greedy">Greedy</a></li>
</ul></li>
<li><a href="#ch:kth_largest_in_stream"><span class="math inline">\(k^{th}\)</span> largest in a stream</a>
<ul>
<li><a href="#introduction-32">Introduction</a></li>
<li><a href="#problem-statement-34">Problem statement</a></li>
<li><a href="#clarification-questions-27">Clarification Questions</a></li>
<li><a href="#kth_largest_in_stream:sec:discussion">Discussion</a>
<ul>
<li><a href="#kth_largest_in_stream:sec:bruteforce">Array based solution</a></li>
<li><a href="#kth_largest_in_stream:sec:map">Ordered set</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:find_k_closest_in_array">Find the <span class="math inline">\(K\)</span> closest elements</a>
<ul>
<li><a href="#introduction-33">Introduction</a></li>
<li><a href="#problem-statement-35">Problem statement</a></li>
<li><a href="#clarification-questions-28">Clarification Questions</a></li>
<li><a href="#sec:find_k_closest_in_array:sorting">Sorting</a>
<ul>
<li><a href="#find_k_closest_in_array:sec:binary_search">Binary Search</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:mirror_binary_tree">Binary Tree mirroring</a>
<ul>
<li><a href="#introduction-34">Introduction</a></li>
<li><a href="#problem-statement-36">Problem statement</a></li>
<li><a href="#mirror_binary_tree:sec:discussion">Discussion</a></li>
</ul></li>
<li><a href="#ch:number_islands">Count the number of islands</a>
<ul>
<li><a href="#problem-statement-37">Problem statement</a></li>
<li><a href="#clarification-questions-29">Clarification Questions</a></li>
<li><a href="#number_islands:sec:discussion">Discussion</a></li>
</ul></li>
<li><a href="#ch:median_sorted_arrays">Median of two sorted arrays</a>
<ul>
<li><a href="#introduction-35">Introduction</a></li>
<li><a href="#problem-statement-38">Problem statement</a></li>
<li><a href="#clarification-questions-30">Clarification Questions</a></li>
<li><a href="#median_sorted_arrays:sec:discussion">Discussion</a>
<ul>
<li><a href="#median_sorted_arrays:sec:bruteforce">Brute-force</a></li>
<li><a href="#median_sorted_arrays:sec:bruteforce_improved">Brute-force improved</a></li>
<li><a href="#median_sorted_arrays:sec:log">Logarithmic solution</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:lowest_common_ancestor">BST Lowest Common Ancestor</a>
<ul>
<li><a href="#introduction-36">Introduction</a></li>
<li><a href="#problem-statement-39">Problem statement</a></li>
<li><a href="#clarification-questions-31">Clarification Questions</a></li>
<li><a href="#lowest_common_ancestor:sec:discussion">Discussion</a></li>
</ul></li>
<li><a href="#ch:distance_between_nodes_in_tree">Distance between nodes in BST</a>
<ul>
<li><a href="#introduction-37">Introduction</a></li>
<li><a href="#sec:distance_between_nodes_in_tree:problem">Problem statement</a></li>
<li><a href="#clarification-questions-32">Clarification Questions</a></li>
<li><a href="#distance_between_nodes_in_tree:sec:discussion">Discussion</a></li>
<li><a href="#conclusion-4">Conclusion</a></li>
</ul></li>
<li><a href="#ch:items_in_containers_amazon">Counts the items in the containers</a>
<ul>
<li><a href="#introduction-38">Introduction</a></li>
<li><a href="#problem-statement-40">Problem statement</a></li>
<li><a href="#clarification-questions-33">Clarification Questions</a></li>
<li><a href="#items_in_containers_amazon:sec:discussion">Discussion</a>
<ul>
<li><a href="#items_in_containers_amazon:sec:bruteforce">Brute-force</a></li>
<li><a href="#items_in_containers_amazon:sec:lineartime">Linear time solution</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:min_difficulty_job_scheduler">Minimum difficulty job schedule</a>
<ul>
<li><a href="#introduction-39">Introduction</a></li>
<li><a href="#problem-statement-41">Problem statement</a></li>
<li><a href="#clarification-questions-34">Clarification Questions</a></li>
<li><a href="#min_difficulty_job_scheduler:sec:discussion">Discussion</a>
<ul>
<li><a href="#min_difficulty_job_scheduler:sec:bruteforce">Brute-force</a></li>
<li><a href="#dynamic-programming-1">Dynamic Programming</a></li>
<li><a href="#top-down">Top-down</a></li>
<li><a href="#bottom-up">Bottom-up</a></li>
</ul></li>
<li><a href="#conclusion-5">Conclusion</a></li>
</ul></li>
<li><a href="#ch:max_triplet">Max triplet sum</a>
<ul>
<li><a href="#introduction-40">Introduction</a></li>
<li><a href="#problem-statement-42">Problem statement</a></li>
<li><a href="#clarification-questions-35">Clarification Questions</a></li>
<li><a href="#max_triplet:sec:discussion">Discussion</a></li>
<li><a href="#max_triplet:sec:bruteforce">Brute-force</a></li>
<li><a href="#precalculation-and-binary-search">Precalculation and Binary Search</a></li>
</ul></li>
<li><a href="#ch:dice_rolls">Number of Dice Rolls With Target Sum</a>
<ul>
<li><a href="#introduction-41">Introduction</a></li>
<li><a href="#problem-statement-43">Problem statement</a></li>
<li><a href="#clarification-questions-36">Clarification Questions</a></li>
<li><a href="#dice_rolls:sec:discussion">Discussion</a>
<ul>
<li><a href="#dice_rolls:sec:bruteforce">Brute-force</a></li>
<li><a href="#dice_rolls:sec:DP">Dynamic Programming - Recursive top-down</a></li>
</ul></li>
<li><a href="#dice_rolls:sec:bottom">Dynamic programming - Iterative bottom-up</a></li>
</ul></li>
<li><a href="#ch:remove_duplicated_sorted_array_inplace">Remove duplicates in sorted array</a>
<ul>
<li><a href="#introduction-42">Introduction</a></li>
<li><a href="#problem-statement-44">Problem statement</a></li>
<li><a href="#clarification-questions-37">Clarification Questions</a></li>
<li><a href="#remove_duplicated_sorted_array_inplace:sec:discussion">Discussion</a>
<ul>
<li><a href="#linear-space-solution">Linear space solution</a></li>
<li><a href="#sec:remove_duplicated_sorted_array_inplace:constant_space">Constant Space</a></li>
</ul></li>
<li><a href="#common-variations-3">Common Variations</a>
<ul>
<li><a href="#max-2-duplicates-allowed">Max <span class="math inline">\(2\)</span> duplicates allowed</a></li>
<li><a href="#discussion-6">Discussion</a></li>
<li><a href="#max-k-duplicates-allowed">Max <span class="math inline">\(k\)</span> duplicates allowed</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:remove_all_occurrences_unsorted_array_inplace">Remove all occurrences - unsorted array</a>
<ul>
<li><a href="#introduction-43">Introduction</a></li>
<li><a href="#problem-statement-45">Problem statement</a></li>
<li><a href="#clarification-questions-38">Clarification Questions</a></li>
<li><a href="#remove_all_occurrences_unsorted_array_inplace:sec:discussion">Discussion</a>
<ul>
<li><a href="#remove_all_occurrences_unsorted_array_inplace:sec:bruteforce">Linear time and linear space solution</a></li>
<li><a href="#remove_all_occurrences_unsorted_array_inplace:sec:constant_space">Linear time and constant space solution</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:max_num_chunks_sorted">Sort the chunks, sort the array.</a>
<ul>
<li><a href="#introduction-44">Introduction</a></li>
<li><a href="#problem-statement-46">Problem statement</a></li>
<li><a href="#clarification-questions-39">Clarification Questions</a></li>
<li><a href="#max_num_chunks_sorted:sec:discussion">Discussion</a></li>
<li><a href="#max_num_chunks_sorted:sec:bruteforce">Brute-force</a></li>
<li><a href="#max_num_chunks_sorted:sec:lineartime">Linear time</a></li>
</ul></li>
<li><a href="#ch:palindrome_partitioning2">Palindrome Partitioning </a>
<ul>
<li><a href="#introduction-45">Introduction</a></li>
<li><a href="#problem-statement-47">Problem statement</a></li>
<li><a href="#clarification-questions-40">Clarification Questions</a></li>
<li><a href="#palindrome_partitioning2:sec:discussion">Discussion</a>
<ul>
<li><a href="#palindrome_partitioning2:sec:bruteforce">Brute-force</a></li>
</ul></li>
<li><a href="#sec:palindrome_partitioning2:DP">Dynamic Programming</a>
<ul>
<li><a href="#top-down-1">Top-down</a></li>
<li><a href="#bottom-up-1">Bottom-up</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:max_gap">Find the largest gap</a>
<ul>
<li><a href="#introduction-46">Introduction</a></li>
<li><a href="#problem-statement-48">Problem statement</a></li>
<li><a href="#clarification-questions-41">Clarification Questions</a></li>
<li><a href="#max_gap:sec:trivial">Trivial Solution</a></li>
<li><a href="#max_gap:sec:radix_sort">Radix Sort</a></li>
<li><a href="#max_gap:sec:buckets">Buckets and the pigeonhole principle</a></li>
</ul></li>
<li><a href="#ch:smallest_range">Smallest Range I and II</a>
<ul>
<li><a href="#introduction-47">Introduction</a></li>
<li><a href="#problem-statement-49">Problem statement</a></li>
<li><a href="#clarification-questions-42">Clarification Questions</a></li>
<li><a href="#smallest_range:sec:discussion">Discussion</a></li>
<li><a href="#common-variations-4">Common Variations</a>
<ul>
<li><a href="#smallest-range-ii">Smallest range II </a></li>
</ul></li>
<li><a href="#smallest_range:sec:discussion">Discussion</a></li>
</ul></li>
<li><a href="#ch:next_greater_element">Next Greater Element I</a>
<ul>
<li><a href="#introduction-48">Introduction</a></li>
<li><a href="#problem-statement-50">Problem statement</a></li>
<li><a href="#clarification-questions-43">Clarification Questions</a>
<ul>
<li><a href="#next_greater_element:sec:bruteforce">Brute-force</a></li>
</ul></li>
<li><a href="#next_greater_element:sec:nlogntime"><span class="math inline">\(O(|B|log(|B|))\)</span> time, <span class="math inline">\(O(|B|)\)</span> space solution</a></li>
<li><a href="#common-variation-3">Common Variation</a>
<ul>
<li><a href="#next_greater_element:sec:first">First next greater element</a></li>
</ul></li>
<li><a href="#next_greater_element:sec:variation1:discussion">Discussion</a></li>
</ul></li>
<li><a href="#ch:count_bits">Count the bits</a>
<ul>
<li><a href="#problem-statement-51">Problem statement</a></li>
<li><a href="#clarification-questions-44">Clarification Questions</a></li>
<li><a href="#count_bits:sec:discussion">Discussion</a>
<ul>
<li><a href="#count_bits:sec:bruteforce">Naïve approach solution</a></li>
<li><a href="#count_bits:sec:dp">DP solution</a></li>
<li><a href="#count_bits:sec:pattern">Another efficient approach</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:decode_string">Decode the message</a>
<ul>
<li><a href="#introduction-49">Introduction</a></li>
<li><a href="#problem-statement-52">Problem statement</a></li>
<li><a href="#clarification-questions-45">Clarification Questions</a></li>
<li><a href="#decode_string:sec:discussion">Discussion</a>
<ul>
<li><a href="#decode_string:sec:recursive">Recursive solution</a></li>
<li><a href="#decode_string:sec:iterative">Iterative solution</a></li>
</ul></li>
</ul></li>
<li><a href="#appendices">Appendices</a>
<ul>
<li><a href="#listings">Listings</a></li>
</ul></li>
</ul>
</nav>
<hr>
<h1 id="ch:power_set">Power set generation</h1>
<h2 class="unnumbered" id="introduction">Introduction</h2>
<p>The concept of power set is familiar to many because it is one of the topics of the first introductory math courses on set theory.</p>
<p>The power set of a set <span class="math inline">\(S\)</span> is the set of all its subsets and in this lesson, we will explore how we can generate the power set of a given set. Very often this is a task we are challenged to solve directly as well as indirectly as part of a coding interview question.</p>
<p>We will investigate two different approaches to solve this problem:</p>
<ol>
<li><p>The first derives straightforwardly from the recursive definition of power-set which says that the power-set of an empty set is a set containing one element only: the empty set itself. For a non-empty set <span class="math inline">\(S\)</span>, let <span class="math inline">\(e\)</span> be an element of <span class="math inline">\(S\)</span> and <span class="math inline">\(T\)</span> be the original set <span class="math inline">\(S\)</span> set minus <span class="math inline">\(e\)</span> ( <span class="math inline">\(T=S \setminus e\)</span>), then the power set of <span class="math inline">\(S\)</span> is defined as the union of two distinct power sets:</p>
<ul>
<li><p>the power set of <span class="math inline">\(T\)</span></p></li>
<li><p>and the power set of <span class="math inline">\(T\)</span> modified in a such way that <span class="math inline">\(e\)</span> is added to all of its elements. This idea is formalized in the Equation <a href="#eq:power_set_recursive_definition" data-reference-type="ref" data-reference="eq:power_set_recursive_definition">[eq:power_set_recursive_definition]</a>:</p>
<p><span class="math inline">\(\mathcal{P}(S)=\begin{cases} 
        \{\{\}\} &amp; \text{if } S=\{\} \\
        \mathcal{P}\{T\} \bigcup \{t \bigcup \{e\} \: : t \in \mathcal{P}\{T\}\} \text{ where }  T = S \setminus \{e\} \text{ } \forall e \in S, &amp; \text{otherwise}
        \end{cases}\)</span></p></li>
</ul></li>
<li><p>The second is based on a property of the distribution of the bits in the binary representation of the integers from <span class="math inline">\(0\)</span> to the size of the power set.</p></li>
</ol>
<h2 id="problem-statement">Problem statement</h2>
<div class="exercise">
<p>Write a function that given a set <span class="math inline">\(S\)</span> returns its power set. The power-set of <span class="math inline">\(S\)</span> (<span class="math inline">\(\mathcal{P}(S)\)</span>) is the set of all its subsets including the empty subset (<span class="math inline">\(\emptyset\)</span>) and <span class="math inline">\(S\)</span> itself.</p>
<div class="example">
<p><span id="ex:power_set:example1" label="ex:power_set:example1">[ex:power_set:example1]</span><br />
Given the set <span class="math inline">\(S=\{a,b,c\}\)</span>, the following is a correct output for this problem: <span class="math display">\[\{\{\}, \{a\}, \{b\}, \{c\}, \{a,b\}, \{b,c\}, \{a,c\}, \{a,b,c\} \}\]</span></p>
</div>
</div>
<h2 id="clarification-questions">Clarification Questions</h2>
<div class="QandA">
<p>What is the maximum input size?</p>
<div class="answered">
<p><em>The maximum number of element in <span class="math inline">\(S\)</span> is strictly less than <span class="math inline">\(32\)</span>.</em></p>
</div>
<p>Are all the elements in the collection distinct?</p>
<div class="answered">
<p><em>No, the elements are not necessarily distinct. <span class="math inline">\(S\)</span> might contain duplicates..</em></p>
</div>
<p>Can the elements of the power-set appear in any order?</p>
<div class="answered">
<p><em>Yes, subsets can appear in any order. For example the following is also a valid output for the input shown in Example <a href="#ex:power_set:example1" data-reference-type="ref" data-reference="ex:power_set:example1">[ex:power_set:example1]</a>:</em> <span class="math inline">\(\{\{\}, \{b,c\}, \{a\}, \{a,b\}, \{a,b,c\}, \{b\}, \{a,c\}, \{c\} \}\)</span></p>
</div>
</div>
<h2 id="sec:powerset:discussion">Discussion</h2>
<p>There is one key point that should immediately be noticed: The power set of a collection of <span class="math inline">\(n\)</span> elements has size <span class="math inline">\(2^n\)</span>. The proof is relatively easy, and it boils down to the fact that a subset of <span class="math inline">\(S\)</span> can be uniquely identified by a list <span class="math inline">\(X=\{x_0,x_1,\ldots x_{|S|-1}\}\)</span> of <span class="math inline">\(|S|\)</span> binary variables each carrying the information about whether <span class="math inline">\(S_i\)</span> is part of the subset; <span class="math inline">\(x_i\)</span> answers the question: <strong>should <span class="math inline">\(S_i\)</span> be part of this subset?</strong> If <span class="math inline">\(x_i\)</span> is true the answer is yes, otherwise it is no. Because we have two possible choices for every element of <span class="math inline">\(S\)</span> (either take it or not), then the total number of distinct <span class="math inline">\(X\)</span>s is: <span class="math inline">\(2 \times 2 \times \ldots \times 2 = 2^{|S|}\)</span>. Two choices for the first element, two for the second, and so on until the last element of <span class="math inline">\(S\)</span>.</p>
<p>This, together with the constraint on <span class="math inline">\(|S|\)</span> (<span class="math inline">\(|S| &lt; 32)\)</span> is a strong hint towards the fact that an <strong>exponential time and space</strong> solution is expected. After all, we are required to output all the elements of the power set, and thus the number of operations of an algorithm designed for this task cannot be less than the size of the power set itself.</p>
<h3 id="bruteforce---backtracking-like-approach">Bruteforce - Backtracking-like approach</h3>
<p>The first solution presented in this lesson is based on the fact that during the generation of one of the elements of the power set a decision has to be taken for each element <span class="math inline">\(e\)</span> of <span class="math inline">\(S\)</span>, on whether to include or not <span class="math inline">\(e\)</span> into the subset. When a decision for the first element is taken, we are left with are <span class="math inline">\(|S|-1\)</span> decisions before we have created a valid subset of <span class="math inline">\(|S|\)</span>.</p>
<p>This kind of process is inherently recursive and is easily visualized with a tree (see the Figure <a href="#ref:power_set_decision_trees" data-reference-type="ref" data-reference="ref:power_set_decision_trees">1.1</a>) where a node at level <span class="math inline">\(i\)</span> represents a decision for the <span class="math inline">\(i^{th}\)</span> element of <span class="math inline">\(S\)</span> and a path from the root to a leaf uniquely identifies a subset of <span class="math inline">\(S\)</span> as, after having traversed all the levels down to a leaf, <span class="math inline">\(n\)</span> decisions have been taken: one for each of the elements of <span class="math inline">\(S\)</span>. Collectively, all the paths from the root to the leaves are the power set, and therefore, in order to solve this problem, we have to visit the entire tree.</p>
<p>A general way to deal with such type of problems is by using a backtracking-like approach to try all possible decisions (or equivalently to visit every path from the root to a leaf). The idea is that, for all elements of <span class="math inline">\(S\)</span>, from first to last, we are going to explore the two available possibilities: either take or exclude the it from the subset.</p>
<p>We start by making a decision for the first element and continuing from there to generate all possible subsets where the first decision is never changed. When there are no more subsets to generate, we <em>backtrack</em> and change our first decision and repeat the process of generating all possible subsets.</p>
<p>For instance, given <span class="math inline">\(S=\{1,2,3\}\)</span>, we might start by deciding to use the element <span class="math inline">\(1\)</span>, and include it in all possible subsets from the remaining elements <span class="math inline">\(\{2, 3\}\)</span> only. When we are done with it we can repeat the same process, only this time, excluding <span class="math inline">\(1\)</span>. What we do is: <span class="math inline">\(\mathcal{P}(S)= \{\{1\} \; \bigcup \;\mathcal{P}(\{2,3\})\} \: \bigcup \: \{\mathcal{P}(\{2,3\})\}\}\)</span></p>
<p>The proposed solution will incrementally construct one subset at a time, using an integer variable to keep track of which element we are currently taking the decision for. This type of problem is naturally solved recursively, with a base case of the recursion happening when there is no more decision to take, meaning that the current subset is ready to be included in the solution (it has been produced after <span class="math inline">\(n\)</span> decision steps).</p>
<p>The C++ code implementing the idea above is shown in Listing <a href="#list:power_set_backtracking" data-reference-type="ref" data-reference="list:power_set_backtracking">[list:power_set_backtracking]</a>. The complexity of this solution is exponential i.e. <span class="math inline">\(O(2^n)\)</span> which as already pointed out is as good as it gets.</p>
<div class="sourceCode" id="list:power_set_backtracking" data-language="c++" data-caption="&quot;C++ to the power set generation using backtracking&quot;" label="list:power_set_backtracking"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:power_set_backtracking-1"><a href="#list:power_set_backtracking-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> power_set_backtracking_helper<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>S<span class="op">,</span></span>
<span id="list:power_set_backtracking-2"><a href="#list:power_set_backtracking-2" aria-hidden="true" tabindex="-1"></a>                                   <span class="at">const</span> <span class="dt">int</span> idx<span class="op">,</span></span>
<span id="list:power_set_backtracking-3"><a href="#list:power_set_backtracking-3" aria-hidden="true" tabindex="-1"></a>                                   <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>curr<span class="op">,</span></span>
<span id="list:power_set_backtracking-4"><a href="#list:power_set_backtracking-4" aria-hidden="true" tabindex="-1"></a>                                   <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> <span class="op">&amp;</span>ans<span class="op">)</span></span>
<span id="list:power_set_backtracking-5"><a href="#list:power_set_backtracking-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:power_set_backtracking-6"><a href="#list:power_set_backtracking-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>idx <span class="op">&gt;=</span> S<span class="op">.</span>size<span class="op">())</span></span>
<span id="list:power_set_backtracking-7"><a href="#list:power_set_backtracking-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// base case</span></span>
<span id="list:power_set_backtracking-8"><a href="#list:power_set_backtracking-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:power_set_backtracking-9"><a href="#list:power_set_backtracking-9" aria-hidden="true" tabindex="-1"></a>    ans<span class="op">.</span>push_back<span class="op">(</span>curr<span class="op">);</span></span>
<span id="list:power_set_backtracking-10"><a href="#list:power_set_backtracking-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="list:power_set_backtracking-11"><a href="#list:power_set_backtracking-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:power_set_backtracking-12"><a href="#list:power_set_backtracking-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:power_set_backtracking-13"><a href="#list:power_set_backtracking-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// include element S[idx]</span></span>
<span id="list:power_set_backtracking-14"><a href="#list:power_set_backtracking-14" aria-hidden="true" tabindex="-1"></a>  curr<span class="op">.</span>push_back<span class="op">(</span>S<span class="op">[</span>idx<span class="op">]);</span></span>
<span id="list:power_set_backtracking-15"><a href="#list:power_set_backtracking-15" aria-hidden="true" tabindex="-1"></a>  power_set_backtracking_helper<span class="op">(</span>S<span class="op">,</span> idx <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> curr<span class="op">,</span> ans<span class="op">);</span></span>
<span id="list:power_set_backtracking-16"><a href="#list:power_set_backtracking-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:power_set_backtracking-17"><a href="#list:power_set_backtracking-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">// exclude element S[idx]</span></span>
<span id="list:power_set_backtracking-18"><a href="#list:power_set_backtracking-18" aria-hidden="true" tabindex="-1"></a>  curr<span class="op">.</span>pop_back<span class="op">();</span></span>
<span id="list:power_set_backtracking-19"><a href="#list:power_set_backtracking-19" aria-hidden="true" tabindex="-1"></a>  power_set_backtracking_helper<span class="op">(</span>S<span class="op">,</span> idx <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> curr<span class="op">,</span> ans<span class="op">);</span></span>
<span id="list:power_set_backtracking-20"><a href="#list:power_set_backtracking-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:power_set_backtracking-21"><a href="#list:power_set_backtracking-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:power_set_backtracking-22"><a href="#list:power_set_backtracking-22" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> power_set_backtracking<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>S<span class="op">)</span></span>
<span id="list:power_set_backtracking-23"><a href="#list:power_set_backtracking-23" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:power_set_backtracking-24"><a href="#list:power_set_backtracking-24" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> ans<span class="op">;</span></span>
<span id="list:power_set_backtracking-25"><a href="#list:power_set_backtracking-25" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> current<span class="op">;</span></span>
<span id="list:power_set_backtracking-26"><a href="#list:power_set_backtracking-26" aria-hidden="true" tabindex="-1"></a>  power_set_backtracking_helper<span class="op">(</span>S<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> current<span class="op">,</span> ans<span class="op">);</span></span>
<span id="list:power_set_backtracking-27"><a href="#list:power_set_backtracking-27" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:power_set_backtracking-28"><a href="#list:power_set_backtracking-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/power_set/images/tree.png" id="ref:power_set_decision_trees" alt="Decision tree for the power-set generation using backtracking. At level i are the decision for the element i in the original set. A label marked with yes identifies the decision to take the corresponding element into the subset, while a node labeled with no the opposite. At the last level is the power set." /><figcaption aria-hidden="true">Decision tree for the power-set generation using backtracking. At level <span class="math inline">\(i\)</span> are the decision for the element <span class="math inline">\(i\)</span> in the original set. A label marked with yes identifies the decision to take the corresponding element into the subset, while a node labeled with no the opposite. At the last level is the power set.</figcaption>
</figure>
<p>The advantages of using this backtracking-like approach to solve this problem are that, once we notice that a problem can be solved by fully exploring the associated search space tree, then we can immediately start writing the code and rely on our experience as backtracking expert writers to implement a correct solution with the added bonuses of being concise and short when written in a recursive form (which gives you fewer chances to make mistakes, and less code to debug and explain), as well as well understood. The downside is that, if you decide to go for it, an iterative implementation can be a little harder and more verbose to write.</p>
<p>Regardless of which type you decide to write, the interviewer is going to be pleased with your code provided you get to the final solution without making too many implementation mistakes like forgetting to handle the base case.</p>
<h3 id="bit-manipulation">Bit Manipulation</h3>
<p>Another approach that can be used to solve this problem is based on the fact that the values of the bits of the numbers <span class="math inline">\(\{0,1,2,\ldots, s^n-1\}\)</span> already provide all the information necessary to decide whether to include or not an element from <span class="math inline">\(S\)</span> into a subset. The main idea is that the binary representation of all the numbers (<span class="math inline">\(2^{|S|}\)</span> of them) from <span class="math inline">\(0\)</span> to <span class="math inline">\(2^{|S|}-1\)</span> is the power set of <span class="math inline">\(n\)</span> bits. This practically means that the binary representation of any of those numbers carry the necessary information that can be used to build one subset of <span class="math inline">\(\mathcal{P}(S)\)</span>.</p>
<p>For instance for the input <span class="math inline">\(S=\{a,b,c\}\)</span> the Table <a href="#tab:mapping_value_bits" data-reference-type="ref" data-reference="tab:mapping_value_bits">1.1</a> shows numbers from <span class="math inline">\(0\)</span> to <span class="math inline">\(2^3-1 = 7\)</span> and their binary representation (in the second column) as well as how the information about which bit is set can be used to construct one subset of <span class="math inline">\(\mathcal{P}(S)\)</span> (in the third column). <strong>When the <span class="math inline">\(i^{th}\)</span> bit is set (its value is <span class="math inline">\(1\)</span>), it means that corresponding <span class="math inline">\(i^{th}\)</span> element of <span class="math inline">\(S\)</span> is chosen, while an unset bit (with value <span class="math inline">\(0\)</span>) means it is excluded</strong>.</p>
<div id="tab:mapping_value_bits">
<table>
<caption>This table shows a 1-to-1 mapping between integer values, their binary representation and an element of the power set.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Number Value</th>
<th style="text-align: left;">Bits</th>
<th style="text-align: left;">Subset</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">0</td>
<td style="text-align: left;">000</td>
<td style="text-align: left;"><span class="math inline">\(\{\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">1</td>
<td style="text-align: left;">001</td>
<td style="text-align: left;"><span class="math inline">\(\{c\}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">2</td>
<td style="text-align: left;">010</td>
<td style="text-align: left;"><span class="math inline">\(\{b\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">3</td>
<td style="text-align: left;">011</td>
<td style="text-align: left;"><span class="math inline">\(\{b,c\}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">4</td>
<td style="text-align: left;">100</td>
<td style="text-align: left;"><span class="math inline">\(\{a\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">5</td>
<td style="text-align: left;">101</td>
<td style="text-align: left;"><span class="math inline">\(\{a,c\}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">6</td>
<td style="text-align: left;">110</td>
<td style="text-align: left;"><span class="math inline">\(\{a,b\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">7</td>
<td style="text-align: left;">111</td>
<td style="text-align: left;"><span class="math inline">\(\{a,b,c\}\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>This idea can be used to write an algorithm in which all the numbers in the range <span class="math inline">\(\{0,1,2,\ldots,
2^{|S|}-1\}\)</span> are considered and each of them is used to generate a subset of the final solution. Every number from this range maps uniquely to a subset of <span class="math inline">\(\mathcal{P}(S)\)</span>.</p>
<p>It is not surprising when we think about the meaning of a bit in the binary representation of integers. One can "build" a number <span class="math inline">\(k\)</span> by summing up powers of <span class="math inline">\(2\)</span> where the bits contain the information about whether a certain power of two should be added to the final value. With <span class="math inline">\(n\)</span> bits one can represent <span class="math inline">\(2^n\)</span> numbers, each corresponding to one and only one subset of the power set of those <span class="math inline">\(n\)</span> bits.</p>
<p>Listing <a href="#list:power_set_bits" data-reference-type="ref" data-reference="list:power_set_bits">[list:power_set_bits]</a> shows a possible C++ implementation of the idea above.</p>
<div class="sourceCode" id="list:power_set_bits" data-language="c++" data-caption="&quot;&quot;" label="list:power_set_bits"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:power_set_bits-1"><a href="#list:power_set_bits-1" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">inline</span> <span class="dt">bool</span> is_bit_set<span class="op">(</span><span class="at">const</span> <span class="dt">int</span> n<span class="op">,</span> <span class="at">const</span> <span class="dt">unsigned</span> p<span class="op">)</span></span>
<span id="list:power_set_bits-2"><a href="#list:power_set_bits-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:power_set_bits-3"><a href="#list:power_set_bits-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">(</span>n <span class="op">&gt;&gt;</span> p<span class="op">)</span> <span class="op">&amp;</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:power_set_bits-4"><a href="#list:power_set_bits-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:power_set_bits-5"><a href="#list:power_set_bits-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:power_set_bits-6"><a href="#list:power_set_bits-6" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> power_set_bit_manipulation<span class="op">(</span></span>
<span id="list:power_set_bits-7"><a href="#list:power_set_bits-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>A<span class="op">)</span></span>
<span id="list:power_set_bits-8"><a href="#list:power_set_bits-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:power_set_bits-9"><a href="#list:power_set_bits-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">size_t</span> limit <span class="op">=</span> <span class="op">(</span><span class="dv">1</span><span class="bu">ll</span> <span class="op">&lt;&lt;</span> A<span class="op">.</span>size<span class="op">())</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:power_set_bits-10"><a href="#list:power_set_bits-10" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> PS<span class="op">;</span></span>
<span id="list:power_set_bits-11"><a href="#list:power_set_bits-11" aria-hidden="true" tabindex="-1"></a>  PS<span class="op">.</span>reserve<span class="op">(</span>limit <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="list:power_set_bits-12"><a href="#list:power_set_bits-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:power_set_bits-13"><a href="#list:power_set_bits-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> limit<span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:power_set_bits-14"><a href="#list:power_set_bits-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:power_set_bits-15"><a href="#list:power_set_bits-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> subset <span class="op">=</span> <span class="op">{};</span></span>
<span id="list:power_set_bits-16"><a href="#list:power_set_bits-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> p <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> p <span class="op">&lt;</span> <span class="dv">32</span><span class="op">;</span> p<span class="op">++)</span></span>
<span id="list:power_set_bits-17"><a href="#list:power_set_bits-17" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>is_bit_set<span class="op">(</span>i<span class="op">,</span> p<span class="op">))</span></span>
<span id="list:power_set_bits-18"><a href="#list:power_set_bits-18" aria-hidden="true" tabindex="-1"></a>      <span class="op">{</span></span>
<span id="list:power_set_bits-19"><a href="#list:power_set_bits-19" aria-hidden="true" tabindex="-1"></a>        subset<span class="op">.</span>push_back<span class="op">(</span>A<span class="op">[</span>p<span class="op">]);</span></span>
<span id="list:power_set_bits-20"><a href="#list:power_set_bits-20" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="list:power_set_bits-21"><a href="#list:power_set_bits-21" aria-hidden="true" tabindex="-1"></a>    PS<span class="op">.</span>push_back<span class="op">(</span>subset<span class="op">);</span></span>
<span id="list:power_set_bits-22"><a href="#list:power_set_bits-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:power_set_bits-23"><a href="#list:power_set_bits-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:power_set_bits-24"><a href="#list:power_set_bits-24" aria-hidden="true" tabindex="-1"></a>  PS<span class="op">.</span>push_back<span class="op">(</span>A<span class="op">);</span></span>
<span id="list:power_set_bits-25"><a href="#list:power_set_bits-25" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> PS<span class="op">;</span></span>
<span id="list:power_set_bits-26"><a href="#list:power_set_bits-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The complexity of this function is, not surprisingly, <span class="math inline">\(O(2^{|S|})\)</span>. We also pay a constant price of <span class="math inline">\(32\)</span> for each number we loop through since we need to inspect all of its bits. The proposed implementation assumes that the size of is <span class="math inline">\(4\)</span> bytes, which is true for most systems.</p>
<p>Moreover, notice the usage that should be used in all those scenarios when we already know the final size of the collection we are building. This saves time because avoids intermediate allocations and copies that must happen during the resize of the vector.</p>
<h1 id="ch:square_root">Square root of an integer</h1>
<h2 class="unnumbered" id="introduction-1">Introduction</h2>
<p>The concept of square root goes is not only one of the central operations in mathematics that we use almost as often as addition or multiplication or division but it is also at the core of countless everyday gadgets and cool technology we use everyday like the radio and GPS systems, for instance.</p>
<p>The square root of a number <span class="math inline">\(x\)</span>, denoted with the <span class="math inline">\(\sqrt{x}\)</span> symbol, is formally defined to be a number <span class="math inline">\(y\)</span> such that <span class="math inline">\(y^2 = y\times y=x\)</span>. For example: <span class="math inline">\(\sqrt{4} = 2\)</span> and <span class="math inline">\(\sqrt{1253} \approx 35.3977\)</span>.</p>
<p>The square root is defined for every positive real number but in this lesson, we will derive an algorithm for the calculation of the square root for integers.</p>
<p>As for almost every coding interview problem, there are multiple possible solutions and approaches we can take to tackle this problem. In this lesson, we will learn how to write a simple and yet sub-optimal solution that runs in <span class="math inline">\(O(\sqrt{n})\)</span> time, as well as a much faster and elegant logarithmic time solution.</p>
<h2 id="problem-statement-1">Problem statement</h2>
<div class="exercise">
<p>Write a function that calculates the integral part of the square root of an integer <span class="math inline">\(n\)</span> i.e. <span class="math inline">\(\lfloor \sqrt{n}\rfloor\)</span>. <strong>You cannot use any library functions</strong>.</p>
<div class="example">
<p><br />
Given <span class="math inline">\(n=9\)</span> the function returns <span class="math inline">\(3\)</span>: <span class="math inline">\(\ceil{\sqrt{9}}=3\)</span></p>
</div>
<div class="example">
<p><br />
Given <span class="math inline">\(n=11\)</span> the function returns <span class="math inline">\(3\)</span>: <span class="math inline">\(\ceil{\sqrt{11}}\approx\ceil{3.316624}=3\)</span></p>
</div>
<div class="example">
<p><br />
Given <span class="math inline">\(n=18\)</span> the function returns <span class="math inline">\(4\)</span>: <span class="math inline">\(\ceil{\sqrt{11}}\approx\ceil{4.242640}=4\)</span></p>
</div>
</div>
<h2 id="clarification-questions-1">Clarification Questions</h2>
<div class="QandA">
<p>What is the maximum value the parameter <span class="math inline">\(n\)</span> can take?</p>
<div class="answered">
<p><em>The greatest input is guaranteed to be smaller than <span class="math inline">\(2^{32}\)</span>.</em></p>
</div>
<p>Is <span class="math inline">\(n\)</span> guaranteed to be always positive?</p>
<div class="answered">
<p><em>Yes, there is no need to check for invalid input.</em></p>
</div>
</div>
<h2 id="discussion">Discussion</h2>
<p>A brute-force solution is quickly derivable from the definition of square root given above (<span class="math inline">\(\sqrt{x} = y\)</span> where <span class="math inline">\(y^2 = x\)</span>.) and the interviewer is very likely expecting to see it mentioned or appearing on the whiteboard within the first few minutes of the interview.</p>
<h3 id="brute-force">Brute-Force</h3>
<p>We know that if <span class="math inline">\(y = \sqrt{x}\)</span> <span class="math inline">\(y^2 = x\)</span>. Moreover, <span class="math inline">\(y\)</span> is an integer only when <span class="math inline">\(x\)</span> is a perfect square<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. If <span class="math inline">\(x\)</span> is not a perfect square than <span class="math inline">\(y\)</span> is a real number and the following holds true: <span class="math inline">\(\lfloor{y}^2 \rfloor \leq x\)</span> and <span class="math inline">\(\lceil{y} \rceil^2 &gt; x\)</span>. For instance <span class="math inline">\(\sqrt{5} \approx 2.2360\)</span> and <span class="math inline">\(2^2=4 \leq 5\)</span> and <span class="math inline">\(3^2=9 &gt; 5\)</span>.</p>
<p>We can use this last property to blindly loop through all the integers <span class="math inline">\(k=0,1,2,\ldots\)</span> until the following is true: <span class="math inline">\(k^2\leq n\)</span> and <span class="math inline">\((k+1)^2 &gt; n\)</span>. A solution is guaranteed to be found because eventually, <span class="math inline">\(k\)</span> will be equal to <span class="math inline">\(\floor{y}\)</span>. Moreover, it is clear that no more than <span class="math inline">\(\sqrt{n}\)</span> numbers will be tested, which proves that the time complexity of this approach is <span class="math inline">\(O(\sqrt{n})\)</span>.</p>
<p>Listing <a href="#list:square_root_brute_force" data-reference-type="ref" data-reference="list:square_root_brute_force">[list:square_root_brute_force]</a> shows a C++ implementation of this idea.</p>
<div class="sourceCode" id="list:square_root_brute_force" data-language="c++" data-caption="$O(\sqrt{n})$ solution to the problem of finding the square root of an integer." label="list:square_root_brute_force"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:square_root_brute_force-1"><a href="#list:square_root_brute_force-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> square_root_brute_force<span class="op">(</span><span class="at">const</span> <span class="dt">int</span> n<span class="op">)</span></span>
<span id="list:square_root_brute_force-2"><a href="#list:square_root_brute_force-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:square_root_brute_force-3"><a href="#list:square_root_brute_force-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">long</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:square_root_brute_force-4"><a href="#list:square_root_brute_force-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">((</span>i <span class="op">*</span> i<span class="op">)</span> <span class="op">&lt;=</span> n<span class="op">)</span></span>
<span id="list:square_root_brute_force-5"><a href="#list:square_root_brute_force-5" aria-hidden="true" tabindex="-1"></a>    i<span class="op">++;</span></span>
<span id="list:square_root_brute_force-6"><a href="#list:square_root_brute_force-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// i at this point is the smallest element s.t. i*i &gt; n</span></span>
<span id="list:square_root_brute_force-7"><a href="#list:square_root_brute_force-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> i <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:square_root_brute_force-8"><a href="#list:square_root_brute_force-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>It is worth noticing that the variable <span class="math inline">\(i\)</span> has a type that is larger in size than an . This is necessary in order to prevent overflows during the calculation of <span class="math inline">\(i^2\)</span> (see the highlighted line). One of the constraints of the problem is that the largest input can be <span class="math inline">\(n=2^{32}-1\)</span>; The square of that number does not fit in a <span class="math inline">\(4\)</span> bytes .</p>
<h3 id="logarithmic-solution">Logarithmic Solution</h3>
<p>Binary search can be effectively used to solve this problem and in order to show that, we are going to look at the problem from a slightly different angle. Let <span class="math display">\[F(k)=\begin{cases} 
	0 &amp; k^2 \leq n \\
	1 &amp; k^2 &gt; n
\end{cases}
\label{eq:square_root_piecewice}\]</span> be a piece-wise function that partition the search space <span class="math inline">\([0\ldots n]\)</span> into two parts (See Table <a href="#tab:sqrt_split_space" data-reference-type="ref" data-reference="tab:sqrt_split_space">2.1</a>):</p>
<ol>
<li><p>the numbers less or equal than <span class="math inline">\(\sqrt{n}\)</span></p></li>
<li><p>the numbers strictly greater or equal than <span class="math inline">\(\sqrt{n}\)</span></p></li>
</ol>
<p>Clearly, <strong>the answer we are looking for is the greatest value <span class="math inline">\(k\)</span> s.t. <span class="math inline">\(F(k) = 0\)</span></strong>.</p>
<div id="tab:sqrt_split_space">
<table>
<caption>Partition of the search space according to the function in Eq. <a href="#eq:square_root_piecewice" data-reference-type="ref" data-reference="eq:square_root_piecewice">[eq:square_root_piecewice]</a></caption>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(0\)</span></th>
<th style="text-align: center;"><span class="math inline">\(1\)</span></th>
<th style="text-align: center;"><span class="math inline">\(2\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\floor{\sqrt{n}}\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\floor{\sqrt{n}}+1\)</span></th>
<th style="text-align: center;">…</th>
<th style="text-align: center;"><span class="math inline">\(n\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0\)</span></td>
<td style="text-align: center;">…</td>
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
<td style="text-align: center;">…</td>
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>Notice that every number in the left part of the search space, <span class="math inline">\(0 \leq l \leq \floor{n}\)</span> has <span class="math inline">\(F(l) = 0\)</span>, while the elements in the right side,<span class="math inline">\(\floor{n}+1 \leq r \leq n\)</span>, have <span class="math inline">\(F(r) = 1\)</span>. Because the function <span class="math inline">\(F(k)\)</span> splits the search space into two parts, we can use binary search to find the end of the first partition (this is actually true in general, and if you ever recognize a problem has these characteristics, you can apply binary search to it). We can do that because if we pick an integer from in <span class="math inline">\([0,n]\)</span>, say <span class="math inline">\(k\)</span>, and <span class="math inline">\(F(k) = 1\)</span> we know that <span class="math inline">\(k\)</span> is not the solution and &lt;ins&gt; crucially, also that all the values greater than <span class="math inline">\(k\)</span> are not good candidates because they all belong to the right partition. On the other hand, if <span class="math inline">\(F(k) = 0\)</span>, we know that <span class="math inline">\(k\)</span> might be the solution but also that,&lt;ins&gt; all the elements smaller than <span class="math inline">\(k\)</span> are not good candidates as <span class="math inline">\(k\)</span> is already a better answer than any of those numbers would be. The idea above is implemented in Listing <a href="#list:square_root_binary_search" data-reference-type="ref" data-reference="list:square_root_binary_search">[list:square_root_binary_search]</a>.</p>
<div class="sourceCode" id="list:square_root_binary_search" data-language="c++" data-caption="$O(log_2(n))$ solution to the problem of finding the square root of an integer." label="list:square_root_binary_search"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:square_root_binary_search-1"><a href="#list:square_root_binary_search-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> square_root_binary_search<span class="op">(</span><span class="at">const</span> <span class="dt">int</span> A<span class="op">)</span></span>
<span id="list:square_root_binary_search-2"><a href="#list:square_root_binary_search-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:square_root_binary_search-3"><a href="#list:square_root_binary_search-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">long</span> l <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> r <span class="op">=</span> A<span class="op">;</span></span>
<span id="list:square_root_binary_search-4"><a href="#list:square_root_binary_search-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:square_root_binary_search-5"><a href="#list:square_root_binary_search-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>l <span class="op">&lt;=</span> r<span class="op">)</span></span>
<span id="list:square_root_binary_search-6"><a href="#list:square_root_binary_search-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:square_root_binary_search-7"><a href="#list:square_root_binary_search-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">long</span> <span class="dt">long</span> mid <span class="op">=</span> l <span class="op">+</span> <span class="op">(</span>r <span class="op">-</span> l<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="list:square_root_binary_search-8"><a href="#list:square_root_binary_search-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">((</span><span class="dt">long</span><span class="op">)(</span>mid <span class="op">*</span> mid<span class="op">)</span> <span class="op">==</span> <span class="op">(</span><span class="dt">long</span><span class="op">)</span>A<span class="op">)</span></span>
<span id="list:square_root_binary_search-9"><a href="#list:square_root_binary_search-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> mid<span class="op">;</span></span>
<span id="list:square_root_binary_search-10"><a href="#list:square_root_binary_search-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>mid <span class="op">*</span> mid <span class="op">&gt;</span> A<span class="op">)</span></span>
<span id="list:square_root_binary_search-11"><a href="#list:square_root_binary_search-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:square_root_binary_search-12"><a href="#list:square_root_binary_search-12" aria-hidden="true" tabindex="-1"></a>      r <span class="op">=</span> mid <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:square_root_binary_search-13"><a href="#list:square_root_binary_search-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:square_root_binary_search-14"><a href="#list:square_root_binary_search-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="list:square_root_binary_search-15"><a href="#list:square_root_binary_search-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:square_root_binary_search-16"><a href="#list:square_root_binary_search-16" aria-hidden="true" tabindex="-1"></a>      l   <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:square_root_binary_search-17"><a href="#list:square_root_binary_search-17" aria-hidden="true" tabindex="-1"></a>      ans <span class="op">=</span> mid<span class="op">;</span></span>
<span id="list:square_root_binary_search-18"><a href="#list:square_root_binary_search-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:square_root_binary_search-19"><a href="#list:square_root_binary_search-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:square_root_binary_search-20"><a href="#list:square_root_binary_search-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:square_root_binary_search-21"><a href="#list:square_root_binary_search-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The algorithm works by maintaining an interval (defined by the variables and ) inside which the solution lies which initially is set to be the entire search space <span class="math inline">\([0,n]\)</span>. It iteratively shrinks this range by testing the middle element of <span class="math inline">\([l,r]\)</span> (value hold by ), and this can lead to one of the following three scenarios:</p>
<ol>
<li><p><span class="math inline">\(middle^2  = n\)</span>: is the solution and also that <span class="math inline">\(n\)</span> is a perfect square.</p></li>
<li><p><span class="math inline">\(middle^2  &gt; n\)</span>: is <strong>not</strong> the solution and we can also exclude all numbers <span class="math inline">\(k \geq middle\)</span> from the search (by setting ).</p></li>
<li><p><span class="math inline">\(middle^2  &lt; n\)</span>: is the best guess we have found so far (it might be the solution). We can, however, exclude every number <span class="math inline">\(k &lt; middle\)</span> (by doing ) as when squared, they would also be smaller than <span class="math inline">\(middle^2\)</span> .</p></li>
</ol>
<p>Pay attention to the way the midpoint between <span class="math inline">\(l\)</span> and <span class="math inline">\(r\)</span> is calculated. It is common to see it calculated by using the following formula: <span class="math inline">\((l+r)/2\)</span>. This however can lead to overflow problems when <span class="math inline">\(l+r\)</span> does not fit in an .</p>
<p>Finally, <strong>the time and space complexity of this algorithm is <span class="math inline">\(O(log(n))\)</span> and <span class="math inline">\(O(1)\)</span></strong>, respectively. A good improvement w.r.t. to the complexity of the brute-force solution.</p>
<h1 id="ch:two_string_anagram">Two string anagram</h1>
<h2 class="unnumbered" id="introduction-2">Introduction</h2>
<p>From a set of words, you can construct other words by only changing the arrangements of their characters. For instance, from the characters in <em>"alerting"</em> you can spell the following words:</p>
<ul>
<li><p><em>"altering"</em></p></li>
<li><p><em>"integral"</em></p></li>
<li><p><em>"relating"</em></p></li>
<li><p><em>"triangle"</em>.</p></li>
</ul>
<p>Words sharing the same characters set are called <strong>anagrams</strong>.</p>
<p>Being able to create good anagrams, especially ones reflecting or commenting on the words they are generated from (for instance turning <em>"Madam Curie"</em> into <em>"Radium came"</em>) is regarded as a rather difficult task. Computers have been used for a long time to find anagrams in long texts as well as to generate the so-called anagram dictionaries, a special kind of dictionary where all the letters in a word and all their transposition are arranged in alphabetical order, that are often used in games like [Scrabble](https://en.wikipedia.org/wiki/Scrabble). Often, at the core of such applications lies an efficient algorithm for determining if a word is an anagram of another word.</p>
<p>As you might have already guessed, the problem discussed in this lesson is about anagrams, and more specifically, about determining the number of modifications you need to make to a word in order to make it a valid anagram of a another word.</p>
<p>As a coding interview question, it is considered an easy one, mostly because, aside from the fact the statement is straightforward to understand and the concept of an anagram is part of the common knowledge, no particular insights or particularly tricky reasoning is required in order to come up with an efficient solution. That said, it is still very much worth studying as it has been frequently asked during the preliminary interview stages. Moreover, despite its simplicity, there is more than one neat and elegant approach leading to an efficient solution to this problem.</p>
<p>In the rest of the lesson, we are going to have a look at three solutions, starting from the slow but easy to understand brute-force touching briefly on a faster approach using sorting, and finally, to the optimal solution running in linear time.</p>
<p>In the rest of the chapter we are going to have a look at three solutions, starting from the slow but easy to understand brute-force in Section <a href="#sec:anagrams:bruteforce" data-reference-type="ref" data-reference="sec:anagrams:bruteforce">3.3.1</a> touching briefly on a faster approach using sorting in Section <a href="#sec:anagrams:sorting" data-reference-type="ref" data-reference="sec:anagrams:sorting">3.3.2</a>,and finally, to the optimal solution running in linear time in Section <a href="#sec:anagrams:histograms" data-reference-type="ref" data-reference="sec:anagrams:histograms">3.3.3</a>.</p>
<h2 id="problem-statement-2">Problem statement</h2>
<div class="exercise">
<p>Write a function that given two string, <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> of length <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span>, respectively, determines the minimum number of character substitution, <span class="math inline">\(C(s, i, c)\)</span>, necessary to make the string <span class="math inline">\(a\)</span> an anagram of the string <span class="math inline">\(b\)</span>.</p>
<p>Two strings are said to be anagrams of one another if you can turn the first string into the second by rearranging its letters.</p>
<p>A substitution operation <span class="math inline">\(C(s,i,c)\)</span> modifies the string <span class="math inline">\(s\)</span>, by changing its <span class="math inline">\(i^{th}\)</span> character into <span class="math inline">\(c\)</span>. Notice that deletions or additions of characters are not allowed. The only operation you can do is change a character of the first string into another one.</p>
<p>In other words, what is the minimum number of characters of the input strings that need to be modified (no addition or deletion) so that <span class="math inline">\(a\)</span> becomes an anagram of <span class="math inline">\(b\)</span>?</p>
<div class="example">
<p><br />
</p>
<ul>
<li><p>a = "aaa"</p></li>
<li><p>b = "bbb"</p></li>
</ul>
<p>The function returns <span class="math inline">\(3\)</span>. All the characters of <em>a</em> need to be changed into <em>’b’</em>. <span id="ex:anagrams:example1" label="ex:anagrams:example1">[ex:anagrams:example1]</span></p>
</div>
<div class="example">
<p><br />
</p>
<ul>
<li><p>a = "tear"</p></li>
<li><p>b = "fear"</p></li>
</ul>
<p>The function returns <span class="math inline">\(1\)</span>. All it is necessary is turning the first letter <em>’t’</em> into a <em>’f’</em>.</p>
</div>
<div class="example">
<p><br />
</p>
<ul>
<li><p>a = "Protectional"</p></li>
<li><p>b = "Lactoprotein"</p></li>
</ul>
<p>The answer for this case is <span class="math inline">\(0\)</span> because <em>Protectional</em> is already an angram of <em>Lactoprotein</em>.</p>
</div>
</div>
<h2 id="clarification-questions-2">Clarification Questions</h2>
<div class="QandA">
<p>Are the letters of the string always only letters from the English alphabet?</p>
<div class="answered">
<p><em>Yes, letters are always from the English alphabet.</em></p>
</div>
<p>Should the function be case sensitive?</p>
<div class="answered">
<p><em>No. You can assume the input letters are always lower case.</em></p>
</div>
<p>Can the input string be modified? No, the input is immutable.</p>
<div class="answered">
<p><em>No, the input strings are immutable.</em></p>
</div>
<p>What value should be returned when there is no solution?</p>
<div class="answered">
<p><em>In such case you can return <span class="math inline">\(-1\)</span>.</em></p>
</div>
</div>
<h2 id="discussion-1">Discussion</h2>
<p>Let’s start by first quickly review what the word anagram means in the context of this problem. First of all, notice that both <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> contain a single word (which can be fairly long). Moreover, for <span class="math inline">\(a\)</span> to be an anagram of <span class="math inline">\(b\)</span>, it has to be the case that exists an arrangement of characters in <span class="math inline">\(a\)</span> that is equal to <span class="math inline">\(b\)</span>. In other words, the question to which we need to answer is: is it possible to shuffle the character of <span class="math inline">\(a\)</span> such that we obtain <span class="math inline">\(b\)</span>? For this to be the case, it must be that <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> contain the same set of characters meaning that sorting both <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> would make them equal. In addition, as a consequence of the fact that no addition or deletion is allowed, <strong><span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> must have the same length</strong>. On the other hand, if they have the same length then it is always possible to solve this problem because in the worst case, we can modify every letter of <span class="math inline">\(a\)</span> (see [Example 1]()). Thus, the only case when the problem has no solution has been isolated: when <span class="math inline">\(n \neq m\)</span> we must return <span class="math inline">\(-1\)</span> otherwise we can proceed with our calculation knowing that a solution exists.</p>
<h3 id="sec:anagrams:bruteforce">Brute-Force</h3>
<p>One of the first options coming to mind is a solution where we generate all possible arrangements of the letters in <span class="math inline">\(a\)</span>, and for each of these arrangements, calculate the number of modifications necessary in order to convert it into <span class="math inline">\(b\)</span>. The key idea is that the cost of transforming a string into another is equal to the number positions having different letters. For instance the cost of transforming <em>"abcb"</em> into <em>"bbbb"</em> is <span class="math inline">\(2\)</span> because the two strings differ in the first and third letters.</p>
<p>Despite being simple to explain this approach is to be considered poor because the number of arrangements of a set of <span class="math inline">\(n\)</span> letters grows as fast as <span class="math inline">\(n!\)</span>. Moreover, enumerating all the arrangements is no trivial task unless we use a library function capable of doing that (for instance, the C++ standard library provides the function <a href="https://en.cppreference.com/w/cpp/algorithm/next_permutation"></a> devoted to this purpose).</p>
<p>Listings <a href="#list:two_string_anagram_bruteforce" data-reference-type="ref" data-reference="list:two_string_anagram_bruteforce">[list:two_string_anagram_bruteforce]</a> shows a C++ implementation of the idea above.</p>
<div class="sourceCode" id="list:two_string_anagram_bruteforce" data-language="c++" data-caption="&quot;Brute force C++ solution to the two string anagram problem.&quot;" label="list:two_string_anagram_bruteforce"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:two_string_anagram_bruteforce-1"><a href="#list:two_string_anagram_bruteforce-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="list:two_string_anagram_bruteforce-2"><a href="#list:two_string_anagram_bruteforce-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;limits&gt;</span></span>
<span id="list:two_string_anagram_bruteforce-3"><a href="#list:two_string_anagram_bruteforce-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="list:two_string_anagram_bruteforce-4"><a href="#list:two_string_anagram_bruteforce-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:two_string_anagram_bruteforce-5"><a href="#list:two_string_anagram_bruteforce-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> count_different_letters<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> &amp;</span>a_perm<span class="op">,</span> <span class="at">const</span> <span class="bu">std::</span>string<span class="op"> &amp;</span>b<span class="op">)</span></span>
<span id="list:two_string_anagram_bruteforce-6"><a href="#list:two_string_anagram_bruteforce-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:two_string_anagram_bruteforce-7"><a href="#list:two_string_anagram_bruteforce-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>a_perm<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> b<span class="op">.</span>size<span class="op">());</span></span>
<span id="list:two_string_anagram_bruteforce-8"><a href="#list:two_string_anagram_bruteforce-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:two_string_anagram_bruteforce-9"><a href="#list:two_string_anagram_bruteforce-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:two_string_anagram_bruteforce-10"><a href="#list:two_string_anagram_bruteforce-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> a_perm<span class="op">.</span>length<span class="op">();</span> i<span class="op">++)</span></span>
<span id="list:two_string_anagram_bruteforce-11"><a href="#list:two_string_anagram_bruteforce-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:two_string_anagram_bruteforce-12"><a href="#list:two_string_anagram_bruteforce-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>a_perm<span class="op">[</span>i<span class="op">]</span> <span class="op">!=</span> b<span class="op">[</span>i<span class="op">])</span></span>
<span id="list:two_string_anagram_bruteforce-13"><a href="#list:two_string_anagram_bruteforce-13" aria-hidden="true" tabindex="-1"></a>      <span class="op">++</span>count<span class="op">;</span></span>
<span id="list:two_string_anagram_bruteforce-14"><a href="#list:two_string_anagram_bruteforce-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:two_string_anagram_bruteforce-15"><a href="#list:two_string_anagram_bruteforce-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> count<span class="op">;</span></span>
<span id="list:two_string_anagram_bruteforce-16"><a href="#list:two_string_anagram_bruteforce-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:two_string_anagram_bruteforce-17"><a href="#list:two_string_anagram_bruteforce-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:two_string_anagram_bruteforce-18"><a href="#list:two_string_anagram_bruteforce-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> solution_brute_force<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> &amp;</span>a<span class="op">,</span> <span class="at">const</span> <span class="bu">std::</span>string<span class="op"> &amp;</span>b<span class="op">)</span></span>
<span id="list:two_string_anagram_bruteforce-19"><a href="#list:two_string_anagram_bruteforce-19" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:two_string_anagram_bruteforce-20"><a href="#list:two_string_anagram_bruteforce-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>a<span class="op">.</span>length<span class="op">()</span> <span class="op">!=</span> b<span class="op">.</span>length<span class="op">())</span></span>
<span id="list:two_string_anagram_bruteforce-21"><a href="#list:two_string_anagram_bruteforce-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:two_string_anagram_bruteforce-22"><a href="#list:two_string_anagram_bruteforce-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:two_string_anagram_bruteforce-23"><a href="#list:two_string_anagram_bruteforce-23" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>string<span class="op"> </span>a_perm<span class="op">(</span>a<span class="op">);</span></span>
<span id="list:two_string_anagram_bruteforce-24"><a href="#list:two_string_anagram_bruteforce-24" aria-hidden="true" tabindex="-1"></a>  sort<span class="op">(</span>a_perm<span class="op">.</span>begin<span class="op">(),</span> a_perm<span class="op">.</span>end<span class="op">());</span></span>
<span id="list:two_string_anagram_bruteforce-25"><a href="#list:two_string_anagram_bruteforce-25" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>max<span class="op">();</span></span>
<span id="list:two_string_anagram_bruteforce-26"><a href="#list:two_string_anagram_bruteforce-26" aria-hidden="true" tabindex="-1"></a>  <span class="cf">do</span></span>
<span id="list:two_string_anagram_bruteforce-27"><a href="#list:two_string_anagram_bruteforce-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:two_string_anagram_bruteforce-28"><a href="#list:two_string_anagram_bruteforce-28" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>ans<span class="op">,</span> count_different_letters<span class="op">(</span>a_perm<span class="op">,</span> b<span class="op">));</span></span>
<span id="list:two_string_anagram_bruteforce-29"><a href="#list:two_string_anagram_bruteforce-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>ans <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:two_string_anagram_bruteforce-30"><a href="#list:two_string_anagram_bruteforce-30" aria-hidden="true" tabindex="-1"></a>      <span class="cf">break</span><span class="op">;</span></span>
<span id="list:two_string_anagram_bruteforce-31"><a href="#list:two_string_anagram_bruteforce-31" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>next_permutation<span class="op">(</span>a_perm<span class="op">.</span>begin<span class="op">(),</span> a_perm<span class="op">.</span>end<span class="op">()));</span></span>
<span id="list:two_string_anagram_bruteforce-32"><a href="#list:two_string_anagram_bruteforce-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:two_string_anagram_bruteforce-33"><a href="#list:two_string_anagram_bruteforce-33" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:two_string_anagram_bruteforce-34"><a href="#list:two_string_anagram_bruteforce-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="sec:anagrams:sorting">Sorting</h3>
<p>The brute-force solution does a lot of superfluous work because it tries to find a permutation of the string <span class="math inline">\(a\)</span> requiring minimal modifications to be morphed into <span class="math inline">\(b\)</span>. But, is it really necessary to turn <span class="math inline">\(a\)</span> into <strong>exactly</strong> <span class="math inline">\(b\)</span>, or is it sufficient to modify <span class="math inline">\(a\)</span> so that it is equal to a particular permutation of <span class="math inline">\(b\)</span>? After all, being an anagram is a transitive property and if <span class="math inline">\(a\)</span> is a permutation of <span class="math inline">\(b\)</span> and <span class="math inline">\(b\)</span> is a permutation of <span class="math inline">\(c\)</span> then, <span class="math inline">\(a\)</span> must also be a permutation of <span class="math inline">\(c\)</span>.</p>
<p>By definition, an anagram of <span class="math inline">\(b\)</span> is any permutation of its characters, and therefore, the particular permutation in which the characters of <span class="math inline">\(b\)</span> are sorted is a valid anagram of its. It is much easier than checking all possible permutations, to modify <span class="math inline">\(a\)</span> into the "sorted" anagram of <span class="math inline">\(b\)</span> (where all of its characters are sorted), rather than to exactly <span class="math inline">\(b\)</span> because all we need to do is to create a copy of both <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, sort both of them and then calculate the character-by-character difference. <em></em>This approach works because if <span class="math inline">\(x\)</span> is an anagram of <span class="math inline">\(b\)</span> then <span class="math inline">\(x\)</span> is also an anagram of <em></em>. In other words, it does not matter how the characters are arranged in <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> as, the only thing that matters is the set of the characters appearing in <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>: the order in which characters in both <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> appear does not matter.</p>
<p>Listings <a href="#list:two_string_anagram_sorting" data-reference-type="ref" data-reference="list:two_string_anagram_sorting">[list:two_string_anagram_sorting]</a> shows how we can take advantage of this fact and write a fast solution for this problem.</p>
<div class="sourceCode" id="list:two_string_anagram_sorting" data-language="c++" data-caption="&quot;Brute force C++ solution to the two string anagram problem.&quot;" label="list:two_string_anagram_sorting"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:two_string_anagram_sorting-1"><a href="#list:two_string_anagram_sorting-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:two_string_anagram_sorting-2"><a href="#list:two_string_anagram_sorting-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> solution_sorting<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> &amp;</span>a<span class="op">,</span> <span class="at">const</span> <span class="bu">std::</span>string<span class="op"> &amp;</span>b<span class="op">)</span></span>
<span id="list:two_string_anagram_sorting-3"><a href="#list:two_string_anagram_sorting-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:two_string_anagram_sorting-4"><a href="#list:two_string_anagram_sorting-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>a<span class="op">.</span>length<span class="op">()</span> <span class="op">!=</span> b<span class="op">.</span>length<span class="op">())</span></span>
<span id="list:two_string_anagram_sorting-5"><a href="#list:two_string_anagram_sorting-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:two_string_anagram_sorting-6"><a href="#list:two_string_anagram_sorting-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:two_string_anagram_sorting-7"><a href="#list:two_string_anagram_sorting-7" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>string<span class="op"> </span>aa<span class="op">(</span>a<span class="op">);</span></span>
<span id="list:two_string_anagram_sorting-8"><a href="#list:two_string_anagram_sorting-8" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>string<span class="op"> </span>bb<span class="op">(</span>b<span class="op">);</span></span>
<span id="list:two_string_anagram_sorting-9"><a href="#list:two_string_anagram_sorting-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:two_string_anagram_sorting-10"><a href="#list:two_string_anagram_sorting-10" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>sort<span class="op">(</span>aa<span class="op">.</span>begin<span class="op">(),</span> aa<span class="op">.</span>end<span class="op">());</span></span>
<span id="list:two_string_anagram_sorting-11"><a href="#list:two_string_anagram_sorting-11" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>sort<span class="op">(</span>bb<span class="op">.</span>begin<span class="op">(),</span> bb<span class="op">.</span>end<span class="op">());</span></span>
<span id="list:two_string_anagram_sorting-12"><a href="#list:two_string_anagram_sorting-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> count_different_letters<span class="op">(</span>aa<span class="op">,</span> bb<span class="op">);</span></span>
<span id="list:two_string_anagram_sorting-13"><a href="#list:two_string_anagram_sorting-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice that, if the input was mutable, then, the additional space occupied by the copies of the string and could have been avoided.</p>
<p><strong>The time complexity of the idea above is <span class="math inline">\(O(n log(n))\)</span></strong> (because of sorting). <strong>The space complexity is <span class="math inline">\(O(n)\)</span></strong> (we create copies of the input strings).</p>
<h3 id="sec:anagrams:histograms">Histograms</h3>
<p>There is another bit of information that we have not yet used: <strong>the alphabet</strong> from which the letters of <span class="math inline">\(a\)</span> and <span class="math inline">\(ab\)</span> are taken from <strong>is small</strong>. If the only thing that matters is the set of characters appearing in <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> (and not their order, as discussed above), then we can use the same idea at the core of the <a href="https://en.wikipedia.org/wiki/Bucket_sort">bucket sort</a> algorithm to achieve a linear time complexity solution.</p>
<p>The key idea is to preprocess <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> so to calculate their per-character frequencies, denoted here as <span class="math inline">\(F_a\)</span> and <span class="math inline">\(F_b\)</span>, respectively. An entry of <span class="math inline">\(F_a[\mathrm{c}]\)</span> and <span class="math inline">\(F_b[\mathrm{c}]\)</span>, where <span class="math inline">\(\mathrm{c} \in \{\mathrm{a},\mathrm{b},\ldots,\mathrm{z}\}\)</span> (a letter of the alphabet), contains the frequency of character <span class="math inline">\(\mathrm{c}\)</span>, in <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, respectively.</p>
<p>If <span class="math inline">\(F_a\)</span> and <span class="math inline">\(F_b\)</span> are the same, then <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> have exactly the same character set and <span class="math inline">\(a\)</span> is an anagram of <span class="math inline">\(b\)</span>. Otherwise, it must be the case that some characters of <span class="math inline">\(a\)</span> appear in <span class="math inline">\(b\)</span> a different number of times. In this case, we can fix <span class="math inline">\(a\)</span> in such a way to make sure that its frequencies <span class="math inline">\(F_a\)</span> ey match the ones in <span class="math inline">\(F_b\)</span>. But the main question is still unanswered: how many operations are necessary to do so? In order to get this answer, it is useful to look at the difference (<span class="math inline">\(D\)</span>) of <span class="math inline">\(F_a\)</span> and <span class="math inline">\(F_b\)</span>.</p>
<p><span class="math inline">\(D = F_a - F_b = \{D[\mathrm{a}] = (F_a[\mathrm{a}] - F_b[\mathrm{a}]), D[\mathrm{b}] = (F_a[\mathrm{b}] - F_b[\mathrm{b}]), D[\mathrm{c}] = (F_a[\mathrm{c}] - F_b[\mathrm{c}]), \ldots, D[\mathrm{z}] = (F_a[\mathrm{z}] - F_b[\mathrm{z}])\}\)</span></p>
<p><span class="math inline">\(D[\mathrm{c}]\)</span> (where <span class="math inline">\(\mathrm{c} \in \{\mathrm{a},\mathrm{b},\ldots,\mathrm{z}\}\)</span>) contains the difference between the number of occurrences of the character <span class="math inline">\(\mathrm{c}\)</span> in the string <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>. Depending on whether the value of <span class="math inline">\(D[\mathrm{c}]\)</span> is greater or smaller than <span class="math inline">\(0\)</span>, <span class="math inline">\(a\)</span> has an excess or a deficit of the letter c, respectively.</p>
<p>Firstly, notice that <span class="math inline">\(\sum_{c=\mathrm{a}}^{\mathrm{z}} D[\mathrm{c}] = 0\)</span>. This observation stems from the fact that <span class="math inline">\(|a|=n=m=|b|\)</span> (<span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> must have equal length for this problem to have a solution, remember?) and that if <span class="math inline">\(a\)</span> has an excess of a certain character <span class="math inline">\(\mathrm{c}\)</span> then there must exist another character <span class="math inline">\(\mathrm{d} \neq \mathrm{c}\)</span> that the string <span class="math inline">\(a\)</span> has a shortage of. If that is not the case, it is impossible for <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> to have equal lenght.</p>
<p>We can use this fact to modify the excesses of the letters of <span class="math inline">\(a\)</span>, the ones having a positive value of <span class="math inline">\(D\)</span> into some of the letters there is a shortage of so that eventually, every single value of <span class="math inline">\(D\)</span> is zero. If <span class="math inline">\(D[\mathrm{c}] = x\)</span> is going to take <span class="math inline">\(x\)</span> modifications to transform the excess of characters <span class="math inline">\(\mathrm{c}\)</span>. The answer to this problem is, therefore, the sum of all the positive numbers of <span class="math inline">\(D\)</span>.</p>
<p>Listings <a href="#list:two_string_anagram_histogram" data-reference-type="ref" data-reference="list:two_string_anagram_histogram">[list:two_string_anagram_histogram]</a> shows a possible implemenetation of the idea above.</p>
<div class="sourceCode" id="list:two_string_anagram_histogram" data-language="c++" data-caption="&quot;C++ solution to the two string anagram problem using the histogram approach.&quot;" label="list:two_string_anagram_histogram"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:two_string_anagram_histogram-1"><a href="#list:two_string_anagram_histogram-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> solution_histogram<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> &amp;</span>a<span class="op">,</span> <span class="at">const</span> <span class="bu">std::</span>string<span class="op"> &amp;</span>b<span class="op">)</span></span>
<span id="list:two_string_anagram_histogram-2"><a href="#list:two_string_anagram_histogram-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:two_string_anagram_histogram-3"><a href="#list:two_string_anagram_histogram-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>a<span class="op">.</span>length<span class="op">()</span> <span class="op">!=</span> b<span class="op">.</span>length<span class="op">())</span></span>
<span id="list:two_string_anagram_histogram-4"><a href="#list:two_string_anagram_histogram-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:two_string_anagram_histogram-5"><a href="#list:two_string_anagram_histogram-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:two_string_anagram_histogram-6"><a href="#list:two_string_anagram_histogram-6" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>array<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">128</span><span class="op">&gt;</span> F <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="list:two_string_anagram_histogram-7"><a href="#list:two_string_anagram_histogram-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> a<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span></span>
<span id="list:two_string_anagram_histogram-8"><a href="#list:two_string_anagram_histogram-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:two_string_anagram_histogram-9"><a href="#list:two_string_anagram_histogram-9" aria-hidden="true" tabindex="-1"></a>    F<span class="op">[</span>a<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> <span class="ch">&#39;a&#39;</span><span class="op">]++;</span></span>
<span id="list:two_string_anagram_histogram-10"><a href="#list:two_string_anagram_histogram-10" aria-hidden="true" tabindex="-1"></a>    F<span class="op">[</span>b<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> <span class="ch">&#39;a&#39;</span><span class="op">]--;</span></span>
<span id="list:two_string_anagram_histogram-11"><a href="#list:two_string_anagram_histogram-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:two_string_anagram_histogram-12"><a href="#list:two_string_anagram_histogram-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:two_string_anagram_histogram-13"><a href="#list:two_string_anagram_histogram-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:two_string_anagram_histogram-14"><a href="#list:two_string_anagram_histogram-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span> x <span class="op">:</span> F<span class="op">)</span></span>
<span id="list:two_string_anagram_histogram-15"><a href="#list:two_string_anagram_histogram-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>x <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:two_string_anagram_histogram-16"><a href="#list:two_string_anagram_histogram-16" aria-hidden="true" tabindex="-1"></a>      ans <span class="op">+=</span> x<span class="op">;</span></span>
<span id="list:two_string_anagram_histogram-17"><a href="#list:two_string_anagram_histogram-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:two_string_anagram_histogram-18"><a href="#list:two_string_anagram_histogram-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:two_string_anagram_histogram-19"><a href="#list:two_string_anagram_histogram-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice how the array of differences of frequencies <span class="math inline">\(D\)</span> can be easily calculated without explicitly computing the frequencies for the characters of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> but by simply adding <span class="math inline">\(1\)</span> to <span class="math inline">\(D[\mathrm{c}]\)</span> when the letter <span class="math inline">\(\mathrm{c}\)</span> appears in <span class="math inline">\(a\)</span> and subtracting <span class="math inline">\(1\)</span> when it does in <span class="math inline">\(b\)</span>.</p>
<p><strong>The time and space complexity of the code above is <span class="math inline">\(O(n)\)</span> and <span class="math inline">\(O(1)\)</span> in space</strong> (we are using an array of <span class="math inline">\(128\)</span> integers regardless of the size of the input). We cannot do better than this as all characters in the input strings must be at least read once.</p>
<h1 id="ch:two_numbers_sum">Two numbers sum problem</h1>
<h2 class="unnumbered" id="introduction-3">Introduction</h2>
<p>The problem described in this lesson is possibly one of the most asked during coding interviews, nowadays, mostly during the early online stages of the hiring process as the interviewer pretty much expects you to be at least familiar with the problem or to have read it at some point during your preparation.</p>
<p>The problem is hard enough to require non-trivial insights in order to be able to write a non-trivial solution but, at the same time, it is not so hard that it would take you hours to come up with something meaningful to say or to write.</p>
<p>We will have a look at a number of solutions, starting from the inefficient brute force that we will later refine into a fast and time-optimal one. We will delve also into a radically different approach based on sorting and finally, we will condense the strengths of all the solutions investigated so far, into a time and space optimal solution that we think would do better in an interview context as it is efficient and not terribly difficult to write and explain (which are fundamental aspects of every successful coding interview).</p>
<h2 id="problem-statement-3">Problem statement</h2>
<div class="exercise">
<p>Write a function that takes an array of integers <span class="math inline">\(A\)</span> of size <span class="math inline">\(n\)</span> and an integer <span class="math inline">\(T\)</span>, and returns <strong>true</strong> if the sum of any two distinct elements <span class="math inline">\(I\)</span> is equal to <span class="math inline">\(T\)</span>, <strong>false</strong> otherwise.</p>
<p>More formally: Given an array <span class="math inline">\(=\{a_1,...,a_n\}\)</span> and <span class="math inline">\(T\)</span>, where <span class="math inline">\(a_i, T \in
	\mathcal{N}\)</span>, return:</p>
<ul>
<li><p><strong>true</strong> if <span class="math inline">\(\: \exists \;i,j \:\: i \neq j\)</span> s.t. <span class="math inline">\(a_i+a_j = T\)</span></p></li>
<li><p><strong>false</strong> otherwise</p></li>
</ul>
<div class="example">
<p><br />
Given <span class="math inline">\(A=\{9, 4, 17, 42, 36, -3 ,15\}\)</span> and <span class="math inline">\(T=14\)</span>, the function returns <strong>true</strong> because we can obtain <span class="math inline">\(14\)</span> by summing up together the elements <span class="math inline">\(17\)</span> and <span class="math inline">\(-3\)</span>. If <span class="math inline">\(T=17\)</span> the answer is <strong>false</strong>.</p>
</div>
<div class="example">
<p><br />
Given <span class="math inline">\(A=\{1,3,7\}\)</span> and <span class="math inline">\(T=8\)</span>, the function returns <strong>true</strong> because we can obtain <span class="math inline">\(8\)</span> by summing up together the elements <span class="math inline">\(7\)</span> and <span class="math inline">\(1\)</span>. If <span class="math inline">\(T=6\)</span> the answer is <strong>false</strong>.</p>
</div>
</div>
<h2 id="clarification-questions-3">Clarification Questions</h2>
<div class="QandA">
<p>Is the input array modifiable?</p>
<div class="answered">
<p><em>Yes, the input array can be modified.</em></p>
</div>
<p>Are the integers guaranteed to be all positive or all negative?</p>
<div class="answered">
<p><em>No, <span class="math inline">\(A\)</span> can contain positive or negative numbers.</em></p>
</div>
<p>Are the values in <span class="math inline">\(A\)</span> guaranteed to be from a given range?</p>
<div class="answered">
<p><em>No, the input is arbitrary. No assumption can be made on the magnitude of the elements of <span class="math inline">\(A\)</span>.</em></p>
</div>
<p>Can a pair be made from an element and itself?</p>
<div class="answered">
<p><em>No, the pair’s elements should be distinct. You cannot use the same element <span class="math inline">\(a_i\)</span> twice. You can however use two elements at indices <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> s.t. <span class="math inline">\(i \neq j\)</span> and <span class="math inline">\(a_i=a_j\)</span>.</em></p>
</div>
<p>Are all elements in the array unique?</p>
<div class="answered">
<p><em>No, duplicates are allowed.</em></p>
</div>
<p>Is the input sorted?</p>
<div class="answered">
<p><em>No, the ordering of <span class="math inline">\(A\)</span> is arbitrary.</em></p>
</div>
<p>Shall the function integer overflow be considered when performing the sum of two integers? Is it possible for two elements of <span class="math inline">\(A\)</span> to sum up to a value that does not fit in a standard ?</p>
<div class="answered">
<p><em>No, you do not need to worry about overflow.</em></p>
</div>
</div>
<h2 id="discussion-2">Discussion</h2>
<h3 id="sec:two_numbers:bruteforce">Brute-force</h3>
<p>The brute force solution is fairly straightforward because it consists of a direct application of the formal problem statement. The solution space consists of all possible ordered pairs <span class="math inline">\((a_i,a_j)\)</span>, <span class="math inline">\(i &lt; j\)</span>. Two nested loops can be used to enumerate all those pairs and, for each of them we can check whether their sum is equal to <span class="math inline">\(T\)</span>: if that is the case then <strong>true</strong> can be immediately returned, otherwise, if we have checked every possible pair and none of them was good, then we can return <strong>false</strong>.</p>
<p>You will find an a fomalization and an implementation of this idea in Algorithm <a href="#algo:two_number_sum_bruteforce" data-reference-type="ref" data-reference="algo:two_number_sum_bruteforce">[algo:two_number_sum_bruteforce]</a> and Listing <a href="#list:two_number_sum_bruteforce" data-reference-type="ref" data-reference="list:two_number_sum_bruteforce">[list:two_number_sum_bruteforce]</a>), respectively.</p>
<div class="algorithm">
<p><strong>End Function</strong></p>
</div>
<div class="sourceCode" id="list:two_number_sum_bruteforce" data-language="c++" data-caption="&quot;C++ solution of the two number sum problem with a brute force approach.&quot;" label="list:two_number_sum_bruteforce"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:two_number_sum_bruteforce-1"><a href="#list:two_number_sum_bruteforce-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> two_numers_sum_bruteforce<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>A<span class="op">,</span> <span class="at">const</span> <span class="dt">int</span> T<span class="op">)</span></span>
<span id="list:two_number_sum_bruteforce-2"><a href="#list:two_number_sum_bruteforce-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:two_number_sum_bruteforce-3"><a href="#list:two_number_sum_bruteforce-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">size_t</span> size <span class="op">=</span> A<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:two_number_sum_bruteforce-4"><a href="#list:two_number_sum_bruteforce-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:two_number_sum_bruteforce-5"><a href="#list:two_number_sum_bruteforce-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> j<span class="op">++)</span></span>
<span id="list:two_number_sum_bruteforce-6"><a href="#list:two_number_sum_bruteforce-6" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>A<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> A<span class="op">[</span>j<span class="op">]</span> <span class="op">==</span> T<span class="op">)</span></span>
<span id="list:two_number_sum_bruteforce-7"><a href="#list:two_number_sum_bruteforce-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:two_number_sum_bruteforce-8"><a href="#list:two_number_sum_bruteforce-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:two_number_sum_bruteforce-9"><a href="#list:two_number_sum_bruteforce-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>The time complexity of this solution is <span class="math inline">\(O(n^2)\)</span></strong> because there is a quadratic number of ordered pairs and in the worst case, we will look at <strong>all</strong> of them. The number of iteration of the internal loop depends on the value of <span class="math inline">\(i\)</span> and it is described by the function: <span class="math inline">\(f(i) = n-i-1\)</span>. The total number of iteration the second loop runs in the worst case is the the sum of <span class="math inline">\(f(i)\)</span> for all values of <span class="math inline">\(i\)</span>: <span class="math inline">\(\sum_{i=0}^{n-2} f(i) = (n-1) + (n-2) + (n-3) \ldots + 1 =\sum_{x=1}^{n-1} x= \frac{n(n-1)}{2} = O(n^2)\)</span></p>
<p><strong>The space complexity is <span class="math inline">\(O(1)\)</span></strong>.</p>
<h3 id="sec:two_numbers:hashing">Hashing</h3>
<p>The internal loop of Listing <a href="#list:two_number_sum_bruteforce" data-reference-type="ref" data-reference="list:two_number_sum_bruteforce">[list:two_number_sum_bruteforce]</a> can be eliminated entirely with the help of a hashtable. The key insight is that if a solution exists involving <span class="math inline">\(a_i\)</span> then, it must the case that exists another element <span class="math inline">\(a_j  = a_i-T\)</span> with <span class="math inline">\(i &gt; j\)</span>.</p>
<p>What this means in practice is that we can loop through <span class="math inline">\(A\)</span> one element at a time and keep track, in a lookup table, of all the elements seen so far so that the lookup operation for the aforementioned element <span class="math inline">\(a_j\)</span> can be performed in constant time.</p>
<p>Algorithm <a href="#algo:two_number_sum_hashset" data-reference-type="ref" data-reference="algo:two_number_sum_hashset">[algo:two_number_sum_hashset]</a> and Listing <a href="#list:two_number_sum_hashing" data-reference-type="ref" data-reference="list:two_number_sum_hashing">[list:two_number_sum_hashing]</a> shows this idea in code.</p>
<div class="algorithm">
<p><strong>End Function</strong></p>
</div>
<div class="sourceCode" id="list:two_number_sum_hashing" data-language="c++" data-caption="&quot;C++ solution of the two number sum problem using hashing.&quot;" label="list:two_number_sum_hashing"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:two_number_sum_hashing-1"><a href="#list:two_number_sum_hashing-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> two_numers_sum_hashset<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>A<span class="op">,</span> <span class="at">const</span> <span class="dt">int</span> T<span class="op">)</span></span>
<span id="list:two_number_sum_hashing-2"><a href="#list:two_number_sum_hashing-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:two_number_sum_hashing-3"><a href="#list:two_number_sum_hashing-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>unordered_set<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> H<span class="op">;</span></span>
<span id="list:two_number_sum_hashing-4"><a href="#list:two_number_sum_hashing-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">size_t</span> size <span class="op">=</span> A<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:two_number_sum_hashing-5"><a href="#list:two_number_sum_hashing-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size <span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:two_number_sum_hashing-6"><a href="#list:two_number_sum_hashing-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:two_number_sum_hashing-7"><a href="#list:two_number_sum_hashing-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>H<span class="op">.</span>find<span class="op">(</span>T<span class="op">-</span>A<span class="op">[</span>i<span class="op">])</span> <span class="op">!=</span> end<span class="op">(</span>H<span class="op">))</span></span>
<span id="list:two_number_sum_hashing-8"><a href="#list:two_number_sum_hashing-8" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:two_number_sum_hashing-9"><a href="#list:two_number_sum_hashing-9" aria-hidden="true" tabindex="-1"></a>    H<span class="op">.</span>insert<span class="op">(</span>A<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:two_number_sum_hashing-10"><a href="#list:two_number_sum_hashing-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:two_number_sum_hashing-11"><a href="#list:two_number_sum_hashing-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:two_number_sum_hashing-12"><a href="#list:two_number_sum_hashing-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The time complexity of this approach is <span class="math inline">\(O(n)\)</span> (technically is linear on average due to complexity of lookups in hash tables) because the input array is scanned once and for each of its elements, only one lookup and insertion are performed in the hashtable (both operations costing constant time on average).</p>
<p>The space complexity is also <span class="math inline">\(O(n)\)</span>, as in the worst case the whole input array is stored in the lookup table.</p>
<p>A common mistake when solving this problem using this approach is to insert the whole input array into the lookup table and only after searching for <span class="math inline">\((T-a_i)\)</span>. The mistake become evident when <span class="math inline">\(T\)</span> is an even number (<span class="math inline">\(2 | T\)</span>) and <span class="math inline">\(\frac{T}{2}\)</span> appears in <span class="math inline">\(A\)</span> exactly once, at index <span class="math inline">\(k\)</span> i.e. <span class="math inline">\(a_k = \frac{T}{2}\)</span> causing to return <strong>true</strong> which is wrong because this correspond to a solution where we sum <span class="math inline">\(a_k\)</span> twice to obtain <span class="math inline">\(T\)</span>.</p>
<p>For instance, when <span class="math inline">\(A=\{1,2,5,4\}\)</span> and <span class="math inline">\(T=10\)</span> this approach returns <strong>true</strong> even if there are not two elements at distinct indices in <span class="math inline">\(A\)</span> whose sum is <span class="math inline">\(T\)</span> (we would use <span class="math inline">\(5\)</span> twice to obtain <span class="math inline">\(10\)</span>).</p>
<div class="example">
<p><br />
</p>
<ul>
<li><p><span class="math inline">\(A=\{1,2,5,4\}\)</span></p></li>
<li><p><span class="math inline">\(T = 10\)</span></p></li>
</ul>
<p>Algorithm <a href="#algo:two_numbers_sum_hashset_wrong" data-reference-type="ref" data-reference="algo:two_numbers_sum_hashset_wrong">[algo:two_numbers_sum_hashset_wrong]</a> wrongly return true even if there are not two distinct elements whose sum is <span class="math inline">\(10\)</span>.</p>
</div>
<div class="algorithm">
<p><strong>End Function</strong></p>
</div>
<h3 id="sect:two_number_problem_binary_search">Sorting and binary search</h3>
<p>As with countless other problems on arrays, sorting the input often opens the way to a faster and more efficient solution.</p>
<p>You can start by asking yourself: <strong>how does the problem change if <span class="math inline">\(A\)</span> is sorted?</strong> Sorted arrays are naturally associated with binary search and for good reasons! Many problems can be solved efficiently by pairing sorting and binary search on arrays. This problem is no different, and we can use binary search if <span class="math inline">\(A\)</span> is sorted to substitute the internal loop of the brute force solution shown in Listing <a href="#list:two_number_sum_bruteforce" data-reference-type="ref" data-reference="list:two_number_sum_bruteforce">[list:two_number_sum_bruteforce]</a>. This way, we can lower the overall time complexity down to <span class="math inline">\(O(n log(n))\)</span>; it costs <span class="math inline">\(O(n log(n))\)</span> to sort the input array in the first place, and the actual search consists of <span class="math inline">\(n\)</span> binary searches, each of them costing <span class="math inline">\(O(log(n))\)</span>.</p>
<p>The space complexity is <span class="math inline">\(O(1)\)</span> because no additional space is required since the array is sorted in place.</p>
<p>Listing <a href="#list:two_number_sum_sorting" data-reference-type="ref" data-reference="list:two_number_sum_sorting">[list:two_number_sum_sorting]</a> shows a C++ implementation of this idea. Notice that it uses from the C++ standard library and that a possible follow up question might be to show your own version of the binary search algorithm.</p>
<div class="sourceCode" id="list:two_number_sum_sorting" data-language="c++" data-caption="&quot;C++ solution of the two number sum problem with sorting and binary search.&quot;" label="list:two_number_sum_sorting"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:two_number_sum_sorting-1"><a href="#list:two_number_sum_sorting-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> two_numers_sum_sorting<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>A<span class="op">,</span> <span class="at">const</span> <span class="dt">int</span> T<span class="op">)</span></span>
<span id="list:two_number_sum_sorting-2"><a href="#list:two_number_sum_sorting-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:two_number_sum_sorting-3"><a href="#list:two_number_sum_sorting-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>ranges<span class="bu">::</span>sort<span class="op">(</span>A<span class="op">);</span></span>
<span id="list:two_number_sum_sorting-4"><a href="#list:two_number_sum_sorting-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">size_t</span> size <span class="op">=</span> A<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:two_number_sum_sorting-5"><a href="#list:two_number_sum_sorting-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:two_number_sum_sorting-6"><a href="#list:two_number_sum_sorting-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>binary_search<span class="op">(</span>begin<span class="op">(</span>A<span class="op">)</span> <span class="op">+</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> end<span class="op">(</span>A<span class="op">),</span> T<span class="op">-</span>A<span class="op">[</span>i<span class="op">]))</span></span>
<span id="list:two_number_sum_sorting-7"><a href="#list:two_number_sum_sorting-7" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:two_number_sum_sorting-8"><a href="#list:two_number_sum_sorting-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:two_number_sum_sorting-9"><a href="#list:two_number_sum_sorting-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="sec:two_numbers:twopointers">Sorting and two pointers technique</h3>
<p>There is a variation to the to the approach described in Section <a href="#sect:two_number_problem_binary_search" data-reference-type="ref" data-reference="sect:two_number_problem_binary_search">4.3.3</a> which still involves sorting but uses a two-pointers technique instead of binary search to finish the job.</p>
<p>The key idea is that once <span class="math inline">\(A\)</span> is sorted, the algorithm initialized two pointers, one starting at the beginning (<span class="math inline">\(p_s\)</span>) and the other at the end (<span class="math inline">\(p_e\)</span>) of the array, respectively. It continues by looking at the sum of the two elements pointed by the two pointers and moving one of the two at each step using the following logic:</p>
<ul>
<li><p>if <span class="math inline">\(a[p_s]+a[p_e] = T\)</span> a solution has been found. The algorithm returns true.</p></li>
<li><p>if <span class="math inline">\(a[p_s]+a[p_e] &gt; T\)</span>, <span class="math inline">\(p_e=p_e-1\)</span>. The right pointer is moved to the left.</p></li>
</ul>
<p>Moving <span class="math inline">\(p_e\)</span> to the left has the effect of making the sum of the values pointed by the two pointers smaller (this has an effect at the next iteration). - if <span class="math inline">\(a[p_s]+a[p_e] &lt; T\)</span>, <span class="math inline">\(p_s=p_s+1\)</span>. The right end pointer is moved to the left. Moving <span class="math inline">\(p_s\)</span> to the right has the effect of making the sum of the values pointed by the two pointers larger.</p>
<p>Listing <a href="#list:two_number_sum_two_pointers" data-reference-type="ref" data-reference="list:two_number_sum_two_pointers">[list:two_number_sum_two_pointers]</a> shows an implementation of the idea above. Notice that compared to the solution using the binary search, this one is shorter and simpler to write. Moreover does not use library functions.</p>
<div class="sourceCode" id="list:two_number_sum_two_pointers" data-language="c++" data-caption="&quot;C++ solution of the two number sum problem with the two pointers tecnique.&quot;" label="list:two_number_sum_two_pointers"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:two_number_sum_two_pointers-1"><a href="#list:two_number_sum_two_pointers-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> two_numers_sum_two_pointers<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>A<span class="op">,</span> <span class="at">const</span> <span class="dt">int</span> T<span class="op">)</span></span>
<span id="list:two_number_sum_two_pointers-2"><a href="#list:two_number_sum_two_pointers-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:two_number_sum_two_pointers-3"><a href="#list:two_number_sum_two_pointers-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> s <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> e <span class="op">=</span> A<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:two_number_sum_two_pointers-4"><a href="#list:two_number_sum_two_pointers-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>s <span class="op">&lt;</span> e<span class="op">)</span></span>
<span id="list:two_number_sum_two_pointers-5"><a href="#list:two_number_sum_two_pointers-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:two_number_sum_two_pointers-6"><a href="#list:two_number_sum_two_pointers-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> sum <span class="op">=</span> A<span class="op">[</span>s<span class="op">]</span> <span class="op">+</span> A<span class="op">[</span>e<span class="op">];</span></span>
<span id="list:two_number_sum_two_pointers-7"><a href="#list:two_number_sum_two_pointers-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>sum <span class="op">&lt;</span> T<span class="op">)</span></span>
<span id="list:two_number_sum_two_pointers-8"><a href="#list:two_number_sum_two_pointers-8" aria-hidden="true" tabindex="-1"></a>      s<span class="op">++;</span></span>
<span id="list:two_number_sum_two_pointers-9"><a href="#list:two_number_sum_two_pointers-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>sum <span class="op">&gt;</span> T<span class="op">)</span></span>
<span id="list:two_number_sum_two_pointers-10"><a href="#list:two_number_sum_two_pointers-10" aria-hidden="true" tabindex="-1"></a>      e<span class="op">--;</span></span>
<span id="list:two_number_sum_two_pointers-11"><a href="#list:two_number_sum_two_pointers-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="list:two_number_sum_two_pointers-12"><a href="#list:two_number_sum_two_pointers-12" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:two_number_sum_two_pointers-13"><a href="#list:two_number_sum_two_pointers-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:two_number_sum_two_pointers-14"><a href="#list:two_number_sum_two_pointers-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:two_number_sum_two_pointers-15"><a href="#list:two_number_sum_two_pointers-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Despite the overall time complexity is still <span class="math inline">\(O(n log(n))\)</span> this solution is likely to be faster than the one using binary search, mostly due to the fact that the array is scanned linearly (which makes caches happier) by the two pointers and not in a scattered way as in the case of binary search.</p>
<h2 id="common-variations">Common Variations</h2>
<h3 id="sec:four_number">Four numbers sum problem</h3>
<h3 id="problem-statement-4">Problem statement</h3>
<div class="exercise">
<p>Write a function that takes four arrays of integers, <span class="math inline">\(A,B,C,D\)</span> and a integer <span class="math inline">\(T\)</span>, and returns how many distinct tuple <span class="math inline">\((i,j,k,l)\)</span> where exist such that <span class="math inline">\(A_i+B_j+C_k+D_l = Y\)</span>.</p>
<div class="example">
<p><br />
Given:</p>
<ul>
<li><p><span class="math inline">\(A=\{1,2\}\)</span>,</p></li>
<li><p><span class="math inline">\(B=\{-2,-1\}\)</span>,</p></li>
<li><p><span class="math inline">\(C=\{-1,2\}\)</span>,</p></li>
<li><p><span class="math inline">\(D=\{0,2\}\)</span>, and</p></li>
<li><p><span class="math inline">\(T = 0\)</span></p></li>
</ul>
<p>The answer is <span class="math inline">\(2\)</span> because the only two valid tuples are:</p>
<ol>
<li><p><span class="math inline">\((0,0,0,1)\)</span>: <span class="math inline">\(A_0 + B_0 + C_0 + D_1 = 1 + (-2) + (-1) + 2 = T = 0\)</span></p></li>
<li><p><span class="math inline">\((1,1,0,0)\)</span>: <span class="math inline">\(A_1 + B_1 + C_0 + D_0 = 2 + (-1) + (-1) + (-1) = T = 0\)</span></p></li>
</ol>
</div>
</div>
<h3 id="naïve-on4-solution">Naïve <span class="math inline">\(O(n^4)\)</span> solution</h3>
<p>We can solve this problem very easily by using the same approach we have described in Section <a href="#sec:two_numbers:bruteforce" data-reference-type="ref" data-reference="sec:two_numbers:bruteforce">4.3.1</a>. The idea is that we can use four nested loops and enumerate all possible 4-elements tuples of indices. Listing <a href="#list:two_number_sum_naive" data-reference-type="ref" data-reference="list:two_number_sum_naive">[list:two_number_sum_naive]</a> shows how such an idea can be implemented. Goes without saying, that this is not the fastest solution we can come up with, considering it has a time complexity of <span class="math inline">\(O(n^4)\)</span></p>
<div class="sourceCode" id="list:two_number_sum_naive" data-language="c++" data-caption="&quot;Brute force na\&quot;ive solution to the four numbers sum problem.&quot;" label="list:two_number_sum_naive"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:two_number_sum_naive-1"><a href="#list:two_number_sum_naive-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> four_sum_bruteforce<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> A<span class="op">,</span></span>
<span id="list:two_number_sum_naive-2"><a href="#list:two_number_sum_naive-2" aria-hidden="true" tabindex="-1"></a>                        <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> B<span class="op">,</span></span>
<span id="list:two_number_sum_naive-3"><a href="#list:two_number_sum_naive-3" aria-hidden="true" tabindex="-1"></a>                        <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> C<span class="op">,</span></span>
<span id="list:two_number_sum_naive-4"><a href="#list:two_number_sum_naive-4" aria-hidden="true" tabindex="-1"></a>                        <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> D<span class="op">,</span></span>
<span id="list:two_number_sum_naive-5"><a href="#list:two_number_sum_naive-5" aria-hidden="true" tabindex="-1"></a>                        <span class="at">const</span> <span class="dt">int</span> T<span class="op">)</span></span>
<span id="list:two_number_sum_naive-6"><a href="#list:two_number_sum_naive-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:two_number_sum_naive-7"><a href="#list:two_number_sum_naive-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:two_number_sum_naive-8"><a href="#list:two_number_sum_naive-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> A<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span></span>
<span id="list:two_number_sum_naive-9"><a href="#list:two_number_sum_naive-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> B<span class="op">.</span>size<span class="op">();</span> j<span class="op">++)</span></span>
<span id="list:two_number_sum_naive-10"><a href="#list:two_number_sum_naive-10" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> C<span class="op">.</span>size<span class="op">();</span> k<span class="op">++)</span></span>
<span id="list:two_number_sum_naive-11"><a href="#list:two_number_sum_naive-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> l <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> l <span class="op">&lt;</span> D<span class="op">.</span>size<span class="op">();</span> l<span class="op">++)</span></span>
<span id="list:two_number_sum_naive-12"><a href="#list:two_number_sum_naive-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="list:two_number_sum_naive-13"><a href="#list:two_number_sum_naive-13" aria-hidden="true" tabindex="-1"></a>          <span class="at">const</span> <span class="dt">long</span> sum <span class="op">=</span> <span class="op">(</span><span class="dt">long</span><span class="op">)</span>A<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> <span class="op">(</span><span class="dt">long</span><span class="op">)</span>B<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> </span>
<span id="list:two_number_sum_naive-14"><a href="#list:two_number_sum_naive-14" aria-hidden="true" tabindex="-1"></a>                           <span class="op">(</span><span class="dt">long</span><span class="op">)</span>C<span class="op">[</span>k<span class="op">]</span> <span class="op">+</span> <span class="op">(</span><span class="dt">long</span><span class="op">)</span>D<span class="op">[</span>l<span class="op">];</span></span>
<span id="list:two_number_sum_naive-15"><a href="#list:two_number_sum_naive-15" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> <span class="op">(</span>sum <span class="op">==</span> T<span class="op">)</span></span>
<span id="list:two_number_sum_naive-16"><a href="#list:two_number_sum_naive-16" aria-hidden="true" tabindex="-1"></a>            ans<span class="op">++;</span></span>
<span id="list:two_number_sum_naive-17"><a href="#list:two_number_sum_naive-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="list:two_number_sum_naive-18"><a href="#list:two_number_sum_naive-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:two_number_sum_naive-19"><a href="#list:two_number_sum_naive-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:two_number_sum_naive-20"><a href="#list:two_number_sum_naive-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="on3-solution"><span class="math inline">\(O(n^3)\)</span> solution</h3>
<p>The trivial solution shown in Listing <a href="#list:two_number_sum_naive" data-reference-type="ref" data-reference="list:two_number_sum_naive">[list:two_number_sum_naive]</a> can be improved by using a similar reason that lead us improve the brute-force quadratic time solution for the two numbers problem in Listing <a href="#list:two_number_sum_bruteforce" data-reference-type="ref" data-reference="list:two_number_sum_bruteforce">[list:two_number_sum_bruteforce]</a> to the linear time (and space) in Listing <a href="#list:two_number_sum_hashing" data-reference-type="ref" data-reference="list:two_number_sum_hashing">[list:two_number_sum_hashing]</a>.</p>
<p>The idea is that inner-most loop is searching for a value <span class="math inline">\(D_l = x\)</span> s.t. if it summed to <span class="math inline">\(A_i+B_j+C_k\)</span> gives us <span class="math inline">\(T\)</span>; in other words: <span class="math inline">\(x+(A_i+B_j+C_k)=T\)</span>. Therefore <span class="math inline">\(x = T-(A_i+B_j+C_k)\)</span>. If there is a way of avoiding a linear search in the array <span class="math inline">\(D\)</span> for such a value, then we could bring down the complexity from <span class="math inline">\(O(n^4)\)</span> to <span class="math inline">\(O(n^3)\)</span>.</p>
<p>Thankfully this is possible if we use a hash map. If we create a hashmap mapping the value of <span class="math inline">\(D\)</span> and to their frequencies, the inner-most loop of the <span class="math inline">\(O(n^4)\)</span> solution above can be substituted with a query to the hashmap which runs in constant time (on average).</p>
<p>Listing <a href="#list:two_number_sum_cubic" data-reference-type="ref" data-reference="list:two_number_sum_cubic">[list:two_number_sum_cubic]</a> shows an implementation of such idea. Notice that in order to obtain the maximum saving in terms of work avoided the arrays are rearranged in such a way so that <span class="math inline">\(D\)</span> is the longest of the four input arrays.</p>
<div class="sourceCode" id="list:two_number_sum_cubic" data-language="c++" data-caption="&quot;Brute force cubic time solution to the four numbers sum problem.&quot;" label="list:two_number_sum_cubic"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:two_number_sum_cubic-1"><a href="#list:two_number_sum_cubic-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> four_sum_cubic<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> A<span class="op">,</span></span>
<span id="list:two_number_sum_cubic-2"><a href="#list:two_number_sum_cubic-2" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> B<span class="op">,</span></span>
<span id="list:two_number_sum_cubic-3"><a href="#list:two_number_sum_cubic-3" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> C<span class="op">,</span></span>
<span id="list:two_number_sum_cubic-4"><a href="#list:two_number_sum_cubic-4" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> D<span class="op">,</span></span>
<span id="list:two_number_sum_cubic-5"><a href="#list:two_number_sum_cubic-5" aria-hidden="true" tabindex="-1"></a>                        <span class="at">const</span> <span class="dt">int</span> T<span class="op">)</span></span>
<span id="list:two_number_sum_cubic-6"><a href="#list:two_number_sum_cubic-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:two_number_sum_cubic-7"><a href="#list:two_number_sum_cubic-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>A<span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;</span> D<span class="op">.</span>size<span class="op">())</span></span>
<span id="list:two_number_sum_cubic-8"><a href="#list:two_number_sum_cubic-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>swap<span class="op">(</span>A<span class="op">,</span>D<span class="op">);</span></span>
<span id="list:two_number_sum_cubic-9"><a href="#list:two_number_sum_cubic-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>B<span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;</span> D<span class="op">.</span>size<span class="op">())</span></span>
<span id="list:two_number_sum_cubic-10"><a href="#list:two_number_sum_cubic-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>swap<span class="op">(</span>B<span class="op">,</span>D<span class="op">);</span></span>
<span id="list:two_number_sum_cubic-11"><a href="#list:two_number_sum_cubic-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>C<span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;</span> D<span class="op">.</span>size<span class="op">())</span></span>
<span id="list:two_number_sum_cubic-12"><a href="#list:two_number_sum_cubic-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>swap<span class="op">(</span>C<span class="op">,</span>D<span class="op">);</span>  </span>
<span id="list:two_number_sum_cubic-13"><a href="#list:two_number_sum_cubic-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:two_number_sum_cubic-14"><a href="#list:two_number_sum_cubic-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">//D is now the longest</span></span>
<span id="list:two_number_sum_cubic-15"><a href="#list:two_number_sum_cubic-15" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>unordered_map<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span><span class="dt">int</span><span class="op">&gt;</span>Dmap<span class="op">;</span> <span class="co">//frequencies map for D</span></span>
<span id="list:two_number_sum_cubic-16"><a href="#list:two_number_sum_cubic-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span><span class="at">const</span> <span class="kw">auto</span> d <span class="op">:</span> D<span class="op">)</span></span>
<span id="list:two_number_sum_cubic-17"><a href="#list:two_number_sum_cubic-17" aria-hidden="true" tabindex="-1"></a>      Dmap<span class="op">[</span>d<span class="op">]++;</span></span>
<span id="list:two_number_sum_cubic-18"><a href="#list:two_number_sum_cubic-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:two_number_sum_cubic-19"><a href="#list:two_number_sum_cubic-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:two_number_sum_cubic-20"><a href="#list:two_number_sum_cubic-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> A<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span></span>
<span id="list:two_number_sum_cubic-21"><a href="#list:two_number_sum_cubic-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> B<span class="op">.</span>size<span class="op">();</span> j<span class="op">++)</span></span>
<span id="list:two_number_sum_cubic-22"><a href="#list:two_number_sum_cubic-22" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> C<span class="op">.</span>size<span class="op">();</span> k<span class="op">++){</span></span>
<span id="list:two_number_sum_cubic-23"><a href="#list:two_number_sum_cubic-23" aria-hidden="true" tabindex="-1"></a>          <span class="at">const</span> <span class="dt">long</span> sum <span class="op">=</span> <span class="op">(</span><span class="dt">long</span><span class="op">)</span>A<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> <span class="op">(</span><span class="dt">long</span><span class="op">)</span>B<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> </span>
<span id="list:two_number_sum_cubic-24"><a href="#list:two_number_sum_cubic-24" aria-hidden="true" tabindex="-1"></a>                           <span class="op">(</span><span class="dt">long</span><span class="op">)</span>C<span class="op">[</span>k<span class="op">];</span></span>
<span id="list:two_number_sum_cubic-25"><a href="#list:two_number_sum_cubic-25" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span><span class="op">(</span><span class="kw">auto</span> it <span class="op">=</span> Dmap<span class="op">.</span>find<span class="op">(</span>T<span class="op">-</span>sum<span class="op">)</span> <span class="op">;</span> it <span class="op">!=</span> Dmap<span class="op">.</span>end<span class="op">()){</span></span>
<span id="list:two_number_sum_cubic-26"><a href="#list:two_number_sum_cubic-26" aria-hidden="true" tabindex="-1"></a>              ans<span class="op">+=</span>it<span class="op">-&gt;</span>second<span class="op">;</span></span>
<span id="list:two_number_sum_cubic-27"><a href="#list:two_number_sum_cubic-27" aria-hidden="true" tabindex="-1"></a>          <span class="op">}</span></span>
<span id="list:two_number_sum_cubic-28"><a href="#list:two_number_sum_cubic-28" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="list:two_number_sum_cubic-29"><a href="#list:two_number_sum_cubic-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:two_number_sum_cubic-30"><a href="#list:two_number_sum_cubic-30" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:two_number_sum_cubic-31"><a href="#list:two_number_sum_cubic-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="on2-solution-using-hashing"><span class="math inline">\(O(n^2)\)</span> solution using hashing</h3>
<p>This problem can be however be solved in quadratic time if we use hashmaps in a smarter way, to hold the frequencies of all the values you can obtain by summing up any two elements of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> and of <span class="math inline">\(C\)</span> and <span class="math inline">\(D\)</span>. The key idea is that we can build two distinct hashmaps:</p>
<ul>
<li><p><span class="math inline">\(AB\)</span>: holding the frequencies of the values obtainable by summing any two elements of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span></p></li>
<li><p><span class="math inline">\(CD\)</span>: holding the frequencies of the values obtainable by summing any two elements of <span class="math inline">\(C\)</span> and <span class="math inline">\(D\)</span>.</p></li>
</ul>
<p>The space required for both <span class="math inline">\(AB\)</span> and <span class="math inline">\(CD\)</span> is quadratic, which is more than the space used by any of the previous solutions, but this extra space enable us to solve this variation also in quadratic time.</p>
<p>The idea is that we are going to spend <span class="math inline">\(O(n^2)\)</span> time to construct both <span class="math inline">\(AB\)</span> and <span class="math inline">\(CD\)</span> and then again <span class="math inline">\(O(n^2)\)</span> to calculate the final answer by searching into <span class="math inline">\(CD\)</span> for the value <span class="math inline">\(T-y\)</span> where <span class="math inline">\(y\)</span> is an element of <span class="math inline">\(AB\)</span>. If such a value exists in <span class="math inline">\(CD\)</span> it means that there exists one element in <span class="math inline">\(A\)</span> and one in <span class="math inline">\(B\)</span> such that they sum up to <span class="math inline">\(y\)</span> and one element <span class="math inline">\(C\)</span> and one in <span class="math inline">\(D\)</span> such that they sum up to <span class="math inline">\(T-y\)</span>. Summing all these elements up gives: <span class="math inline">\(y+T-y = T\)</span>. This approach is shown in Listing <a href="#list:two_number_sum_quadratic" data-reference-type="ref" data-reference="list:two_number_sum_quadratic">[list:two_number_sum_quadratic]</a>.</p>
<div class="sourceCode" id="list:two_number_sum_quadratic" data-language="c++" data-caption="&quot;Quadratic time solution to the four numbers sum problem.&quot;" label="list:two_number_sum_quadratic"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:two_number_sum_quadratic-1"><a href="#list:two_number_sum_quadratic-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> four_sum_hashing<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> A<span class="op">,</span></span>
<span id="list:two_number_sum_quadratic-2"><a href="#list:two_number_sum_quadratic-2" aria-hidden="true" tabindex="-1"></a>                    <span class="at">const</span>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> B<span class="op">,</span></span>
<span id="list:two_number_sum_quadratic-3"><a href="#list:two_number_sum_quadratic-3" aria-hidden="true" tabindex="-1"></a>                     <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> C<span class="op">,</span></span>
<span id="list:two_number_sum_quadratic-4"><a href="#list:two_number_sum_quadratic-4" aria-hidden="true" tabindex="-1"></a>                     <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> D<span class="op">,</span></span>
<span id="list:two_number_sum_quadratic-5"><a href="#list:two_number_sum_quadratic-5" aria-hidden="true" tabindex="-1"></a>                     <span class="at">const</span> <span class="dt">int</span> T<span class="op">)</span></span>
<span id="list:two_number_sum_quadratic-6"><a href="#list:two_number_sum_quadratic-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:two_number_sum_quadratic-7"><a href="#list:two_number_sum_quadratic-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">size_t</span> size <span class="op">=</span> A<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:two_number_sum_quadratic-8"><a href="#list:two_number_sum_quadratic-8" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>unordered_map<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> ab<span class="op">;</span></span>
<span id="list:two_number_sum_quadratic-9"><a href="#list:two_number_sum_quadratic-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:two_number_sum_quadratic-10"><a href="#list:two_number_sum_quadratic-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> j<span class="op">++)</span></span>
<span id="list:two_number_sum_quadratic-11"><a href="#list:two_number_sum_quadratic-11" aria-hidden="true" tabindex="-1"></a>      ab<span class="op">[</span>A<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> B<span class="op">[</span>j<span class="op">]]++;</span></span>
<span id="list:two_number_sum_quadratic-12"><a href="#list:two_number_sum_quadratic-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:two_number_sum_quadratic-13"><a href="#list:two_number_sum_quadratic-13" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>unordered_map<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> cd<span class="op">;</span></span>
<span id="list:two_number_sum_quadratic-14"><a href="#list:two_number_sum_quadratic-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:two_number_sum_quadratic-15"><a href="#list:two_number_sum_quadratic-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> j<span class="op">++)</span></span>
<span id="list:two_number_sum_quadratic-16"><a href="#list:two_number_sum_quadratic-16" aria-hidden="true" tabindex="-1"></a>      cd<span class="op">[</span>C<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> D<span class="op">[</span>j<span class="op">]]++;</span></span>
<span id="list:two_number_sum_quadratic-17"><a href="#list:two_number_sum_quadratic-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:two_number_sum_quadratic-18"><a href="#list:two_number_sum_quadratic-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:two_number_sum_quadratic-19"><a href="#list:two_number_sum_quadratic-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span> <span class="op">[</span>k<span class="op">,</span> v<span class="op">]</span> <span class="op">:</span> ab<span class="op">)</span></span>
<span id="list:two_number_sum_quadratic-20"><a href="#list:two_number_sum_quadratic-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:two_number_sum_quadratic-21"><a href="#list:two_number_sum_quadratic-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> it <span class="op">=</span> cd<span class="op">.</span>find<span class="op">(</span>T<span class="op">-</span>k<span class="op">);</span> it <span class="op">!=</span> cd<span class="op">.</span>end<span class="op">())</span></span>
<span id="list:two_number_sum_quadratic-22"><a href="#list:two_number_sum_quadratic-22" aria-hidden="true" tabindex="-1"></a>      ans <span class="op">+=</span> v <span class="op">*</span> it<span class="op">-&gt;</span>second<span class="op">;</span></span>
<span id="list:two_number_sum_quadratic-23"><a href="#list:two_number_sum_quadratic-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:two_number_sum_quadratic-24"><a href="#list:two_number_sum_quadratic-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:two_number_sum_quadratic-25"><a href="#list:two_number_sum_quadratic-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice that the first thing we do is to fill <span class="math inline">\(AB\)</span> by looping over all possible pairs of elements from <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>. We then do the same thing for <span class="math inline">\(CD\)</span>, and finally, in the last loop, we take care of calculating the answer by searching, for each element <span class="math inline">\((k,v)\)</span> of <span class="math inline">\(AB\)</span>, where <span class="math inline">\(k\)</span> is the sum obtained by one element of <span class="math inline">\(A\)</span> and one of <span class="math inline">\(B\)</span>, and <span class="math inline">\(v\)</span> is the number of ways we can obtain it, into <span class="math inline">\(CD\)</span> for the target value <span class="math inline">\(T-k\)</span>. If such a value exists into <span class="math inline">\(CD\)</span> then we know we can obtain <span class="math inline">\(T\)</span>. The number of times that is possible is dictated by the frequencies of <span class="math inline">\(k\)</span> and of the target value in <span class="math inline">\(CD\)</span>.</p>
<p>However, you might have already noticed that we do not really need to explicitly create the map <span class="math inline">\(CD\)</span>. The idea is that when we create <span class="math inline">\(CD\)</span> we already have all the values of <span class="math inline">\(AB\)</span> and therefore for a given <span class="math inline">\(C_i+D_j\)</span> we can already find out how many pairs in <span class="math inline">\(AB\)</span> exists that we can use to get a total sum of <span class="math inline">\(T\)</span>. This optimization does not really change the overall space complexity but in practice this mean that we use half the memory and we avoid doing <span class="math inline">\(O(n^2)\)</span> work by eliminating the last loop.</p>
<p>Listing <a href="#list:two_number_sum_quadratic_opti" data-reference-type="ref" data-reference="list:two_number_sum_quadratic_opti">[list:two_number_sum_quadratic_opti]</a> shows this optimized version.</p>
<div class="sourceCode" id="list:two_number_sum_quadratic_opti" data-language="c++" data-caption="&quot;Space optimized quadratic time solution to the four numbers sum problem.&quot;" label="list:two_number_sum_quadratic_opti"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:two_number_sum_quadratic_opti-1"><a href="#list:two_number_sum_quadratic_opti-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> four_sum_hashing_space_optimized<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> A<span class="op">,</span></span>
<span id="list:two_number_sum_quadratic_opti-2"><a href="#list:two_number_sum_quadratic_opti-2" aria-hidden="true" tabindex="-1"></a>                                     <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> B<span class="op">,</span></span>
<span id="list:two_number_sum_quadratic_opti-3"><a href="#list:two_number_sum_quadratic_opti-3" aria-hidden="true" tabindex="-1"></a>                                     <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> C<span class="op">,</span></span>
<span id="list:two_number_sum_quadratic_opti-4"><a href="#list:two_number_sum_quadratic_opti-4" aria-hidden="true" tabindex="-1"></a>                                     <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> D<span class="op">,</span></span>
<span id="list:two_number_sum_quadratic_opti-5"><a href="#list:two_number_sum_quadratic_opti-5" aria-hidden="true" tabindex="-1"></a>                                     <span class="at">const</span> <span class="dt">int</span> T<span class="op">)</span></span>
<span id="list:two_number_sum_quadratic_opti-6"><a href="#list:two_number_sum_quadratic_opti-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:two_number_sum_quadratic_opti-7"><a href="#list:two_number_sum_quadratic_opti-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">size_t</span> size <span class="op">=</span> A<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:two_number_sum_quadratic_opti-8"><a href="#list:two_number_sum_quadratic_opti-8" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>unordered_map<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> ab<span class="op">;</span></span>
<span id="list:two_number_sum_quadratic_opti-9"><a href="#list:two_number_sum_quadratic_opti-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:two_number_sum_quadratic_opti-10"><a href="#list:two_number_sum_quadratic_opti-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> j<span class="op">++)</span></span>
<span id="list:two_number_sum_quadratic_opti-11"><a href="#list:two_number_sum_quadratic_opti-11" aria-hidden="true" tabindex="-1"></a>      ab<span class="op">[</span>A<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> B<span class="op">[</span>j<span class="op">]]++;</span></span>
<span id="list:two_number_sum_quadratic_opti-12"><a href="#list:two_number_sum_quadratic_opti-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:two_number_sum_quadratic_opti-13"><a href="#list:two_number_sum_quadratic_opti-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:two_number_sum_quadratic_opti-14"><a href="#list:two_number_sum_quadratic_opti-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:two_number_sum_quadratic_opti-15"><a href="#list:two_number_sum_quadratic_opti-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> j<span class="op">++)</span></span>
<span id="list:two_number_sum_quadratic_opti-16"><a href="#list:two_number_sum_quadratic_opti-16" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> it <span class="op">=</span> ab<span class="op">.</span>find<span class="op">(</span>T<span class="op">-(</span>C<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> D<span class="op">[</span>j<span class="op">]));</span> it <span class="op">!=</span> ab<span class="op">.</span>end<span class="op">())</span></span>
<span id="list:two_number_sum_quadratic_opti-17"><a href="#list:two_number_sum_quadratic_opti-17" aria-hidden="true" tabindex="-1"></a>        ans <span class="op">+=</span> it<span class="op">-&gt;</span>second<span class="op">;</span></span>
<span id="list:two_number_sum_quadratic_opti-18"><a href="#list:two_number_sum_quadratic_opti-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:two_number_sum_quadratic_opti-19"><a href="#list:two_number_sum_quadratic_opti-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:two_number_sum_quadratic_opti-20"><a href="#list:two_number_sum_quadratic_opti-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="ch:unique_elements">Unique Elements in a collection</h1>
<h2 class="unnumbered" id="introduction-4">Introduction</h2>
<p>The problem presented in this section is probably one of the most popular possibly because it features an incredibly simple statement and it is and easy to understand. This problem has an intuitive brute-force solution that can be coded in a few minutes and that can be refined and optimized into a short and efficient one.</p>
<h2 id="problem-statement-5">Problem statement</h2>
<p>Given a string <span class="math inline">\(s\)</span> of length <span class="math inline">\(n\)</span>, determine whether it does <strong>not</strong> contain duplicate characters.</p>
<div class="example">
<ul>
<li><p>Given <em>s="graph"</em> the function returns . There are no duplicates in <span class="math inline">\(s\)</span>.</p></li>
<li><p>Given <em>s="tree"</em> the function returns . Characters at indices <span class="math inline">\(2\)</span> and <span class="math inline">\(3\)</span> are the same.</p></li>
</ul>
</div>
<h2 id="clarification-questions-4">Clarification Questions</h2>
<div class="QandA">
<p>What is the maximum size of the input?</p>
<div class="answered">
<p><em>The maximum length for the input string is <span class="math inline">\(10^6\)</span>.</em></p>
</div>
<p>Are all characters upper or lower case?</p>
<div class="answered">
<p><em>No, both upper and lower case might be present.</em></p>
</div>
<p>Is the function case-sensitive?</p>
<div class="answered">
<p><em>Yes.</em></p>
</div>
<p>Can I assume characters only alphanumeric characters are present in the input?</p>
<div class="answered">
<p><em>Yes. Upper and lower case Latin letters and numbers only.</em></p>
</div>
</div>
<h2 id="discussion-3">Discussion</h2>
<p>Being this problem so popular, the interviewer is expecting you to come up with a good solution in a relatively small time-window. For this reason the obvious <span class="math inline">\(O(n^2)\)</span> solution should be immediately put on the whiteboard or at least spoken out-loud.</p>
<h3 id="brute-force-1">Brute Force</h3>
<p>The trivial and easy approach in solving this problem works by looping over each character at index <span class="math inline">\(i\)</span>, and checking if <span class="math inline">\(s_i\)</span> is present in any of the elements of <span class="math inline">\(s\)</span> appearing at positions higher than <span class="math inline">\(i\)</span>. In other words we want to check whether the following is true: <span class="math inline">\(\exists \; j\)</span> s.t. <span class="math inline">\(s_j=s_i\)</span> and <span class="math inline">\(j&gt;i\)</span>. This idea can be implemented as shown in Listing <a href="#list:unique_elements_brute_force1" data-reference-type="ref" data-reference="list:unique_elements_brute_force1">[list:unique_elements_brute_force1]</a> using two simple nested loops.</p>
<div class="sourceCode" id="list:unique_elements_brute_force1" data-language="c++" data-caption="&quot;C++ solution for determining all characters in a string are unique.&quot;" label="list:unique_elements_brute_force1"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:unique_elements_brute_force1-1"><a href="#list:unique_elements_brute_force1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> unique_elements_brute_force<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> &amp;</span>s<span class="op">)</span></span>
<span id="list:unique_elements_brute_force1-2"><a href="#list:unique_elements_brute_force1-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:unique_elements_brute_force1-3"><a href="#list:unique_elements_brute_force1-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> s<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span></span>
<span id="list:unique_elements_brute_force1-4"><a href="#list:unique_elements_brute_force1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> j <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> s<span class="op">.</span>size<span class="op">();</span> j<span class="op">++)</span></span>
<span id="list:unique_elements_brute_force1-5"><a href="#list:unique_elements_brute_force1-5" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>s<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> s<span class="op">[</span>j<span class="op">])</span></span>
<span id="list:unique_elements_brute_force1-6"><a href="#list:unique_elements_brute_force1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:unique_elements_brute_force1-7"><a href="#list:unique_elements_brute_force1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:unique_elements_brute_force1-8"><a href="#list:unique_elements_brute_force1-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:unique_elements_brute_force1-9"><a href="#list:unique_elements_brute_force1-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>As a stylistic improvements to the code in Listing <a href="#list:unique_elements_brute_force1" data-reference-type="ref" data-reference="list:unique_elements_brute_force1">[list:unique_elements_brute_force1]</a>, Listing <a href="#list:unique_elements_brute_force2" data-reference-type="ref" data-reference="list:unique_elements_brute_force2">[list:unique_elements_brute_force2]</a> uses the C++ standard library function to search for a duplicate of the character <span class="math inline">\(s_i\)</span>. This not only makes the code shorter and cleaner, but also shows to the interviewer that you are able to use the standard library and do not reinvent the wheel.</p>
<div class="sourceCode" id="list:unique_elements_brute_force2" data-language="c++" data-caption="&quot;C++ solution for determining if all characters in a string are unique using \inline{std::find}&quot;" label="list:unique_elements_brute_force2"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:unique_elements_brute_force2-1"><a href="#list:unique_elements_brute_force2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> unique_elements_brute_force_std<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> &amp;</span>s<span class="op">)</span></span>
<span id="list:unique_elements_brute_force2-2"><a href="#list:unique_elements_brute_force2-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:unique_elements_brute_force2-3"><a href="#list:unique_elements_brute_force2-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> it <span class="op">=</span> s<span class="op">.</span>begin<span class="op">();</span> it <span class="op">!=</span> s<span class="op">.</span>end<span class="op">();</span> it<span class="op">++)</span></span>
<span id="list:unique_elements_brute_force2-4"><a href="#list:unique_elements_brute_force2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>find<span class="op">(</span>it <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> s<span class="op">.</span>end<span class="op">(),</span> <span class="op">*</span>it<span class="op">)</span> <span class="op">!=</span> s<span class="op">.</span>end<span class="op">())</span></span>
<span id="list:unique_elements_brute_force2-5"><a href="#list:unique_elements_brute_force2-5" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:unique_elements_brute_force2-6"><a href="#list:unique_elements_brute_force2-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:unique_elements_brute_force2-7"><a href="#list:unique_elements_brute_force2-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="linear-time---hashset">Linear time - Hashset</h3>
<p>In Listing <a href="#list:unique_elements_brute_force1" data-reference-type="ref" data-reference="list:unique_elements_brute_force1">[list:unique_elements_brute_force1]</a> the internal loop is doing the hard work of searching for a duplicate of the character at index <span class="math inline">\(i\)</span>. We can trade space for time and reduce the complexity of the search for a duplicate of <span class="math inline">\(s_i\)</span> down to <span class="math inline">\(O(1)\)</span>. The idea is that wen can use a set to keep track, as we loop over the characters of <span class="math inline">\(s\)</span>, of all the distinct characters seen so far. A search for a duplicate of <span class="math inline">\(s_i\)</span> becomes a query into this set. If the query is positive then we know we have seen this character before, otherwise we inser <span class="math inline">\(s_i\)</span> into the set and can continue processing the rest of <span class="math inline">\(s\)</span>. Listing <a href="#list:unique_elements_brute_force_map" data-reference-type="ref" data-reference="list:unique_elements_brute_force_map">[list:unique_elements_brute_force_map]</a> shows how this idea can be implemented.</p>
<div class="sourceCode" id="list:unique_elements_brute_force_map" data-language="c++" data-caption="&quot;C++ solution for determining all characters in a string are unique in $O(n)$ using an hashset.&quot;" label="list:unique_elements_brute_force_map"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:unique_elements_brute_force_map-1"><a href="#list:unique_elements_brute_force_map-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> unique_elements_map<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> &amp;</span>s<span class="op">)</span></span>
<span id="list:unique_elements_brute_force_map-2"><a href="#list:unique_elements_brute_force_map-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:unique_elements_brute_force_map-3"><a href="#list:unique_elements_brute_force_map-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>unordered_set<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;</span> L<span class="op">;</span></span>
<span id="list:unique_elements_brute_force_map-4"><a href="#list:unique_elements_brute_force_map-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> s<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span></span>
<span id="list:unique_elements_brute_force_map-5"><a href="#list:unique_elements_brute_force_map-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:unique_elements_brute_force_map-6"><a href="#list:unique_elements_brute_force_map-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>L<span class="op">.</span>contains<span class="op">(</span>s<span class="op">[</span>i<span class="op">]))</span></span>
<span id="list:unique_elements_brute_force_map-7"><a href="#list:unique_elements_brute_force_map-7" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:unique_elements_brute_force_map-8"><a href="#list:unique_elements_brute_force_map-8" aria-hidden="true" tabindex="-1"></a>    L<span class="op">.</span>insert<span class="op">(</span>s<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:unique_elements_brute_force_map-9"><a href="#list:unique_elements_brute_force_map-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:unique_elements_brute_force_map-10"><a href="#list:unique_elements_brute_force_map-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:unique_elements_brute_force_map-11"><a href="#list:unique_elements_brute_force_map-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This approach effectively lowers the time complexity down to linear, but at the cost of some space. But how much space exactly? The intuition would suggest <span class="math inline">\(O(n)\)</span> because that is the size of the input string, and afterall we might be inserting into the hashset all of the characters of <span class="math inline">\(s\)</span>. But the intuition is wrong as the string is made of characters from an alphabet <span class="math inline">\(\Sigma\)</span> which has a (very) limited size, at most <span class="math inline">\(128\)</span> (which is the size of the ASCII set) elements. The insert instruction will not be executed more than <span class="math inline">\(|\Sigma|\)</span> times. Because of this the space complexity of this solution is <span class="math inline">\(O(1)\)</span>.</p>
<p>The previous argument can be expanded furthermore with the following idea: <strong>Every string with more than <span class="math inline">\(|\Sigma|\)</span> character contains at least one duplicate</strong>(follows from the pigeon principle<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>). The longest string with only unique characters is one of the permutations of <em>"abcde…zABCD …Z123 …9"</em>. Thus the solution using the hashset has complexity of <span class="math inline">\(O(1)\)</span> because in the worst case we can have <span class="math inline">\(|\Sigma|\)</span> negative lookups. For this reason, we can limit our investigation to only strings that have size smaller or equal to <span class="math inline">\(|\Sigma|\)</span> character. For all other strings we can immediately return false. Note that under the light of these new facts the brute-force approach also has a complexity of <span class="math inline">\(O(1)\)</span> if <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> in Listing <a href="#list:unique_elements_brute_force1" data-reference-type="ref" data-reference="list:unique_elements_brute_force1">[list:unique_elements_brute_force1]</a> are forced to stay below <span class="math inline">\(|\Sigma|\)</span>.</p>
<p>Armed with these new arguments, the solution we suggest to present during an actual interview only uses a array of booleans of size <span class="math inline">\(|\Sigma|\)</span> storing the information regarding the presence of a character in the portion of <span class="math inline">\(s\)</span> considered so far. If at any time the currently examined character has been already seen, then it is a duplicate. Listing <a href="#list:unique_elements_brute_force_final" data-reference-type="ref" data-reference="list:unique_elements_brute_force_final">[list:unique_elements_brute_force_final]</a> shows an implementation of this idea.</p>
<div class="sourceCode" id="list:unique_elements_brute_force_final" data-language="c++" data-caption="&quot;C++ solution for determining all characters in a string are unique in $O(n)$ using an hashset.&quot;" label="list:unique_elements_brute_force_final"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:unique_elements_brute_force_final-1"><a href="#list:unique_elements_brute_force_final-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> unique_elements_final<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> &amp;</span>s<span class="op">)</span></span>
<span id="list:unique_elements_brute_force_final-2"><a href="#list:unique_elements_brute_force_final-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:unique_elements_brute_force_final-3"><a href="#list:unique_elements_brute_force_final-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> <span class="dt">size_t</span> ALPH_SIZE <span class="op">=</span> <span class="dv">128</span><span class="op">;</span></span>
<span id="list:unique_elements_brute_force_final-4"><a href="#list:unique_elements_brute_force_final-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:unique_elements_brute_force_final-5"><a href="#list:unique_elements_brute_force_final-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>s<span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;</span> ALPH_SIZE<span class="op">)</span></span>
<span id="list:unique_elements_brute_force_final-6"><a href="#list:unique_elements_brute_force_final-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:unique_elements_brute_force_final-7"><a href="#list:unique_elements_brute_force_final-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:unique_elements_brute_force_final-8"><a href="#list:unique_elements_brute_force_final-8" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>array<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> ALPH_SIZE<span class="op">&gt;</span> F <span class="op">=</span> <span class="op">{};</span></span>
<span id="list:unique_elements_brute_force_final-9"><a href="#list:unique_elements_brute_force_final-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">!=</span> s<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span></span>
<span id="list:unique_elements_brute_force_final-10"><a href="#list:unique_elements_brute_force_final-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:unique_elements_brute_force_final-11"><a href="#list:unique_elements_brute_force_final-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// index in F</span></span>
<span id="list:unique_elements_brute_force_final-12"><a href="#list:unique_elements_brute_force_final-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> idx <span class="op">=</span> s<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> <span class="ch">&#39;a&#39;</span><span class="op">;</span></span>
<span id="list:unique_elements_brute_force_final-13"><a href="#list:unique_elements_brute_force_final-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>F<span class="op">[</span>idx<span class="op">])</span></span>
<span id="list:unique_elements_brute_force_final-14"><a href="#list:unique_elements_brute_force_final-14" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:unique_elements_brute_force_final-15"><a href="#list:unique_elements_brute_force_final-15" aria-hidden="true" tabindex="-1"></a>    F<span class="op">[</span>idx<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:unique_elements_brute_force_final-16"><a href="#list:unique_elements_brute_force_final-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:unique_elements_brute_force_final-17"><a href="#list:unique_elements_brute_force_final-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:unique_elements_brute_force_final-18"><a href="#list:unique_elements_brute_force_final-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="ch:greatest_right">Greatest element on the right side</h1>
<h2 class="unnumbered" id="introduction-5">Introduction</h2>
<p>This chapter discusses a farily common problem asked during the on-site interview at Amazon.</p>
<h2 id="problem-statement-6">Problem statement</h2>
<div class="exercise">
<p>You are given an array <span class="math inline">\(A\)</span> of size <span class="math inline">\(n\)</span>. You have to modify <span class="math inline">\(A\)</span> in place s.t. <span class="math inline">\(A[i] = max(A[i+1], A[i+2],\ldots, A[n-1])\)</span>. In other words <span class="math inline">\(A[i]\)</span> should be substituted with the maximum value among all elements <span class="math inline">\(A[j], j &gt; i\)</span>. If such element does not exists set <span class="math inline">\(A[i] = -1\)</span>.</p>
</div>
<div class="example">
<p><br />
Given the input array <span class="math inline">\(A = \{15, 22, 12, 13, 12, 19, 0, 2\}\)</span>, the output of the function in this case shluld be <span class="math inline">\(A = \{22, 19, 19, 19, 19, 2, 2, -1\}\)</span>.</p>
</div>
<div class="example">
<p><br />
Given the input array <span class="math inline">\(A = \{2, 3, 1, 9\}\)</span>, the output of the function in this case shluld be <span class="math inline">\(A = \{9, 9, 9, -1\}\)</span>.</p>
</div>
<h2 id="clarification-questions-5">Clarification Questions</h2>
<div class="QandA">
<p>Are the element of the array sorted?</p>
<div class="answered">
<p><em>No, the input array is not sorted.</em></p>
</div>
<p>Are the element always positive or negative?</p>
<div class="answered">
<p><em>The elements can be either positive or negative.</em></p>
</div>
</div>
<h2 id="discussion-4">Discussion</h2>
<p>Since this is a quite an easy problem, hence it is very important to to focus on making a good impression on the interviewer by showing a clean reasoning and elegant implementation of the solution. This problem is considered not very challengind because it already has all the information required to solve it in its statement.</p>
<h3 id="brute-force-2">Brute Force</h3>
<p>As usual one should always start talking to the interviewer right away about the bruteforce solution which in this case is quite straightforward. All it is necessary is scanning the array from left ro right and for each element finding the greatest element among all the elements on its right. This can be very easily implemented in C++ using the <code>std::max_element()</code> function as shown in Listing <a href="#list::greatest_right_bruteforce" data-reference-type="ref" data-reference="list::greatest_right_bruteforce">[list::greatest_right_bruteforce]</a>. Note how the search on the right side is enforced by using as starting point <span class="math inline">\(begin(A)+i+1\)</span> for the range in the <code>std::max_element()</code> function.</p>
<div class="sourceCode" id="list::greatest_right_bruteforce" data-language="c++" data-caption="C++ bruteforce solution to the problem of modifying an array in place with the greatest element on the right side." label="list::greatest_right_bruteforce"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list::greatest_right_bruteforce-1"><a href="#list::greatest_right_bruteforce-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> greatest_right_bruteforce<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>A<span class="op">)</span></span>
<span id="list::greatest_right_bruteforce-2"><a href="#list::greatest_right_bruteforce-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list::greatest_right_bruteforce-3"><a href="#list::greatest_right_bruteforce-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> A<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span></span>
<span id="list::greatest_right_bruteforce-4"><a href="#list::greatest_right_bruteforce-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list::greatest_right_bruteforce-5"><a href="#list::greatest_right_bruteforce-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> greatest <span class="op">=</span> max_element<span class="op">(</span>begin<span class="op">(</span>A<span class="op">)</span> <span class="op">+</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> end<span class="op">(</span>A<span class="op">));</span></span>
<span id="list::greatest_right_bruteforce-6"><a href="#list::greatest_right_bruteforce-6" aria-hidden="true" tabindex="-1"></a>    A<span class="op">[</span>i<span class="op">]</span>                <span class="op">=</span> <span class="op">(</span>greatest <span class="op">!=</span> end<span class="op">(</span>A<span class="op">))</span> <span class="op">?</span> <span class="op">*</span>greatest <span class="op">:</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list::greatest_right_bruteforce-7"><a href="#list::greatest_right_bruteforce-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list::greatest_right_bruteforce-8"><a href="#list::greatest_right_bruteforce-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note also that the last element will always be modified into <span class="math inline">\(-1\)</span> because, it is the only element which does not have any element on its right side and according to the statement in this case it should be modified into <span class="math inline">\(-1\)</span>.</p>
<p>This solution is considered poor because it has a time complexity of <span class="math inline">\(O(n^2)\)</span> and a linear solution exists.</p>
<h3 id="sec:greatest_right:linear">Linear solution</h3>
<p>The approach used in Listing <a href="#list::greatest_right_bruteforce" data-reference-type="ref" data-reference="list::greatest_right_bruteforce">[list::greatest_right_bruteforce]</a> can be greately improved if instead of looping from left to right, the scan is performed from right to left (from <span class="math inline">\(A.size()-2\)</span> to <span class="math inline">\(0\)</span>)<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. This allows for keeping track of the maximum element on the right side of the element currenlty analyzed, <span class="math inline">\(M\)</span>, to be calculated in constant time because:</p>
<ul>
<li><p>at first the maximum element on the right of <span class="math inline">\(A.size()-2\)</span> is <span class="math inline">\(A.size()-1\)</span> i.e. <span class="math inline">\(M = A[A.size()-1]\)</span>.</p></li>
<li><p>when <span class="math inline">\(A.size()-2\)</span> is processed <span class="math inline">\(M\)</span> can be updated by only using the the <strong>old</strong> value in <span class="math inline">\(A[A.size()-2]\)</span> i.e. <span class="math inline">\(M= max(M, A_{old}[A.size()-2])\)</span></p></li>
<li><p>after each element <span class="math inline">\(i\)</span> is processed: <span class="math inline">\(M= max(M, A_{old}[i+1])\)</span></p></li>
</ul>
<p>The idea above is implemented in Listing <a href="#list:greatest_right_final1" data-reference-type="ref" data-reference="list:greatest_right_final1">[list:greatest_right_final1]</a></p>
<div class="sourceCode" id="list:greatest_right_final1" data-language="c++" data-caption="C++ linear time solution to the problem of modifying an array in place with the greatest element on the right side." label="list:greatest_right_final1"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:greatest_right_final1-1"><a href="#list:greatest_right_final1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> greatest_right_final1<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>V<span class="op">)</span></span>
<span id="list:greatest_right_final1-2"><a href="#list:greatest_right_final1-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:greatest_right_final1-3"><a href="#list:greatest_right_final1-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>V<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:greatest_right_final1-4"><a href="#list:greatest_right_final1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="list:greatest_right_final1-5"><a href="#list:greatest_right_final1-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// max so far</span></span>
<span id="list:greatest_right_final1-6"><a href="#list:greatest_right_final1-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> M <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:greatest_right_final1-7"><a href="#list:greatest_right_final1-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> i <span class="op">=</span> V<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:greatest_right_final1-8"><a href="#list:greatest_right_final1-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">do</span></span>
<span id="list:greatest_right_final1-9"><a href="#list:greatest_right_final1-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:greatest_right_final1-10"><a href="#list:greatest_right_final1-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> m <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>M<span class="op">,</span> V<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:greatest_right_final1-11"><a href="#list:greatest_right_final1-11" aria-hidden="true" tabindex="-1"></a>    V<span class="op">[</span>i<span class="op">]</span>        <span class="op">=</span> M<span class="op">;</span></span>
<span id="list:greatest_right_final1-12"><a href="#list:greatest_right_final1-12" aria-hidden="true" tabindex="-1"></a>    M           <span class="op">=</span> m<span class="op">;</span></span>
<span id="list:greatest_right_final1-13"><a href="#list:greatest_right_final1-13" aria-hidden="true" tabindex="-1"></a>    i<span class="op">--;</span></span>
<span id="list:greatest_right_final1-14"><a href="#list:greatest_right_final1-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="cf">while</span> <span class="op">(</span>i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="list:greatest_right_final1-15"><a href="#list:greatest_right_final1-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Please note how in Listing <a href="#list:greatest_right_final1" data-reference-type="ref" data-reference="list:greatest_right_final1">[list:greatest_right_final1]</a>the variable <span class="math inline">\(m\)</span> is used to keep track of the old value of the element of A currenlty processed and how the last element of <span class="math inline">\(A\)</span> is always turned into <span class="math inline">\(-1\)</span>. An alternative and more condensed implementation is shown in Listing <a href="#list:greatest_right_final2" data-reference-type="ref" data-reference="list:greatest_right_final2">[list:greatest_right_final2]</a>.</p>
<div class="sourceCode" id="list:greatest_right_final2" data-language="c++" data-caption="Alternative Listing \ref{list:greatest_right_final1} implementation of C++ linear time solution to the problem of modifying an array in place with the greatest element on the right side." label="list:greatest_right_final2"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:greatest_right_final2-1"><a href="#list:greatest_right_final2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> greatest_right_final2<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>V<span class="op">)</span></span>
<span id="list:greatest_right_final2-2"><a href="#list:greatest_right_final2-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:greatest_right_final2-3"><a href="#list:greatest_right_final2-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>V<span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:greatest_right_final2-4"><a href="#list:greatest_right_final2-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:greatest_right_final2-5"><a href="#list:greatest_right_final2-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> V<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">2</span><span class="op">,</span> M <span class="op">=</span> V<span class="op">.</span>back<span class="op">();</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span></span>
<span id="list:greatest_right_final2-6"><a href="#list:greatest_right_final2-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:greatest_right_final2-7"><a href="#list:greatest_right_final2-7" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="dt">int</span> m <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>M<span class="op">,</span> V<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:greatest_right_final2-8"><a href="#list:greatest_right_final2-8" aria-hidden="true" tabindex="-1"></a>      V<span class="op">[</span>i<span class="op">]</span>        <span class="op">=</span> M<span class="op">;</span></span>
<span id="list:greatest_right_final2-9"><a href="#list:greatest_right_final2-9" aria-hidden="true" tabindex="-1"></a>      M           <span class="op">=</span> m<span class="op">;</span></span>
<span id="list:greatest_right_final2-10"><a href="#list:greatest_right_final2-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:greatest_right_final2-11"><a href="#list:greatest_right_final2-11" aria-hidden="true" tabindex="-1"></a>    V<span class="op">.</span>back<span class="op">()</span> <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:greatest_right_final2-12"><a href="#list:greatest_right_final2-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:greatest_right_final2-13"><a href="#list:greatest_right_final2-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="ch:string_to_int">String to Integer</h1>
<h2 class="unnumbered" id="introduction-6">Introduction</h2>
<p>The problem discussed in this chapter is an extremely popular one often used as a warm-up question asked during the onsite interview as well as part of many online assessment exercices. It is important to ask the right questions to the interview so to make sure that the problem is understood well and that all the corner cases are handled properly. For instance the interviewer might ask to take car care of negative numbers, but that might not be explicitly stated in the problem statement.</p>
<h2 id="problem-statement-7">Problem statement</h2>
<div class="exercise">
<p>Write a function that given a string <span class="math inline">\(s\)</span> containing only numbers (characters from the range [0-9]), parse it into its integer representation without using any library specific functions (like <code>atoi()</code> in C++ or <code>Integer.parseInt()</code> in Java).</p>
</div>
<div class="example">
<p><br />
If <span class="math inline">\(s\)</span> ="12345", then the function should return the integer <span class="math inline">\(12345\)</span>.</p>
</div>
<h2 id="clarification-questions-6">Clarification Questions</h2>
<div class="QandA">
<p>Does the function need to handle integer overflow?</p>
<div class="answered">
<p><em>No, the input will never cause overflow.</em></p>
</div>
<p>Can the string have leading zeros?</p>
<div class="answered">
<p><em>Yes, the string might have one or more leading zeros.</em></p>
<div class="example">
<p><br />
If <span class="math inline">\(s\)</span> ="0000012345", then the function should return the integer <span class="math inline">\(12345\)</span>.</p>
</div>
</div>
</div>
<h2 id="string_to_int:sec:discussion">Discussion</h2>
<p>This problem can be solved very eleganlty by just using the idea behind the decimal positional numeral systems. In any positional number system, the ultimate numeric value of a digit is determined by the position it holds, not only by the digit itself. Take as an example the number <span class="math inline">\(427\)</span>: although <span class="math inline">\(7\)</span> is thought of as a larger number than 4, the <span class="math inline">\(7\)</span> is worth less than the <span class="math inline">\(4\)</span> in this instance because of its respective position within the number. The value of a digit <span class="math inline">\(d\)</span> at position <span class="math inline">\(i\)</span> is equal to <span class="math inline">\(d\times 10^i\)</span>. Thus the value of the a number <span class="math inline">\(n=d_0d_1 \ldots d_k\)</span> is equal to <span class="math inline">\((d_0 \times 10^0) + (d_1 \times 10^1) + \ldots + (d_k \times 10^k)\)</span>. Using this approach leading zeros are not a problem because they clearly do not contribute to the final result as <span class="math inline">\(0 \times 10^x = 0\)</span>.</p>
<div class="example">
<p><br />
<span class="math inline">\(n\)</span> ="22498" then its decimal value is equal to: <span class="math inline">\((2 \times 10^4) + (2 \times 10^3) + (4 \times 10^2) + (9 \times 10^1) + (8 \times 10^0) = 20000 + 2000 + 400 +90 +8 = 22498\)</span></p>
</div>
<p>The idea above can be implemented by looping though the string from right to left and summing up each digit of the string at position <span class="math inline">\(i\)</span> multiplied by <span class="math inline">\(10^i\)</span> as shown in Listing <a href="#list:string_to_int1" data-reference-type="ref" data-reference="list:string_to_int1">[list:string_to_int1]</a>.</p>
<div class="sourceCode" id="list:string_to_int1" data-language="c++" data-caption="C++ solution to the string to integer problem." label="list:string_to_int1"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:string_to_int1-1"><a href="#list:string_to_int1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> string_to_int1<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> &amp;</span>s<span class="op">)</span></span>
<span id="list:string_to_int1-2"><a href="#list:string_to_int1-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:string_to_int1-3"><a href="#list:string_to_int1-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:string_to_int1-4"><a href="#list:string_to_int1-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> p   <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>  <span class="co">// 10^i</span></span>
<span id="list:string_to_int1-5"><a href="#list:string_to_int1-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> s<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span></span>
<span id="list:string_to_int1-6"><a href="#list:string_to_int1-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:string_to_int1-7"><a href="#list:string_to_int1-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> char_to_int <span class="op">=</span> <span class="op">(</span><span class="dt">int</span><span class="op">)(</span>s<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> <span class="ch">&#39;0&#39;</span><span class="op">);</span></span>
<span id="list:string_to_int1-8"><a href="#list:string_to_int1-8" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">+=</span> char_to_int <span class="op">*</span> p<span class="op">;</span></span>
<span id="list:string_to_int1-9"><a href="#list:string_to_int1-9" aria-hidden="true" tabindex="-1"></a>    p <span class="op">*=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="list:string_to_int1-10"><a href="#list:string_to_int1-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:string_to_int1-11"><a href="#list:string_to_int1-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:string_to_int1-12"><a href="#list:string_to_int1-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This is considered a good solution, as its complexity is linear in the size of the input string and handles leading zeros elegantly.</p>
<h3 id="common-variation">Common Variation</h3>
<ul>
<li><p>Add support for negative numbers. One optional char which could either be + or -, at the beginning of the string signals the sign. See Listing <a href="#list:string_to_int_negative" data-reference-type="ref" data-reference="list:string_to_int_negative">[list:string_to_int_negative]</a>.</p></li>
<li><p>Return <span class="math inline">\(0\)</span> when the answer does not fit into an int.</p></li>
<li><p>Raise an exception (or return a certain value) in case of bad input. For instance when letters are present in the string e.g. <span class="math inline">\(s=123f456\)</span>.</p></li>
</ul>
<div class="sourceCode" id="list:string_to_int_negative" data-language="c++" data-caption="C++ solution to the string to integer problem with negative number support." label="list:string_to_int_negative"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:string_to_int_negative-1"><a href="#list:string_to_int_negative-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> string_to_int_negative<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> &amp;</span>s<span class="op">)</span></span>
<span id="list:string_to_int_negative-2"><a href="#list:string_to_int_negative-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:string_to_int_negative-3"><a href="#list:string_to_int_negative-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>s<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:string_to_int_negative-4"><a href="#list:string_to_int_negative-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:string_to_int_negative-5"><a href="#list:string_to_int_negative-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> sign <span class="op">=</span> s<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="ch">&#39;-&#39;</span> <span class="op">?</span> <span class="op">-</span><span class="dv">1</span> <span class="op">:</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:string_to_int_negative-6"><a href="#list:string_to_int_negative-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// skip the first char if sign is specified</span></span>
<span id="list:string_to_int_negative-7"><a href="#list:string_to_int_negative-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> start <span class="op">=</span> <span class="op">(</span>s<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="ch">&#39;-&#39;</span><span class="op">)</span> <span class="op">||</span> <span class="op">(</span>s<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="ch">&#39;+&#39;</span><span class="op">)</span> <span class="op">?</span> <span class="dv">1</span> <span class="op">:</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:string_to_int_negative-8"><a href="#list:string_to_int_negative-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> sign <span class="op">*</span> string_to_int1<span class="op">(</span><span class="bu">std::</span>string<span class="op">(</span>begin<span class="op">(</span>s<span class="op">)</span> <span class="op">+</span> start<span class="op">,</span> end<span class="op">(</span>s<span class="op">)));</span></span>
<span id="list:string_to_int_negative-9"><a href="#list:string_to_int_negative-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="ch:stairs_climbing">Climb the Stairs</h1>
<h2 class="unnumbered" id="introduction-7">Introduction</h2>
<p>The problem covered by this chapter is a classical one, that has been asked during interview at big tech companies like Amazon or Google. It shares the underlying structure and key properties with many other problems and thus, not surprisingly, also its solution is very similar to theirs (for instance there is a one-to-one correnspondence with the coin change problem and the solution described in this chapter can be used to solve that problem too.). The tecniques discussed in the chapter can be applied to all problem which statements goes like this: <em>Given a target find minimum (maximum) cost / path / sum to reach the target</em>. Usually the problem should be tackled by using the following approach: <em>Choose minimum/maximum path among all possible paths before the current state, then add the value for the current state.</em> Words like state and current will be clearer by the end of the chapter.</p>
<h2 id="sec:stairs_climbing_statement_easy">Problem statement</h2>
<div class="exercise">
<p>You are climbing a stair case and it takes <span class="math inline">\(n\)</span> steps to reach to the top.</p>
<p>Each time you can either climb <span class="math inline">\(1\)</span> or <span class="math inline">\(2\)</span> steps. In how many distinct ways can you climb to the top?</p>
</div>
<div class="example">
<p><br />
Given <span class="math inline">\(n = 3\)</span> the answer is <span class="math inline">\(3\)</span> because there are three ways (See image <a href="#fig:stair_example_3" data-reference-type="ref" data-reference="fig:stair_example_3">8.1</a> to climb to the top of the stairs:</p>
<ol>
<li><p><span class="math inline">\(1\)</span> step + <span class="math inline">\(1\)</span> step + <span class="math inline">\(1\)</span> step</p></li>
<li><p><span class="math inline">\(1\)</span> step + <span class="math inline">\(2\)</span> steps</p></li>
<li><p><span class="math inline">\(2\)</span> steps + <span class="math inline">\(1\)</span> step</p></li>
</ol>
<p><span id="fig:stair_example_3" label="fig:stair_example_3">[fig:stair_example_3]</span> <img src="/home/dspataro/git/algorithm_articles/sources/stairs_climbing/images/3stairs.png" title="fig:" id="fig:stair_example_3" alt="All different ways to climb a 3 stairs staricase using steps of size 1 or 2." /></p>
</div>
<div class="example">
<p><br />
Given <span class="math inline">\(n = 4\)</span> the answer is <span class="math inline">\(5\)</span> because there are five ways (See image <a href="#fig:stair_example_5" data-reference-type="ref" data-reference="fig:stair_example_5">8.2</a> to climb to the top of the stairs:</p>
<ol>
<li><p><span class="math inline">\(1\)</span> step + <span class="math inline">\(1\)</span> step + <span class="math inline">\(1\)</span> step + <span class="math inline">\(1\)</span> step</p></li>
<li><p><span class="math inline">\(2\)</span> steps + <span class="math inline">\(1\)</span> step + <span class="math inline">\(1\)</span> step</p></li>
<li><p><span class="math inline">\(1\)</span> step + <span class="math inline">\(1\)</span> step + <span class="math inline">\(2\)</span> steps</p></li>
<li><p><span class="math inline">\(1\)</span> step + <span class="math inline">\(2\)</span> steps + <span class="math inline">\(1\)</span> step</p></li>
<li><p><span class="math inline">\(2\)</span> steps + <span class="math inline">\(2\)</span> steps</p></li>
</ol>
<p><span id="fig:stair_example_5" label="fig:stair_example_5">[fig:stair_example_5]</span> <img src="/home/dspataro/git/algorithm_articles/sources/stairs_climbing/images/5stairs.png" title="fig:" id="fig:stair_example_5" alt="All different ways to climb a four stairs staricase using steps of size 1 or 2." /></p>
</div>
<h2 id="clarification-questions-7">Clarification Questions</h2>
<div class="QandA">
<p>Can the size of the stair be zero?</p>
<div class="answered">
<p><em>Yes, the staircase can be made of zero steps.</em></p>
</div>
<p>It is guaranteed the answer to fit a built-in integer?</p>
<div class="answered">
<p><em>Yes, do not worry about overflow.</em></p>
</div>
</div>
<h2 id="stairs_climbing:sec:discussion">Discussion</h2>
<p>This is probably one problem that it is easier to tackle by first looking at a few examples so it is easier to see patterns. Table <a href="#tab:stairs_climbing_ways_up_tp_7" data-reference-type="ref" data-reference="tab:stairs_climbing_ways_up_tp_7">8.1</a> shows how many ways there are to climb a stair of lenght <span class="math inline">\(n\)</span> up to <span class="math inline">\(n=7\)</span>.</p>
<div id="tab:stairs_climbing_ways_up_tp_7">
<table>
<caption>All the ways to climb a stair of lenght <span class="math inline">\(n \leq 7\)</span> </caption>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(n\)</span></th>
<th style="text-align: center;"><strong>Ways</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(3\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(4\)</span></td>
<td style="text-align: center;"><span class="math inline">\(5\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(5\)</span></td>
<td style="text-align: center;"><span class="math inline">\(8\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(6\)</span></td>
<td style="text-align: center;"><span class="math inline">\(13\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(7\)</span></td>
<td style="text-align: center;"><span class="math inline">\(21\)</span></td>
</tr>
</tbody>
</table>
</div>
<p><span id="tab:stairs_climbing_ways_up_tp_7" label="tab:stairs_climbing_ways_up_tp_7">[tab:stairs_climbing_ways_up_tp_7]</span></p>
<p>Looking at the table one thing should be immediately noticed i.e. the number of ways to climb the stair of size <span class="math inline">\(n\)</span> is equal to the <span class="math inline">\(n^th\)</span> element of the <strong>Fibonacci</strong> sequence (starting with two <span class="math inline">\(1\)</span>). Once tht is clear then the solution is straightforward as shown in Listing <a href="#list:stairs_climbing_fibonacci" data-reference-type="ref" data-reference="list:stairs_climbing_fibonacci">[list:stairs_climbing_fibonacci]</a>.</p>
<div class="sourceCode" id="list:stairs_climbing_fibonacci" data-language="c++" data-caption="Solution to the stairs climbining problem with steps of size $1$ and $2$ using Fibonacci." label="list:stairs_climbing_fibonacci"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:stairs_climbing_fibonacci-1"><a href="#list:stairs_climbing_fibonacci-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*int fibonacci(int k)</span></span>
<span id="list:stairs_climbing_fibonacci-2"><a href="#list:stairs_climbing_fibonacci-2" aria-hidden="true" tabindex="-1"></a><span class="co">{</span></span>
<span id="list:stairs_climbing_fibonacci-3"><a href="#list:stairs_climbing_fibonacci-3" aria-hidden="true" tabindex="-1"></a><span class="co">        int p = 0, c = 1;</span></span>
<span id="list:stairs_climbing_fibonacci-4"><a href="#list:stairs_climbing_fibonacci-4" aria-hidden="true" tabindex="-1"></a><span class="co">        while(k--)</span></span>
<span id="list:stairs_climbing_fibonacci-5"><a href="#list:stairs_climbing_fibonacci-5" aria-hidden="true" tabindex="-1"></a><span class="co">        {</span></span>
<span id="list:stairs_climbing_fibonacci-6"><a href="#list:stairs_climbing_fibonacci-6" aria-hidden="true" tabindex="-1"></a><span class="co">                const int tmp = c;</span></span>
<span id="list:stairs_climbing_fibonacci-7"><a href="#list:stairs_climbing_fibonacci-7" aria-hidden="true" tabindex="-1"></a><span class="co">                c = p+tmp;</span></span>
<span id="list:stairs_climbing_fibonacci-8"><a href="#list:stairs_climbing_fibonacci-8" aria-hidden="true" tabindex="-1"></a><span class="co">                p = tmp;</span></span>
<span id="list:stairs_climbing_fibonacci-9"><a href="#list:stairs_climbing_fibonacci-9" aria-hidden="true" tabindex="-1"></a><span class="co">        }</span></span>
<span id="list:stairs_climbing_fibonacci-10"><a href="#list:stairs_climbing_fibonacci-10" aria-hidden="true" tabindex="-1"></a><span class="co">        return p;</span></span>
<span id="list:stairs_climbing_fibonacci-11"><a href="#list:stairs_climbing_fibonacci-11" aria-hidden="true" tabindex="-1"></a><span class="co">}*/</span></span>
<span id="list:stairs_climbing_fibonacci-12"><a href="#list:stairs_climbing_fibonacci-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:stairs_climbing_fibonacci-13"><a href="#list:stairs_climbing_fibonacci-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> fibonacci<span class="op">(</span><span class="dt">int</span> k<span class="op">)</span></span>
<span id="list:stairs_climbing_fibonacci-14"><a href="#list:stairs_climbing_fibonacci-14" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:stairs_climbing_fibonacci-15"><a href="#list:stairs_climbing_fibonacci-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>k <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="list:stairs_climbing_fibonacci-16"><a href="#list:stairs_climbing_fibonacci-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:stairs_climbing_fibonacci-17"><a href="#list:stairs_climbing_fibonacci-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> fibonacci<span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">+</span> fibonacci<span class="op">(</span>k <span class="op">-</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="list:stairs_climbing_fibonacci-18"><a href="#list:stairs_climbing_fibonacci-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:stairs_climbing_fibonacci-19"><a href="#list:stairs_climbing_fibonacci-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:stairs_climbing_fibonacci-20"><a href="#list:stairs_climbing_fibonacci-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> stair_climbing_fibonacci<span class="op">(</span><span class="at">const</span> <span class="dt">int</span> n<span class="op">)</span></span>
<span id="list:stairs_climbing_fibonacci-21"><a href="#list:stairs_climbing_fibonacci-21" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:stairs_climbing_fibonacci-22"><a href="#list:stairs_climbing_fibonacci-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="list:stairs_climbing_fibonacci-23"><a href="#list:stairs_climbing_fibonacci-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> n<span class="op">;</span></span>
<span id="list:stairs_climbing_fibonacci-24"><a href="#list:stairs_climbing_fibonacci-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> fibonacci<span class="op">(</span>n<span class="op">);</span></span>
<span id="list:stairs_climbing_fibonacci-25"><a href="#list:stairs_climbing_fibonacci-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Now, let’s have a look at why the seemingly unrelated fibonacci sequence plays a role in this problem. If the problem is looked at as an iterative process in which at each step a certain number of stairs are climbed. For instance if <span class="math inline">\(n = 3\)</span> and:</p>
<ul>
<li><p><span class="math inline">\(1\)</span> step is hopped then the number of remaining steps is <span class="math inline">\(3-1 = 2\)</span>.</p></li>
<li><p><span class="math inline">\(2\)</span> steps are hopped then the number of remaining steps is <span class="math inline">\(3-2 = 1\)</span>.</p></li>
</ul>
<p>When one step is hopped, the problem changes from climbing <span class="math inline">\(n\)</span> stairs to <span class="math inline">\(n-1\)</span> stairs. At this point the problem is seemingly unchanged except for the number of stairs left to climb and the same reasoning can be applied again:</p>
<ul>
<li><p><span class="math inline">\(1\)</span> step is hopped then the number of remaining steps is <span class="math inline">\((n-1)-1 = n-2\)</span>.</p></li>
<li><p><span class="math inline">\(2\)</span> steps are hopped then the number of remaining steps is <span class="math inline">\((n-1)-2 = (n-3)\)</span>.</p></li>
</ul>
<p>As can be seen, two decisions are possible i.e. climbing one or two stairs, exactly like in the fibinacci sequence, until either the <span class="math inline">\(n\)</span> step or a point past to it is reached.</p>
<h2 id="common-variation-1">Common Variation </h2>
<h3 id="stairs_climbing:sec:arbitrary_steps">Arbitrary step lengths</h3>
<p>But what happens when the step sizes allowed are not just <span class="math inline">\(1\)</span> or <span class="math inline">\(2\)</span> but an array of <span class="math inline">\(k\)</span> positive values <span class="math inline">\(A=\{s_1 &lt; s_2 &lt; \ldots &lt; s_k\}\)</span>. The problem statement for this harder variant of the problem is as follows:</p>
<div class="exercise">
<p>You are climbing a stair case and it takes <span class="math inline">\(n\)</span> steps to reach to the top.</p>
<p>Each time you can either climb <span class="math inline">\(s_1\)</span> or <span class="math inline">\(s_2\)</span> or <span class="math inline">\(\ldots\)</span> or <span class="math inline">\(s_k\)</span> steps where <span class="math inline">\(0 &lt; s_1 &lt; s_2 &lt; \ldots &lt; s_k\)</span>. In how many distinct ways can you climb to the top?</p>
</div>
<p>Note how this problem is equivalent to the easier version described in Section <a href="#sec:stairs_climbing_statement_easy" data-reference-type="ref" data-reference="sec:stairs_climbing_statement_easy">8.1</a> when the allowed step sizes are <span class="math inline">\(s_i = 1\)</span> and <span class="math inline">\(s_2=2\)</span>.</p>
<h1 id="ch:wave_array">Wave Array</h1>
<h2 class="unnumbered" id="introduction-8">Introduction</h2>
<p>We are used to talking about sorting in terms of arranging items in either ascending or descending order. But in general, sorting is the process of arranging items systematically according to a criterion that can be purely arbitrary.</p>
<p>The problem discussed in this lesson is about writing an algorithm for sorting the items of a collection in a rather unusual and peculiar way where the goal is to place elements at even indices such that they all are surrounded by either greater or smaller elements. For instance the collection: <span class="math inline">\(\{1,3,-1,3,2,4\}\)</span> is properly sorted while <span class="math inline">\(\{1,3,-1,1,2,4\}\)</span> is not.</p>
<p>This question has been asked at companies like <em>Adobe</em>, and <em>Google</em>, mostly during the firsts on-site interview stages as it is not considered to be a very hard one and you can solve it by writing just a handful of lines. In fact, provided you come up with the right idea and make no implementation mistakes this problem can be cleared rather quickly. It has, however, proven to be challenging for many, especially in getting it right the first time, and we advise you to spend some time after you have a working draft of the solution to make sure the code is behaving as expected especially on corner cases.</p>
<h2 id="problem-statement-8">Problem statement</h2>
<div class="exercise">
<p>Given an array <span class="math inline">\(A\)</span> of <span class="math inline">\(n\)</span> integers, arrange the numbers in a wave-like fashion. A valid wave array <span class="math inline">\(X\)</span> has its elements arranged in one of the two following ways:</p>
<ol>
<li><p><span class="math inline">\(x_0 \geq x_1 \leq x_2 \geq x_3 \leq  x_5 \geq \ldots\)</span> where <span class="math inline">\(x_{2i-1} \geq x_{2i} \leq x_{2i+1}\)</span></p></li>
<li><p><span class="math inline">\(x_1 \leq x_2 \geq x_3 \leq x_4 \geq x_5 \leq \ldots\)</span> where <span class="math inline">\(x_{2i-1} \leq x_{2i} \geq x_{2i+1}\)</span></p></li>
</ol>
<div class="example">
<p><br />
<span id="ex:wave_array:example1" label="ex:wave_array:example1">[ex:wave_array:example1]</span> Given <span class="math inline">\(A= \{10, 5, 6, 3, 2, 20, 100, 80\}\)</span> the followings are all valid output:</p>
<ul>
<li><p>{20, 5, 10, 2, 80, 6, 100, 3}</p></li>
<li><p>{10, 5, 6, 2, 20, 3, 100, 80}</p></li>
</ul>
</div>
<div class="example">
<p><br />
<span id="ex:wave_array:example2" label="ex:wave_array:example2">[ex:wave_array:example2]</span> Given <span class="math inline">\(A= \{20, 10, 8, 6, 4, 2\}\)</span> the followings are all valid output:</p>
<ul>
<li><p>{20, 8, 10, 4, 6, 2}</p></li>
<li><p>{10, 8, 20, 2, 6, 4}</p></li>
</ul>
</div>
<div class="example">
<p><br />
<span id="ex:wave_array:example3" label="ex:wave_array:example3">[ex:wave_array:example3]</span> Given <span class="math inline">\(A= \{10,9,8,7,6,5,4,3,2,1\}\)</span> the following is a output: <span class="math inline">\(\{10, 8, 9, 6, 7, 4, 5, 2, 3, 0,
		1 \}\)</span></p>
</div>
</div>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/wave_array/images/example1.png" id="fig:dice_rolls:12faces_dice" alt="Input and solutions for Example [ex:wave_array:example1]." /><figcaption aria-hidden="true">Input and solutions for Example <a href="#ex:wave_array:example1" data-reference-type="ref" data-reference="ex:wave_array:example1">[ex:wave_array:example1]</a>.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/wave_array/images/example1.png" id="fig:dice_rolls:6faces_dice" alt="Input and solutions for Example [ex:wave_array:example2]." /><figcaption aria-hidden="true">Input and solutions for Example <a href="#ex:wave_array:example2" data-reference-type="ref" data-reference="ex:wave_array:example2">[ex:wave_array:example2]</a>.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/wave_array/images/example1.png" id="fig:dice_rolls:20faces_dice" alt="Input and solutions for Example [ex:wave_array:example3]." /><figcaption aria-hidden="true">Input and solutions for Example <a href="#ex:wave_array:example3" data-reference-type="ref" data-reference="ex:wave_array:example3">[ex:wave_array:example3]</a>.</figcaption>
</figure>
<h2 id="clarification-questions-8">Clarification Questions</h2>
<div class="QandA">
<p>Does the array <span class="math inline">\(A\)</span> only contain positive numbers?</p>
<div class="answered">
<p><em>No, the input numbers can be positive or negative.</em></p>
</div>
<p>Are duplicates in <span class="math inline">\(A\)</span> allowed?</p>
<div class="answered">
<p><em>Yes, duplicates might be present.</em></p>
</div>
<p>Do the numbers in <span class="math inline">\(A\)</span> lie in a given particular range? If yes which one?</p>
<div class="answered">
<p><em>No; no assumptions can be made on the values in <span class="math inline">\(A\)</span>.</em></p>
</div>
</div>
<h2 id="wave_array:sec:discussion">Discussion</h2>
<p>The challenge confronting us is about the creation of an entirely new array <span class="math inline">\(X\)</span> (we, therefore, know from the very beginning we must make a copy of <span class="math inline">\(A\)</span> at some point) that contains the same elements in <span class="math inline">\(A\)</span>, arranged in a form that reminds a wave. An array of this type has its elements arranged so that they produce a zig-zig-like pattern when plotted on a graph.</p>
<p>Sequences of numbers of this type can be described as having the property that all of their elements located at even indices are <strong>all</strong> either <em>local</em> <strong>minima</strong> or <strong>maxima</strong><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. Identifying a local minimum/maximum is easy but, it is only helpful when we want to test whether a sequence is a valid wave array.</p>
<h3 id="wave_array:sec:bruteforce">Brute-force</h3>
<p>One way to attack this problem is by enumerating every possible arrangement of the elements of <span class="math inline">\(A\)</span> and apply the criteria of wave-array validity discussed above to find a solution.</p>
<p>We can enumerate all permutations of an array quite easily by using a function like which &gt; Rearranges the elements in the range [first,last) into the next lexicographically greater permutation.</p>
<p>This idea is implemented in Listing <a href="#list:wave_array_linear_bruteforce" data-reference-type="ref" data-reference="list:wave_array_linear_bruteforce">[list:wave_array_linear_bruteforce]</a>.</p>
<div class="sourceCode" id="list:wave_array_linear_bruteforce" data-language="c++" data-caption="Brute-force time solution to the wave array problem." label="list:wave_array_linear_bruteforce"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:wave_array_linear_bruteforce-1"><a href="#list:wave_array_linear_bruteforce-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> It<span class="op">,</span> <span class="kw">typename</span> Cmp_fn<span class="op">&gt;</span></span>
<span id="list:wave_array_linear_bruteforce-2"><a href="#list:wave_array_linear_bruteforce-2" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> is_valid_wave_array<span class="op">(</span>It begin<span class="op">,</span> It end<span class="op">,</span> Cmp_fn fn <span class="op">=</span> <span class="bu">std::</span>greater<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;())</span></span>
<span id="list:wave_array_linear_bruteforce-3"><a href="#list:wave_array_linear_bruteforce-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:wave_array_linear_bruteforce-4"><a href="#list:wave_array_linear_bruteforce-4" aria-hidden="true" tabindex="-1"></a>  It curr <span class="op">=</span> begin<span class="op">;</span></span>
<span id="list:wave_array_linear_bruteforce-5"><a href="#list:wave_array_linear_bruteforce-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span><span class="op">(</span>curr <span class="op">!=</span> end<span class="op">){</span></span>
<span id="list:wave_array_linear_bruteforce-6"><a href="#list:wave_array_linear_bruteforce-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="list:wave_array_linear_bruteforce-7"><a href="#list:wave_array_linear_bruteforce-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span><span class="at">const</span> It prev <span class="op">=</span> curr<span class="op">-</span><span class="dv">1</span><span class="op">;</span> prev <span class="op">&gt;=</span> begin <span class="op">&amp;&amp;</span> <span class="op">!</span>cmp_fn<span class="op">(</span>curr<span class="op">,</span> prev<span class="op">))</span></span>
<span id="list:wave_array_linear_bruteforce-8"><a href="#list:wave_array_linear_bruteforce-8" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:wave_array_linear_bruteforce-9"><a href="#list:wave_array_linear_bruteforce-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="list:wave_array_linear_bruteforce-10"><a href="#list:wave_array_linear_bruteforce-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span><span class="at">const</span> It next <span class="op">=</span> curr<span class="op">+</span><span class="dv">1</span><span class="op">;</span> next <span class="op">&lt;</span> end <span class="op">&amp;&amp;</span> <span class="op">!</span>cmp_fn<span class="op">(</span>curr<span class="op">,</span> next<span class="op">))</span></span>
<span id="list:wave_array_linear_bruteforce-11"><a href="#list:wave_array_linear_bruteforce-11" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:wave_array_linear_bruteforce-12"><a href="#list:wave_array_linear_bruteforce-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:wave_array_linear_bruteforce-13"><a href="#list:wave_array_linear_bruteforce-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:wave_array_linear_bruteforce-14"><a href="#list:wave_array_linear_bruteforce-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:wave_array_linear_bruteforce-15"><a href="#list:wave_array_linear_bruteforce-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:wave_array_linear_bruteforce-16"><a href="#list:wave_array_linear_bruteforce-16" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> wave_brute_force<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>A<span class="op">)</span></span>
<span id="list:wave_array_linear_bruteforce-17"><a href="#list:wave_array_linear_bruteforce-17" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:wave_array_linear_bruteforce-18"><a href="#list:wave_array_linear_bruteforce-18" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> B<span class="op">(</span>A<span class="op">);</span></span>
<span id="list:wave_array_linear_bruteforce-19"><a href="#list:wave_array_linear_bruteforce-19" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>sort<span class="op">(</span>begin<span class="op">(</span>B<span class="op">),</span> end<span class="op">(</span>B<span class="op">));</span></span>
<span id="list:wave_array_linear_bruteforce-20"><a href="#list:wave_array_linear_bruteforce-20" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="list:wave_array_linear_bruteforce-21"><a href="#list:wave_array_linear_bruteforce-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">do</span> <span class="op">{</span></span>
<span id="list:wave_array_linear_bruteforce-22"><a href="#list:wave_array_linear_bruteforce-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>is_valid_wave_array<span class="op">(</span>B<span class="op">.</span>begin<span class="op">(),</span> B<span class="op">.</span>end<span class="op">(),</span> <span class="bu">std::</span>greater<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;())</span> <span class="op">||</span> </span>
<span id="list:wave_array_linear_bruteforce-23"><a href="#list:wave_array_linear_bruteforce-23" aria-hidden="true" tabindex="-1"></a>      is_valid_wave_array<span class="op">(</span>B<span class="op">.</span>begin<span class="op">(),</span> B<span class="op">.</span>end<span class="op">(),</span> <span class="bu">std::</span>less<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;())</span> <span class="op">)</span></span>
<span id="list:wave_array_linear_bruteforce-24"><a href="#list:wave_array_linear_bruteforce-24" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> B<span class="op">;</span></span>
<span id="list:wave_array_linear_bruteforce-25"><a href="#list:wave_array_linear_bruteforce-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="cf">while</span> <span class="op">(</span> <span class="bu">std::</span>next_permutation<span class="op">(</span>B<span class="op">.</span>begin<span class="op">(),</span>B<span class="op">.</span>end<span class="op">())</span> <span class="op">);</span></span>
<span id="list:wave_array_linear_bruteforce-26"><a href="#list:wave_array_linear_bruteforce-26" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="list:wave_array_linear_bruteforce-27"><a href="#list:wave_array_linear_bruteforce-27" aria-hidden="true" tabindex="-1"></a>  <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">(</span><span class="st">&quot;Should never happen&quot;</span><span class="op">);</span></span>
<span id="list:wave_array_linear_bruteforce-28"><a href="#list:wave_array_linear_bruteforce-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="wave_array:sec:sorting">Sorting solution</h3>
<p>As per all array problems, the first question that should come to mind is: <em>does sorting the elements (we are referring here to a canonical sorting in increasing order) changes the difficulty of the problem?</em> Incrementally sorted sequences are easy to reason about as they provide strong and clear guarantees on how elements relate to each. Most importantly the same problem is very often a lot easier to solve on a sorted collection than on an unsorted one.</p>
<p>If we apply the wave-array validity criterion (discussed above on local minima/maxima) on a sorted array <span class="math inline">\(S=\{s_0 \leq s_1 \leq \ldots \leq s_{n-1}\}\)</span> we notice that <span class="math inline">\(S\)</span> fails the test as there is only one local minimum and local maximum i.e. <span class="math inline">\(s_0\)</span> and <span class="math inline">\(s_{n-1}\)</span> (which also happen to be the global minimum and maximum).</p>
<p>But how <span class="math inline">\(S\)</span> changes if every element that is located at an even indix is swapped with its subsequent neighbor? When every elements at indices <span class="math inline">\(2i\)</span> and <span class="math inline">\(2i+1\)</span> (<span class="math inline">\(i=0,1,\ldots\)</span>) are swapped, then: <span class="math inline">\(S=\{s_1
\geq s_0 \leq s_3 \geq s_2 \leq s_5 \geq s_4 \leq s_7  \geq \ldots\}\)</span> which is now in better shape to pass the wave-array validity test as now every element at even index is surrounded by smaller (or equal) elements.</p>
<p>Notice that the elements of <span class="math inline">\(S\)</span> have been shuffled around and that now the element <span class="math inline">\(a_i\)</span> is not located at index <span class="math inline">\(i\)</span> anymore (contrary to how it was originally). We can see that <span class="math inline">\(a_3\)</span> is now located at index <span class="math inline">\(2\)</span> and it is surrounded by <span class="math inline">\(a_0\)</span> and <span class="math inline">\(a_2\)</span> which are both smaller or equal to <span class="math inline">\(a_3\)</span>. Similarly <span class="math inline">\(a_5\)</span> is now placed at index <span class="math inline">\(4\)</span> and it is surrounded by the elements <span class="math inline">\(a_2\)</span> and <span class="math inline">\(a_4\)</span>, both known to be smaller or equal than <span class="math inline">\(a_5\)</span>.</p>
<p>We can use this observation to solve this problem efficiently and elegantly as shown in Listing <a href="#list:wave_array_sorting" data-reference-type="ref" data-reference="list:wave_array_sorting">[list:wave_array_sorting]</a>.</p>
<div class="sourceCode" id="list:wave_array_sorting" data-language="c++" data-caption="Solution to the wave array problem using sorting." label="list:wave_array_sorting"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:wave_array_sorting-1"><a href="#list:wave_array_sorting-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> wave_sorting<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>A<span class="op">)</span></span>
<span id="list:wave_array_sorting-2"><a href="#list:wave_array_sorting-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:wave_array_sorting-3"><a href="#list:wave_array_sorting-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> B<span class="op">(</span>A<span class="op">);</span></span>
<span id="list:wave_array_sorting-4"><a href="#list:wave_array_sorting-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>sort<span class="op">(</span>begin<span class="op">(</span>B<span class="op">),</span> end<span class="op">(</span>B<span class="op">));</span></span>
<span id="list:wave_array_sorting-5"><a href="#list:wave_array_sorting-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> it <span class="op">=</span> B<span class="op">.</span>begin<span class="op">();</span></span>
<span id="list:wave_array_sorting-6"><a href="#list:wave_array_sorting-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> it <span class="op">=</span> B<span class="op">.</span>begin<span class="op">();</span> it <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;</span> B<span class="op">.</span>end<span class="op">();</span> it <span class="op">+=</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="list:wave_array_sorting-7"><a href="#list:wave_array_sorting-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:wave_array_sorting-8"><a href="#list:wave_array_sorting-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(*</span>it<span class="op">,</span> <span class="op">*(</span>it <span class="op">+</span> <span class="dv">1</span><span class="op">));</span></span>
<span id="list:wave_array_sorting-9"><a href="#list:wave_array_sorting-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:wave_array_sorting-10"><a href="#list:wave_array_sorting-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> B<span class="op">;</span></span>
<span id="list:wave_array_sorting-11"><a href="#list:wave_array_sorting-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The code above works by creating a copy of the input array <span class="math inline">\(A\)</span> named <span class="math inline">\(B\)</span>, which is subsequently sorted. The code then proceeds in swapping every element located at an even location with the element after it. You can see the operation is applied to the iterators and and that at the end of each iteration is incremented by <span class="math inline">\(2\)</span>. This, together with the fact initially pointer to the first even element at location <span class="math inline">\(0\)</span>, effectively means that only pairs of items at indices of the form <span class="math inline">\((2i, 2i+1)\)</span> are swapped.</p>
<p>The code above is considered good as its time and space complexity are <span class="math inline">\(O(nlog(n))\)</span> and <span class="math inline">\(O(n)\)</span>, respectively.</p>
<p>In some cases, the interviewer might ask you to return, among all possible valid arrangments, the one being the lexicographically minimum. If it is the case the solution proposed below won’t work and it should not be attempted.</p>
<h3 id="linear-time-solution">Linear time solution</h3>
<p>Despite the solution using sorting presented in Section <a href="#wave_array:sec:sorting" data-reference-type="ref" data-reference="wave_array:sec:sorting">9.3.2</a> is already good enough to possibly clear the interview, there exists a solution that works in linear time and that is as easy to implement and explain. The core idea is always the same: elements at even index should always be greater (or smaller, equivalently) than their adjacents neighbors. Only this time we will enforce it in a single pass on the array, by swapping elements at even indices with their direct neighbors (to the left and to the right) if they happen to be smaller in such a way that the largest element among <span class="math inline">\(x_{2i-1},x_{2i},x_{2i+1}\)</span> always end up going to the location <span class="math inline">\(2i\)</span>.</p>
<p>We can do that by iterating over all even indices and performing the following operations:</p>
<ol>
<li><p>if the current element <span class="math inline">\(a_{2i}\)</span> is smaller than the element <span class="math inline">\(a_{2i-1}\)</span> then swap them.</p></li>
<li><p>if the current element <span class="math inline">\(a_{2i}\)</span> (possibly newly assigned from the previous step) is smaller than the element <span class="math inline">\(a_{2i+1}\)</span> then swap them.</p></li>
</ol>
<p>At this point we have effectively placed the largest among <span class="math inline">\(x_{2i-1},x_{2i},x_{2i+1}\)</span> at the location <span class="math inline">\(2i\)</span> and we can proceed to the next even element <span class="math inline">\(a_{2(i+1)}\)</span>.</p>
<p>See Listing <a href="#list:wave_array_linear" data-reference-type="ref" data-reference="list:wave_array_linear">[list:wave_array_linear]</a> for a possible implementation of this idea.</p>
<div class="sourceCode" id="list:wave_array_linear" data-language="c++" data-caption="Linear time solution to the wave array problem." label="list:wave_array_linear"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:wave_array_linear-1"><a href="#list:wave_array_linear-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> wave_linear<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>A<span class="op">)</span></span>
<span id="list:wave_array_linear-2"><a href="#list:wave_array_linear-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:wave_array_linear-3"><a href="#list:wave_array_linear-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>A<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;=</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="list:wave_array_linear-4"><a href="#list:wave_array_linear-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> A<span class="op">;</span></span>
<span id="list:wave_array_linear-5"><a href="#list:wave_array_linear-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:wave_array_linear-6"><a href="#list:wave_array_linear-6" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> B<span class="op">(</span>A<span class="op">);</span></span>
<span id="list:wave_array_linear-7"><a href="#list:wave_array_linear-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> B<span class="op">.</span>size<span class="op">();</span> i <span class="op">+=</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="list:wave_array_linear-8"><a href="#list:wave_array_linear-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:wave_array_linear-9"><a href="#list:wave_array_linear-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> B<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&gt;</span> B<span class="op">[</span>i<span class="op">])</span></span>
<span id="list:wave_array_linear-10"><a href="#list:wave_array_linear-10" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>swap<span class="op">(</span>B<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> B<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:wave_array_linear-11"><a href="#list:wave_array_linear-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:wave_array_linear-12"><a href="#list:wave_array_linear-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">&lt;</span> B<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> B<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&gt;</span> B<span class="op">[</span>i<span class="op">])</span></span>
<span id="list:wave_array_linear-13"><a href="#list:wave_array_linear-13" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>swap<span class="op">(</span>B<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">],</span> B<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:wave_array_linear-14"><a href="#list:wave_array_linear-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:wave_array_linear-15"><a href="#list:wave_array_linear-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> B<span class="op">;</span></span>
<span id="list:wave_array_linear-16"><a href="#list:wave_array_linear-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice that the code above performs some checks on the corner elements so that we do not perform out-of-bound accesses.</p>
<p><strong>This solution is optimal as it runs in <span class="math inline">\(o(n)\)</span> space and time.</strong></p>
<p>Like the solution using sorting, it does not work when the lexicographical minimum arrangement should be returned.</p>
<h1 id="ch:first_positive_missing">First positive missing</h1>
<h2 class="unnumbered" id="introduction-9">Introduction</h2>
<p>In this chapter, we are going to address a fairly common problem that has been asked primarily during on-site interviews and for which exist quite a number of solutions making up for a wide range of time and space complexities.</p>
<p>There is no doubt that coming up with what is considered to be the best solution (in terms of asymptotic complexity) is challenging. This problem is definitely a tricky one, that is worth looking into in-depth.</p>
<p>It features a short and sometimes, depending on the examples provided, slightly vague ( possibly on purpose) statement. Therefore, more than for other problems, it is important to ask questions and clarify with the interviewer every unclear aspect of the statement before actually attempting to write any code for it so as to make sure the statement is understood fully <a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> and there is no misunderstanding about the details.</p>
<h2 id="problem-statement-9">Problem statement</h2>
<div class="exercise">
<p>Write a function that, given an unsorted integer array <span class="math inline">\(A\)</span>, returns the smallest positive integer not contained in <span class="math inline">\(A\)</span>.</p>
<div class="example">
<p><br />
Given <span class="math inline">\(A=\{ 1, 0, -1, -2\}\)</span> the answer is <span class="math inline">\(2\)</span>.</p>
</div>
<div class="example">
<p><br />
Given <span class="math inline">\(A=\{ 2, 3, -7, 6, 8, 1, -10, 15\}\)</span> the answer is <span class="math inline">\(4\)</span>.</p>
</div>
<div class="example">
<p><br />
Given <span class="math inline">\(A=\{ 1, 0, -1, -2\}\)</span> the answer is <span class="math inline">\(2\)</span>.</p>
</div>
</div>
<h2 id="clarification-questions-9">Clarification Questions</h2>
<div class="QandA">
<p>Are the input numbers always positive?</p>
<div class="answered">
<p><em>No, the array contains positive and negative numbers.</em></p>
</div>
<p>Are all the elements distinct?</p>
<div class="answered">
<p><em>No, the array might contains duplicates.</em></p>
</div>
<p>Can be the input array be modified?</p>
<div class="answered">
<p><em>Yes.</em></p>
</div>
<p>Can the size of the array be zero? In other words, can the array be empty?</p>
<div class="answered">
<p><em>No, the input array contains at least one element.</em></p>
</div>
<p>Is <span class="math inline">\(0\)</span> a valid output?</p>
<div class="answered">
<p><em>No, only strictly positive numbers should be returned.</em></p>
</div>
</div>
<h2 id="first_positive_missing:sec:discussion">Discussion</h2>
<p>This is actually a problem with a solid real-life application. Imagine for instance how an OS might assign PID<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>s to processes. One approach would be to keep a list of all the PIDs for all the processes running, and once a new one is fired up, the OS will assign to it the smallest PID <strong>not already assigned</strong> to any other process.</p>
<p>In a highly dynamic environment like the OS with thousands of applications active at the same time, the focus of solving this task should be on sheer speed as you want the process to be up and running as fast as possible.</p>
<h3 id="bruteforce">Bruteforce</h3>
<p>One of the simplest approaches we can think about consists of blindly searching,incrementally starting from <span class="math inline">\(1\)</span>, in <span class="math inline">\(A\)</span> for the missing number. What this practically means is that we are going to perform a search operation in <span class="math inline">\(A\)</span> for each number from <span class="math inline">\(1\)</span> onward <strong>until the search fails</strong>. This algorithm is guaranteed to return always the smallest missing number because we perform the searches in order, with the smallest numbers being searched first.</p>
<p>Listing <a href="#list:first_positive_missing_bruteforce" data-reference-type="ref" data-reference="list:first_positive_missing_bruteforce">[list:first_positive_missing_bruteforce]</a> shows an implementation of this idea where we use as a means to do the actual search in the <span class="math inline">\(A\)</span>.</p>
<div class="sourceCode" id="list:first_positive_missing_bruteforce" data-language="c++" data-caption="Two bruteforce solution implementations the problem of finding the smallest missing positive integer in an array." label="list:first_positive_missing_bruteforce"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:first_positive_missing_bruteforce-1"><a href="#list:first_positive_missing_bruteforce-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> first_positive_missing_bruteforce1<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> A<span class="op">)</span></span>
<span id="list:first_positive_missing_bruteforce-2"><a href="#list:first_positive_missing_bruteforce-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:first_positive_missing_bruteforce-3"><a href="#list:first_positive_missing_bruteforce-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:first_positive_missing_bruteforce-4"><a href="#list:first_positive_missing_bruteforce-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// until ans is found</span></span>
<span id="list:first_positive_missing_bruteforce-5"><a href="#list:first_positive_missing_bruteforce-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>find<span class="op">(</span>begin<span class="op">(</span>A<span class="op">),</span> end<span class="op">(</span>A<span class="op">),</span> ans<span class="op">)</span> <span class="op">!=</span> end<span class="op">(</span>A<span class="op">))</span></span>
<span id="list:first_positive_missing_bruteforce-6"><a href="#list:first_positive_missing_bruteforce-6" aria-hidden="true" tabindex="-1"></a>    ans<span class="op">++;</span></span>
<span id="list:first_positive_missing_bruteforce-7"><a href="#list:first_positive_missing_bruteforce-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:first_positive_missing_bruteforce-8"><a href="#list:first_positive_missing_bruteforce-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:first_positive_missing_bruteforce-9"><a href="#list:first_positive_missing_bruteforce-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:first_positive_missing_bruteforce-10"><a href="#list:first_positive_missing_bruteforce-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> first_positive_missing_bruteforce2<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> A<span class="op">)</span></span>
<span id="list:first_positive_missing_bruteforce-11"><a href="#list:first_positive_missing_bruteforce-11" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:first_positive_missing_bruteforce-12"><a href="#list:first_positive_missing_bruteforce-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;;</span> i<span class="op">++)</span></span>
<span id="list:first_positive_missing_bruteforce-13"><a href="#list:first_positive_missing_bruteforce-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:first_positive_missing_bruteforce-14"><a href="#list:first_positive_missing_bruteforce-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// not found</span></span>
<span id="list:first_positive_missing_bruteforce-15"><a href="#list:first_positive_missing_bruteforce-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>find<span class="op">(</span>begin<span class="op">(</span>A<span class="op">),</span> end<span class="op">(</span>A<span class="op">),</span> i<span class="op">)</span> <span class="op">==</span> end<span class="op">(</span>A<span class="op">))</span></span>
<span id="list:first_positive_missing_bruteforce-16"><a href="#list:first_positive_missing_bruteforce-16" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> i<span class="op">;</span></span>
<span id="list:first_positive_missing_bruteforce-17"><a href="#list:first_positive_missing_bruteforce-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:first_positive_missing_bruteforce-18"><a href="#list:first_positive_missing_bruteforce-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This is, however, considered to be a poor solution (as a rule of thumb, in the context of coding interviews, all brute-force solutions are) and has a complexity of <span class="math inline">\(O(n^2)\)</span> time and <span class="math inline">\(O(1)\)</span> space.</p>
<p>The advantages of this approach are that it is extremely easy and fast to write as well as very difficult to makes implementations mistakes because the logic is simple and the amount of code involved is small.</p>
<h3 id="first_positive_missing:sec:sorting">Sorting</h3>
<p>The next most intuitive (after brute-force) way to solve this problem is by thinking about sorting the input because as we will see, having the numbers sorted is helpful and makes coming up with a fast approach to this problem easy.</p>
<p>When the <span class="math inline">\(A\)</span> is sorted, we know the positive numbers in it will all be appearing <strong>in an ordered fashion</strong> from a certain index <span class="math inline">\(k\geq 0\)</span> onwards (the positions from index <span class="math inline">\(0\)</span> to <span class="math inline">\(k-1\)</span> are occupied by negatives or zeros).</p>
<p>We also know that if no number is missing in <span class="math inline">\(A[k \ldots n-1]\)</span> then we would expect to see:</p>
<ul>
<li><p><span class="math inline">\(A[k]=1\)</span></p></li>
<li><p><span class="math inline">\(A[k+1]=2\)</span></p></li>
<li><p><span class="math inline">\(A[k+2]=3\)</span></p></li>
<li><p><span class="math inline">\(\ldots\)</span></p></li>
<li><p><span class="math inline">\(A[n-1]=n-k+1\)</span></p></li>
</ul>
<p>i.e. all numbers from <span class="math inline">\(1\)</span> onwards appearing in their natural order <span class="math inline">\((1,2,3, \ldots (n-k+1))\)</span> from the cell at index <span class="math inline">\(k\)</span> to the end of <span class="math inline">\(A\)</span>. If any of these numbers are missing, then we would not be able to see such a sequence.</p>
<p>The goal of this problem is to find the first number that is missing from that sequence and we can do that by finding the first element among <span class="math inline">\(A[k \ldots n-1]\)</span> where the condition <span class="math inline">\(A[k+i]=i+1\)</span> with <span class="math inline">\((i=0,1,2, \ldots)\)</span> is <strong>false</strong>. When this happens, we can conclude the missing number is <span class="math inline">\(i+1\)</span>. If such a cell does not exist (every cell satisfies the condition above), then we know that the missing number is <span class="math inline">\(A[n-1]+1\)</span>.</p>
<p>For instance consider the array <span class="math inline">\(A=\{ 9,-7,0,4,5,2,0,1\}\)</span>. When sorted, the array becomes <span class="math inline">\(A=\{ -7,0,0,1,2,4,5,9\}\)</span>. The positives start at index <span class="math inline">\(k=3\)</span>:</p>
<ul>
<li><p><span class="math inline">\(A[3+0] = 1\)</span> (test passes)</p></li>
<li><p><span class="math inline">\(A[3+1] = 2\)</span> (test passes)</p></li>
<li><p><span class="math inline">\(A[3+2] = 4\)</span> (<strong>test fails</strong>)</p></li>
</ul>
<p>As we can see the test fails after three tries, and therefore we can conclude the missing number is <span class="math inline">\(3\)</span>.</p>
<p>Now let’s consider the array <span class="math inline">\(B=\{ 3,-7,0,4,5,2,0,1\}\)</span> which is exactly the same as in the previous example with the exception we have swapped a <span class="math inline">\(9\)</span> for a <span class="math inline">\(3\)</span>. When sorted, the array becomes <span class="math inline">\(B=\{ -7,0,0,1,2,3,4,5\}\)</span> which contains no gaps between any of the positive numbers. As before, the positives start at index <span class="math inline">\(k=3\)</span> but this time every element passes the test:</p>
<ul>
<li><p><span class="math inline">\(A[3+0] = 1\)</span> (test passes)</p></li>
<li><p><span class="math inline">\(A[4+1] = 2\)</span> (test passes)</p></li>
<li><p><span class="math inline">\(A[4+2] = 3\)</span> (test passes)</p></li>
<li><p><span class="math inline">\(A[4+3] = 4\)</span> (test passes)</p></li>
<li><p><span class="math inline">\(A[4+4] = 5\)</span> (test passes)</p></li>
</ul>
<p>We can clearly see that the missing number is <span class="math inline">\(6 = A[8]+1 = A[n-1]+1\)</span>.</p>
<p>An implementation of this idea is shown in Listing <a href="#list:first_positive_missing_sorting" data-reference-type="ref" data-reference="list:first_positive_missing_sorting">[list:first_positive_missing_sorting]</a>.</p>
<div class="sourceCode" id="list:first_positive_missing_sorting" data-language="c++" data-caption="Solution to the problem of finding the smallest missing positive integer in an array." label="list:first_positive_missing_sorting"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:first_positive_missing_sorting-1"><a href="#list:first_positive_missing_sorting-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> first_positive_missing_sorting<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> A<span class="op">)</span></span>
<span id="list:first_positive_missing_sorting-2"><a href="#list:first_positive_missing_sorting-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:first_positive_missing_sorting-3"><a href="#list:first_positive_missing_sorting-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>sort<span class="op">(</span>begin<span class="op">(</span>A<span class="op">),</span> end<span class="op">(</span>A<span class="op">));</span></span>
<span id="list:first_positive_missing_sorting-4"><a href="#list:first_positive_missing_sorting-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:first_positive_missing_sorting-5"><a href="#list:first_positive_missing_sorting-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> it <span class="op">=</span></span>
<span id="list:first_positive_missing_sorting-6"><a href="#list:first_positive_missing_sorting-6" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>find_if<span class="op">(</span>begin<span class="op">(</span>A<span class="op">),</span> end<span class="op">(</span>A<span class="op">),</span> <span class="op">[](</span><span class="at">const</span> <span class="kw">auto</span> <span class="op">&amp;</span>x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> x <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> <span class="op">});</span></span>
<span id="list:first_positive_missing_sorting-7"><a href="#list:first_positive_missing_sorting-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:first_positive_missing_sorting-8"><a href="#list:first_positive_missing_sorting-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> expected <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:first_positive_missing_sorting-9"><a href="#list:first_positive_missing_sorting-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>it <span class="op">!=</span> end<span class="op">(</span>A<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">(*</span>it<span class="op">)</span> <span class="op">==</span> expected<span class="op">)</span></span>
<span id="list:first_positive_missing_sorting-10"><a href="#list:first_positive_missing_sorting-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:first_positive_missing_sorting-11"><a href="#list:first_positive_missing_sorting-11" aria-hidden="true" tabindex="-1"></a>    expected<span class="op">++;</span></span>
<span id="list:first_positive_missing_sorting-12"><a href="#list:first_positive_missing_sorting-12" aria-hidden="true" tabindex="-1"></a>    it<span class="op">++;</span></span>
<span id="list:first_positive_missing_sorting-13"><a href="#list:first_positive_missing_sorting-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:first_positive_missing_sorting-14"><a href="#list:first_positive_missing_sorting-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> expected<span class="op">;</span></span>
<span id="list:first_positive_missing_sorting-15"><a href="#list:first_positive_missing_sorting-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice that:</p>
<ul>
<li><p>the iterator always points at the currently evaluated element. It is initialized to either:</p>
<ul>
<li><p>the <strong>smallest positive</strong> in the sorted array, or,</p></li>
<li><p>to one element past the end of the array if no positives are present.</p></li>
</ul>
<p>is moved to its initial location by using the function from the STL which runs in linear time. We could have very well used binary search to perform this task, but that would have not really helped us lowering the overall asymptotic time complexity because the sorting operation itself costs <span class="math inline">\(O(nlog(n))\)</span> and the subsequent loop runs in linear time.</p></li>
<li><p>is a variable holding the value that is expected to be found where is pointing to (the value <span class="math inline">\(i+1\)</span> mentioned above).</p></li>
<li><p>if the runs to completion because we have examined every element of <span class="math inline">\(A\)</span> () then points to .</p></li>
<li><p>if no positives are present, then the does not even run once and <span class="math inline">\(1\)</span> is returned.</p></li>
</ul>
<p>This is considered a good solution with an overall time and space complexity of <span class="math inline">\(O(nlog(n))\)</span> and <span class="math inline">\(O(n)\)</span>, respectively. It is, however, not optimal as solutions with better time and space complexities exist as we will see in the next section.</p>
<h3 id="first_positive_missing:sec:linear_space">Linear time and space solution</h3>
<p>Looking at the problem a bit closer we can immediately notice that the missing number will always be in the range <span class="math inline">\([1,n]\)</span> where <span class="math inline">\(n\)</span> is the size of the input array. <strong>Why is this the case?</strong> We can convince ourselves this is the case by thinking about which input can possibly lead to the largest possible output: among all possible arrays of size <span class="math inline">\(n\)</span> only one configuration leads to the highest missing number: <span class="math inline">\(A =
\{1,2,3,4, \ldots ,n\}\)</span> i.e. the configuration where all numbers from <span class="math inline">\(1\)</span> to <span class="math inline">\(n\)</span> are present. All the other configurations contain duplicates, negative or numbers higher than <span class="math inline">\(n\)</span> which forces the input to have “holes” (i.e. missing numbers in the range <span class="math inline">\([1,n]\)</span>).</p>
<p>This fact can be exploited to keep track of which positive numbers from <span class="math inline">\(1\)</span> to <span class="math inline">\(n\)</span> are present in <span class="math inline">\(A\)</span>. We can use an array of booleans flags of size <span class="math inline">\(n\)</span> to store this information. Therefore, all we have to do is, for each number <span class="math inline">\(x\)</span> in <span class="math inline">\(A\)</span> in the range <span class="math inline">\([1,n]\)</span>, to set the <span class="math inline">\(x^{th}\)</span> flag to true. Eventually, this array of flags contains the answer, which can be found by scanning through it linearly to find the first <strong>false</strong> element which signals that this is the first missing element.</p>
<p>An implementation of the idea above is found in Listing <a href="#list:first_positive_missing_linear_space" data-reference-type="ref" data-reference="list:first_positive_missing_linear_space">[list:first_positive_missing_linear_space]</a>.</p>
<div class="sourceCode" id="list:first_positive_missing_linear_space" data-language="c++" data-caption="Solution to the problem of finding the smallest missing positive integer in an array." label="list:first_positive_missing_linear_space"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:first_positive_missing_linear_space-1"><a href="#list:first_positive_missing_linear_space-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> first_positive_missing_linear_space<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> A<span class="op">)</span></span>
<span id="list:first_positive_missing_linear_space-2"><a href="#list:first_positive_missing_linear_space-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:first_positive_missing_linear_space-3"><a href="#list:first_positive_missing_linear_space-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span> F<span class="op">(</span>A<span class="op">.</span>size<span class="op">(),</span> <span class="kw">false</span><span class="op">);</span></span>
<span id="list:first_positive_missing_linear_space-4"><a href="#list:first_positive_missing_linear_space-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:first_positive_missing_linear_space-5"><a href="#list:first_positive_missing_linear_space-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span> <span class="op">&amp;</span>x <span class="op">:</span> A<span class="op">)</span></span>
<span id="list:first_positive_missing_linear_space-6"><a href="#list:first_positive_missing_linear_space-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:first_positive_missing_linear_space-7"><a href="#list:first_positive_missing_linear_space-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>x <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> x <span class="op">&lt;</span> A<span class="op">.</span>size<span class="op">())</span></span>
<span id="list:first_positive_missing_linear_space-8"><a href="#list:first_positive_missing_linear_space-8" aria-hidden="true" tabindex="-1"></a>      F<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:first_positive_missing_linear_space-9"><a href="#list:first_positive_missing_linear_space-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:first_positive_missing_linear_space-10"><a href="#list:first_positive_missing_linear_space-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> F<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span></span>
<span id="list:first_positive_missing_linear_space-11"><a href="#list:first_positive_missing_linear_space-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>F<span class="op">[</span>i<span class="op">])</span></span>
<span id="list:first_positive_missing_linear_space-12"><a href="#list:first_positive_missing_linear_space-12" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> i<span class="op">;</span></span>
<span id="list:first_positive_missing_linear_space-13"><a href="#list:first_positive_missing_linear_space-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:first_positive_missing_linear_space-14"><a href="#list:first_positive_missing_linear_space-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> A<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:first_positive_missing_linear_space-15"><a href="#list:first_positive_missing_linear_space-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The code works in two phases:</p>
<ol>
<li><p>For each number of <span class="math inline">\(A\)</span> in the range <span class="math inline">\([1,n]\)</span>, we remember we have found it by marking the cell at index in .</p></li>
<li><p>We find if exists the first cell in containing false which means the corresponding element was not found in <span class="math inline">\(A\)</span>. If a false cell does not exist then we can conclude the missing number is <span class="math inline">\(n+1\)</span>.</p></li>
</ol>
<p>This approach is considered good and it has time and space complexity both equal to <span class="math inline">\(O(n)\)</span>.</p>
<p>As an alternative, instead of an array, we can use a hashmap to keep track of which element has been already seen as the array is scanned from left to right. This might have advantages in some cases, especially when <span class="math inline">\(n\)</span> is large but there are many duplicates in <span class="math inline">\(A\)</span>.</p>
<h3 id="first_positive_missing:sec:linear_space">Linear time and constant space solution</h3>
<p>As mentioned above, the optimal solution does not use any additional space but shares the idea of keeping track of which element has been found with the solution described in Section <a href="#first_positive_missing:sec:linear_space" data-reference-type="ref" data-reference="first_positive_missing:sec:linear_space">10.3.4</a>.</p>
<p>In order not to use additional space, we have to somehow implement the functionality the array (in the code above) provides using the input array itself! Doing so sounds harder than it really is, especially until we realize that we can store the information about a positive number being present in <span class="math inline">\(A\)</span> in the sign of some other cell.</p>
<p>We know already from what we have seen in the previous solutions that we can safely ignore every negative number in <span class="math inline">\(A\)</span> and that the largest output we can ever hope to get is always less than the number of positives in <span class="math inline">\(A\)</span>. For instance, if we have an array of size <span class="math inline">\(n\)</span> with <span class="math inline">\(x\)</span> negatives and <span class="math inline">\(y\)</span> positives (<span class="math inline">\(n=x+y\)</span>) then the largest possible output we can get is: <span class="math inline">\(y+1\)</span>.</p>
<p>For instance, let’s consider the array <span class="math inline">\(A=\{-1, -2, -3, 0, 1, 2, 3\}\)</span> which has <span class="math inline">\(x=4\)</span> negatives and <span class="math inline">\(y=3\)</span> positives (<span class="math inline">\(n=7\)</span>). We can see that the missing number is <span class="math inline">\(4=y+1\)</span> and also that if we substitute any positive (or negative or zeros for that matter) number with a different positive the output of the function will **not increase**.</p>
<p>The idea is to loop through <span class="math inline">\(A\)</span> and for each number <span class="math inline">\(x&gt;0\)</span> store the information about <span class="math inline">\(x\)</span> being present in <span class="math inline">\(A\)</span> in some cell of <span class="math inline">\(A\)</span> itself. But which one? What we want is to have a mapping from the positives in <span class="math inline">\(A\)</span> to indices of <span class="math inline">\(A\)</span>. We will use this mapping to choose the cell in which we remember whether a number is present or not by changing its sign.</p>
<p>We can start noticing that if <span class="math inline">\(A\)</span> contains <span class="math inline">\(y\)</span> positive, then we have <span class="math inline">\(y\)</span> cells to which we can change the sign from positive to negative. In our quest to creating this 1-to1 mapping one problem we face is that <span class="math inline">\(A\)</span> is unsorted and positives and negatives are all shuffled around. Therefore the first step would be to rearrange the elements so that all the positives appear before all the negatives. This way, creating the mapping becomes much easier. If all <span class="math inline">\(y\)</span> positive are located from index <span class="math inline">\(0\)</span> to <span class="math inline">\(y-1\)</span>, then every time we process an element of <span class="math inline">\(x\)</span> of <span class="math inline">\(A\)</span> which value is between <span class="math inline">\(1\)</span> and <span class="math inline">\(y\)</span> (<span class="math inline">\(1 \leq x \leq y\)</span>) we can change the value of the cell at index <span class="math inline">\(x\)</span> to remember the fact the value <span class="math inline">\(x\)</span> is present in <span class="math inline">\(A\)</span>. The main problem at this point is therefore to rearrange the <span class="math inline">\(A\)</span> so that all positives appear before all negatives and zeros in an efficient manner.</p>
<p>Given an unsorted array, we can rearrange its element so that all positives before all negatives by using a two-pointer technique where we use (not surprisingly) two pointers <span class="math inline">\(s\)</span> and <span class="math inline">\(e\)</span> pointing initially to index <span class="math inline">\(0\)</span> and <span class="math inline">\(n-1\)</span>, respectively. The idea is to keep moving <span class="math inline">\(s\)</span> towards the end of the array and <span class="math inline">\(e\)</span> towards the start until <span class="math inline">\(s\)</span> points to a positive and <span class="math inline">\(e\)</span> points to a negative. At this point <span class="math inline">\(s\)</span> points to a value that should appear after the element pointed by <span class="math inline">\(e\)</span> and therefore we swap those values. If we keep repeating this process until <span class="math inline">\(s&gt;=e\)</span> eventually all the pairs of misplaced elements (a negative appearing before a positive) are swapped and the final array is arranged so that all negatives appear in the first <span class="math inline">\(x\)</span> positions of the array.</p>
<p>Consider for instance the array <span class="math inline">\(A=\{-1, 1, 2,-2 0,3,-3\}\)</span>. Initially <span class="math inline">\(s=0\)</span> and <span class="math inline">\(e=6\)</span>. We first move <span class="math inline">\(s\)</span> to the first positive which happens to appear at index <span class="math inline">\(1\)</span>. Similarly we move <span class="math inline">\(e\)</span> to the left towards the first negative which appear at index <span class="math inline">\(6\)</span>. The elements pointed by <span class="math inline">\(s\)</span> and <span class="math inline">\(e\)</span> are swapped, and <span class="math inline">\(A=\{-1, -3, 2,-2 0,3,1\}\)</span>.</p>
<p>The same process is repeated and after they are moved <span class="math inline">\(s=2\)</span> and <span class="math inline">\(e=4\)</span>. The values they point to are swapped leaving <span class="math inline">\(A=\{-1, -3, 0,-2 2,3,1\}\)</span>. When the pointers are moved next, they cross, and this signals the rearrangement is finally complete. It is important to notice that the aim of this process is not to sort the array, but to simply make all the negatives appear before all the positives (therefore still allowing the positives and the negatives to appear in any order).</p>
<p>After all the numbers ins <span class="math inline">\(A\)</span> are processed this way, similarly to what we did in step <span class="math inline">\(2\)</span> of the solution running in linear time and space in Section <a href="#first_positive_missing:sec:linear_space" data-reference-type="ref" data-reference="first_positive_missing:sec:linear_space">10.3.4</a> (where we used the array ), we can scan the portion of <span class="math inline">\(A\)</span> from index <span class="math inline">\(0\)</span> to <span class="math inline">\(y\)</span> looking for positives. If we find one at index <span class="math inline">\(k\)</span>, it means that the element <span class="math inline">\(k+1\)</span> is missing from the array as if it was present it would have undergone a sign change. If all those cells contain negative, then it means that the missing number is <span class="math inline">\(n+1\)</span>.</p>
<p>This idea is implemented in Listing <a href="#list:first_positive_missing_linear_space" data-reference-type="ref" data-reference="list:first_positive_missing_linear_space">[list:first_positive_missing_linear_space]</a> shown below.</p>
<div class="sourceCode" id="list:first_positive_missing_linear_space" data-language="c++" data-caption="Linear time and constantspace solution to the problem of finding the smallest missing positive integer in an array." label="list:first_positive_missing_linear_space"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:first_positive_missing_linear_space-1"><a href="#list:first_positive_missing_linear_space-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> divide_pos_neg<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> N<span class="op">)</span></span>
<span id="list:first_positive_missing_linear_space-2"><a href="#list:first_positive_missing_linear_space-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:first_positive_missing_linear_space-3"><a href="#list:first_positive_missing_linear_space-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> s <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:first_positive_missing_linear_space-4"><a href="#list:first_positive_missing_linear_space-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> e <span class="op">=</span> N<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:first_positive_missing_linear_space-5"><a href="#list:first_positive_missing_linear_space-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>s <span class="op">&lt;=</span> e<span class="op">)</span></span>
<span id="list:first_positive_missing_linear_space-6"><a href="#list:first_positive_missing_linear_space-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:first_positive_missing_linear_space-7"><a href="#list:first_positive_missing_linear_space-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>s <span class="op">&lt;=</span> e <span class="op">&amp;&amp;</span> N<span class="op">[</span>s<span class="op">]</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:first_positive_missing_linear_space-8"><a href="#list:first_positive_missing_linear_space-8" aria-hidden="true" tabindex="-1"></a>      s<span class="op">++;</span></span>
<span id="list:first_positive_missing_linear_space-9"><a href="#list:first_positive_missing_linear_space-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>s <span class="op">&lt;=</span> e <span class="op">&amp;&amp;</span> N<span class="op">[</span>e<span class="op">]</span> <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:first_positive_missing_linear_space-10"><a href="#list:first_positive_missing_linear_space-10" aria-hidden="true" tabindex="-1"></a>      e<span class="op">--;</span></span>
<span id="list:first_positive_missing_linear_space-11"><a href="#list:first_positive_missing_linear_space-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>s <span class="op">&gt;=</span> e<span class="op">)</span></span>
<span id="list:first_positive_missing_linear_space-12"><a href="#list:first_positive_missing_linear_space-12" aria-hidden="true" tabindex="-1"></a>      <span class="cf">break</span><span class="op">;</span></span>
<span id="list:first_positive_missing_linear_space-13"><a href="#list:first_positive_missing_linear_space-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:first_positive_missing_linear_space-14"><a href="#list:first_positive_missing_linear_space-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(</span>N<span class="op">[</span>s<span class="op">],</span> N<span class="op">[</span>e<span class="op">]);</span></span>
<span id="list:first_positive_missing_linear_space-15"><a href="#list:first_positive_missing_linear_space-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:first_positive_missing_linear_space-16"><a href="#list:first_positive_missing_linear_space-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> s<span class="op">;</span></span>
<span id="list:first_positive_missing_linear_space-17"><a href="#list:first_positive_missing_linear_space-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:first_positive_missing_linear_space-18"><a href="#list:first_positive_missing_linear_space-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:first_positive_missing_linear_space-19"><a href="#list:first_positive_missing_linear_space-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> first_positive_missing_constant_space<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> N<span class="op">)</span></span>
<span id="list:first_positive_missing_linear_space-20"><a href="#list:first_positive_missing_linear_space-20" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:first_positive_missing_linear_space-21"><a href="#list:first_positive_missing_linear_space-21" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> num_pos <span class="op">=</span> divide_pos_neg<span class="op">(</span>N<span class="op">);</span></span>
<span id="list:first_positive_missing_linear_space-22"><a href="#list:first_positive_missing_linear_space-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> num_pos<span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:first_positive_missing_linear_space-23"><a href="#list:first_positive_missing_linear_space-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:first_positive_missing_linear_space-24"><a href="#list:first_positive_missing_linear_space-24" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> ni <span class="op">=</span> abs<span class="op">(</span>N<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:first_positive_missing_linear_space-25"><a href="#list:first_positive_missing_linear_space-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>ni <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> ni <span class="op">-</span> <span class="dv">1</span> <span class="op">&lt;</span> num_pos<span class="op">)</span></span>
<span id="list:first_positive_missing_linear_space-26"><a href="#list:first_positive_missing_linear_space-26" aria-hidden="true" tabindex="-1"></a>      N<span class="op">[</span>ni <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">*=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:first_positive_missing_linear_space-27"><a href="#list:first_positive_missing_linear_space-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:first_positive_missing_linear_space-28"><a href="#list:first_positive_missing_linear_space-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:first_positive_missing_linear_space-29"><a href="#list:first_positive_missing_linear_space-29" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> num_pos<span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:first_positive_missing_linear_space-30"><a href="#list:first_positive_missing_linear_space-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>N<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:first_positive_missing_linear_space-31"><a href="#list:first_positive_missing_linear_space-31" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> i<span class="op">;</span></span>
<span id="list:first_positive_missing_linear_space-32"><a href="#list:first_positive_missing_linear_space-32" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> num_pos <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:first_positive_missing_linear_space-33"><a href="#list:first_positive_missing_linear_space-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The two phases of this solution are packaged into two functions:</p>
<ul>
<li><p>builds on it and uses the rearrangement to mark the presence of any element <span class="math inline">\(x\)</span> in the range <span class="math inline">\([1,y]\)</span> by changing the sign of the cell at index <span class="math inline">\(x-1\)</span>. When it is done with it, it processed in finding the answer by searching for the smallest index in <span class="math inline">\(i\)</span> containing a positive.</p></li>
<li><p>is responsible for rearranging the input array as discussed above</p></li>
</ul>
<p>The complexity of this approach is linear in time and constant in space which is optimal.</p>
<h1 id="ch:exponentiation">Exponentiation</h1>
<h2 class="unnumbered" id="introduction-10">Introduction</h2>
<p>This chapter addresses a common problem that asks you to implement a function to calculate the power of an integer. It is fairly easy to come up with a good solution that works in linear time and that, when implemented properly, can already be enough to get the green light from the interviewer and pass the interview stage. However, in order to be sure to ace the question, we need to push ourselves a bit further than this and develop a more sophisticated and efficient solution. In order to achieve this goal We will use an old and well-refined idea: the <em>exponentiation by squaring</em> which can be applied not only to integers but also to many other mathematical objects such as polynomials or matrices (for instance, it can be used to calculate the <span class="math inline">\(k^{th}\)</span> Fibonacci number in <span class="math inline">\(log_2(k)\)</span> steps), and that will be key to the solutions we present here.</p>
<h2 id="problem-statement-10">Problem statement</h2>
<div class="exercise">
<p>Implement a function that given two positive integers <span class="math inline">\(n\)</span> and <span class="math inline">\(k\)</span> calculates <span class="math inline">\(n^k\)</span>.</p>
<div class="example">
<p><br />
Given <span class="math inline">\(n=2\)</span> and <span class="math inline">\(k=3\)</span> the function returns <span class="math inline">\(8\)</span>.</p>
</div>
<div class="example">
<p><br />
Given <span class="math inline">\(n=5\)</span> and <span class="math inline">\(k=2\)</span> the function returns <span class="math inline">\(25\)</span>.</p>
</div>
</div>
<h2 id="clarification-questions-10">Clarification Questions</h2>
<div class="QandA">
<p>Should the function handle the case where <span class="math inline">\(k=0\)</span>?</p>
<div class="answered">
<p><em>Yes <span class="math inline">\(k=0\)</span> is a valid input.</em></p>
</div>
<p>Should the function handles integer overflow?</p>
<div class="answered">
<p><em>No overflow should not be accounted for.</em> <a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
</div>
</div>
<h2 id="exponentiation:sec:discussion">Discussion</h2>
<p>Exponentiation is such a basic operation that we all know how to calculate powers by means of performing a number of consecutive multiplications. This method stems directly from the definition of exponentiation which involves two numbers <span class="math inline">\(n\)</span> (the base) and <span class="math inline">\(k\)</span> (the exponent) and it is usually written as <span class="math inline">\(n^k\)</span> (pronounced as <em>"<span class="math inline">\(n\)</span> raised to the power of <span class="math inline">\(k\)</span>"</em> or <em>the <span class="math inline">\({k^{th}}\)</span> power of <span class="math inline">\(n\)</span>"</em>): <span class="math inline">\(n^k = \underbrace{n \times n \times n \times \ldots \times n}_{k \text{ times}}\)</span> which shows that we can multiply the base with itself <span class="math inline">\(k\)</span> times to obtain the result.</p>
<p>This simple algorithm embedded in the definition can be coded in just a few lines and a possible iterative implementation is shown in Listing <a href="#list:exponentiation_linear" data-reference-type="ref" data-reference="list:exponentiation_linear">[list:exponentiation_linear]</a>. The code works by calculating the answer, stored in the variable , by multiplying itself and , times like we would do with on a blackboard and exactly like stated in the definition of exponentiation above. Notice that:</p>
<ul>
<li><p>Listing <a href="#list:exponentiation_linear" data-reference-type="ref" data-reference="list:exponentiation_linear">[list:exponentiation_linear]</a> assumes <span class="math inline">\(k &gt;=0\)</span>,</p></li>
<li><p>when <span class="math inline">\(k=0\)</span> the while loop is not executed at all and the final result is <span class="math inline">\(1\)</span> (which is correct as any positive to the power of <span class="math inline">\(0\)</span> is <span class="math inline">\(1\)</span>.)</p></li>
<li><p>the time complexity is <span class="math inline">\(O(k)\)</span> as the while loop decreases the value of <span class="math inline">\(k\)</span> by <span class="math inline">\(1\)</span> at each iteration and,</p></li>
<li><p>the space complexity is constant.</p></li>
</ul>
<div class="sourceCode" id="list:exponentiation_linear" data-language="c++" data-caption="Iterative linear time solution." label="list:exponentiation_linear"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:exponentiation_linear-1"><a href="#list:exponentiation_linear-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> exponentiation_linear<span class="op">(</span><span class="at">const</span> <span class="dt">unsigned</span> n<span class="op">,</span> <span class="dt">unsigned</span> k<span class="op">)</span></span>
<span id="list:exponentiation_linear-2"><a href="#list:exponentiation_linear-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:exponentiation_linear-3"><a href="#list:exponentiation_linear-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">unsigned</span> ans <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:exponentiation_linear-4"><a href="#list:exponentiation_linear-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>k <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:exponentiation_linear-5"><a href="#list:exponentiation_linear-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:exponentiation_linear-6"><a href="#list:exponentiation_linear-6" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">*=</span> n<span class="op">;</span></span>
<span id="list:exponentiation_linear-7"><a href="#list:exponentiation_linear-7" aria-hidden="true" tabindex="-1"></a>    k<span class="op">--;</span></span>
<span id="list:exponentiation_linear-8"><a href="#list:exponentiation_linear-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:exponentiation_linear-9"><a href="#list:exponentiation_linear-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:exponentiation_linear-10"><a href="#list:exponentiation_linear-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>When discussing this solution, the interviewer might explicitly ask for a recursive solution. The definition of power by repetitive multiplication already provides all the ingredients to write one, and in particular it should be noticed that we can regroup the operations in the definition above so that: <span class="math inline">\(n^k = n \times \underbrace{(n \times n \times n \times \ldots \times n)}_{k-1 \text{ times}} = n \times n^{k-1}\)</span> which shows that the <span class="math inline">\({k^{th}}\)</span> power of <span class="math inline">\(n\)</span> is function of its <span class="math inline">\({(k-1)^{th}}\)</span> power. Listing <a href="#list:exponentiation_linear_recursive" data-reference-type="ref" data-reference="list:exponentiation_linear_recursive">[list:exponentiation_linear_recursive]</a> shows a recursive code implementing this idea which runs in <span class="math inline">\(O(k)\)</span> time and space as:</p>
<ul>
<li><p>the base case <span class="math inline">\(k=0\)</span> is reached only after <span class="math inline">\(k\)</span> steps as each recursive call decreases the value of <span class="math inline">\(k\)</span> by <span class="math inline">\(1\)</span> and each call costs constant time;</p></li>
<li><p>we need to use space for the activation record of each of the <span class="math inline">\(O(k)\)</span> recursive calls.</p></li>
</ul>
<div class="sourceCode" id="list:exponentiation_linear_recursive" data-language="c++" data-caption="Recursive linear solution." label="list:exponentiation_linear_recursive"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:exponentiation_linear_recursive-1"><a href="#list:exponentiation_linear_recursive-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> exponentiation_linear_recursive<span class="op">(</span><span class="at">const</span> <span class="dt">unsigned</span> n<span class="op">,</span> <span class="dt">unsigned</span> k<span class="op">)</span></span>
<span id="list:exponentiation_linear_recursive-2"><a href="#list:exponentiation_linear_recursive-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:exponentiation_linear_recursive-3"><a href="#list:exponentiation_linear_recursive-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span><span class="op">(</span>k<span class="op">==</span><span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:exponentiation_linear_recursive-4"><a href="#list:exponentiation_linear_recursive-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">//n * n^{k-1}</span></span>
<span id="list:exponentiation_linear_recursive-5"><a href="#list:exponentiation_linear_recursive-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> n<span class="op">*</span>exponentiation_linear_recursive<span class="op">(</span>n<span class="op">,</span>k<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="list:exponentiation_linear_recursive-6"><a href="#list:exponentiation_linear_recursive-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="exponentiation:sec:fast_exponentiation">Binary fast exponentiation</h3>
<p>The recursive solution showed above was built on top of the notion that the <span class="math inline">\({k^{th}}\)</span> power of <span class="math inline">\(n\)</span> is function of its <span class="math inline">\({k-1^{th}}\)</span> power. We have obtained this result by simply regrouping the definition of exponentiation given in the introduction of this chapter. However, this is not the only possible way of regrouping these multiplications as for instance we can calculate <span class="math inline">\(n^k\)</span> as <span class="math inline">\(n^{4} \times n^{k-4}\)</span>. This is possible thanks to two well known properties of powers:</p>
<ol>
<li><p>if <span class="math inline">\(x+y=k\)</span> then, <span class="math inline">\(n^k = n^x  n^y = n^{x+y}\)</span></p></li>
<li><p>if <span class="math inline">\(x \times y=k\)</span> then, <span class="math inline">\(n^k = (n^x)^y\)</span></p></li>
</ol>
<p>How can we use this fact to speed-up the exponentiation process? Think for instance what happens when <span class="math inline">\(k\)</span> is a power of <span class="math inline">\(2\)</span>.All it takes to calculate <span class="math inline">\(n^k\)</span> is knowning the value of <span class="math inline">\(n^{\frac{k}{2}}\)</span> and in turn all it takes to calculate <span class="math inline">\(n^{\frac{k}{2}}\)</span> is <span class="math inline">\(n^{\frac{\frac{k}{2}}{2}}\)</span> and …. You see where this reasoning is heading towards to. Eventually the exponent would be one, and at that point we know the answer right away. Because at every step the exponent is divided by <span class="math inline">\(2\)</span>, after <span class="math inline">\(log_2(k)\)</span> steps we have all the ingredients to calculate the answer as <span class="math inline">\(n^k : n^{\frac{k}{2}} \times n^{\frac{k}{2}} = (n^{\frac{k}{4}} \times n^{\frac{k}{4}}) \times (n^{\frac{k}{4}} \times n^{\frac{k}{4}}) = \big ( (n^{\frac{k}{8}} \times n^{\frac{k}{8}}) \times (n^{\frac{k}{8}} \times n^{\frac{k}{8}}) \big ) \times \big ( (n^{\frac{k}{8}} \times n^{\frac{k}{8}}) \times (n^{\frac{k}{8}} \times n^{\frac{k}{8}}) \big )  = \ldots\)</span></p>
<p>We have effectively reduced the time complexity down to <span class="math inline">\(log_2(k)\)</span> <strong>when <span class="math inline">\(k\)</span> is a power of two</strong>. But what about the general case? Notice that we can split <span class="math inline">\(k\)</span> in half every time <span class="math inline">\(k\)</span> is even (and that when <span class="math inline">\(k\)</span> is a power of <span class="math inline">\(2\)</span> all the intermediate division lead to an even number), and therefore we can start by applying the idea above only when <span class="math inline">\(k\)</span> is even and relying on the <span class="math inline">\(1\)</span>-<span class="math inline">\(k-1\)</span> split in all the other cases.</p>
<p>In other words the idea is to calculate the answer by multiplying two smaller powers: <span class="math inline">\(n^p\)</span> and <span class="math inline">\(n^q\)</span> with <span class="math inline">\(p,q &lt; k\)</span>. The value of <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> depends on the parity of <span class="math inline">\(k\)</span> (whether <span class="math inline">\(k\)</span> is even or odd) and more in particular we want: <span class="math display">\[n^k = \begin{cases}
                p=q \Longrightarrow n^{\frac{k}{2}} \times n^{\frac{k}{2}}, &amp; \text{if  k even}\\
                p=1, q=k-1 \Longrightarrow n \times n^{k-1}, &amp; \text{if k odd}\\
            \end{cases}\]</span> This allows for the number of multiplication to be reduced by half all the times that <span class="math inline">\(k\)</span> is even but also crucially when <span class="math inline">\(k\)</span> is odd as <span class="math inline">\(n^{k-1}\)</span> can be calculated by reducing the number of multiplications by half because <span class="math inline">\(k-1\)</span> is even.</p>
<p>Clearly, this approach is inherently recursive and can be coded as such easily as shown in Listing <a href="#list:exponentiation_fast" data-reference-type="ref" data-reference="list:exponentiation_fast">[list:exponentiation_fast]</a>.</p>
<div class="sourceCode" id="list:exponentiation_fast" data-language="c++" data-caption="Recursive $O(log_2$ solution to the exponentiation problem." label="list:exponentiation_fast"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:exponentiation_fast-1"><a href="#list:exponentiation_fast-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> exponentiation_fast<span class="op">(</span><span class="dt">unsigned</span> n<span class="op">,</span> <span class="dt">unsigned</span> k<span class="op">)</span></span>
<span id="list:exponentiation_fast-2"><a href="#list:exponentiation_fast-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:exponentiation_fast-3"><a href="#list:exponentiation_fast-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>k <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:exponentiation_fast-4"><a href="#list:exponentiation_fast-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:exponentiation_fast-5"><a href="#list:exponentiation_fast-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>k <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:exponentiation_fast-6"><a href="#list:exponentiation_fast-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:exponentiation_fast-7"><a href="#list:exponentiation_fast-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> ans <span class="op">=</span> exponentiation_fast<span class="op">(</span>n<span class="op">,</span> k <span class="op">/</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="list:exponentiation_fast-8"><a href="#list:exponentiation_fast-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans <span class="op">*</span> ans<span class="op">;</span></span>
<span id="list:exponentiation_fast-9"><a href="#list:exponentiation_fast-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:exponentiation_fast-10"><a href="#list:exponentiation_fast-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> n <span class="op">*</span> exponentiation_fast<span class="op">(</span>n<span class="op">,</span> k <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="list:exponentiation_fast-11"><a href="#list:exponentiation_fast-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The code works similarly to how Listing <a href="#list:exponentiation_linear_recursive" data-reference-type="ref" data-reference="list:exponentiation_linear_recursive">[list:exponentiation_linear_recursive]</a> works except for the special treatment <span class="math inline">\(k\)</span> receives when it is even. This solution has a time complexity of <span class="math inline">\(log_2(k)\)</span>. The intuitive idea is that in the worst-case scenario, every two invocations of the function we split the value of <span class="math inline">\(k\)</span> in half anyways.</p>
<h3 id="iterative-implementation">Iterative implementation</h3>
<p>Another way to tackle this problem is by looking at the binary representation of the exponent <span class="math inline">\(k =
b_0 \times 2^0 + b_1 \times 2^1 + \ldots + b_l \times 2^l\)</span> where <span class="math inline">\(b_i\)</span> is a binary digit. When plugging <span class="math inline">\(k\)</span> into the formula for the calculation of <span class="math inline">\(n^k\)</span> the following is obtained (and by applying the properties of powers shown above): <span class="math display">\[\begin{array}{lcl}
        n^k &amp; = &amp;  n^{b_0 \times 2^0 + b_1 \times 2^1 + \ldots + b_l \times 2^l} \\
        &amp; = &amp; n^{b_0 \times 2^0} \times n^{b_1 \times 2^1} \times \ldots \times n^{b_l \times 2^l} \\
        &amp; = &amp; (n^{2^0})^{b_0} \times  (n^{2^1})^{b_1} \times \ldots \times (n^{2^l})^{b_l} \\
        &amp; = &amp; (n^{2^0})^{b_0} \times  (n^{2^1})^{b_1} \times \ldots \times (n^{2^l})^{b_l} 
    \end{array}\]</span></p>
<p>It is clear that the term <span class="math inline">\(i^{th}\)</span> in the final multiplication chain contributes to the final result only when the corresponding value of <span class="math inline">\(b_i\)</span> is set to <span class="math inline">\(1\)</span>, because if it is <span class="math inline">\(0\)</span> then the term contribution is <span class="math inline">\(1\)</span> (which is the neutral element for multiplication). Additionally as <span class="math inline">\(i\)</span> increases, <span class="math inline">\(n\)</span> get squared at each step as <span class="math inline">\(i\)</span> is in the formula an exponent for <span class="math inline">\(2\)</span>.</p>
<p>The idea above can be used to implement a fast exponentiation iterative solution by looking only at the bits of <span class="math inline">\(k\)</span> and using the formula above to calculates the answers accordingly. Listing <a href="#list:exponentiation_fast_iterative" data-reference-type="ref" data-reference="list:exponentiation_fast_iterative">[list:exponentiation_fast_iterative]</a> and <a href="#list:exponentiation_fast_iterative_alternative" data-reference-type="ref" data-reference="list:exponentiation_fast_iterative_alternative">[list:exponentiation_fast_iterative_alternative]</a> shows two possible ways of doing this.</p>
<div class="sourceCode" id="list:exponentiation_fast_iterative" data-language="c++" data-caption="Logaritmic solution based on the analysis of the bits of the exponent." label="list:exponentiation_fast_iterative"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:exponentiation_fast_iterative-1"><a href="#list:exponentiation_fast_iterative-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> exponentiation_fast_iterative_simple<span class="op">(</span><span class="dt">unsigned</span> n<span class="op">,</span> <span class="dt">unsigned</span> k<span class="op">)</span></span>
<span id="list:exponentiation_fast_iterative-2"><a href="#list:exponentiation_fast_iterative-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:exponentiation_fast_iterative-3"><a href="#list:exponentiation_fast_iterative-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>k <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:exponentiation_fast_iterative-4"><a href="#list:exponentiation_fast_iterative-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:exponentiation_fast_iterative-5"><a href="#list:exponentiation_fast_iterative-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:exponentiation_fast_iterative-6"><a href="#list:exponentiation_fast_iterative-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:exponentiation_fast_iterative-7"><a href="#list:exponentiation_fast_iterative-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>digits<span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:exponentiation_fast_iterative-8"><a href="#list:exponentiation_fast_iterative-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:exponentiation_fast_iterative-9"><a href="#list:exponentiation_fast_iterative-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">bool</span> bit <span class="op">=</span> <span class="op">(</span>k <span class="op">&gt;&gt;</span> i<span class="op">)</span> <span class="op">&amp;</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:exponentiation_fast_iterative-10"><a href="#list:exponentiation_fast_iterative-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>bit<span class="op">)</span></span>
<span id="list:exponentiation_fast_iterative-11"><a href="#list:exponentiation_fast_iterative-11" aria-hidden="true" tabindex="-1"></a>      ans <span class="op">*=</span> n<span class="op">;</span></span>
<span id="list:exponentiation_fast_iterative-12"><a href="#list:exponentiation_fast_iterative-12" aria-hidden="true" tabindex="-1"></a>    n <span class="op">*=</span> n<span class="op">;</span></span>
<span id="list:exponentiation_fast_iterative-13"><a href="#list:exponentiation_fast_iterative-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:exponentiation_fast_iterative-14"><a href="#list:exponentiation_fast_iterative-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:exponentiation_fast_iterative-15"><a href="#list:exponentiation_fast_iterative-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The code works by keeping track of two quantities:</p>
<ol>
<li><p>: a variable holding the partial calculations of the answers along the multiplication chain and,</p></li>
<li><p>which stores the value of <span class="math inline">\(n\)</span> raised to <span class="math inline">\(2\)</span> to the power of the current iteration index <span class="math inline">\(i\)</span>. The value of <span class="math inline">\(n\)</span> is squared at each iteration.</p></li>
</ol>
<p>The loop is used to inspect the <span class="math inline">\(i^{th}\)</span> bit of <span class="math inline">\(k\)</span> and when it is set, is multiplied by the current value hold by .</p>
<p>The complexity of this approach is <span class="math inline">\(O(log_2(k))\)</span> because the algorithm does not perform more iteration than the number of bits of the exponent <span class="math inline">\(k\)</span>. Thus at most <span class="math inline">\(\floor{log(k)}\)</span> squaring and multiplication are performed. If native types like are used then the complexity is constant as these types have a finite precision and therefore a fixed number of bits (the same reasoning holds for all the solutions discussed in all the sections above).</p>
<p>Listing <a href="#list:exponentiation_fast_iterative_alternative" data-reference-type="ref" data-reference="list:exponentiation_fast_iterative_alternative">[list:exponentiation_fast_iterative_alternative]</a> shows an alternative implementation which is slightly more sophisticated and efficient as it stops as soon as it notices there is no bit set in <span class="math inline">\(k\)</span> anymore, while Listing <a href="#list:exponentiation_fast_iterative" data-reference-type="ref" data-reference="list:exponentiation_fast_iterative">[list:exponentiation_fast_iterative]</a> iterates blindly over all the bits of <span class="math inline">\(k\)</span>. In practice, this might not be a real or even measurable advantage.</p>
<div class="sourceCode" id="list:exponentiation_fast_iterative_alternative" data-language="c++" data-caption="Alternative implementation of Listing \ref{list:exponentiation_fast_iterative}." label="list:exponentiation_fast_iterative_alternative"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:exponentiation_fast_iterative_alternative-1"><a href="#list:exponentiation_fast_iterative_alternative-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> exponentiation_fast_iterative<span class="op">(</span><span class="dt">unsigned</span> n<span class="op">,</span> <span class="dt">unsigned</span> k<span class="op">)</span></span>
<span id="list:exponentiation_fast_iterative_alternative-2"><a href="#list:exponentiation_fast_iterative_alternative-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:exponentiation_fast_iterative_alternative-3"><a href="#list:exponentiation_fast_iterative_alternative-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>k <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:exponentiation_fast_iterative_alternative-4"><a href="#list:exponentiation_fast_iterative_alternative-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:exponentiation_fast_iterative_alternative-5"><a href="#list:exponentiation_fast_iterative_alternative-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:exponentiation_fast_iterative_alternative-6"><a href="#list:exponentiation_fast_iterative_alternative-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:exponentiation_fast_iterative_alternative-7"><a href="#list:exponentiation_fast_iterative_alternative-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>k <span class="op">&gt;</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="list:exponentiation_fast_iterative_alternative-8"><a href="#list:exponentiation_fast_iterative_alternative-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:exponentiation_fast_iterative_alternative-9"><a href="#list:exponentiation_fast_iterative_alternative-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>k <span class="op">&amp;</span> <span class="dv">1</span><span class="op">)</span>  <span class="co">// bit set</span></span>
<span id="list:exponentiation_fast_iterative_alternative-10"><a href="#list:exponentiation_fast_iterative_alternative-10" aria-hidden="true" tabindex="-1"></a>      ans <span class="op">*=</span> n<span class="op">;</span></span>
<span id="list:exponentiation_fast_iterative_alternative-11"><a href="#list:exponentiation_fast_iterative_alternative-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:exponentiation_fast_iterative_alternative-12"><a href="#list:exponentiation_fast_iterative_alternative-12" aria-hidden="true" tabindex="-1"></a>    k <span class="op">&gt;&gt;=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:exponentiation_fast_iterative_alternative-13"><a href="#list:exponentiation_fast_iterative_alternative-13" aria-hidden="true" tabindex="-1"></a>    n <span class="op">*=</span> n<span class="op">;</span></span>
<span id="list:exponentiation_fast_iterative_alternative-14"><a href="#list:exponentiation_fast_iterative_alternative-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:exponentiation_fast_iterative_alternative-15"><a href="#list:exponentiation_fast_iterative_alternative-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> n <span class="op">*</span> ans<span class="op">;</span></span>
<span id="list:exponentiation_fast_iterative_alternative-16"><a href="#list:exponentiation_fast_iterative_alternative-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Finally, it should be noted that, because one of the constraints of the problem is that overflow is guaranteed to never occur, then we are assured that <span class="math inline">\(k\)</span> is a relatively small number and we can safely assume it is smaller than <span class="math inline">\(64\)</span> otherwise we would need data types with a capacity of more than <span class="math inline">\(64\)</span> bits to store the answer. Under this constraint the logarithmic time solution might also not provide a measurable speed-up or it might even be slower due to the fact that the linear time solution features a simple loop with basic operations that can be well optimized by the compiler optimizer.</p>
<p>In the introduction, we also mentioned that exponentiation not only applies to numbers but that can be basically applied to a larger class of objects like matrices for instance. The codes we have developed during the discussion of this problem can be easily extended so that work on any type providing the , and the operators by using s.</p>
<h1 id="ch:max_sum_continguous_subarray">Max sum contiguous subarray</h1>
<h2 class="unnumbered" id="introduction-11">Introduction</h2>
<p>This chapter describes a very popular problem that is asked frequently during interviews but also has many real life applications including, but not limited to: genomic sequence analysis (to identify protein sequences), computer vision (to identify the brightest or darkest part of an image).</p>
<h2 id="problem-statement-11">Problem statement</h2>
<div class="exercise">
<p>Find the largest sum of a contiguous subarray (containing at least one element) within an array, <span class="math inline">\(A\)</span> of length <span class="math inline">\(n\)</span>, and return it. Formally, the task is to find two indices <span class="math inline">\(0 \leq i \leq j &lt; n\)</span> s.t. the following sum is as large as possible: <span class="math display">\[\sum_{x=i}^j   = A[x] = A[i] + A[i+1] + \ldots + A[j]\]</span></p>
</div>
<div class="example">
<p><br />
Given <span class="math inline">\(A=\{-2, -5, \underbrace{6, -2, -3, 1, 5}\text{}, -6\}\)</span> then the answer is <span class="math inline">\(7\)</span> which can be obtained by summing all elements from index <span class="math inline">\(2\)</span> to <span class="math inline">\(6\)</span> i.e. <span class="math inline">\(\sum_{2}^7 A[i] = 7\)</span></p>
</div>
<div class="example">
<p><br />
Given <span class="math inline">\(A=\{-2, 1, -3, \underbrace{4, -1, 2, 1}\text{}, -5, 4\}\)</span> then the answer is <span class="math inline">\(6\)</span> which can be obtained by summing all elements from index <span class="math inline">\(3\)</span> to <span class="math inline">\(6\)</span> i.e. <span class="math inline">\(\sum_{3}^6 A[i] = 6\)</span></p>
</div>
<h2 id="clarification-questions-11">Clarification Questions</h2>
<div class="QandA">
<p>Are the elements all positive or negative?</p>
<div class="answered">
<p><em>No, the input numbers can be either positive, or negative</em></p>
</div>
<p>Is the array sorted?</p>
<div class="answered">
<p><em>No, the array is not sorted.</em></p>
</div>
</div>
<h2 id="max_sum_continguous_subarray:sec:discussion">Discussion</h2>
<p>First of all let’s start by notiving that</p>
<ul>
<li><p>If the array only contains non-negative numbers then the problem is trivial because the answer is the sum of the whole array.</p></li>
<li><p>if, on the contrary, the array contains only non-positive numbers, then the answer is the sum of a one element subarray which coincides with the largest number.</p></li>
<li><p>The answer is unique, but more than one subarray might have sum up to that value.</p></li>
</ul>
<h3 id="sec:max_sum_continguous_subarray_bruteforce">Brute-force</h3>
<p>One way to tackle this problem is to look at the sum of all possible subarray and return the largest sum. The idea is that for all elements <span class="math inline">\(A[i]\)</span>, the sum of all subarrays having it as starting element can be easily calculated as shown in Listing <a href="#list:max_sum_continguous_subarray_bruteforce" data-reference-type="ref" data-reference="list:max_sum_continguous_subarray_bruteforce">[list:max_sum_continguous_subarray_bruteforce]</a>. This approach works but it is unnecessarly slow, havig a time complexity of <span class="math inline">\(O(n^3)\)</span>. There are <span class="math inline">\(O(n^2)\)</span> ordered pairs each identifying a subarray, and calculating the sum of a single subarray costs <span class="math inline">\(O(O(n)\)</span> for a grand total of <span class="math inline">\(O(n^3)\)</span>.</p>
<div class="sourceCode" id="list:max_sum_continguous_subarray_bruteforce" data-language="c++" data-caption="Sample Caption" label="list:max_sum_continguous_subarray_bruteforce"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:max_sum_continguous_subarray_bruteforce-1"><a href="#list:max_sum_continguous_subarray_bruteforce-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> max_sum_contiguous_subarray_bruteforce<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>A<span class="op">)</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce-2"><a href="#list:max_sum_continguous_subarray_bruteforce-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce-3"><a href="#list:max_sum_continguous_subarray_bruteforce-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>min<span class="op">();</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce-4"><a href="#list:max_sum_continguous_subarray_bruteforce-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> i <span class="op">=</span> begin<span class="op">(</span>A<span class="op">);</span> i <span class="op">!=</span> end<span class="op">(</span>A<span class="op">);</span> i<span class="op">++)</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce-5"><a href="#list:max_sum_continguous_subarray_bruteforce-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce-6"><a href="#list:max_sum_continguous_subarray_bruteforce-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> j <span class="op">=</span> i<span class="op">;</span> j <span class="op">!=</span> end<span class="op">(</span>A<span class="op">);</span> j<span class="op">++)</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce-7"><a href="#list:max_sum_continguous_subarray_bruteforce-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce-8"><a href="#list:max_sum_continguous_subarray_bruteforce-8" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="dt">int</span> subarray_sum <span class="op">=</span> <span class="bu">std::</span>accumulate<span class="op">(</span>i<span class="op">,</span> j <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce-9"><a href="#list:max_sum_continguous_subarray_bruteforce-9" aria-hidden="true" tabindex="-1"></a>      ans                    <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>ans<span class="op">,</span> subarray_sum<span class="op">);</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce-10"><a href="#list:max_sum_continguous_subarray_bruteforce-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce-11"><a href="#list:max_sum_continguous_subarray_bruteforce-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce-12"><a href="#list:max_sum_continguous_subarray_bruteforce-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce-13"><a href="#list:max_sum_continguous_subarray_bruteforce-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This is considered a very poor solution because it is quite far off from the optimal linear time complexity solution that exists for this problem.</p>
<h3 id="max_sum_continguous_subarray:sec:bruteforce_improved">Brute-force improved</h3>
<p>The bruteforce solution proposed in Section <a href="#max_sum_continguous_subarray:sec:bruteforce" data-reference-type="ref" data-reference="max_sum_continguous_subarray:sec:bruteforce">[max_sum_continguous_subarray:sec:bruteforce]</a> can be improved by using avoiding calculating the sum of a subarray over and over again. Given two indices <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> the correnspoding subarray sum can be calculated in constant time <span class="math inline">\(O(1)\)</span> by calculating the prefix sum (See Section <a href="#sect:appendix:prefix_sum" data-reference-type="ref" data-reference="sect:appendix:prefix_sum">[sect:appendix:prefix_sum]</a>) of the input array before hand. This allows for constant time computation of the sum of any subarray. Given the prefix sum <span class="math inline">\(Y\)</span> for the array <span class="math inline">\(A\)</span> then subarray sum between indices <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> is: <span class="math inline">\(Y[j]-Y[i-1]\)</span> where <span class="math inline">\(Y[-1] = 0\)</span>.</p>
<p>The code in Listing <a href="#list:max_sum_continguous_subarray_bruteforce_improved" data-reference-type="ref" data-reference="list:max_sum_continguous_subarray_bruteforce_improved">[list:max_sum_continguous_subarray_bruteforce_improved]</a> shows a <span class="math inline">\(O(n^2)\)</span> implementation of the bruteforce method described in Section <a href="#sec:max_sum_continguous_subarray_bruteforce" data-reference-type="ref" data-reference="sec:max_sum_continguous_subarray_bruteforce">12.3.1</a> using prefix sum for constant time computation of subarrays sum.</p>
<div class="sourceCode" id="list:max_sum_continguous_subarray_bruteforce_improved" data-language="c++" data-caption="Sample Caption" label="list:max_sum_continguous_subarray_bruteforce_improved"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:max_sum_continguous_subarray_bruteforce_improved-1"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> prefix_sum<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>A<span class="op">)</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-2"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-3"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>A<span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-4"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-5"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-5" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> Y<span class="op">(</span>A<span class="op">.</span>size<span class="op">());</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-6"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-6" aria-hidden="true" tabindex="-1"></a>  Y<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> A<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-7"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> A<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-8"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-8" aria-hidden="true" tabindex="-1"></a>    Y<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> Y<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> A<span class="op">[</span>i<span class="op">];</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-9"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-10"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> Y<span class="op">;</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-11"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-12"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-13"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> max_sum_contiguous_subarray_bruteforce_prefix_sum<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>A<span class="op">)</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-14"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-14" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-15"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-15" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> Y <span class="op">=</span> prefix_sum<span class="op">(</span>A<span class="op">);</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-16"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-17"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>min<span class="op">();</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-18"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> A<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-19"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-20"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> j <span class="op">=</span> i<span class="op">;</span> j <span class="op">&lt;</span> A<span class="op">.</span>size<span class="op">();</span> j<span class="op">++)</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-21"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-22"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-22" aria-hidden="true" tabindex="-1"></a>      <span class="dt">int</span> subarray_sum <span class="op">=</span> Y<span class="op">[</span>j<span class="op">];</span>  <span class="co">// 0 to j</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-23"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-23" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-24"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-24" aria-hidden="true" tabindex="-1"></a>        subarray_sum <span class="op">-=</span> Y<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span>  <span class="co">// 0 to i</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-25"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-26"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-26" aria-hidden="true" tabindex="-1"></a>      ans <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>ans<span class="op">,</span> subarray_sum<span class="op">);</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-27"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-28"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-28" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-29"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-29" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:max_sum_continguous_subarray_bruteforce_improved-30"><a href="#list:max_sum_continguous_subarray_bruteforce_improved-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Despite the dramatic improvement in time complexity the version shown in Listing <a href="#list:max_sum_continguous_subarray_bruteforce_improved" data-reference-type="ref" data-reference="list:max_sum_continguous_subarray_bruteforce_improved">[list:max_sum_continguous_subarray_bruteforce_improved]</a> is, compared to the raw bruteforce solution, it is still considered a rather poor solution. Factoring in the fact that the prefix sum approach uses additional space and the popularity of this interview question, during a real interview a linear time and constant space solution is expected to be presented.</p>
<h3 id="sec:kadane_algorithm">Kadane’s Algorithm</h3>
<p>Kadane’s agorithm is used to solve this problem efficiently by using a dynamic programming approach. In its simplest form uses an additional array <span class="math inline">\(B\)</span> storing at each position <span class="math inline">\(j\)</span> the largest sum for a subarray ending (and including) <span class="math inline">\(A[j]\)</span>. In other words <span class="math inline">\(B[j]\)</span> stores the information regarding the largest sum obtainable by summing up a contiguous chunk of <span class="math inline">\(A\)</span> ending and including <span class="math inline">\(A[j]\)</span>. Once <span class="math inline">\(B\)</span> is filled, the solution to the problem is simply the maximum element of <span class="math inline">\(B\)</span>. The idea above is shown in Listing <a href="#list:max_sum_continguous_subarray_kadane_additional_space" data-reference-type="ref" data-reference="list:max_sum_continguous_subarray_kadane_additional_space">[list:max_sum_continguous_subarray_kadane_additional_space]</a>. Note how <span class="math inline">\(B[i]\)</span> is incrementally constructed by reusing the information about index <span class="math inline">\(i-1\)</span>. The line <code>std::max(A[i] , B[i-1]+A[i]);</code> really means that the maximum subarray sum ending at (and including) <span class="math inline">\(A[i]\)</span> is either from:</p>
<ol>
<li><p>the subarray starting and ending at index <span class="math inline">\(i\)</span> i.e. only containing <span class="math inline">\(A[i]\)</span>, or</p></li>
<li><p>extending the best subarray ending at index <span class="math inline">\(i-1\)</span> by adding <span class="math inline">\(A[i]\)</span> to it. The sum of the best subarray ending t <span class="math inline">\(i-1\)</span> is already computed and stored in <span class="math inline">\(B[i-1]\)</span>. By doing so we are effectively avoiding a lot of re-computation, and this is the reason why Kadane’s algorithm is so fast.</p></li>
</ol>
<div class="sourceCode" id="list:max_sum_continguous_subarray_kadane_additional_space" data-language="c++" data-caption="Sample Caption" label="list:max_sum_continguous_subarray_kadane_additional_space"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:max_sum_continguous_subarray_kadane_additional_space-1"><a href="#list:max_sum_continguous_subarray_kadane_additional_space-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> max_sum_contiguous_subarray_kadane_space<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>A<span class="op">)</span></span>
<span id="list:max_sum_continguous_subarray_kadane_additional_space-2"><a href="#list:max_sum_continguous_subarray_kadane_additional_space-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:max_sum_continguous_subarray_kadane_additional_space-3"><a href="#list:max_sum_continguous_subarray_kadane_additional_space-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> B<span class="op">(</span>A<span class="op">.</span>size<span class="op">(),</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>min<span class="op">());</span></span>
<span id="list:max_sum_continguous_subarray_kadane_additional_space-4"><a href="#list:max_sum_continguous_subarray_kadane_additional_space-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_sum_continguous_subarray_kadane_additional_space-5"><a href="#list:max_sum_continguous_subarray_kadane_additional_space-5" aria-hidden="true" tabindex="-1"></a>  B<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> A<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="list:max_sum_continguous_subarray_kadane_additional_space-6"><a href="#list:max_sum_continguous_subarray_kadane_additional_space-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> A<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span></span>
<span id="list:max_sum_continguous_subarray_kadane_additional_space-7"><a href="#list:max_sum_continguous_subarray_kadane_additional_space-7" aria-hidden="true" tabindex="-1"></a>    B<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>A<span class="op">[</span>i<span class="op">],</span> B<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> A<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:max_sum_continguous_subarray_kadane_additional_space-8"><a href="#list:max_sum_continguous_subarray_kadane_additional_space-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_sum_continguous_subarray_kadane_additional_space-9"><a href="#list:max_sum_continguous_subarray_kadane_additional_space-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">*</span>max_element<span class="op">(</span>begin<span class="op">(</span>B<span class="op">),</span> end<span class="op">(</span>B<span class="op">));</span></span>
<span id="list:max_sum_continguous_subarray_kadane_additional_space-10"><a href="#list:max_sum_continguous_subarray_kadane_additional_space-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>But, is the additional space used by <span class="math inline">\(B\)</span> really necessary? A closer look at the implementation in Listing <a href="#list:max_sum_continguous_subarray_kadane_additional_space" data-reference-type="ref" data-reference="list:max_sum_continguous_subarray_kadane_additional_space">[list:max_sum_continguous_subarray_kadane_additional_space]</a> provides the answer which is, no. Infact every value of <span class="math inline">\(B\)</span> is only used once, and then ignored for the rest of the execution. Thus the algorithm can be modified so it only uses a single variable to store the latest calculated value of <span class="math inline">\(B\)</span> i.e. the value for the index <span class="math inline">\(i-1\)</span> as shown in Listing <a href="#list:max_sum_continguous_subarray_kadane" data-reference-type="ref" data-reference="list:max_sum_continguous_subarray_kadane">[list:max_sum_continguous_subarray_kadane]</a></p>
<div class="sourceCode" id="list:max_sum_continguous_subarray_kadane" data-language="c++" data-caption="Sample Caption" label="list:max_sum_continguous_subarray_kadane"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:max_sum_continguous_subarray_kadane-1"><a href="#list:max_sum_continguous_subarray_kadane-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> max_sum_contiguous_subarray_kadane<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>A<span class="op">)</span></span>
<span id="list:max_sum_continguous_subarray_kadane-2"><a href="#list:max_sum_continguous_subarray_kadane-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:max_sum_continguous_subarray_kadane-3"><a href="#list:max_sum_continguous_subarray_kadane-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>A<span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="list:max_sum_continguous_subarray_kadane-4"><a href="#list:max_sum_continguous_subarray_kadane-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_sum_continguous_subarray_kadane-5"><a href="#list:max_sum_continguous_subarray_kadane-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans             <span class="op">=</span> A<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="list:max_sum_continguous_subarray_kadane-6"><a href="#list:max_sum_continguous_subarray_kadane-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> max_ending_here <span class="op">=</span> A<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="list:max_sum_continguous_subarray_kadane-7"><a href="#list:max_sum_continguous_subarray_kadane-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> A<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span></span>
<span id="list:max_sum_continguous_subarray_kadane-8"><a href="#list:max_sum_continguous_subarray_kadane-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:max_sum_continguous_subarray_kadane-9"><a href="#list:max_sum_continguous_subarray_kadane-9" aria-hidden="true" tabindex="-1"></a>    max_ending_here <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>A<span class="op">[</span>i<span class="op">],</span> max_ending_here <span class="op">+</span> A<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:max_sum_continguous_subarray_kadane-10"><a href="#list:max_sum_continguous_subarray_kadane-10" aria-hidden="true" tabindex="-1"></a>    ans             <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>ans<span class="op">,</span> max_ending_here<span class="op">);</span></span>
<span id="list:max_sum_continguous_subarray_kadane-11"><a href="#list:max_sum_continguous_subarray_kadane-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:max_sum_continguous_subarray_kadane-12"><a href="#list:max_sum_continguous_subarray_kadane-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:max_sum_continguous_subarray_kadane-13"><a href="#list:max_sum_continguous_subarray_kadane-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note how the variable <code>max_ending_here</code> is doing the job that the variable <code>B[i-1]</code> was doing in Listing <a href="#list:max_sum_continguous_subarray_kadane_additional_space" data-reference-type="ref" data-reference="list:max_sum_continguous_subarray_kadane_additional_space">[list:max_sum_continguous_subarray_kadane_additional_space]</a> and also how the final answer is the maximum among all values taken by <code>max_ending_here</code>.</p>
<p>The complexity of this approach is <span class="math inline">\(O(n)\)</span> in time and constant in space, and very likely is the sort of complexity the interviewer expects.</p>
<h2 id="common-variations-1">Common Variations</h2>
<h3 id="minium-sum-contiguous-subarray">Minium sum contiguous subarray</h3>
<p>A very common variation of this problem is to find the smallest sum instead of the largest. This variation is very quickly solved by just changing the the way the variables <code>min_ending_here</code> (the variable is names min insteda of max so to reflect the nature of the problem) and <code>ans</code> are updated. Since the minimum is to be returned then they should be updated using <code>min_ending_here = std::min(A[i] , max_ending_here+A[i]);</code> and <code>std::min(ans, in_ending_here);</code>, respectively.</p>
<h3 id="longest-positivenegative-contiguous-subarray">Longest positive/negative contiguous subarray</h3>
<p>Another common variation of the max/min sum contiguous subarray is to find the longest subarray only made of positive or negative numbers. The same core idea used for the other variant can be used here as well. At each iteration <span class="math inline">\(i\)</span> the variable <code>longest_ending_here</code> represents the longest positive subarray up to that iteration and including the element <span class="math inline">\(A[i]\)</span> and can be updated as follows: <code>longest_ending_here = A[i] &gt;= 0 ? longest_ending_here+1 : 0;</code>.</p>
<h1 id="ch:string_reverse">String Reverse</h1>
<h2 class="unnumbered" id="introduction-12">Introduction</h2>
<p>Reversing a string is an obiquitous operation and because of that is it very often asked during programming interview. There are basically two variation of this problem:</p>
<ol>
<li><p>in-place.</p></li>
<li><p>out-of-place.</p></li>
</ol>
<p>and the first thing it should be clarified is which type is the interviewer asking. Moreover considering the popularity of this problem it is important not to make mistakes and solve the problem in a relatively short time frame. The interviewer most likely is expecting you to have seen this question or solved this challenge yourself more than once in the past.</p>
<h2 id="problem-statement-12">Problem statement</h2>
<p>The problmen statement is very simple and fits in a single line:</p>
<div class="exercise">
<p>Write a method that takes a string <span class="math inline">\(s\)</span> of length <span class="math inline">\(n\)</span> and reverses it.</p>
</div>
<div class="example">
<p><br />
Given <span class="math inline">\(s=&quot;abcde&quot;\)</span> the function produces <span class="math inline">\(s=&quot;edcba&quot;\)</span>.</p>
</div>
<div class="example">
<p><br />
Given <span class="math inline">\(s=&quot;programming&quot;\)</span> the function produces <span class="math inline">\(s=&quot;gnimmargorp&quot;\)</span>.</p>
</div>
<h2 id="clarification-questions-12">Clarification Questions</h2>
<div class="QandA">
<p>Should the function reverses the string in place?</p>
<div class="answered">
<p><em>Yes, a copy of the input cannot be created.</em></p>
</div>
<p>Is the empty string a valid input?</p>
<div class="answered">
<p><em>Yes, the input string might be empty.</em></p>
</div>
</div>
<h2 id="string_reverse:sec:discussion">Discussion</h2>
<p>The problem asks to reverse a string in place. But what does it exactly mean to do it <em>in-place</em>? It means that no auxiliary storage is allowed and that the input itself will be processed by the function and will be eventually transformed into the output. Since the original content of the input is lost once the function is terminaed, in-place algorithms are also called <em>destructive</em>. Note that no additional storage does not literally mean that not even a single variable can be created. In this case it should be interpreted more as that a copy of the input is disallowed, or that the function should work in <span class="math inline">\(O(1)\)</span> (constant) space.</p>
<p>Let’s take a deeper look at what happens to the single letters of the string once they are reversed. For instance consider the string <span class="math inline">\(s=&quot;a_0 a_1 a_2 a_3 a_4 a_5&quot;\)</span> which is transformed into <span class="math inline">\(s&#39;=&quot;a_5 a_4 a_3 a_2 a_1 a_0&quot;\)</span>. The subscript <span class="math inline">\(i\)</span> in <span class="math inline">\(a_i\)</span> identifies the position in which the letter <span class="math inline">\(a_i\)</span> appears in the original input. The core of the problem is to figure our how are letters shuffled from the original to the reversed string. In order to do so one can analyze how the indices are moved during the reverse process. It can clearly be seen from the example above that the indices modifies as follows: <span class="math display">\[\begin{array}{l}
    0 \rightarrow 5  \\ 
    5 \rightarrow 0  \\ 
    1 \rightarrow 4  \\ 
    4 \rightarrow 1  \\ 
    3 \rightarrow 2  \\ 
    2 \rightarrow 3  \\ 
  \end{array}\]</span> The example contains all the information that are necessary to deduce the function that maps the indices of the original string into the indices of the reversed string. An index <span class="math inline">\(i\)</span> gets mappes to an index <span class="math inline">\(j\)</span> s.t. <span class="math inline">\(i+j = n\)</span> (index <span class="math inline">\(0\)</span> goes to <span class="math inline">\(5\)</span>). A quick manipulation of that equation shows that <span class="math inline">\(j\)</span> (the index of where the letter at index <span class="math inline">\(i\)</span> in the original string will be in the reversed on) is equal to <span class="math inline">\(j = n-i\)</span>. This equation effectively says that each letter at index <span class="math inline">\(i\)</span> in the original input is moved to the <span class="math inline">\(j\)</span>’s location. Also notice from the example above that letter at index <span class="math inline">\(j\)</span> is itself mapped to index <span class="math inline">\(i\)</span> meaning that letters are positions <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are effectively swapped.</p>
<p>So to summarize, each character in the input string need to be swapped with its symmetrical sibling (See Listing <a href="#list:string_reverse_1" data-reference-type="ref" data-reference="list:string_reverse_1">[list:string_reverse_1]</a>).</p>
<div class="sourceCode" id="list:string_reverse_1" data-language="c++" data-caption="Iterative solution to the in-place string reverse question." label="list:string_reverse_1"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:string_reverse_1-1"><a href="#list:string_reverse_1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> reverse_string_inplace<span class="op">(</span><span class="bu">std::</span>string<span class="op"> &amp;</span>s<span class="op">)</span></span>
<span id="list:string_reverse_1-2"><a href="#list:string_reverse_1-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:string_reverse_1-3"><a href="#list:string_reverse_1-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> len <span class="op">=</span> s<span class="op">.</span>length<span class="op">();</span></span>
<span id="list:string_reverse_1-4"><a href="#list:string_reverse_1-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> len <span class="op">/</span> <span class="dv">2</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:string_reverse_1-5"><a href="#list:string_reverse_1-5" aria-hidden="true" tabindex="-1"></a>    swap<span class="op">(</span>s<span class="op">[</span>i<span class="op">],</span> s<span class="op">[</span>len <span class="op">-</span> <span class="dv">1</span> <span class="op">-</span> i<span class="op">]);</span></span>
<span id="list:string_reverse_1-6"><a href="#list:string_reverse_1-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note how the loop terminates at only half the size of the input string. This is necessary because a swap operations on the index <span class="math inline">\(i&lt;\frac{n}{2}\)</span> involves also an element of the second half of the string (its simmetrycal sibling). If the loop would not terminate at <span class="math inline">\(\frac{n}{2}\)</span> then for each element <span class="math inline">\(i\)</span> two swap operations would be performed. For instacce for the letter at index <span class="math inline">\(0\)</span> the following swaps would occur:</p>
<ul>
<li><p>swap(0,n-1)</p></li>
<li><p>swap(n-1,0)</p></li>
</ul>
<p>. Considering that two<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> swap operations on the same indices result in having the original status of the letters (on those indeces) restored, if the loop does not stop at <span class="math inline">\(\frac{n}{2}\)</span> then the function would not modify the original string at all.</p>
<p>This is considered a good solution because the time and space complexity of Listing <a href="#list:string_reverse_1" data-reference-type="ref" data-reference="list:string_reverse_1">[list:string_reverse_1]</a> are <span class="math inline">\(O(n)\)</span> and <span class="math inline">\(O(1)\)</span> respectively, which are optimal. Moreover the solution is short and expressive.</p>
<h2 id="string_reverse:sec:variations">Common Variation</h2>
<h3 id="out-of-place-solution">Out-of-place solution</h3>
<p>Sometimes the interviewe might ask an easier version of this problem which asks to return a reversed copy of the original string. This version is easier compared to the in-place version because one can simply construct the reversed string by looping the original string backwards as shown in Listing <a href="#list:string_reverse_outplace_rawloop" data-reference-type="ref" data-reference="list:string_reverse_outplace_rawloop">[list:string_reverse_outplace_rawloop]</a> and Listing <a href="#list:string_reverse_outplace_iterators" data-reference-type="ref" data-reference="list:string_reverse_outplace_iterators">[list:string_reverse_outplace_iterators]</a>.</p>
<div class="sourceCode" id="list:string_reverse_outplace_rawloop" data-language="c++" data-caption="Iterative out-of-place solution using raw loops. Both time and space complexity for this version is $O(n)$." label="list:string_reverse_outplace_rawloop"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:string_reverse_outplace_rawloop-1"><a href="#list:string_reverse_outplace_rawloop-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:string_reverse_outplace_rawloop-2"><a href="#list:string_reverse_outplace_rawloop-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string<span class="op"> </span>reverse_string_outplace_raw_loop<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> &amp;</span>s<span class="op">)</span></span>
<span id="list:string_reverse_outplace_rawloop-3"><a href="#list:string_reverse_outplace_rawloop-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:string_reverse_outplace_rawloop-4"><a href="#list:string_reverse_outplace_rawloop-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>string<span class="op"> </span>ans<span class="op">;</span></span>
<span id="list:string_reverse_outplace_rawloop-5"><a href="#list:string_reverse_outplace_rawloop-5" aria-hidden="true" tabindex="-1"></a>  ans<span class="op">.</span>reserve<span class="op">(</span>s<span class="op">.</span>size<span class="op">());</span></span>
<span id="list:string_reverse_outplace_rawloop-6"><a href="#list:string_reverse_outplace_rawloop-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:string_reverse_outplace_rawloop-7"><a href="#list:string_reverse_outplace_rawloop-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> s<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span></span>
<span id="list:string_reverse_outplace_rawloop-8"><a href="#list:string_reverse_outplace_rawloop-8" aria-hidden="true" tabindex="-1"></a>    ans<span class="op">.</span>push_back<span class="op">(</span>s<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:string_reverse_outplace_rawloop-9"><a href="#list:string_reverse_outplace_rawloop-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:string_reverse_outplace_rawloop-10"><a href="#list:string_reverse_outplace_rawloop-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:string_reverse_outplace_rawloop-11"><a href="#list:string_reverse_outplace_rawloop-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="list:string_reverse_outplace_iterators" data-language="c++" data-caption="Alternative implementation of an iterative out-of-place solution using iterators. Both time and space complexity for this version is $O(n)$." label="list:string_reverse_outplace_iterators"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:string_reverse_outplace_iterators-1"><a href="#list:string_reverse_outplace_iterators-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string<span class="op"> </span>reverse_string_outplace_iterator<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> &amp;</span>s<span class="op">)</span></span>
<span id="list:string_reverse_outplace_iterators-2"><a href="#list:string_reverse_outplace_iterators-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:string_reverse_outplace_iterators-3"><a href="#list:string_reverse_outplace_iterators-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>string<span class="op"> </span>ans<span class="op">;</span></span>
<span id="list:string_reverse_outplace_iterators-4"><a href="#list:string_reverse_outplace_iterators-4" aria-hidden="true" tabindex="-1"></a>  ans<span class="op">.</span>reserve<span class="op">(</span>s<span class="op">.</span>size<span class="op">());</span></span>
<span id="list:string_reverse_outplace_iterators-5"><a href="#list:string_reverse_outplace_iterators-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:string_reverse_outplace_iterators-6"><a href="#list:string_reverse_outplace_iterators-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> it_s <span class="op">=</span> <span class="bu">std::</span>prev<span class="op">(</span>end<span class="op">(</span>s<span class="op">));</span></span>
<span id="list:string_reverse_outplace_iterators-7"><a href="#list:string_reverse_outplace_iterators-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>it_s <span class="op">&gt;=</span> s<span class="op">.</span>begin<span class="op">())</span></span>
<span id="list:string_reverse_outplace_iterators-8"><a href="#list:string_reverse_outplace_iterators-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:string_reverse_outplace_iterators-9"><a href="#list:string_reverse_outplace_iterators-9" aria-hidden="true" tabindex="-1"></a>    ans<span class="op">.</span>push_back<span class="op">(*</span>it_s<span class="op">);</span></span>
<span id="list:string_reverse_outplace_iterators-10"><a href="#list:string_reverse_outplace_iterators-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">--</span>it_s<span class="op">;</span></span>
<span id="list:string_reverse_outplace_iterators-11"><a href="#list:string_reverse_outplace_iterators-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:string_reverse_outplace_iterators-12"><a href="#list:string_reverse_outplace_iterators-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:string_reverse_outplace_iterators-13"><a href="#list:string_reverse_outplace_iterators-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:string_reverse_outplace_iterators-14"><a href="#list:string_reverse_outplace_iterators-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="recursive-solution">Recursive solution</h3>
<p>Another commonly asked variation of the string reverse problem is the one in which recursion has to be used. The problem is well suited for recursion infact, a look at the iterative solution shows that at any given point in the loop the status of the string is the following: <span class="math inline">\(a_{n-1}a_{n-2} \ldots \underbrace{a_k a_{k+1} \ldots a_l}_\text{untouched} a_{k-1}a_{k-2} \ldots a_0\)</span>. There is always a portion of the string delimited by two indices <span class="math inline">\(k\)</span> and <span class="math inline">\(l\)</span>, <span class="math inline">\(k&gt;=l\)</span> which is yet to be processed (i.e. with the original content). This can be easily used to derive a recursive solution. At first the <span class="math inline">\(k=0\)</span> and <span class="math inline">\(l=n-1\)</span> and the string can be reversed by swapping <span class="math inline">\(a_k=0\)</span> and <span class="math inline">\(a_l=n-1\)</span> and by recursively reversing the inner part of the string i.e. in the range <span class="math inline">\(k=1\)</span> and <span class="math inline">\(l=n-2\)</span>. This can be continuosly be done until <span class="math inline">\(l &gt; k\)</span>. At that point the function can simply terminate (See Equation <a href="#eq:string_reversal_recursion" data-reference-type="ref" data-reference="eq:string_reversal_recursion">[eq:string_reversal_recursion]</a> and Listing <a href="#list:string_reversal_recursion" data-reference-type="ref" data-reference="list:string_reversal_recursion">[list:string_reversal_recursion]</a>).</p>
<p><span class="math display">\[R(s, k, l)=\begin{cases} 
\text{swap}(s[k]s[l]) \: \wedge \: R(s,k+1, l-1) &amp; \text{if } k\geq l\\
\text{return} &amp; \text{otherwise}
\end{cases}
\label{eq:string_reversal_recursion}\]</span></p>
<p>The complexity analysis for this case can be a bit controversial because one have to consider also the stack space utilized by the recursion which can be <span class="math inline">\(O(n)\)</span>. It is therefore important to clarify this aspect with the interviewer. Discussing this might open the possibility for questions related to this, especially regarding Tail Call Optimization(TCO)<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>, so one needs to be careful while opening this pandora box.</p>
<div class="sourceCode" id="list:string_reversal_recursion" data-language="c++" data-caption="Recursive in-place solution to the string reversal problem." label="list:string_reversal_recursion"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:string_reversal_recursion-1"><a href="#list:string_reversal_recursion-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> reverse_string_inplace_recursive_helper<span class="op">(</span><span class="bu">std::</span>string<span class="op"> &amp;</span>s<span class="op">,</span></span>
<span id="list:string_reversal_recursion-2"><a href="#list:string_reversal_recursion-2" aria-hidden="true" tabindex="-1"></a>                                             <span class="at">const</span> <span class="dt">int</span> k<span class="op">,</span></span>
<span id="list:string_reversal_recursion-3"><a href="#list:string_reversal_recursion-3" aria-hidden="true" tabindex="-1"></a>                                             <span class="at">const</span> <span class="dt">int</span> l<span class="op">)</span></span>
<span id="list:string_reversal_recursion-4"><a href="#list:string_reversal_recursion-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:string_reversal_recursion-5"><a href="#list:string_reversal_recursion-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>k <span class="op">&gt;=</span> l<span class="op">)</span></span>
<span id="list:string_reversal_recursion-6"><a href="#list:string_reversal_recursion-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="list:string_reversal_recursion-7"><a href="#list:string_reversal_recursion-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:string_reversal_recursion-8"><a href="#list:string_reversal_recursion-8" aria-hidden="true" tabindex="-1"></a>  swap<span class="op">(</span>s<span class="op">[</span>k<span class="op">],</span> s<span class="op">[</span>l<span class="op">]);</span></span>
<span id="list:string_reversal_recursion-9"><a href="#list:string_reversal_recursion-9" aria-hidden="true" tabindex="-1"></a>  reverse_string_inplace_recursive_helper<span class="op">(</span>s<span class="op">,</span> k <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> l <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="list:string_reversal_recursion-10"><a href="#list:string_reversal_recursion-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:string_reversal_recursion-11"><a href="#list:string_reversal_recursion-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:string_reversal_recursion-12"><a href="#list:string_reversal_recursion-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> reverse_string_inplace_recursive<span class="op">(</span><span class="bu">std::</span>string<span class="op"> &amp;</span>s<span class="op">)</span></span>
<span id="list:string_reversal_recursion-13"><a href="#list:string_reversal_recursion-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:string_reversal_recursion-14"><a href="#list:string_reversal_recursion-14" aria-hidden="true" tabindex="-1"></a>  reverse_string_inplace_recursive_helper<span class="op">(</span>s<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> s<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="list:string_reversal_recursion-15"><a href="#list:string_reversal_recursion-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="ch:find_odd_occurring_element">Find the odd occurring element</h1>
<h2 class="unnumbered" id="introduction-13">Introduction</h2>
<p>This chapter describes a problem on array and the XOR<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> (also called disjuntive-or, <span class="math inline">\(\oplus\)</span>) operation that has a very easy yet inefficient brute-force solution and a faster one that is conceptually very different from the brute-force approach. For this reason it can be challenging to start from the brute-force and then iteratively improve the solution so that it reaches the optimal time and space complexity. It is therefore better to approach this problem by reading the problem statement a carefully and to reason about the property of XOR.</p>
<h2 id="problem-statement-13">Problem statement</h2>
<div class="exercise">
<p>Write a function that given an array <span class="math inline">\(A\)</span> of positive integers where all elements except one appear an even number of times, returns the (only) element appearing an odd numbers of time.</p>
</div>
<div class="example">
<p><br />
Given the array <span class="math inline">\(A=\{4,3,6,2,4,2,3,4,3,3,6\}\)</span> the function returns <span class="math inline">\(4\)</span> because it appears <span class="math inline">\(3\)</span> times while all the other elements appear an even number of times.</p>
</div>
<h2 id="clarification-questions-13">Clarification Questions</h2>
<div class="QandA">
<p>Is the input array always valid. Does it always contain only one element appearing an odd number of times?</p>
<div class="answered">
<p><em>Yes the input array can be assumed to be valid.</em></p>
</div>
<p>Is the range of the input integers known?<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a></p>
<div class="answered">
<p><em>No it is not. All integers that are representable can be present in the input array.</em></p>
</div>
</div>
<h2 id="discussion-5">Discussion</h2>
<h3 id="find_odd_occurring_element:sec:bruteforce">Brute-force</h3>
<p>The brute-force solution to this problem is quite easy: provided that a function ‘count‘ is available which counts the occurrences of an element in the array, it is only matter of using that function for all the elements in the array and return as soon as it return an odd number. Listing <a href="#list:find_odd_occurring_element_bruteforce_rawloop" data-reference-type="ref" data-reference="list:find_odd_occurring_element_bruteforce_rawloop">[list:find_odd_occurring_element_bruteforce_rawloop]</a> shows a possible implementation in C++ using the standard library function <code>count</code> for counting the number of occurrences of a given number in the array.</p>
<div class="sourceCode" id="list:find_odd_occurring_element_bruteforce_rawloop" data-language="c++" data-caption="Brute force solution to the problem of finding the odd occurring element in an array." label="list:find_odd_occurring_element_bruteforce_rawloop"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:find_odd_occurring_element_bruteforce_rawloop-1"><a href="#list:find_odd_occurring_element_bruteforce_rawloop-1" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">bool</span> is_odd<span class="op">(</span><span class="at">const</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="list:find_odd_occurring_element_bruteforce_rawloop-2"><a href="#list:find_odd_occurring_element_bruteforce_rawloop-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:find_odd_occurring_element_bruteforce_rawloop-3"><a href="#list:find_odd_occurring_element_bruteforce_rawloop-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> x <span class="op">&amp;</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:find_odd_occurring_element_bruteforce_rawloop-4"><a href="#list:find_odd_occurring_element_bruteforce_rawloop-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:find_odd_occurring_element_bruteforce_rawloop-5"><a href="#list:find_odd_occurring_element_bruteforce_rawloop-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> odd_appearing_element_bruteforce_rawloop<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> A<span class="op">)</span></span>
<span id="list:find_odd_occurring_element_bruteforce_rawloop-6"><a href="#list:find_odd_occurring_element_bruteforce_rawloop-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:find_odd_occurring_element_bruteforce_rawloop-7"><a href="#list:find_odd_occurring_element_bruteforce_rawloop-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> x <span class="op">:</span> A<span class="op">)</span></span>
<span id="list:find_odd_occurring_element_bruteforce_rawloop-8"><a href="#list:find_odd_occurring_element_bruteforce_rawloop-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:find_odd_occurring_element_bruteforce_rawloop-9"><a href="#list:find_odd_occurring_element_bruteforce_rawloop-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">size_t</span> number_appeareance <span class="op">=</span> <span class="bu">std::</span>count<span class="op">(</span>begin<span class="op">(</span>A<span class="op">),</span> end<span class="op">(</span>A<span class="op">),</span> x<span class="op">);</span></span>
<span id="list:find_odd_occurring_element_bruteforce_rawloop-10"><a href="#list:find_odd_occurring_element_bruteforce_rawloop-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>is_odd<span class="op">(</span>number_appeareance<span class="op">))</span></span>
<span id="list:find_odd_occurring_element_bruteforce_rawloop-11"><a href="#list:find_odd_occurring_element_bruteforce_rawloop-11" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> x<span class="op">;</span></span>
<span id="list:find_odd_occurring_element_bruteforce_rawloop-12"><a href="#list:find_odd_occurring_element_bruteforce_rawloop-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:find_odd_occurring_element_bruteforce_rawloop-13"><a href="#list:find_odd_occurring_element_bruteforce_rawloop-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument<span class="op">(</span></span>
<span id="list:find_odd_occurring_element_bruteforce_rawloop-14"><a href="#list:find_odd_occurring_element_bruteforce_rawloop-14" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;Invalid input array. No elements appear an odd number of times&quot;</span><span class="op">);</span></span>
<span id="list:find_odd_occurring_element_bruteforce_rawloop-15"><a href="#list:find_odd_occurring_element_bruteforce_rawloop-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>What the code above is really trying to do is to <strong>find</strong> the element appearing an odd number of times. Instead of using a raw loop for doing so, the code can be made much more expressive (which is always appreciated and positively evaluated by the interviewer) by using the standard <code>find_if</code> (or equivalents in other languages) function as shown in the Listing <a href="#list:find_odd_occurring_element_bruteforce_standard" data-reference-type="ref" data-reference="list:find_odd_occurring_element_bruteforce_standard">[list:find_odd_occurring_element_bruteforce_standard]</a></p>
<div class="sourceCode" id="list:find_odd_occurring_element_bruteforce_standard" data-language="c++" data-caption="Brute force solution to the problem of finding the odd occurring element in an array using only standard libraries functions." label="list:find_odd_occurring_element_bruteforce_standard"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:find_odd_occurring_element_bruteforce_standard-1"><a href="#list:find_odd_occurring_element_bruteforce_standard-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> odd_appearing_element_bruteforce_standard<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>A<span class="op">)</span></span>
<span id="list:find_odd_occurring_element_bruteforce_standard-2"><a href="#list:find_odd_occurring_element_bruteforce_standard-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:find_odd_occurring_element_bruteforce_standard-3"><a href="#list:find_odd_occurring_element_bruteforce_standard-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">*</span><span class="bu">std::</span>find_if<span class="op">(</span>begin<span class="op">(</span>A<span class="op">),</span> end<span class="op">(</span>A<span class="op">),</span> <span class="op">[&amp;](</span><span class="at">const</span> <span class="kw">auto</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="list:find_odd_occurring_element_bruteforce_standard-4"><a href="#list:find_odd_occurring_element_bruteforce_standard-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> is_odd<span class="op">(</span><span class="bu">std::</span>count<span class="op">(</span>begin<span class="op">(</span>A<span class="op">),</span> end<span class="op">(</span>A<span class="op">),</span> x<span class="op">));</span></span>
<span id="list:find_odd_occurring_element_bruteforce_standard-5"><a href="#list:find_odd_occurring_element_bruteforce_standard-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">});</span></span>
<span id="list:find_odd_occurring_element_bruteforce_standard-6"><a href="#list:find_odd_occurring_element_bruteforce_standard-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This is however considered a poor solution because the time complexity is <span class="math inline">\(O(n^2)\)</span> which is much higher than the optimal, while space complexity is constant. Please also note that the code in Listing <a href="#list:find_odd_occurring_element_bruteforce_rawloop" data-reference-type="ref" data-reference="list:find_odd_occurring_element_bruteforce_rawloop">[list:find_odd_occurring_element_bruteforce_rawloop]</a> also handles the case when the input is invalid. Even if the interviewer says is it not necessary to take care of this scenario, it is good to show that the code can handle it without big penalty. By adding a throw statement, both expressiveness and performances are preserved<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a> , and this add a bonus point to the solution.</p>
<h3 id="find_odd_occurring_element:sec:map">Linear time and space solution</h3>
<p>In order to speed up the process of keeping count of how many times each element appear in the input array a map-like structure can be adopted, where the keys are the input numbers and the values are integers representing the number of times each element appear in the array. If an hash-map is used then this effectively reduces the time complexity down to O(n) (on average) but the space complexity increases to linear as well. However keeping track of the actual number of times an element appears is also unnecessary, mainly because all it is needed is the information whether or not the number of times it appears is even or odd. A single bit is sufficient to store this information, and thus, a bool can be used as a value type for the hash-map. The in Listing <a href="#list:find_odd_occurring_element_bruteforce_linearspace" data-reference-type="ref" data-reference="list:find_odd_occurring_element_bruteforce_linearspace">[list:find_odd_occurring_element_bruteforce_linearspace]</a> shows a possible implementation of the idea above.</p>
<div class="sourceCode" id="list:find_odd_occurring_element_bruteforce_linearspace" data-language="c++" data-caption="Linear time and space solution to the problem of finding the odd occurring element in an array." label="list:find_odd_occurring_element_bruteforce_linearspace"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:find_odd_occurring_element_bruteforce_linearspace-1"><a href="#list:find_odd_occurring_element_bruteforce_linearspace-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> odd_appearing_element_linear_space<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> A<span class="op">)</span></span>
<span id="list:find_odd_occurring_element_bruteforce_linearspace-2"><a href="#list:find_odd_occurring_element_bruteforce_linearspace-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:find_odd_occurring_element_bruteforce_linearspace-3"><a href="#list:find_odd_occurring_element_bruteforce_linearspace-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// true = even</span></span>
<span id="list:find_odd_occurring_element_bruteforce_linearspace-4"><a href="#list:find_odd_occurring_element_bruteforce_linearspace-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// false = odd</span></span>
<span id="list:find_odd_occurring_element_bruteforce_linearspace-5"><a href="#list:find_odd_occurring_element_bruteforce_linearspace-5" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>unordered_map<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">bool</span><span class="op">&gt;</span> M<span class="op">;</span></span>
<span id="list:find_odd_occurring_element_bruteforce_linearspace-6"><a href="#list:find_odd_occurring_element_bruteforce_linearspace-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> x <span class="op">:</span> A<span class="op">)</span></span>
<span id="list:find_odd_occurring_element_bruteforce_linearspace-7"><a href="#list:find_odd_occurring_element_bruteforce_linearspace-7" aria-hidden="true" tabindex="-1"></a>    M<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> <span class="op">!</span>M<span class="op">[</span>x<span class="op">];</span></span>
<span id="list:find_odd_occurring_element_bruteforce_linearspace-8"><a href="#list:find_odd_occurring_element_bruteforce_linearspace-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:find_odd_occurring_element_bruteforce_linearspace-9"><a href="#list:find_odd_occurring_element_bruteforce_linearspace-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> kv <span class="op">:</span> M<span class="op">)</span></span>
<span id="list:find_odd_occurring_element_bruteforce_linearspace-10"><a href="#list:find_odd_occurring_element_bruteforce_linearspace-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>kv<span class="op">.</span>second<span class="op">)</span>  <span class="co">// kv is a pair&lt;key, value&gt;</span></span>
<span id="list:find_odd_occurring_element_bruteforce_linearspace-11"><a href="#list:find_odd_occurring_element_bruteforce_linearspace-11" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> kv<span class="op">.</span>first<span class="op">;</span></span>
<span id="list:find_odd_occurring_element_bruteforce_linearspace-12"><a href="#list:find_odd_occurring_element_bruteforce_linearspace-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:find_odd_occurring_element_bruteforce_linearspace-13"><a href="#list:find_odd_occurring_element_bruteforce_linearspace-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument<span class="op">(</span></span>
<span id="list:find_odd_occurring_element_bruteforce_linearspace-14"><a href="#list:find_odd_occurring_element_bruteforce_linearspace-14" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;Invalid input array. No elements appear an odd number of times&quot;</span><span class="op">);</span></span>
<span id="list:find_odd_occurring_element_bruteforce_linearspace-15"><a href="#list:find_odd_occurring_element_bruteforce_linearspace-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This solution is considered fairly good and has a time and complexity of <span class="math inline">\(O(n)\)</span>.</p>
<h3 id="find_odd_occurring_element:sec:constant_space">Linear time and constant space solution</h3>
<p>There is however a way to solve this problem in constant space and linear time. This solution makes itself appearent once one analyses the property of the <span class="math inline">\(\oplus\)</span> fuunction. The function can be thought as the equivalent of the sum for bits and has two interesting properties that can be used to derive a solution for this problem:</p>
<ul>
<li><p>The neutral element for the <span class="math inline">\(\oplus\)</span> is the number <span class="math inline">\(0\)</span>. It means that xor-ing a number <span class="math inline">\(x\)</span> with <span class="math inline">\(0\)</span> always results in <span class="math inline">\(x\)</span> i.e. <span class="math inline">\(x \oplus 0 = x\)</span></p></li>
<li><p>xor-ing an element with itself always results in 0 i.e. <span class="math inline">\(x \oplus x = 0\)</span></p></li>
</ul>
<p>This means that when xor-ing an element <span class="math inline">\(x\)</span> with itself an odd number of times the result is <span class="math inline">\(x\)</span>: <span class="math inline">\((x \oplus x) \oplus x  = (0 \oplus x) = x)\)</span> but, xor-ing an even number of times results in <span class="math inline">\(0\)</span>: <span class="math inline">\((x \oplus x) \oplus (x \oplus x) = 0 \oplus 0  = 0\)</span></p>
<p>Why is this useful? It is very useful because it is known that the all input integers are occurring an even number of times except of one. If all numbers are xor-ed together then all it is left at the end is the number appearing an odd number of times. W.r.t. to the example above <span class="math inline">\(A=\{4,3,6,2,4,2,3,4,3,3,6\}\)</span> we obtain: <span class="math inline">\(4 \oplus 3 \oplus  6 \oplus 2 \oplus 4 \oplus 2 \oplus 3 \oplus 4 \oplus 3 \oplus 3 \oplus 6 = 4\)</span>. the <span class="math inline">\(\oplus\)</span> operation is commutative, distributive and associative, and thus, the operation above can be rearranged as follows (sorting the input array): <span class="math inline">\(\underbrace{(2 \oplus 2)}_{0} \oplus \underbrace{(3 \oplus 3 \oplus 3 \oplus 3)}_{0} \oplus \underbrace{(4 \oplus 4 \oplus 4)}_{4} \oplus \underbrace{(6 \oplus 6)}_{0} = 4\)</span>.</p>
<p>An implementation of the idea above can be found in Listings <a href="#list:find_odd_occurring_element_bruteforce_final1" data-reference-type="ref" data-reference="list:find_odd_occurring_element_bruteforce_final1">[list:find_odd_occurring_element_bruteforce_final1]</a> and <a href="#list:find_odd_occurring_element_bruteforce_final2" data-reference-type="ref" data-reference="list:find_odd_occurring_element_bruteforce_final2">[list:find_odd_occurring_element_bruteforce_final2]</a> (implemented using C++ standard library functions).</p>
<div class="sourceCode" id="list:find_odd_occurring_element_bruteforce_final1" data-language="c++" data-caption="Linear time and constnat space solution to the problem of finding the odd occurring element in an array using XOR $\oplus$." label="list:find_odd_occurring_element_bruteforce_final1"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:find_odd_occurring_element_bruteforce_final1-1"><a href="#list:find_odd_occurring_element_bruteforce_final1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> odd_appearing_element_final<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>A<span class="op">)</span></span>
<span id="list:find_odd_occurring_element_bruteforce_final1-2"><a href="#list:find_odd_occurring_element_bruteforce_final1-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:find_odd_occurring_element_bruteforce_final1-3"><a href="#list:find_odd_occurring_element_bruteforce_final1-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:find_odd_occurring_element_bruteforce_final1-4"><a href="#list:find_odd_occurring_element_bruteforce_final1-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="dt">int</span> x <span class="op">:</span> A<span class="op">)</span></span>
<span id="list:find_odd_occurring_element_bruteforce_final1-5"><a href="#list:find_odd_occurring_element_bruteforce_final1-5" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">^=</span> x<span class="op">;</span></span>
<span id="list:find_odd_occurring_element_bruteforce_final1-6"><a href="#list:find_odd_occurring_element_bruteforce_final1-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:find_odd_occurring_element_bruteforce_final1-7"><a href="#list:find_odd_occurring_element_bruteforce_final1-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="list:find_odd_occurring_element_bruteforce_final2" data-language="c++" data-caption="Linear time and constnat space solution to the problem of finding the odd occurring element in an array using XOR $\oplus$ and C++ standard library accumulate function." label="list:find_odd_occurring_element_bruteforce_final2"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:find_odd_occurring_element_bruteforce_final2-1"><a href="#list:find_odd_occurring_element_bruteforce_final2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> odd_appearing_element_final_std<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>A<span class="op">)</span></span>
<span id="list:find_odd_occurring_element_bruteforce_final2-2"><a href="#list:find_odd_occurring_element_bruteforce_final2-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:find_odd_occurring_element_bruteforce_final2-3"><a href="#list:find_odd_occurring_element_bruteforce_final2-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">std::</span>accumulate<span class="op">(</span></span>
<span id="list:find_odd_occurring_element_bruteforce_final2-4"><a href="#list:find_odd_occurring_element_bruteforce_final2-4" aria-hidden="true" tabindex="-1"></a>      begin<span class="op">(</span>A<span class="op">),</span> end<span class="op">(</span>A<span class="op">),</span> <span class="dv">0</span><span class="op">,</span> <span class="op">[](</span><span class="at">const</span> <span class="dt">int</span> acc<span class="op">,</span> <span class="at">const</span> <span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> acc <span class="op">^</span> x<span class="op">;</span> <span class="op">});</span></span>
<span id="list:find_odd_occurring_element_bruteforce_final2-5"><a href="#list:find_odd_occurring_element_bruteforce_final2-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="ch:capitalize_words_first_letter">Capitalize the first letters of every words</h1>
<h2 class="unnumbered" id="introduction-14">Introduction</h2>
<p>This chapter describes a common problem on strings often asked during the preliminary whiteboard sessions, mostly because it is easy to understand and explain and can be implemented quickly. It is a good warm-up problem. The idea is that we are given a long text and we need to capitalize every first letter of the words in it leaving the rest of the text intact.</p>
<h2 id="problem-statement-14">Problem statement</h2>
<div class="exercise">
<p>Given a string s, modify s such that every first letter of every word in s is capital. The rest of the string should not be touched.</p>
</div>
<div class="example">
<p><br />
Given the string:</p>
<pre><code>	&quot;Truth May Seem BUt Cannot be;
	Beauty brag but ’tis not she;
	TruTh and beauty buried be.&quot;
	</code></pre>
<p>The function should turn it into:</p>
<pre><code>	&quot;Truth May Seem BUt Cannot Be;
	Beauty Brag But ’tis Not She;
	TruTh And Beauty Buried Be.&quot;
	</code></pre>
</div>
<h2 id="capitalize_words_first_letter:sec:discussion">Discussion</h2>
<p>This problem does not require to come up with a smart algorithm in order to do what it should. The idea behind this problem is more that you should be able to put an implementation on the table in a reasonable amount of time which is correct from the first draft. The interviewer wants to know that you are comfortable deriving a non-trivial algorithm on the spot and that you can write correct code under pressure. One way to solve this problem in a blink of an eye is to notice some properties of this problem:</p>
<ol>
<li><p>all spaces need to be ignored</p></li>
<li><p>the first non space character needs to be modified</p></li>
<li><p>all the rest of non-space characters can be ignored</p></li>
</ol>
<p>This three rules can be easily converted into code as shown in Listing <a href="#list:capitalize_words_first_letter_iterator" data-reference-type="ref" data-reference="list:capitalize_words_first_letter_iterator">[list:capitalize_words_first_letter_iterator]</a>. The code is clearly divided into three distint blocks each doing one of the item listed above i.e. processing the text from left to right and, in this order, ignoring all the spaces, until a letter is found, that is capitalized, and finally all the rest of the word is also ignored. The process repeats until the text is fully processed.</p>
<div class="sourceCode" id="list:capitalize_words_first_letter_iterator" data-language="c++" data-caption="Solution to the problem of turning all first letter of every word in a text into capital case. Works by ignoring all the spaces until a letter is found (marking the beginning of a word) and turning it into capital case and then ignoring the rest of the letters of that word. The process repeats until all the text is processed." label="list:capitalize_words_first_letter_iterator"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:capitalize_words_first_letter_iterator-1"><a href="#list:capitalize_words_first_letter_iterator-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> capitalize_words_first_letter_iterator<span class="op">(</span><span class="bu">std::</span>string<span class="op"> &amp;</span>s<span class="op">)</span></span>
<span id="list:capitalize_words_first_letter_iterator-2"><a href="#list:capitalize_words_first_letter_iterator-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:capitalize_words_first_letter_iterator-3"><a href="#list:capitalize_words_first_letter_iterator-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> it <span class="op">=</span> begin<span class="op">(</span>s<span class="op">);</span></span>
<span id="list:capitalize_words_first_letter_iterator-4"><a href="#list:capitalize_words_first_letter_iterator-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>it <span class="op">!=</span> end<span class="op">(</span>s<span class="op">))</span></span>
<span id="list:capitalize_words_first_letter_iterator-5"><a href="#list:capitalize_words_first_letter_iterator-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:capitalize_words_first_letter_iterator-6"><a href="#list:capitalize_words_first_letter_iterator-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//(1) skip all spaces</span></span>
<span id="list:capitalize_words_first_letter_iterator-7"><a href="#list:capitalize_words_first_letter_iterator-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>it <span class="op">!=</span> end<span class="op">(</span>s<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">*</span>it <span class="op">==</span> <span class="ch">&#39; &#39;</span><span class="op">)</span></span>
<span id="list:capitalize_words_first_letter_iterator-8"><a href="#list:capitalize_words_first_letter_iterator-8" aria-hidden="true" tabindex="-1"></a>      it<span class="op">++;</span></span>
<span id="list:capitalize_words_first_letter_iterator-9"><a href="#list:capitalize_words_first_letter_iterator-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">//(2) to_upper</span></span>
<span id="list:capitalize_words_first_letter_iterator-10"><a href="#list:capitalize_words_first_letter_iterator-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>it <span class="op">!=</span> end<span class="op">(</span>s<span class="op">))</span></span>
<span id="list:capitalize_words_first_letter_iterator-11"><a href="#list:capitalize_words_first_letter_iterator-11" aria-hidden="true" tabindex="-1"></a>      <span class="op">*</span>it <span class="op">=</span> toupper<span class="op">(*</span>it<span class="op">);</span></span>
<span id="list:capitalize_words_first_letter_iterator-12"><a href="#list:capitalize_words_first_letter_iterator-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:capitalize_words_first_letter_iterator-13"><a href="#list:capitalize_words_first_letter_iterator-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">//(3) skip the rest of the word</span></span>
<span id="list:capitalize_words_first_letter_iterator-14"><a href="#list:capitalize_words_first_letter_iterator-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>it <span class="op">!=</span> end<span class="op">(</span>s<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">*</span>it <span class="op">!=</span> <span class="ch">&#39; &#39;</span><span class="op">)</span></span>
<span id="list:capitalize_words_first_letter_iterator-15"><a href="#list:capitalize_words_first_letter_iterator-15" aria-hidden="true" tabindex="-1"></a>      it<span class="op">++;</span></span>
<span id="list:capitalize_words_first_letter_iterator-16"><a href="#list:capitalize_words_first_letter_iterator-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:capitalize_words_first_letter_iterator-17"><a href="#list:capitalize_words_first_letter_iterator-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note that the check <code>it != end(s)</code> appears first in the <code>&amp;&amp;</code> expression. If it points to the end of the word then <code>*it</code> is not evaluated (this behavior of <code>&amp;&amp;</code> is known as short circuit<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a><span class="citation" data-cites="cit:wiki:shortcircuit"></span>).</p>
<p>The complexity of this solution is linear in space and constant in time, as the every letter is not read of modified more than once and no additional space is allocated.</p>
<h2 id="solution-using-stdadjacent_find">Solution using <code>std::adjacent_find</code></h2>
<p>An alternative way of solving this problem is by noticing that all the characters that need satisfy both the followings:</p>
<ul>
<li><p>are letters (not spaces)</p></li>
<li><p>are preceded by a bspace</p></li>
</ul>
<p>The core idea is that when a pair made of a space followed by a non-space is found in the text, then the second element of this pair can be made uppercase. This works because whenever such a pair is found, then its second element represent the starting point of a new word. This methods do not work when the are not spaces at the beginning of the text and the first word starts with a lower case letter. Thus, a special treatement for this case is necessary. The first <code>if</code> handles this special case.</p>
<p>One way to implement this idea in C++ is by using the standard algorithm <code>std::adjacent_find</code> as shown in Listing <a href="#list:capitalize_words_first_letter_adj_find" data-reference-type="ref" data-reference="list:capitalize_words_first_letter_adj_find">[list:capitalize_words_first_letter_adj_find]</a>.</p>
<div class="sourceCode" id="list:capitalize_words_first_letter_adj_find" data-language="c++" data-caption="Solution to the problem of turning all first letter of every word in a text into capital case. uses the function \href{https://en.cppreference.com/w/cpp/algorithm/adjacent_find}{\texttt{std::adjacent\_find}}\cite{cit::std::adjancefind} to find subsequent occurrence of a space and a letter in the text. This sequence marks the beginning of a word. by" label="list:capitalize_words_first_letter_adj_find"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:capitalize_words_first_letter_adj_find-1"><a href="#list:capitalize_words_first_letter_adj_find-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> capitalize_words_first_letter_adj_find<span class="op">(</span><span class="bu">std::</span>string<span class="op">&amp;</span> s<span class="op">)</span></span>
<span id="list:capitalize_words_first_letter_adj_find-2"><a href="#list:capitalize_words_first_letter_adj_find-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:capitalize_words_first_letter_adj_find-3"><a href="#list:capitalize_words_first_letter_adj_find-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>s<span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> <span class="op">!</span><span class="bu">std::</span>isspace<span class="op">(</span>s<span class="op">.</span>front<span class="op">()))</span></span>
<span id="list:capitalize_words_first_letter_adj_find-4"><a href="#list:capitalize_words_first_letter_adj_find-4" aria-hidden="true" tabindex="-1"></a>    s<span class="op">.</span>front<span class="op">()</span> <span class="op">=</span> <span class="bu">std::</span>toupper<span class="op">(</span>s<span class="op">.</span>front<span class="op">());</span></span>
<span id="list:capitalize_words_first_letter_adj_find-5"><a href="#list:capitalize_words_first_letter_adj_find-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:capitalize_words_first_letter_adj_find-6"><a href="#list:capitalize_words_first_letter_adj_find-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> p <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> x<span class="op">,</span> <span class="kw">auto</span><span class="op">&amp;</span> y<span class="op">)</span> <span class="op">{</span></span>
<span id="list:capitalize_words_first_letter_adj_find-7"><a href="#list:capitalize_words_first_letter_adj_find-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>isspace<span class="op">(</span>x<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">!</span><span class="bu">std::</span>isspace<span class="op">(</span>y<span class="op">);</span></span>
<span id="list:capitalize_words_first_letter_adj_find-8"><a href="#list:capitalize_words_first_letter_adj_find-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="list:capitalize_words_first_letter_adj_find-9"><a href="#list:capitalize_words_first_letter_adj_find-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> it <span class="op">=</span> <span class="bu">std::</span>adjacent_find<span class="op">(</span>begin<span class="op">(</span>s<span class="op">),</span> end<span class="op">(</span>s<span class="op">),</span> p<span class="op">);</span></span>
<span id="list:capitalize_words_first_letter_adj_find-10"><a href="#list:capitalize_words_first_letter_adj_find-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>it <span class="op">!=</span> <span class="bu">std::</span>end<span class="op">(</span>s<span class="op">))</span></span>
<span id="list:capitalize_words_first_letter_adj_find-11"><a href="#list:capitalize_words_first_letter_adj_find-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:capitalize_words_first_letter_adj_find-12"><a href="#list:capitalize_words_first_letter_adj_find-12" aria-hidden="true" tabindex="-1"></a>    it<span class="op">++;</span></span>
<span id="list:capitalize_words_first_letter_adj_find-13"><a href="#list:capitalize_words_first_letter_adj_find-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>it <span class="op">=</span> <span class="bu">std::</span>toupper<span class="op">(*</span>it<span class="op">);</span></span>
<span id="list:capitalize_words_first_letter_adj_find-14"><a href="#list:capitalize_words_first_letter_adj_find-14" aria-hidden="true" tabindex="-1"></a>    it  <span class="op">=</span> <span class="bu">std::</span>adjacent_find<span class="op">(</span>it<span class="op">,</span> <span class="bu">std::</span>end<span class="op">(</span>s<span class="op">),</span> p<span class="op">);</span></span>
<span id="list:capitalize_words_first_letter_adj_find-15"><a href="#list:capitalize_words_first_letter_adj_find-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:capitalize_words_first_letter_adj_find-16"><a href="#list:capitalize_words_first_letter_adj_find-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The complexity of the solution in Listing is linear in time and constant in space and it is considered a very good solution. This version is asymptotically as fast as the one presented in Listing <a href="#list:capitalize_words_first_letter_adj_iterator" data-reference-type="ref" data-reference="list:capitalize_words_first_letter_adj_iterator">[list:capitalize_words_first_letter_adj_iterator]</a> but much more expressive, thus is considered better in a interview.</p>
<h2 id="capitalize_words_first_letter:sec:variation">Common Variations</h2>
<h3 id="user-provided-function">User provided function</h3>
<p>It is not unlikely that this problem can be posed such that the operation to be applied on it is different than the one which capitalize the letter. A way to solve this is to make the solution generic such that it accept the operation from the user. Listing <a href="#list:capitalize_words_first_letter_userdefined" data-reference-type="ref" data-reference="list:capitalize_words_first_letter_userdefined">[list:capitalize_words_first_letter_userdefined]</a> shows a possible implementation of the idea above. The code takes as a input a string and a function which takes as a input a character and return a character and applies it to every first letter of all words in the text.</p>
<div class="sourceCode" id="list:capitalize_words_first_letter_userdefined" data-language="c++" data-caption="Solution to the problem of modifying all first letter of every word in a text using a user provided function." label="list:capitalize_words_first_letter_userdefined"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:capitalize_words_first_letter_userdefined-1"><a href="#list:capitalize_words_first_letter_userdefined-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> Fn<span class="op">&gt;</span></span>
<span id="list:capitalize_words_first_letter_userdefined-2"><a href="#list:capitalize_words_first_letter_userdefined-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> capitalize_words_first_letter_adj_find<span class="op">(</span><span class="bu">std::</span>string<span class="op">&amp;</span> s<span class="op">,</span> Fn f<span class="op">)</span></span>
<span id="list:capitalize_words_first_letter_userdefined-3"><a href="#list:capitalize_words_first_letter_userdefined-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:capitalize_words_first_letter_userdefined-4"><a href="#list:capitalize_words_first_letter_userdefined-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>s<span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> <span class="op">!</span><span class="bu">std::</span>isspace<span class="op">(</span>s<span class="op">.</span>front<span class="op">()))</span></span>
<span id="list:capitalize_words_first_letter_userdefined-5"><a href="#list:capitalize_words_first_letter_userdefined-5" aria-hidden="true" tabindex="-1"></a>    s<span class="op">.</span>front<span class="op">()</span> <span class="op">=</span> f<span class="op">(</span>s<span class="op">.</span>front<span class="op">());</span></span>
<span id="list:capitalize_words_first_letter_userdefined-6"><a href="#list:capitalize_words_first_letter_userdefined-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:capitalize_words_first_letter_userdefined-7"><a href="#list:capitalize_words_first_letter_userdefined-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> p <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> x<span class="op">,</span> <span class="kw">auto</span><span class="op">&amp;</span> y<span class="op">)</span> <span class="op">{</span></span>
<span id="list:capitalize_words_first_letter_userdefined-8"><a href="#list:capitalize_words_first_letter_userdefined-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>isspace<span class="op">(</span>x<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">!</span><span class="bu">std::</span>isspace<span class="op">(</span>y<span class="op">);</span></span>
<span id="list:capitalize_words_first_letter_userdefined-9"><a href="#list:capitalize_words_first_letter_userdefined-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="list:capitalize_words_first_letter_userdefined-10"><a href="#list:capitalize_words_first_letter_userdefined-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> it <span class="op">=</span> <span class="bu">std::</span>adjacent_find<span class="op">(</span>begin<span class="op">(</span>s<span class="op">),</span> end<span class="op">(</span>s<span class="op">),</span> p<span class="op">);</span></span>
<span id="list:capitalize_words_first_letter_userdefined-11"><a href="#list:capitalize_words_first_letter_userdefined-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>it <span class="op">!=</span> <span class="bu">std::</span>end<span class="op">(</span>s<span class="op">))</span></span>
<span id="list:capitalize_words_first_letter_userdefined-12"><a href="#list:capitalize_words_first_letter_userdefined-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:capitalize_words_first_letter_userdefined-13"><a href="#list:capitalize_words_first_letter_userdefined-13" aria-hidden="true" tabindex="-1"></a>    it<span class="op">++;</span></span>
<span id="list:capitalize_words_first_letter_userdefined-14"><a href="#list:capitalize_words_first_letter_userdefined-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>it <span class="op">=</span> f<span class="op">(*</span>it<span class="op">);</span></span>
<span id="list:capitalize_words_first_letter_userdefined-15"><a href="#list:capitalize_words_first_letter_userdefined-15" aria-hidden="true" tabindex="-1"></a>    it  <span class="op">=</span> <span class="bu">std::</span>adjacent_find<span class="op">(</span>it<span class="op">,</span> <span class="bu">std::</span>end<span class="op">(</span>s<span class="op">),</span> p<span class="op">);</span></span>
<span id="list:capitalize_words_first_letter_userdefined-16"><a href="#list:capitalize_words_first_letter_userdefined-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:capitalize_words_first_letter_userdefined-17"><a href="#list:capitalize_words_first_letter_userdefined-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="modify-the-every-kth-character-of-every-word">Modify the every <span class="math inline">\(k^{th}\)</span> character of every word</h3>
<p>Another common variation asks to modify (to make upper, or lower case for instance) every <span class="math inline">\(k^{th}\)</span> character of a word (if exists). For instance you might be asked to:</p>
<div class="exercise">
<p>Given a string s, modify s such that every <span class="math inline">\(3^{rd}\)</span> letter of every word in <span class="math inline">\(s\)</span> is modifyed accordin to a function provided by the user. The rest of the string should not be touched.</p>
</div>
<p>The implementation of this exercice is left to the reader.</p>
<h1 id="ch:trapping_water">Trapping Water</h1>
<h2 class="unnumbered" id="introduction-15">Introduction</h2>
<p>This chapter describes a quite challenging and extremely popular and fun problem that is asked at big companies like Google and Microsoft.</p>
<h2 id="problem-statement-15">Problem statement</h2>
<div class="exercise">
<p>Write a function that takes as input an array of length <span class="math inline">\(n\)</span> of non-negative integers representing an elevation map (or an histogram) where the width of each bar is <span class="math inline">\(1\)</span>. The function should return the amount of water that is trapped in the histogram after an heavy rain overnight.</p>
<div class="example">
<p><span id="ex:trapping_water:exmaple1" label="ex:trapping_water:exmaple1">[ex:trapping_water:exmaple1]</span><br />
Given the array <span class="math inline">\(H=[0,1,0,2,1,0,1,3,2,1,2,1]\)</span> (see Figure <a href="#fig:trapping_water_example1" data-reference-type="ref" data-reference="fig:trapping_water_example1">16.1</a>), the function return <span class="math inline">\(8\)</span></p>
</div>
<div class="example">
<p><span id="ex:trapping_water:exmaple2" label="ex:trapping_water:exmaple2">[ex:trapping_water:exmaple2]</span><br />
Given the array <span class="math inline">\(H=[1,0,2,1,0,1]\)</span> (see Figure <a href="#fig:trapping_water_example2" data-reference-type="ref" data-reference="fig:trapping_water_example2">16.2</a>), the function return <span class="math inline">\(14\)</span></p>
</div>
</div>
<p><span id="fig:trapping_water_example1" label="fig:trapping_water_example1">[fig:trapping_water_example1]</span> <img src="/home/dspataro/git/algorithm_articles/sources/trapping_water/images/example1.png" title="fig:" id="fig:trapping_water_example1" alt="Visual representation of the example [ex:trapping_water:exmaple1]. Blue squares represent water, while the red ones, bricks." /></p>
<p><span id="fig:trapping_water_example2" label="fig:trapping_water_example2">[fig:trapping_water_example2]</span> <img src="/home/dspataro/git/algorithm_articles/sources/trapping_water/images/example2.png" title="fig:" id="fig:trapping_water_example2" alt="Visual representation of the example [ex:trapping_water:exmaple2]. Blue squares represent water, while the red ones, bricks." /></p>
<h2 id="trapping_water:sec:discussion">Discussion</h2>
<p>There are at least <span class="math inline">\(3\)</span> of ways we can solve this challenge in a way that will satisfy our interviewer:</p>
<ol>
<li><p>Dynamic programming</p></li>
<li><p>Stack based solution</p></li>
<li><p>Two pointers</p></li>
</ol>
<p>We will start investigating this problem by using a brute force approach, for then to pass on more sophisticated and better solutions.</p>
<h3 id="trapping_water:sec:bruteforce">Brute-force</h3>
<p>The brute-force approach is easy once we realize that each element of the array can potentially be holding some water provided that there are other two bars, one on its left and one on its right, with height equal or higher than its. It that is the case then, we can safely add enough water so the its level reach the minimum between the highest bar on the left and on the right. For instance w.r.t. to <a href="#ex:trapping_water:exmaple2" data-reference-type="ref" data-reference="ex:trapping_water:exmaple2">[ex:trapping_water:exmaple2]</a>, we can see that for the element at index <span class="math inline">\(6\)</span> having height <span class="math inline">\(1\)</span>, the highest bars on its left and right sides are both respectively of height <span class="math inline">\(3\)</span> and <span class="math inline">\(4\)</span>. We can fill with water the boxes at index <span class="math inline">\(6\)</span> up to an height of <span class="math inline">\(3\)</span> (the minimum between <span class="math inline">\(3\)</span> and <span class="math inline">\(4\)</span>). If the current element is higher than both the highest bars on its left and right side, then it is not possible to fit any water on it (for instance, this is the case when processing the highest bar on the histogram). Figure <a href="#fig:trapping_water_example3" data-reference-type="ref" data-reference="fig:trapping_water_example3">16.3</a> depicts how one element (the one marked with the question mark) of the array can be processed using this approach i.e. by calculating the minimum between <span class="math inline">\(b_l\)</span> and <span class="math inline">\(b_r\)</span>.</p>
<p><span id="fig:trapping_water_example3" label="fig:trapping_water_example3">[fig:trapping_water_example3]</span> <img src="/home/dspataro/git/algorithm_articles/sources/trapping_water/images/example3.png" title="fig:" id="fig:trapping_water_example3" alt="This figure shows how the contribution of a single element of the histogram can be calculated using the information about the highest bar on its left and right." /></p>
<p>To summarize, we can calculate the answer to this problem by:</p>
<ol>
<li><p>For each element of the array</p></li>
<li><p>calculate the highest bar on its left and the highest bar on its right .</p></li>
<li><p>add</p></li>
</ol>
<p>Step <span class="math inline">\(2\)</span> of this approach can be implemented with a simple linear search with a cost of <span class="math inline">\(O(n)\)</span> making the complexity of whole algorithm equal to <span class="math inline">\(O(n^2)\)</span>. Finding the maximum elements on left and right costs has a linear complexity, and it needs to be done for all the bars. Moreover note that the first and the last element will never be able to contain any water as those elements have no bars on their left and right, respectively.</p>
<p>Listing <a href="#list:trapping_water:bruteforce" data-reference-type="ref" data-reference="list:trapping_water:bruteforce">[list:trapping_water:bruteforce]</a> shows a possible implementation of this idea. Note how the function from C++ STL can be employed elegantly to calculate <span class="math inline">\(b_l\)</span> and <span class="math inline">\(b_r\)</span>.</p>
<div class="sourceCode" id="list:trapping_water:bruteforce" data-language="c++" data-caption="Brute-force solution to the problem of calculating the amount of water trapped between buildings." label="list:trapping_water:bruteforce"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:trapping_water:bruteforce-1"><a href="#list:trapping_water:bruteforce-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> trapping_water_brute_force<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>height<span class="op">)</span></span>
<span id="list:trapping_water:bruteforce-2"><a href="#list:trapping_water:bruteforce-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:trapping_water:bruteforce-3"><a href="#list:trapping_water:bruteforce-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> size <span class="op">=</span> height<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:trapping_water:bruteforce-4"><a href="#list:trapping_water:bruteforce-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans        <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:trapping_water:bruteforce-5"><a href="#list:trapping_water:bruteforce-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> size <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:trapping_water:bruteforce-6"><a href="#list:trapping_water:bruteforce-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:trapping_water:bruteforce-7"><a href="#list:trapping_water:bruteforce-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> b_l <span class="op">=</span></span>
<span id="list:trapping_water:bruteforce-8"><a href="#list:trapping_water:bruteforce-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span><span class="bu">std::</span>max_element<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>height<span class="op">),</span> <span class="bu">std::</span>begin<span class="op">(</span>height<span class="op">)</span> <span class="op">+</span> i<span class="op">);</span></span>
<span id="list:trapping_water:bruteforce-9"><a href="#list:trapping_water:bruteforce-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> b_r <span class="op">=</span></span>
<span id="list:trapping_water:bruteforce-10"><a href="#list:trapping_water:bruteforce-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span><span class="bu">std::</span>max_element<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>height<span class="op">)</span> <span class="op">+</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="bu">std::</span>end<span class="op">(</span>height<span class="op">));</span></span>
<span id="list:trapping_water:bruteforce-11"><a href="#list:trapping_water:bruteforce-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:trapping_water:bruteforce-12"><a href="#list:trapping_water:bruteforce-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> min_max_on_side <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>b_l<span class="op">,</span> b_r<span class="op">);</span></span>
<span id="list:trapping_water:bruteforce-13"><a href="#list:trapping_water:bruteforce-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// equivalent to</span></span>
<span id="list:trapping_water:bruteforce-14"><a href="#list:trapping_water:bruteforce-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// if(min_max_on_side - height[i] &gt; 0) ans+=min_max_on_side - height[i]</span></span>
<span id="list:trapping_water:bruteforce-15"><a href="#list:trapping_water:bruteforce-15" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">+=</span> <span class="bu">std::</span>max<span class="op">(</span><span class="dv">0</span><span class="op">,</span> min_max_on_side <span class="op">-</span> height<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:trapping_water:bruteforce-16"><a href="#list:trapping_water:bruteforce-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:trapping_water:bruteforce-17"><a href="#list:trapping_water:bruteforce-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:trapping_water:bruteforce-18"><a href="#list:trapping_water:bruteforce-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="trapping_water:sec:dp">Dynamic Programming</h3>
<p>The solution proposed in Section <a href="#trapping_water:sec:bruteforce" data-reference-type="ref" data-reference="trapping_water:sec:bruteforce">16.2.1</a> is far from optimal, but it can be transformed into a good one, if we realize that for each element of the array, we can calculate and <strong>store</strong> the values for its max element on its right and on its left. As already discussed in Chapter <a href="#ch:greatest_right" data-reference-type="ref" data-reference="ch:greatest_right">6</a>, this task can be accomplished in linear time. Thus all it is necessary is to keep two additional arrays, <span class="math inline">\(R\)</span>, and <span class="math inline">\(L\)</span>, of length <span class="math inline">\(n\)</span> (same length of the input).</p>
<ul>
<li><p><span class="math inline">\(R[i]\)</span> contains the value of the highest bar among all elements of the input with index <span class="math inline">\(j &gt; i\)</span> (on the right of, and not considering, <span class="math inline">\(i\)</span>).</p></li>
<li><p>symmetrically, <span class="math inline">\(L[i]\)</span> contains the value of the highest bar among all elements of the input with index <span class="math inline">\(j &lt; i\)</span> (on the left of, and not considering, <span class="math inline">\(i\)</span>).</p></li>
</ul>
<p>Armed with this information, the same algorithm used in the Section <a href="#trapping_water:sec:bruteforce" data-reference-type="ref" data-reference="trapping_water:sec:bruteforce">16.2.1</a> can be turned into an elegant and efficient solution that will make any interviewer happy. Listing <a href="#list:trapping_water:dp" data-reference-type="ref" data-reference="list:trapping_water:dp">[list:trapping_water:dp]</a> shows a possible implementation of this idea. Note that we can calculate <span class="math inline">\(R\)</span>, given a function, that is able to calculate <span class="math inline">\(L\)</span>, by simply providing its input reversed and reversing the results once again. This is how <span class="math inline">\(R\)</span> is calculated in Listing <a href="#list:trapping_water:dp" data-reference-type="ref" data-reference="list:trapping_water:dp">[list:trapping_water:dp]</a>.</p>
<p>Figures <a href="#fig:trapping_water_DPL" data-reference-type="ref" data-reference="fig:trapping_water_DPL">16.4</a> and <a href="#fig:trapping_water_DPR" data-reference-type="ref" data-reference="fig:trapping_water_DPR">16.5</a> show a representation of <span class="math inline">\(L\)</span> and <span class="math inline">\(R\)</span>. As we can see in Figure <a href="#fig:trapping_water_DPLR" data-reference-type="ref" data-reference="fig:trapping_water_DPLR">[fig:trapping_water_DPLR]</a> the amount of trapped water can be visualized by superimposing the two figures and taking the intersection of the shadowed cells.</p>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/trapping_water/images/DPR.png" id="fig:trapping_water_DPL" alt="Representation of the highest value on the right of each element. A cell colored in \blacksquare have at least a pile with height higher or equal to the cell itself on its right. " /><figcaption aria-hidden="true">Representation of the highest value on the right of each element. A cell colored in <span style="color: 3268d5"><span class="math inline">\(\blacksquare\)</span></span> have at least a pile with height higher or equal to the cell itself on its <strong>right</strong>. </figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/trapping_water/images/DPL.png" id="fig:trapping_water_DPR" alt="Representation of the highest value on the right of each element. A cell colored in \blacksquare have at least a pile with height higher or equal to the cell itself on its left." /><figcaption aria-hidden="true">Representation of the highest value on the right of each element. A cell colored in <span style="color: 32d579"><span class="math inline">\(\blacksquare\)</span></span> have at least a pile with height higher or equal to the cell itself on its <strong>left</strong>.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/trapping_water/images/DPLR.png" id="fig:trapping_water_DPRL" alt="Superimposition of Figures 16.4 and 16.5. Cells colored in \blacksquare represent the intersection between cells colored in \blacksquare in Figure 16.4 and cells colored in \blacksquare in Figure 16.5. Those cells are the ones that can be filled up with water." /><figcaption aria-hidden="true">Superimposition of Figures <a href="#fig:trapping_water_DPL" data-reference-type="ref" data-reference="fig:trapping_water_DPL">16.4</a> and <a href="#fig:trapping_water_DPR" data-reference-type="ref" data-reference="fig:trapping_water_DPR">16.5</a>. Cells colored in <span style="color: 5aa1c7"><span class="math inline">\(\blacksquare\)</span></span> represent the intersection between cells colored in <span style="color: 3268d5"><span class="math inline">\(\blacksquare\)</span></span> in Figure <a href="#fig:trapping_water_DPL" data-reference-type="ref" data-reference="fig:trapping_water_DPL">16.4</a> and cells colored in <span style="color: 32d579"><span class="math inline">\(\blacksquare\)</span></span> in Figure <a href="#fig:trapping_water_DPR" data-reference-type="ref" data-reference="fig:trapping_water_DPR">16.5</a>. Those cells are the ones that can be filled up with water.</figcaption>
</figure>
<div class="sourceCode" id="list:trapping_water:dp" data-language="c++" data-caption="Dynamic programming, $O(n)$ time and space, solution to the problem of calculating the amount of water trapped between buildings." label="list:trapping_water:dp"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:trapping_water:dp-1"><a href="#list:trapping_water:dp-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> max_left_it<span class="op">(</span><span class="kw">auto</span> begin<span class="op">,</span> <span class="kw">auto</span> end<span class="op">)</span></span>
<span id="list:trapping_water:dp-2"><a href="#list:trapping_water:dp-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:trapping_water:dp-3"><a href="#list:trapping_water:dp-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> L<span class="op">(</span><span class="bu">std::</span>distance<span class="op">(</span>begin<span class="op">,</span> end<span class="op">),</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="list:trapping_water:dp-4"><a href="#list:trapping_water:dp-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:trapping_water:dp-5"><a href="#list:trapping_water:dp-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> i    <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:trapping_water:dp-6"><a href="#list:trapping_water:dp-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> cmax <span class="op">=</span> <span class="op">*</span>begin<span class="op">;</span></span>
<span id="list:trapping_water:dp-7"><a href="#list:trapping_water:dp-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(++</span>begin <span class="op">!=</span> end<span class="op">)</span></span>
<span id="list:trapping_water:dp-8"><a href="#list:trapping_water:dp-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:trapping_water:dp-9"><a href="#list:trapping_water:dp-9" aria-hidden="true" tabindex="-1"></a>    L<span class="op">[++</span>i<span class="op">]</span> <span class="op">=</span> cmax<span class="op">;</span></span>
<span id="list:trapping_water:dp-10"><a href="#list:trapping_water:dp-10" aria-hidden="true" tabindex="-1"></a>    cmax   <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>cmax<span class="op">,</span> <span class="op">*</span>begin<span class="op">);</span></span>
<span id="list:trapping_water:dp-11"><a href="#list:trapping_water:dp-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:trapping_water:dp-12"><a href="#list:trapping_water:dp-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> L<span class="op">;</span></span>
<span id="list:trapping_water:dp-13"><a href="#list:trapping_water:dp-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:trapping_water:dp-14"><a href="#list:trapping_water:dp-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:trapping_water:dp-15"><a href="#list:trapping_water:dp-15" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> trapping_water_DP<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>height<span class="op">)</span></span>
<span id="list:trapping_water:dp-16"><a href="#list:trapping_water:dp-16" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:trapping_water:dp-17"><a href="#list:trapping_water:dp-17" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">size_t</span> len <span class="op">=</span> height<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:trapping_water:dp-18"><a href="#list:trapping_water:dp-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>len <span class="op">&lt;</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="list:trapping_water:dp-19"><a href="#list:trapping_water:dp-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:trapping_water:dp-20"><a href="#list:trapping_water:dp-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:trapping_water:dp-21"><a href="#list:trapping_water:dp-21" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:trapping_water:dp-22"><a href="#list:trapping_water:dp-22" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> L<span class="op">(</span>max_left_it<span class="op">(</span>height<span class="op">.</span>begin<span class="op">(),</span> height<span class="op">.</span>end<span class="op">()));</span></span>
<span id="list:trapping_water:dp-23"><a href="#list:trapping_water:dp-23" aria-hidden="true" tabindex="-1"></a>  <span class="co">// reversed input to calculate</span></span>
<span id="list:trapping_water:dp-24"><a href="#list:trapping_water:dp-24" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> R<span class="op">(</span>max_left_it<span class="op">(</span>height<span class="op">.</span>rbegin<span class="op">(),</span> height<span class="op">.</span>rend<span class="op">()));</span></span>
<span id="list:trapping_water:dp-25"><a href="#list:trapping_water:dp-25" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>reverse<span class="op">(</span>R<span class="op">.</span>begin<span class="op">(),</span> R<span class="op">.</span>end<span class="op">());</span></span>
<span id="list:trapping_water:dp-26"><a href="#list:trapping_water:dp-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:trapping_water:dp-27"><a href="#list:trapping_water:dp-27" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> height<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span></span>
<span id="list:trapping_water:dp-28"><a href="#list:trapping_water:dp-28" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:trapping_water:dp-29"><a href="#list:trapping_water:dp-29" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">+=</span> <span class="bu">std::</span>max<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="bu">std::</span>min<span class="op">(</span>R<span class="op">[</span>i<span class="op">],</span> L<span class="op">[</span>i<span class="op">])</span> <span class="op">-</span> height<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:trapping_water:dp-30"><a href="#list:trapping_water:dp-30" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:trapping_water:dp-31"><a href="#list:trapping_water:dp-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:trapping_water:dp-32"><a href="#list:trapping_water:dp-32" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:trapping_water:dp-33"><a href="#list:trapping_water:dp-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This solution has a time complexity of <span class="math inline">\(O(n)\)</span> because the computation of <span class="math inline">\(L\)</span> and <span class="math inline">\(R\)</span> can be done in linear time, while calculating the final answer can be done in a single pass over the array. The space complexity if linear as well because the arrays <span class="math inline">\(L\)</span> and <span class="math inline">\(R\)</span> are both of size proportional to the size of <span class="math inline">\(n\)</span>.</p>
<h3 id="trapping_water:sec:two_pointers">Two pointers solution</h3>
<p>Despite the fact that the solution presented in Section <a href="#trapping_water:sec:dp" data-reference-type="ref" data-reference="trapping_water:sec:dp">16.2.2</a> is already a good one, we can definitely do better and lower the space complexity down to <span class="math inline">\(O(1)\)</span>. The key idea is that, we do not really need to store <span class="math inline">\(L\)</span> and <span class="math inline">\(R\)</span> in their entirety. All of time, we only need one element from both <span class="math inline">\(L\)</span> and <span class="math inline">\(R\)</span> and nothing else. Once an element of the input array is processed we can discard the corresponding element in <span class="math inline">\(L\)</span> and <span class="math inline">\(R\)</span> because they are of no use anymore in the future. They do not play a role in the calculation of any other element of the input array <span class="math inline">\(H\)</span>. Therefore the solution proposed in this section will use a two pointer technique and will keep two <em>rolling</em> maximum value <span class="math inline">\(m_l\)</span> and <span class="math inline">\(m_r\)</span>, one for the left and one for the right. When processing the cell at index <span class="math inline">\(i\)</span> of the input array, <span class="math inline">\(m_l\)</span> and <span class="math inline">\(m_r\)</span> will contain the maximum value on the left and on the right of <span class="math inline">\(i\)</span>, respectively.</p>
<p>The input arrays is traversed from left to right using two pointers <span class="math inline">\(l\)</span> and <span class="math inline">\(r\)</span>, pointing at first to the beginning and the end of the input array.<span class="math inline">\(m_l\)</span> and <span class="math inline">\(m_r\)</span> are set to <span class="math inline">\(0\)</span> respectively. At each iteration only one of the two pointers is moved towards the center depending on whether is:</p>
<dl>
<dt>true</dt>
<dd><p>then the contribution of is bounded by (because . the left pointer is moved towards the center (we have considered the contribution of this cell and we can move forward).<br />
</p>
</dd>
<dt>false</dt>
<dd><p>then the contribution of is bounded by (because . The right pointer is moved towards the center (we have considered the contribution of this cell and we can move forward).<br />
</p>
</dd>
</dl>
<p>While moving the pointers the variables <span class="math inline">\(m_l\)</span> or <span class="math inline">\(m_r\)</span> are updated and the contribution of every single element summed up.</p>
<p>An implementation of the idea above is shown in Listing <a href="#list:trapping_water:two_pointers" data-reference-type="ref" data-reference="list:trapping_water:two_pointers">[list:trapping_water:two_pointers]</a>. Note that all the elements of the input array will be eventually considered because <span class="math inline">\(l\)</span> and <span class="math inline">\(r\)</span> are moved one by one against each other.</p>
<div class="sourceCode" id="list:trapping_water:two_pointers" data-language="c++" data-caption="Two pointers solution, $O(n)$ time and  $O(1)$ space, solution to the problem of calculating the amount of water trapped between buildings." label="list:trapping_water:two_pointers"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:trapping_water:two_pointers-1"><a href="#list:trapping_water:two_pointers-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> trapping_water_two_pointers<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> H<span class="op">)</span></span>
<span id="list:trapping_water:two_pointers-2"><a href="#list:trapping_water:two_pointers-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:trapping_water:two_pointers-3"><a href="#list:trapping_water:two_pointers-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> <span class="va">m_l</span><span class="op">,</span> <span class="va">m_r</span><span class="op">;</span></span>
<span id="list:trapping_water:two_pointers-4"><a href="#list:trapping_water:two_pointers-4" aria-hidden="true" tabindex="-1"></a>  <span class="va">m_l</span> <span class="op">=</span> <span class="va">m_r</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:trapping_water:two_pointers-5"><a href="#list:trapping_water:two_pointers-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:trapping_water:two_pointers-6"><a href="#list:trapping_water:two_pointers-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> l <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:trapping_water:two_pointers-7"><a href="#list:trapping_water:two_pointers-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> r <span class="op">=</span> H<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:trapping_water:two_pointers-8"><a href="#list:trapping_water:two_pointers-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:trapping_water:two_pointers-9"><a href="#list:trapping_water:two_pointers-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:trapping_water:two_pointers-10"><a href="#list:trapping_water:two_pointers-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>l <span class="op">&lt;</span> r<span class="op">)</span></span>
<span id="list:trapping_water:two_pointers-11"><a href="#list:trapping_water:two_pointers-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:trapping_water:two_pointers-12"><a href="#list:trapping_water:two_pointers-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>H<span class="op">[</span>l<span class="op">]</span> <span class="op">&lt;=</span> H<span class="op">[</span>r<span class="op">])</span></span>
<span id="list:trapping_water:two_pointers-13"><a href="#list:trapping_water:two_pointers-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:trapping_water:two_pointers-14"><a href="#list:trapping_water:two_pointers-14" aria-hidden="true" tabindex="-1"></a>      <span class="va">m_l</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span><span class="va">m_l</span><span class="op">,</span> H<span class="op">[</span>l<span class="op">]);</span></span>
<span id="list:trapping_water:two_pointers-15"><a href="#list:trapping_water:two_pointers-15" aria-hidden="true" tabindex="-1"></a>      ans <span class="op">+=</span> <span class="va">m_l</span> <span class="op">-</span> H<span class="op">[</span>l<span class="op">];</span></span>
<span id="list:trapping_water:two_pointers-16"><a href="#list:trapping_water:two_pointers-16" aria-hidden="true" tabindex="-1"></a>      l<span class="op">++;</span></span>
<span id="list:trapping_water:two_pointers-17"><a href="#list:trapping_water:two_pointers-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:trapping_water:two_pointers-18"><a href="#list:trapping_water:two_pointers-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="list:trapping_water:two_pointers-19"><a href="#list:trapping_water:two_pointers-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:trapping_water:two_pointers-20"><a href="#list:trapping_water:two_pointers-20" aria-hidden="true" tabindex="-1"></a>      <span class="va">m_r</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span><span class="va">m_r</span><span class="op">,</span> H<span class="op">[</span>r<span class="op">]);</span></span>
<span id="list:trapping_water:two_pointers-21"><a href="#list:trapping_water:two_pointers-21" aria-hidden="true" tabindex="-1"></a>      ans <span class="op">+=</span> <span class="va">m_r</span> <span class="op">-</span> H<span class="op">[</span>r<span class="op">];</span></span>
<span id="list:trapping_water:two_pointers-22"><a href="#list:trapping_water:two_pointers-22" aria-hidden="true" tabindex="-1"></a>      r<span class="op">--;</span></span>
<span id="list:trapping_water:two_pointers-23"><a href="#list:trapping_water:two_pointers-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:trapping_water:two_pointers-24"><a href="#list:trapping_water:two_pointers-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:trapping_water:two_pointers-25"><a href="#list:trapping_water:two_pointers-25" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:trapping_water:two_pointers-26"><a href="#list:trapping_water:two_pointers-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This approach has a time complexity of <span class="math inline">\(O(n)\)</span> (we cannot do better than this because at least we have to touch all the elements of the input at least once) and a space complexity of <span class="math inline">\(O(1)\)</span>. This is therefore the optimal approach to solve this problem and we believe this should be your solution during an actual interview.</p>
<h3 id="trapping_water:sec:stack">Stack based solution</h3>
<p>There is another way of solving this problem that uses an additional stack. At any moment the stack will contains indexes of bars that are bounded on the left by some other bar. It means that the stack will contain bars in a decreasing order (from the bottom to the top). The idea is that we start with an empty stack <span class="math inline">\(S\)</span> and iterate thought the input array from start to end, and for each bar <span class="math inline">\(b_i\)</span>: we check whether it is lower than the top of the stack <span class="math inline">\(S_{top}\)</span>. If that is the case, the current top of the stack is higher than this element and so it means that the current top bounds the current element from the left. In this case we simply add it to the top of the stack. If it not the case then we have a bar that is higher or equal to the top. Thus all the bars in the stack that are smaller or equal of <span class="math inline">\(i\)</span> can trap some water because they are bound from left (by other taller elements in the stack) and to the right by <span class="math inline">\(i\)</span> itself. Given the stack <span class="math inline">\(S=[s_0, s_1,s_2]\)</span> where <span class="math inline">\(s_0 \geq s_1 \geq s_2\)</span> (remember they are increasing from top to bottom) we know that we can use bar <span class="math inline">\(i\)</span> and bar <span class="math inline">\(s_1\)</span> to calculate the contribution of <span class="math inline">\(s_2\)</span> to the final answer and we can use bar <span class="math inline">\(i\)</span> and bar <span class="math inline">\(s_0\)</span> to calculate the contribution of <span class="math inline">\(s_1\)</span>. The contribution of each element is calculated as the rectangle of base equal to the distance between the two bounding bars and height that is equal to the minimum of the heights between the two bounding bars <strong>minus</strong> the height of the bar we are calculating the contribution.</p>
<p>A possible implementation of this idea is shown in Listing <a href="#list:trapping_water:stack" data-reference-type="ref" data-reference="list:trapping_water:stack">[list:trapping_water:stack]</a>. Note how all the real work happens inside the loop and that the bar we calculate the contribution is named top while the bar on the left and right are named and respectively. Moreover, no matter the stack is unwounded or not the is <strong>added</strong> to the stack because when controls reaches line <span class="math inline">\(21\)</span> it will be either the only bar in the stack of it will be smaller than the current top.</p>
<div class="sourceCode" id="list:trapping_water:stack" data-language="c++" data-caption="Stack based solution, $O(n)$ time and  space, solution to the problem of calculating the amount of water trapped between buildings." label="list:trapping_water:stack"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:trapping_water:stack-1"><a href="#list:trapping_water:stack-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> trapping_water_stack<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>H<span class="op">)</span></span>
<span id="list:trapping_water:stack-2"><a href="#list:trapping_water:stack-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:trapping_water:stack-3"><a href="#list:trapping_water:stack-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> current <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:trapping_water:stack-4"><a href="#list:trapping_water:stack-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// w store indexes of the bars</span></span>
<span id="list:trapping_water:stack-5"><a href="#list:trapping_water:stack-5" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>stack<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> w<span class="op">;</span></span>
<span id="list:trapping_water:stack-6"><a href="#list:trapping_water:stack-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:trapping_water:stack-7"><a href="#list:trapping_water:stack-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> bar_right <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> bar_right <span class="op">&lt;</span> H<span class="op">.</span>size<span class="op">();</span> bar_right<span class="op">++)</span></span>
<span id="list:trapping_water:stack-8"><a href="#list:trapping_water:stack-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:trapping_water:stack-9"><a href="#list:trapping_water:stack-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(!</span>w<span class="op">.</span>empty<span class="op">()</span> <span class="op">&amp;&amp;</span> H<span class="op">[</span>bar_right<span class="op">]</span> <span class="op">&gt;</span> H<span class="op">[</span>w<span class="op">.</span>top<span class="op">()])</span></span>
<span id="list:trapping_water:stack-10"><a href="#list:trapping_water:stack-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:trapping_water:stack-11"><a href="#list:trapping_water:stack-11" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="dt">int</span> old_top <span class="op">=</span> w<span class="op">.</span>top<span class="op">();</span></span>
<span id="list:trapping_water:stack-12"><a href="#list:trapping_water:stack-12" aria-hidden="true" tabindex="-1"></a>      w<span class="op">.</span>pop<span class="op">();</span></span>
<span id="list:trapping_water:stack-13"><a href="#list:trapping_water:stack-13" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>w<span class="op">.</span>empty<span class="op">())</span></span>
<span id="list:trapping_water:stack-14"><a href="#list:trapping_water:stack-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="list:trapping_water:stack-15"><a href="#list:trapping_water:stack-15" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="dt">int</span> bar_left <span class="op">=</span> w<span class="op">.</span>top<span class="op">();</span></span>
<span id="list:trapping_water:stack-16"><a href="#list:trapping_water:stack-16" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="dt">int</span> distance <span class="op">=</span> bar_right <span class="op">-</span> bar_left <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:trapping_water:stack-17"><a href="#list:trapping_water:stack-17" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="dt">int</span> bounded_height <span class="op">=</span></span>
<span id="list:trapping_water:stack-18"><a href="#list:trapping_water:stack-18" aria-hidden="true" tabindex="-1"></a>          <span class="bu">std::</span>min<span class="op">(</span>H<span class="op">[</span>bar_right<span class="op">],</span> H<span class="op">[</span>bar_left<span class="op">])</span> <span class="op">-</span> H<span class="op">[</span>old_top<span class="op">];</span></span>
<span id="list:trapping_water:stack-19"><a href="#list:trapping_water:stack-19" aria-hidden="true" tabindex="-1"></a>      ans <span class="op">+=</span> distance <span class="op">*</span> bounded_height<span class="op">;</span></span>
<span id="list:trapping_water:stack-20"><a href="#list:trapping_water:stack-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:trapping_water:stack-21"><a href="#list:trapping_water:stack-21" aria-hidden="true" tabindex="-1"></a>    w<span class="op">.</span>push<span class="op">(</span>bar_right<span class="op">);</span></span>
<span id="list:trapping_water:stack-22"><a href="#list:trapping_water:stack-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:trapping_water:stack-23"><a href="#list:trapping_water:stack-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:trapping_water:stack-24"><a href="#list:trapping_water:stack-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="ch:min_rotated_array">Minimum element in rotated sorted array</h1>
<h2 class="unnumbered" id="introduction-16">Introduction</h2>
<p>The problem described in this chapter is a very popular interview question that has a surprisingly short statement in length and has an obvious linear time solution. However, solving this problem efficiently is a different story, and it requires a fair amount of thinking and careful coding to implement an elegant solution.</p>
<p>This problem is based upon the concept of array rotations. To develop an intuitive understanding of this concept, Imagine that we want to "rotate" the elements of an array, that is to shift all of them to the right by a certain number <span class="math inline">\(k\)</span> of positions. The element that was used to be at position <span class="math inline">\(0\)</span> is now at position <span class="math inline">\(k\)</span> and the element that was at position one is now at <span class="math inline">\(k+1\)</span> and so on (see Figure <a href="#fig:min_rotated_array:arrayrotation" data-reference-type="ref" data-reference="fig:min_rotated_array:arrayrotation">17.1</a> for an example).</p>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/min_rotated_array/images/arrayrotation.png" id="fig:min_rotated_array:arrayrotation" alt="Example of rotation of the array \{0,1,2,3,4\} where every element is moved to the right of k=2 positions." /><figcaption aria-hidden="true">Example of rotation of the array <span class="math inline">\(\{0,1,2,3,4\}\)</span> where every element is moved to the right of <span class="math inline">\(k=2\)</span> positions.</figcaption>
</figure>
<h2 id="problem-statement-16">Problem statement</h2>
<div class="exercise">
<p>Given an array <span class="math inline">\(A\)</span> sorted in an ascending order with no duplicates and rotated around a pivot, return the smallest element.</p>
<div class="example">
<p><br />
Given the rotated array <span class="math inline">\(\{3,4,5,6,1,2\}\)</span> the function returns <span class="math inline">\(1\)</span>.</p>
</div>
<div class="example">
<p><br />
Given the rotated array <span class="math inline">\(\{0,2,3\}\)</span> the function returns <span class="math inline">\(0\)</span>.</p>
</div>
<div class="example">
<p><br />
Given the rotated array <span class="math inline">\(\{3,2,1\}\)</span> the function returns <span class="math inline">\(1\)</span>.</p>
</div>
</div>
<h2 id="clarification-questions-14">Clarification Questions</h2>
<div class="QandA">
<p>Are all the elements unique?</p>
<div class="answered">
<p><em>Yes, you can assume all the elements are unique</em></p>
</div>
<p>Can the input array be empty?</p>
<div class="answered">
<p><em>No, you might assume the array contains at least one element.</em></p>
</div>
</div>
<h2 id="min_rotated_array:sec:discussion">Discussion</h2>
<p>What does it really mean for a sorted array to be rotated around an element? Given a sorted array <span class="math inline">\(A=\{a_0, a_1, \ldots,a_{n-1}\}\)</span> s.t. <span class="math inline">\(\forall \: 0 \leq i &lt; n: a_i &lt; a_{i+1}\)</span>, rotating A around the pivot element at index <span class="math inline">\(p\)</span> results in: <span class="math inline">\(A_p=\{a_p, a_{p+1}, \ldots,a_{n-1}, a_0, a_1, \ldots, a_{p-1}\}\)</span>. In nutshell all the elements are rotated in such a way that the element at index <span class="math inline">\(p\)</span> becomes the first element of the array. For instance, rotating the array <span class="math inline">\(X=\{1,2,3,4,5\}\)</span> around the element at index <span class="math inline">\(2\)</span>, results in <span class="math inline">\(X=\{3,4,5,1,2\}\)</span>.</p>
<p>This way of performing rotation is very common, to the point that there is algorithm in the C++ STL<span class="citation" data-cites="cit::std::rotate"></span> adoption this API.</p>
<h3 id="min_rotated_array:sec:bruteforce">Brute-force</h3>
<p>The brute-force solution to this problem is trivial and consist in simply looping through the array and keeping record of the smallest element encountered. In C++ this can be implemented with a one-liner as shown in Listings <a href="#list:min_rotated_array_bf" data-reference-type="ref" data-reference="list:min_rotated_array_bf">[list:min_rotated_array_bf]</a> and <a href="#list:min_rotated_array_bf_manual" data-reference-type="ref" data-reference="list:min_rotated_array_bf_manual">[list:min_rotated_array_bf_manual]</a> both having <span class="math inline">\(O(n)\)</span> time <span class="math inline">\(O(1)\)</span> space complexity.</p>
<div class="sourceCode" id="list:min_rotated_array_bf" data-language="c++" data-caption="One-linear brute force (using C++ STL) solution to the problem of finding the minimum element in a sorted rotated array." label="list:min_rotated_array_bf"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:min_rotated_array_bf-1"><a href="#list:min_rotated_array_bf-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_rotated_array_bf-2"><a href="#list:min_rotated_array_bf-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:min_rotated_array_bf-3"><a href="#list:min_rotated_array_bf-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> min_rotated_array_brute_force<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> V<span class="op">)</span></span>
<span id="list:min_rotated_array_bf-4"><a href="#list:min_rotated_array_bf-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:min_rotated_array_bf-5"><a href="#list:min_rotated_array_bf-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(!</span>V<span class="op">.</span>empty<span class="op">());</span></span>
<span id="list:min_rotated_array_bf-6"><a href="#list:min_rotated_array_bf-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">*(</span><span class="bu">std::</span>min_element<span class="op">(</span>begin<span class="op">(</span>V<span class="op">),</span> end<span class="op">(</span>V<span class="op">)));</span></span>
<span id="list:min_rotated_array_bf-7"><a href="#list:min_rotated_array_bf-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="list:min_rotated_array_bf_manual" data-language="c++" data-caption="One-linear brute force solution to the problem of finding the minimum element in a sorted rotated array." label="list:min_rotated_array_bf_manual"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:min_rotated_array_bf_manual-1"><a href="#list:min_rotated_array_bf_manual-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:min_rotated_array_bf_manual-2"><a href="#list:min_rotated_array_bf_manual-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> min_rotated_array_brute_force_1<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> V<span class="op">)</span></span>
<span id="list:min_rotated_array_bf_manual-3"><a href="#list:min_rotated_array_bf_manual-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:min_rotated_array_bf_manual-4"><a href="#list:min_rotated_array_bf_manual-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> ans <span class="op">=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span>T<span class="op">&gt;::</span>max<span class="op">();</span></span>
<span id="list:min_rotated_array_bf_manual-5"><a href="#list:min_rotated_array_bf_manual-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span> v <span class="op">:</span> V<span class="op">)</span></span>
<span id="list:min_rotated_array_bf_manual-6"><a href="#list:min_rotated_array_bf_manual-6" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>ans<span class="op">,</span> v<span class="op">);</span></span>
<span id="list:min_rotated_array_bf_manual-7"><a href="#list:min_rotated_array_bf_manual-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:min_rotated_array_bf_manual-8"><a href="#list:min_rotated_array_bf_manual-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This approach should just be mentioned during the interview but no time should be spent in the actual implementation of this idea, as the interviewer is assuming you know how to trivially search for the minimum in an unsorted array. He is clearly looking for a more advanced solution that takes advantage of the fact that the array is sorted (even if rotated).</p>
<h3 id="min_rotated_array:sec:log">Logarithmic solution</h3>
<p>As usual, when in a problem statement the word "sorted" makes its appearance the first thought that should cross our brain is <strong>binary search</strong>(see Appendix <a href="#sect:appendix:binary_search" data-reference-type="ref" data-reference="sect:appendix:binary_search">[sect:appendix:binary_search]</a>). In this case, we are almost forced to think about binary search immediately as the problem does not only involve a sorted input but is also about searching. But how can we use binary search to actually solve this problem given the fact we have this weirdly sorted array?</p>
<p>Firstly notice that despite the fact the array is not sorted in a canonical way, it still is very much sorted as there is an index <span class="math inline">\(i\)</span> of the array holding the smallest value from which you could iterate the array forward and all you would see is a sorted sequence. Moreover, as for all the binary search applications we need to:</p>
<ol>
<li><p>keep track of a range of element that are currently under examination. Initially this range is the following closed interval: <span class="math inline">\([l=0, r=A.size()-1]\)</span> i.e. the entire array.</p></li>
<li><p>analyze the element on the middle of this range.</p></li>
<li><p>if the middle element is the element we are looking for we are done</p></li>
<li><p>otherwise, the search proceed either to the left or to the right or the range.</p></li>
</ol>
<p>The key point of this problem lies at steps <span class="math inline">\(2\)</span> and <span class="math inline">\(4\)</span> because we need to be able:</p>
<ul>
<li><p>test whether an element is the minimum or not (<span class="math inline">\(2\)</span>)</p></li>
<li><p>decide how to split the space range into two and whether proceed the search on the right-hand or on the left-hand side (<span class="math inline">\(4\)</span>).</p></li>
</ul>
<h4 id="test-if-an-element-is-the-minimum">Test if an element is the minimum</h4>
<p>In order to decide whether an element <span class="math inline">\(a_k\)</span> at index <span class="math inline">\(k\)</span> is the minimum it is useful to look at one property that differentiates it from all the other values in the collection. The minimum element is the only element s.t. both the elements on its right and left are <strong>greater</strong> than it (this element is also called inflection point). Another other useful property that can be helpful in the identification of the minimum is that the element on its left it is always the maximum element of the array (see examples in the Section <a href="#min_rotated_array:sec:discussion" data-reference-type="ref" data-reference="min_rotated_array:sec:discussion">17.3</a> and Figure <a href="#fig:min_rotated_array:test_element" data-reference-type="ref" data-reference="fig:min_rotated_array:test_element">17.2</a>). Thus whenever <span class="math inline">\(a_{k-1} &gt; a_{k}\)</span> (meaning that <span class="math inline">\(a_k\)</span> is the minimum and <span class="math inline">\(a_{k+1}\)</span> the maximum) or <span class="math inline">\(a_{k} &gt; a_{k+1}\)</span> (meaning that <span class="math inline">\(a_k\)</span> is the maximum element and <span class="math inline">\(a_{k+1}\)</span> the minimum) we can stop and return because we have found the answer.</p>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/min_rotated_array/images/inflection_point.png" id="fig:min_rotated_array:test_element" alt="Inflection point in a rotated sorted array. When the binary search examines both element 7 and 2 it is able to determine the inflection point (element 2). " /><figcaption aria-hidden="true">Inflection point in a rotated sorted array. When the binary search examines both element <span class="math inline">\(7\)</span> and <span class="math inline">\(2\)</span> it is able to determine the inflection point (element <span class="math inline">\(2\)</span>). </figcaption>
</figure>
<p>In short, Listing <a href="#list:test_answer" data-reference-type="ref" data-reference="list:test_answer">[list:test_answer]</a> shows the condition that can be used in the binary search to test whether <span class="math inline">\(a_k\)</span> is the answer to the problem. Please note how the modulo operations is used in order to avoid having to specialize this test for the elements at the beginning and at the end of the array (positions <span class="math inline">\(0\)</span> and <span class="math inline">\(A.size()-1\)</span>, respectively)..</p>
<div class="sourceCode" id="list:test_answer" data-language="c++" data-caption="Test to verify whether the binary search can stop because an answer has been found." label="list:test_answer"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:test_answer-1"><a href="#list:test_answer-1" aria-hidden="true" tabindex="-1"></a><span class="op">]{</span></span>
<span id="list:test_answer-2"><a href="#list:test_answer-2" aria-hidden="true" tabindex="-1"></a>	<span class="at">const</span> <span class="dt">int</span> curr <span class="op">=</span> A<span class="op">[</span>k<span class="op">];</span></span>
<span id="list:test_answer-3"><a href="#list:test_answer-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:test_answer-4"><a href="#list:test_answer-4" aria-hidden="true" tabindex="-1"></a>	<span class="at">const</span> <span class="dt">int</span> prec <span class="op">=</span> A<span class="op">[(</span>k<span class="op">-</span><span class="dv">1</span><span class="op">+</span>A<span class="op">.</span>size<span class="op">())</span> 	<span class="co">//+A.size() due to negative modulo</span></span>
<span id="list:test_answer-5"><a href="#list:test_answer-5" aria-hidden="true" tabindex="-1"></a>	<span class="at">const</span> <span class="dt">int</span> succ <span class="op">=</span> A<span class="op">[(</span>k<span class="op">+</span><span class="dv">1</span><span class="op">)%</span>A<span class="op">.</span>size<span class="op">()];</span></span>
<span id="list:test_answer-6"><a href="#list:test_answer-6" aria-hidden="true" tabindex="-1"></a>	<span class="cf">if</span><span class="op">(</span> <span class="op">(</span>curr <span class="op">&lt;=</span> prec <span class="op">)</span> <span class="op">||</span> <span class="op">(</span>curr <span class="op">&gt;=</span> succ<span class="op">))</span></span>
<span id="list:test_answer-7"><a href="#list:test_answer-7" aria-hidden="true" tabindex="-1"></a>		<span class="cf">return</span> min<span class="op">({</span>prec <span class="op">,</span> curr <span class="op">,</span> succ<span class="op">});</span></span>
<span id="list:test_answer-8"><a href="#list:test_answer-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="binary-search-range-split">Binary search range split</h4>
<p>The last part of the algorithm that still need to be figured out is how and in which split of the array to continue the binary search in the case the element in the middle of the range is not good to determine the answer. An useful property of the sorted rotated array is that when the smallest element is at position <span class="math inline">\(i\)</span> then <strong>all the element on the right side of the element <span class="math inline">\(i\)</span> are smaller than the very first element of the array</strong> (at index <span class="math inline">\(0\)</span>) i.e. the following is always true:</p>
<ul>
<li><p><span class="math inline">\((a_i &lt; a_0) \: \wedge (a_{i+1} &lt; a_0) \: \wedge \ldots (a_{n-1} &lt; a_0)\)</span></p></li>
<li><p><span class="math inline">\((a_{i-1} \geq a_0) \: \wedge \: (a_{i-2} \geq a_0) \: \wedge \: \ldots \: (a_{0} \geq a_0)\)</span></p></li>
</ul>
<p>For instance, consider the sorted rotated array <span class="math inline">\(\{8,9,10,5,6,7\}\)</span>: the minimum element <span class="math inline">\(5\)</span> is at index <span class="math inline">\(3\)</span> and all the elements located between index <span class="math inline">\(3\)</span> and <span class="math inline">\(5\)</span> are strictly smaller than the first element <span class="math inline">\(8\)</span> while all the elements to the left of <span class="math inline">\(5\)</span> are larger or equal than <span class="math inline">\(8\)</span>.</p>
<p>This is the last piece of information that is needed in order to make the binary search work because we can use it to determine which portion of the two subarrays, the one to the left or to the right of <em>middle</em> to discard. Therefore, given an element at position <span class="math inline">\(i\)</span> that is not the answer, we will continue the binary search on the subarray to the left of <span class="math inline">\(i\)</span> if <span class="math inline">\(a_i &gt; a_0\)</span>, otherwise we will use the right side.</p>
<p>By being able to test whether and element is the smallest element in the array, and if not, how to split the array and continue the binary search, we have all the ingredients necessary to solve this problem efficiently.</p>
<p>An implementation of this idea is shown in the Listing <a href="#list:min_rotated_array_log" data-reference-type="ref" data-reference="list:min_rotated_array_log">[list:min_rotated_array_log]</a>. This solution as a complexity of <span class="math inline">\(O(log(n))\)</span> time and <span class="math inline">\(O(1)\)</span> space.</p>
<div class="sourceCode" id="list:min_rotated_array_log" data-language="c++" data-caption="Logaritmic solution to the problem of finding the minimum element in a sorted and rotated array." label="list:min_rotated_array_log"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:min_rotated_array_log-1"><a href="#list:min_rotated_array_log-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:min_rotated_array_log-2"><a href="#list:min_rotated_array_log-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> min_rotated_array_brute_force_log<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">&amp;</span>V<span class="op">)</span></span>
<span id="list:min_rotated_array_log-3"><a href="#list:min_rotated_array_log-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:min_rotated_array_log-4"><a href="#list:min_rotated_array_log-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> size <span class="op">=</span> V<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:min_rotated_array_log-5"><a href="#list:min_rotated_array_log-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_rotated_array_log-6"><a href="#list:min_rotated_array_log-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> l <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> r <span class="op">=</span> size <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:min_rotated_array_log-7"><a href="#list:min_rotated_array_log-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>l <span class="op">&lt;=</span> r<span class="op">)</span></span>
<span id="list:min_rotated_array_log-8"><a href="#list:min_rotated_array_log-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:min_rotated_array_log-9"><a href="#list:min_rotated_array_log-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> mid   <span class="op">=</span> l <span class="op">+</span> <span class="op">(</span>r <span class="op">-</span> l<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="list:min_rotated_array_log-10"><a href="#list:min_rotated_array_log-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> curr <span class="op">=</span> V<span class="op">[</span>mid<span class="op">];</span></span>
<span id="list:min_rotated_array_log-11"><a href="#list:min_rotated_array_log-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> prec <span class="op">=</span> V<span class="op">[(</span>mid <span class="op">-</span> <span class="dv">1</span> <span class="op">+</span> size<span class="op">)</span> <span class="op">%</span> size<span class="op">];</span></span>
<span id="list:min_rotated_array_log-12"><a href="#list:min_rotated_array_log-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> succ <span class="op">=</span> V<span class="op">[(</span>mid <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> size<span class="op">];</span></span>
<span id="list:min_rotated_array_log-13"><a href="#list:min_rotated_array_log-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_rotated_array_log-14"><a href="#list:min_rotated_array_log-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">((</span>curr <span class="op">&lt;=</span> prec<span class="op">)</span> <span class="op">||</span> <span class="op">(</span>curr <span class="op">&gt;=</span> succ<span class="op">))</span></span>
<span id="list:min_rotated_array_log-15"><a href="#list:min_rotated_array_log-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:min_rotated_array_log-16"><a href="#list:min_rotated_array_log-16" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="bu">std::</span>min<span class="op">(</span><span class="bu">std::</span>min<span class="op">(</span>curr<span class="op">,</span> succ<span class="op">),</span> prec<span class="op">);</span></span>
<span id="list:min_rotated_array_log-17"><a href="#list:min_rotated_array_log-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:min_rotated_array_log-18"><a href="#list:min_rotated_array_log-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_rotated_array_log-19"><a href="#list:min_rotated_array_log-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>curr <span class="op">&gt;</span> V<span class="op">[</span><span class="dv">0</span><span class="op">])</span></span>
<span id="list:min_rotated_array_log-20"><a href="#list:min_rotated_array_log-20" aria-hidden="true" tabindex="-1"></a>      l <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:min_rotated_array_log-21"><a href="#list:min_rotated_array_log-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="list:min_rotated_array_log-22"><a href="#list:min_rotated_array_log-22" aria-hidden="true" tabindex="-1"></a>      r <span class="op">=</span> mid <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:min_rotated_array_log-23"><a href="#list:min_rotated_array_log-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:min_rotated_array_log-24"><a href="#list:min_rotated_array_log-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:min_rotated_array_log-25"><a href="#list:min_rotated_array_log-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The code is just a straightforward implementation of the binary search where and determine the range under examination, is the element in the middle of and while and are the element preceeding and succeeding , respectively. Notice how the modulo operation is used to make sure that both and always point a valid element. The time complexity of this implementation is <span class="math inline">\(O(log(n))\)</span> while the space complexity is constant.</p>
<h1 id="ch:search_sorted_rotated_array">Search in sorted and rotated array</h1>
<h2 class="unnumbered" id="introduction-17">Introduction</h2>
<p>The problem presented in this chapter is considered one of the classic among interview questions as has been asked in countless interviews. It can be considered an evolution of the problem of finding the minimum element in a sorted and rotated array which was covered in chapter <a href="#ch:min_rotated_array" data-reference-type="ref" data-reference="ch:min_rotated_array">17</a> at page . The two problems are so linked together that in-fact, it is possible to solve this problem by using the other.</p>
<h2 id="problem-statement-17">Problem statement</h2>
<div class="exercise">
<p>Write a function that given an ascending sorted array <span class="math inline">\(A\)</span> of lenght <span class="math inline">\(n\)</span> with no duplicates and rotated around a pivot <span class="math inline">\(p\)</span> (meaning that the array has been rotated such that the smallest element of <span class="math inline">\(A\)</span> ends up at index <span class="math inline">\(p\)</span>), and an integer <span class="math inline">\(t\)</span>, returns:</p>
<ul>
<li><p>if <span class="math inline">\(t\)</span> does not exists in <span class="math inline">\(A\)</span> it returns <span class="math inline">\(-1\)</span></p></li>
<li><p>otherwise the index of <span class="math inline">\(A\)</span> where <span class="math inline">\(t\)</span> appears.</p></li>
</ul>
<div class="example">
<p><br />
Given <span class="math inline">\(A=\{3,4,5,6,1,2\}\)</span> and <span class="math inline">\(t=5\)</span> the function returns <span class="math inline">\(2\)</span>.</p>
</div>
<div class="example">
<p><br />
Given <span class="math inline">\(A=\{3,4,5,6,1,2\}\)</span> and <span class="math inline">\(t=7\)</span> the function returns <span class="math inline">\(-1\)</span>.</p>
</div>
</div>
<h2 id="clarification-questions-15">Clarification Questions</h2>
<div class="QandA">
<p>Are all the elements unique?</p>
<div class="answered">
<p><em>Yes, you can assume all the elements are unique</em></p>
</div>
<p>Can the input array be empty?</p>
<div class="answered">
<p><em>No, you might assume the array contains at least one element.</em></p>
</div>
</div>
<h2 id="search_sorted_rotated_array:sec:discussion">Discussion</h2>
<h3 id="search_sorted_rotated_array:sec:bruteforce">Brute-force</h3>
<p>As for the problem of finding the minimum in a sorted and rotated array (Chapter <a href="#ch:min_rotated_array" data-reference-type="ref" data-reference="ch:min_rotated_array">17</a>) the brute-force solution is trivial and consist of simply running a linear search in the entire array as shown in Listing <a href="#list:search_sorted_rotated_array:bruteforce" data-reference-type="ref" data-reference="list:search_sorted_rotated_array:bruteforce">[list:search_sorted_rotated_array:bruteforce]</a>. Not surprisingly, the complexity of this implementation if linear in time and constant in space.</p>
<div class="sourceCode" id="list:search_sorted_rotated_array:bruteforce" data-language="c++" data-caption="Brute force solution (linear search) to the problem of finding an element in a sorted and potentially rotated array." label="list:search_sorted_rotated_array:bruteforce"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:search_sorted_rotated_array:bruteforce-1"><a href="#list:search_sorted_rotated_array:bruteforce-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> search_sorted_rotated_array_bruteforce<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> A<span class="op">,</span></span>
<span id="list:search_sorted_rotated_array:bruteforce-2"><a href="#list:search_sorted_rotated_array:bruteforce-2" aria-hidden="true" tabindex="-1"></a>                                           <span class="at">const</span> <span class="dt">int</span> t<span class="op">)</span></span>
<span id="list:search_sorted_rotated_array:bruteforce-3"><a href="#list:search_sorted_rotated_array:bruteforce-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:search_sorted_rotated_array:bruteforce-4"><a href="#list:search_sorted_rotated_array:bruteforce-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> it <span class="op">=</span> <span class="bu">std::</span>find<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>A<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>A<span class="op">),</span> t<span class="op">);</span></span>
<span id="list:search_sorted_rotated_array:bruteforce-5"><a href="#list:search_sorted_rotated_array:bruteforce-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> it <span class="op">!=</span> <span class="bu">std::</span>end<span class="op">(</span>A<span class="op">)</span> <span class="op">?</span> <span class="bu">std::</span>distance<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>A<span class="op">),</span> it<span class="op">)</span> <span class="op">:</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:search_sorted_rotated_array:bruteforce-6"><a href="#list:search_sorted_rotated_array:bruteforce-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="search_sorted_rotated_array:sec:log">Logarithmic time solution</h3>
<p>The solution presented in Section <a href="#search_sorted_rotated_array:sec:bruteforce" data-reference-type="ref" data-reference="search_sorted_rotated_array:sec:bruteforce">18.3.1</a> is far from being optimal because we can solve this problem in logarithmic time and constant space (as we did for the problem in Chapter <a href="#ch:min_rotated_array" data-reference-type="ref" data-reference="ch:min_rotated_array">17</a>).</p>
<p>The main idea is that we need to take advantage of the fact that the array is sorted and that if we know the pivot location, <span class="math inline">\(p\)</span> then we can logically divide the array into two starting and ending at indices:</p>
<ol>
<li><p><span class="math inline">\(0\)</span> and <span class="math inline">\(p-1\)</span></p></li>
<li><p><span class="math inline">\(p\)</span> and <span class="math inline">\(n-1\)</span> (<span class="math inline">\(n\)</span> is the size of the array)</p></li>
</ol>
<p>Both arrays are sorted and thus binary search can be applied in each of the subarrays separately. This is why we can reuse the solution to the problem of finding the minimum element in a sorted and rotated array to solve this one.</p>
<p>To summarize the algorithm proceed as follows:</p>
<ul>
<li><p>search for the pivot index <span class="math inline">\(p\)</span></p></li>
<li><p>search for <span class="math inline">\(t\)</span> in <span class="math inline">\(A[0,p-1]\)</span>. If the search is successful return the found index for <span class="math inline">\(t\)</span>.</p></li>
<li><p>search for <span class="math inline">\(t\)</span> in <span class="math inline">\(A[p,n-1]\)</span>. If the search is successful return the found index for <span class="math inline">\(t\)</span>.</p></li>
<li><p>None of the searches had success. <span class="math inline">\(t\)</span> is not in the array. Return <span class="math inline">\(-1\)</span>.</p></li>
</ul>
<p>This algorithm can be implemented as shown in Listing <a href="#list:search_sorted_rotated_array:log" data-reference-type="ref" data-reference="list:search_sorted_rotated_array:log">[list:search_sorted_rotated_array:log]</a>. Note that the function is almost identical to the one in Listing <a href="#list:min_rotated_array_log" data-reference-type="ref" data-reference="list:min_rotated_array_log">[list:min_rotated_array_log]</a> and has been modified so to return the index instead of the value for the smallest element in the array.</p>
<p>Also note that the function is not implemented as because that might cause overflow during the computation of even if the final result fits in a . Specifically, it fails if the sum of low and high is greater than the maximum positive value (<span class="math inline">\(2^{31} - 1\)</span> in most C++ implementation). The sum overflows to a negative value, and the value stays negative when divided by two. In C++ this causes an array index out of bounds with unpredictable results. In Java, it throws .</p>
<p>Finally, the function implements a simple and canonical recursive binary search. The complexity of the overall implementation is <span class="math inline">\(O(log(n))\)</span> in time and <span class="math inline">\(O(1)\)</span> in space.</p>
<div class="sourceCode" id="list:search_sorted_rotated_array:log" data-language="c++" data-caption="Log time solution (using binary search) to the problem of finding an element in a sorted and rotated array." label="list:search_sorted_rotated_array:log"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:search_sorted_rotated_array:log-1"><a href="#list:search_sorted_rotated_array:log-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> Range <span class="op">=</span> <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;;</span></span>
<span id="list:search_sorted_rotated_array:log-2"><a href="#list:search_sorted_rotated_array:log-2" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">unsigned</span> midpoint<span class="op">(</span><span class="at">const</span> <span class="dt">unsigned</span> l<span class="op">,</span> <span class="at">const</span> <span class="dt">unsigned</span> r<span class="op">)</span></span>
<span id="list:search_sorted_rotated_array:log-3"><a href="#list:search_sorted_rotated_array:log-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:search_sorted_rotated_array:log-4"><a href="#list:search_sorted_rotated_array:log-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> l <span class="op">+</span> <span class="op">(</span>r <span class="op">-</span> l<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="list:search_sorted_rotated_array:log-5"><a href="#list:search_sorted_rotated_array:log-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:search_sorted_rotated_array:log-6"><a href="#list:search_sorted_rotated_array:log-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:search_sorted_rotated_array:log-7"><a href="#list:search_sorted_rotated_array:log-7" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">int</span> positive_modulo<span class="op">(</span><span class="at">const</span> <span class="dt">int</span> n<span class="op">,</span> <span class="at">const</span> <span class="dt">int</span> m<span class="op">)</span></span>
<span id="list:search_sorted_rotated_array:log-8"><a href="#list:search_sorted_rotated_array:log-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:search_sorted_rotated_array:log-9"><a href="#list:search_sorted_rotated_array:log-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">(</span>n <span class="op">+</span> m<span class="op">)</span> <span class="op">%</span> m<span class="op">;</span></span>
<span id="list:search_sorted_rotated_array:log-10"><a href="#list:search_sorted_rotated_array:log-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:search_sorted_rotated_array:log-11"><a href="#list:search_sorted_rotated_array:log-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:search_sorted_rotated_array:log-12"><a href="#list:search_sorted_rotated_array:log-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> find_idx_min<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> A<span class="op">)</span></span>
<span id="list:search_sorted_rotated_array:log-13"><a href="#list:search_sorted_rotated_array:log-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:search_sorted_rotated_array:log-14"><a href="#list:search_sorted_rotated_array:log-14" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> size <span class="op">=</span> A<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:search_sorted_rotated_array:log-15"><a href="#list:search_sorted_rotated_array:log-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> l          <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:search_sorted_rotated_array:log-16"><a href="#list:search_sorted_rotated_array:log-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> r          <span class="op">=</span> A<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:search_sorted_rotated_array:log-17"><a href="#list:search_sorted_rotated_array:log-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>A<span class="op">[</span>l<span class="op">]</span> <span class="op">&lt;</span> A<span class="op">[</span>r<span class="op">])</span></span>
<span id="list:search_sorted_rotated_array:log-18"><a href="#list:search_sorted_rotated_array:log-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> l<span class="op">;</span></span>
<span id="list:search_sorted_rotated_array:log-19"><a href="#list:search_sorted_rotated_array:log-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>l <span class="op">&lt;=</span> r<span class="op">)</span></span>
<span id="list:search_sorted_rotated_array:log-20"><a href="#list:search_sorted_rotated_array:log-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:search_sorted_rotated_array:log-21"><a href="#list:search_sorted_rotated_array:log-21" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> mid <span class="op">=</span> midpoint<span class="op">(</span>l<span class="op">,</span> r<span class="op">);</span></span>
<span id="list:search_sorted_rotated_array:log-22"><a href="#list:search_sorted_rotated_array:log-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:search_sorted_rotated_array:log-23"><a href="#list:search_sorted_rotated_array:log-23" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> curr <span class="op">=</span> A<span class="op">[</span>mid<span class="op">];</span></span>
<span id="list:search_sorted_rotated_array:log-24"><a href="#list:search_sorted_rotated_array:log-24" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> next <span class="op">=</span> A<span class="op">[</span>positive_modulo<span class="op">(</span>mid <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> size<span class="op">)];</span></span>
<span id="list:search_sorted_rotated_array:log-25"><a href="#list:search_sorted_rotated_array:log-25" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> prec <span class="op">=</span> A<span class="op">[</span>positive_modulo<span class="op">(</span>mid <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> size<span class="op">)];</span></span>
<span id="list:search_sorted_rotated_array:log-26"><a href="#list:search_sorted_rotated_array:log-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:search_sorted_rotated_array:log-27"><a href="#list:search_sorted_rotated_array:log-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>curr <span class="op">&lt;=</span> next <span class="op">&amp;&amp;</span> curr <span class="op">&lt;=</span> prec<span class="op">)</span></span>
<span id="list:search_sorted_rotated_array:log-28"><a href="#list:search_sorted_rotated_array:log-28" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> mid<span class="op">;</span></span>
<span id="list:search_sorted_rotated_array:log-29"><a href="#list:search_sorted_rotated_array:log-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>curr <span class="op">&lt;</span> A<span class="op">[</span><span class="dv">0</span><span class="op">])</span></span>
<span id="list:search_sorted_rotated_array:log-30"><a href="#list:search_sorted_rotated_array:log-30" aria-hidden="true" tabindex="-1"></a>      r <span class="op">=</span> mid <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:search_sorted_rotated_array:log-31"><a href="#list:search_sorted_rotated_array:log-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="list:search_sorted_rotated_array:log-32"><a href="#list:search_sorted_rotated_array:log-32" aria-hidden="true" tabindex="-1"></a>      l <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:search_sorted_rotated_array:log-33"><a href="#list:search_sorted_rotated_array:log-33" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:search_sorted_rotated_array:log-34"><a href="#list:search_sorted_rotated_array:log-34" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> l<span class="op">;</span></span>
<span id="list:search_sorted_rotated_array:log-35"><a href="#list:search_sorted_rotated_array:log-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:search_sorted_rotated_array:log-36"><a href="#list:search_sorted_rotated_array:log-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:search_sorted_rotated_array:log-37"><a href="#list:search_sorted_rotated_array:log-37" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> binary_search<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> A<span class="op">,</span> <span class="at">const</span> Range<span class="op">&amp;</span> range<span class="op">,</span> <span class="at">const</span> <span class="dt">int</span> t<span class="op">)</span></span>
<span id="list:search_sorted_rotated_array:log-38"><a href="#list:search_sorted_rotated_array:log-38" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:search_sorted_rotated_array:log-39"><a href="#list:search_sorted_rotated_array:log-39" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> <span class="op">[</span>l<span class="op">,</span> r<span class="op">]</span> <span class="op">=</span> range<span class="op">;</span></span>
<span id="list:search_sorted_rotated_array:log-40"><a href="#list:search_sorted_rotated_array:log-40" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>l <span class="op">&gt;</span> r<span class="op">)</span></span>
<span id="list:search_sorted_rotated_array:log-41"><a href="#list:search_sorted_rotated_array:log-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:search_sorted_rotated_array:log-42"><a href="#list:search_sorted_rotated_array:log-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:search_sorted_rotated_array:log-43"><a href="#list:search_sorted_rotated_array:log-43" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> mid <span class="op">=</span> midpoint<span class="op">(</span>l<span class="op">,</span> r<span class="op">);</span></span>
<span id="list:search_sorted_rotated_array:log-44"><a href="#list:search_sorted_rotated_array:log-44" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>A<span class="op">[</span>mid<span class="op">]</span> <span class="op">==</span> t<span class="op">)</span></span>
<span id="list:search_sorted_rotated_array:log-45"><a href="#list:search_sorted_rotated_array:log-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mid<span class="op">;</span></span>
<span id="list:search_sorted_rotated_array:log-46"><a href="#list:search_sorted_rotated_array:log-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:search_sorted_rotated_array:log-47"><a href="#list:search_sorted_rotated_array:log-47" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>A<span class="op">[</span>mid<span class="op">]</span> <span class="op">&lt;</span> t<span class="op">)</span></span>
<span id="list:search_sorted_rotated_array:log-48"><a href="#list:search_sorted_rotated_array:log-48" aria-hidden="true" tabindex="-1"></a>    l <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:search_sorted_rotated_array:log-49"><a href="#list:search_sorted_rotated_array:log-49" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span></span>
<span id="list:search_sorted_rotated_array:log-50"><a href="#list:search_sorted_rotated_array:log-50" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> mid <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:search_sorted_rotated_array:log-51"><a href="#list:search_sorted_rotated_array:log-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:search_sorted_rotated_array:log-52"><a href="#list:search_sorted_rotated_array:log-52" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> binary_search<span class="op">(</span>A<span class="op">,</span> <span class="op">{</span>l<span class="op">,</span> r<span class="op">},</span> t<span class="op">);</span></span>
<span id="list:search_sorted_rotated_array:log-53"><a href="#list:search_sorted_rotated_array:log-53" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:search_sorted_rotated_array:log-54"><a href="#list:search_sorted_rotated_array:log-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:search_sorted_rotated_array:log-55"><a href="#list:search_sorted_rotated_array:log-55" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> search_sorted_rotated_array_log<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> A<span class="op">,</span> <span class="dt">int</span> t<span class="op">)</span></span>
<span id="list:search_sorted_rotated_array:log-56"><a href="#list:search_sorted_rotated_array:log-56" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:search_sorted_rotated_array:log-57"><a href="#list:search_sorted_rotated_array:log-57" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>A<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:search_sorted_rotated_array:log-58"><a href="#list:search_sorted_rotated_array:log-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:search_sorted_rotated_array:log-59"><a href="#list:search_sorted_rotated_array:log-59" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> idx <span class="op">=</span> find_idx_min<span class="op">(</span>A<span class="op">);</span></span>
<span id="list:search_sorted_rotated_array:log-60"><a href="#list:search_sorted_rotated_array:log-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:search_sorted_rotated_array:log-61"><a href="#list:search_sorted_rotated_array:log-61" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> binary_search<span class="op">(</span>A<span class="op">,</span> Range<span class="op">(</span><span class="dv">0</span><span class="op">,</span> idx <span class="op">-</span> <span class="dv">1</span><span class="op">),</span> t<span class="op">);</span></span>
<span id="list:search_sorted_rotated_array:log-62"><a href="#list:search_sorted_rotated_array:log-62" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>ans <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span></span>
<span id="list:search_sorted_rotated_array:log-63"><a href="#list:search_sorted_rotated_array:log-63" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">=</span> binary_search<span class="op">(</span>A<span class="op">,</span> Range<span class="op">(</span>idx<span class="op">,</span> A<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">),</span> t<span class="op">);</span></span>
<span id="list:search_sorted_rotated_array:log-64"><a href="#list:search_sorted_rotated_array:log-64" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:search_sorted_rotated_array:log-65"><a href="#list:search_sorted_rotated_array:log-65" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="ch:verify_BST">Verify BST property</h1>
<h2 class="unnumbered" id="introduction-18">Introduction</h2>
<p>This problem is binary search trees, which are one of the most discussed data structures during coding interviews. This problem has been asked at <strong>Microsoft, Google, Amazon, Ebay</strong> and it is among the group of questions that should be well understood and digested because its solution’s structure can be applied to many others on binary trees.</p>
<h2 id="problem-statement-18">Problem statement</h2>
<div class="exercise">
<p>Given a binary tree <span class="citation" data-cites="cit:wiki:BST"></span>, determine if it is a valid binary search tree.</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li><p>The left subtree of a node contains only nodes with keys less than the node’s key.</p></li>
<li><p>The right subtree of a node contains only nodes with keys greater than the node’s key.</p></li>
</ul>
<p>You can assume that the tree structure is defined as shown in Listing <a href="#list:verify_BST:tree_structure" data-reference-type="ref" data-reference="list:verify_BST:tree_structure">[list:verify_BST:tree_structure]</a>:</p>
</div>
<div class="sourceCode" id="list:verify_BST:tree_structure" data-language="c++" data-caption="Binary tree definition used in this exercice." label="list:verify_BST:tree_structure"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:verify_BST:tree_structure-1"><a href="#list:verify_BST:tree_structure-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:verify_BST:tree_structure-2"><a href="#list:verify_BST:tree_structure-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">struct</span> TreeNode <span class="op">{</span></span>
<span id="list:verify_BST:tree_structure-3"><a href="#list:verify_BST:tree_structure-3" aria-hidden="true" tabindex="-1"></a>     <span class="dt">int</span> val<span class="op">;</span></span>
<span id="list:verify_BST:tree_structure-4"><a href="#list:verify_BST:tree_structure-4" aria-hidden="true" tabindex="-1"></a>     TreeNode <span class="op">*</span>left<span class="op">;</span></span>
<span id="list:verify_BST:tree_structure-5"><a href="#list:verify_BST:tree_structure-5" aria-hidden="true" tabindex="-1"></a>     TreeNode <span class="op">*</span>right<span class="op">;</span></span>
<span id="list:verify_BST:tree_structure-6"><a href="#list:verify_BST:tree_structure-6" aria-hidden="true" tabindex="-1"></a>     TreeNode<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">:</span> val<span class="op">(</span>x<span class="op">),</span> left<span class="op">(</span><span class="kw">nullptr</span><span class="op">),</span> right<span class="op">(</span><span class="kw">nullptr</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="list:verify_BST:tree_structure-7"><a href="#list:verify_BST:tree_structure-7" aria-hidden="true" tabindex="-1"></a> <span class="op">};</span></span></code></pre></div>
<div class="example">
<p><br />
For the following tree the function should return <strong>false</strong>.</p>
<pre><code>	    5
	   / \
	  1   4
	     / \
	    3   6
	</code></pre>
</div>
<div class="example">
<p><br />
For the following tree the function should return <strong>true</strong>.</p>
<pre><code>	    2
	   / \
	  1   3
	</code></pre>
</div>
<div class="example">
<p><span id="example:verify_BST_:one" label="example:verify_BST_:one">[example:verify_BST_:one]</span><br />
For the following tree the function should return <strong>true</strong>.</p>
<pre><code>	    10
	   / \
	  1   14
	 / \    \
0  9     16
        /  \
       15   19
	</code></pre>
</div>
<h2 id="clarification-questions-16">Clarification Questions</h2>
<div class="QandA">
<p>Are all elements in the tree distinct?</p>
<div class="answered">
<p><em>Yes, you can assume all elemets are distinct.</em></p>
</div>
<p>How many nodes does the tree contain?</p>
<div class="answered">
<p><em>Up to <span class="math inline">\(10^6\)</span> nodes.</em></p>
</div>
</div>
<h2 id="verify_BST:sec:discussion">Discussion</h2>
<p>The question is asking for a function that verifies whether a given tree is a binary search tree or not. But what does it mean exactly? A tree <span class="math inline">\(T\)</span> is a binary search tree if:</p>
<ol>
<li><p>Every node has two subtree (named left and right, respectively) i.e. <span class="math inline">\(T\)</span> is a binary tree</p></li>
<li><p>given a node <span class="math inline">\(n\)</span> in the tree <strong>all</strong> the nodes in its left subtree are smaller than the value in <span class="math inline">\(n\)</span>.</p></li>
<li><p>additionally, <strong>all</strong> nodes in the right subtree are larger.</p></li>
</ol>
<p>For instance the tree in the example <a href="#ex:verify_BST:no_BST" data-reference-type="ref" data-reference="ex:verify_BST:no_BST">[ex:verify_BST:no_BST]</a> is not a valid BST because node <span class="math inline">\(15\)</span> is a right descendent of the root but is it not greater than it.</p>
<pre><code>[language=c++,frame=single,caption={Binary tree, but not a binary search tree.}&quot;,label=ex:verify_BST:no_BST, numbers=none]
	    20
	    / \
	   10 30
	     / \
	    15  40</code></pre>
<h3 id="a-common-mistake">A common mistake</h3>
<p>When solving this question a very common mistake is to use the following greedy algorithm to verify the BST property: for each node <span class="math inline">\(n\)</span> of the tree verify that <code>n.val &gt; n-&gt;left.val &amp;&amp; n.val &lt; n-&gt;right.val</code> i.e. that the value of the node curreclty analyzed is greater than the value of its left child but smaller than its right one. This algorithm might work even for some trees but fails on others, and it is thus not correct. For instance the algorithm described above fails on the example <a href="#ex:verify_BST:no_BST" data-reference-type="ref" data-reference="ex:verify_BST:no_BST">[ex:verify_BST:no_BST]</a> as it will say that it is a valid BST.</p>
<p>It is clear at this point that all nodes in the tree need to be visited in order to verify whether the BST property holds and that somehow the information about the values from nodes higher in the tree need to be passed down to the children and descendants. Let’s see how this can be done.</p>
<h3 id="verify_BST:sec:topdown">Top Down approach</h3>
<p>When talking about tree, one should immediately think about a top down approach and recursion. This problem is no different and in-fact becomes almost trivial if approached using recursione and the following key considerations are made:</p>
<ol>
<li><p>every node can be thought as the root of a tree for which the BST property needs to hold (and thus verified).</p></li>
<li><p>empty trees satisfy the BST property</p></li>
<li><p>every nodes must be within a certain range that is determined by its parent. For instance, given the node <span class="math inline">\(15\)</span> in the example <a href="#example:verify_BST_:one" data-reference-type="ref" data-reference="example:verify_BST_:one">[example:verify_BST_:one]</a>, in order for the tree to be a valid it must be within the range <span class="math inline">\((14,16)\)</span>. Why is that? Because its parent, the node <span class="math inline">\(16\)</span> must be within the range <span class="math inline">\((14,+\infty)\)</span> and additionally node <span class="math inline">\(15\)</span>, being the left subtree of node <span class="math inline">\(16\)</span> must be lower than its parent. The same reasoning can be applied recusively up to the root of the tree where the range of the value is simply <span class="math inline">\((-\infty, +\infty)\)</span> (no constraints).</p>
<p>The node <span class="math inline">\(9\)</span> in the example <a href="#example:verify_BST_:one" data-reference-type="ref" data-reference="example:verify_BST_:one">[example:verify_BST_:one]</a> must be within the range <span class="math inline">\((1,10)\)</span> for similar reasons.</p></li>
</ol>
<p>To summarize, we can visit the tree in a top-down fashion and maintain a range that the current node must satisfy starting with a range equal to <span class="math inline">\((-\infty, +\infty)\)</span> for the root (meaning that de-facto there is no restriction on the value the root can take). Once the value is checked against the range, then the same function can be applied to the right and left children but making sure that the range is modified accordingly when recurring on the children.</p>
<p>But how does such a range change when visiting down the tree? The idea is simple: Given a node <span class="math inline">\(n\)</span> with parent <span class="math inline">\(p\)</span> and range <span class="math inline">\((l_p, u_p)\)</span> then:</p>
<ul>
<li><p>if <span class="math inline">\(n\)</span> is the right child of <span class="math inline">\(p\)</span>, then the range for <span class="math inline">\(n\)</span> is: <span class="math inline">\((p, u_p)\)</span>: all nodes in the right subtree of <span class="math inline">\(p\)</span> must be <strong>higher</strong> than <span class="math inline">\(p\)</span>. Note that <span class="math inline">\(p &gt; l_p\)</span> (otherwise the BST property would be violeted when checking <span class="math inline">\(p\)</span>) and thus the range for <span class="math inline">\(n\)</span> becomes smaller meaning that all the constrains coming from the ancestors of <span class="math inline">\(p\)</span> will also be satisfied with the new range <span class="math inline">\((p, u_p)\)</span>.</p></li>
<li><p>A similar reasoning applies if <span class="math inline">\(n\)</span> is the left child of <span class="math inline">\(p\)</span>. The range for <span class="math inline">\(n\)</span> is then : <span class="math inline">\((l_u,p)\)</span>.</p></li>
</ul>
<p>The idea above is shown in Listing <a href="#list:verify_BST" data-reference-type="ref" data-reference="list:verify_BST">[list:verify_BST]</a>. Note how short and concise the code can be implemented with recursion. The complexity of this approach is <span class="math inline">\(O(n)\)</span> time and <span class="math inline">\(O(1)\)</span> space (if you do not count the space on the stack taken by the recursion.</p>
<div class="sourceCode" id="list:verify_BST" data-language="c++" data-caption="Linear time recursive solution to the problem of verifying the BST property." label="list:verify_BST"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:verify_BST-1"><a href="#list:verify_BST-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:verify_BST-2"><a href="#list:verify_BST-2" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">bool</span> isValidBST_helper<span class="op">(</span><span class="at">const</span> TreeNode<span class="op">*</span> <span class="at">const</span> root<span class="op">,</span></span>
<span id="list:verify_BST-3"><a href="#list:verify_BST-3" aria-hidden="true" tabindex="-1"></a>                              <span class="at">const</span> <span class="dt">long</span> lower<span class="op">,</span></span>
<span id="list:verify_BST-4"><a href="#list:verify_BST-4" aria-hidden="true" tabindex="-1"></a>                              <span class="at">const</span> <span class="dt">long</span> upper<span class="op">)</span></span>
<span id="list:verify_BST-5"><a href="#list:verify_BST-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:verify_BST-6"><a href="#list:verify_BST-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>root<span class="op">)</span></span>
<span id="list:verify_BST-7"><a href="#list:verify_BST-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:verify_BST-8"><a href="#list:verify_BST-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:verify_BST-9"><a href="#list:verify_BST-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">(</span>root<span class="op">-&gt;</span>val <span class="op">&gt;</span> lower<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">(</span>root<span class="op">-&gt;</span>val <span class="op">&lt;</span> upper<span class="op">)</span></span>
<span id="list:verify_BST-10"><a href="#list:verify_BST-10" aria-hidden="true" tabindex="-1"></a>         <span class="op">&amp;&amp;</span> isValidBST_helper<span class="op">(</span>root<span class="op">-&gt;</span>left<span class="op">,</span> lower<span class="op">,</span> root<span class="op">-&gt;</span>val<span class="op">)</span></span>
<span id="list:verify_BST-11"><a href="#list:verify_BST-11" aria-hidden="true" tabindex="-1"></a>         <span class="op">&amp;&amp;</span> isValidBST_helper<span class="op">(</span>root<span class="op">-&gt;</span>right<span class="op">,</span> root<span class="op">-&gt;</span>val<span class="op">,</span> upper<span class="op">);</span></span>
<span id="list:verify_BST-12"><a href="#list:verify_BST-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:verify_BST-13"><a href="#list:verify_BST-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:verify_BST-14"><a href="#list:verify_BST-14" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> isValidBST_top_down<span class="op">(</span>TreeNode<span class="op">*</span> root<span class="op">)</span></span>
<span id="list:verify_BST-15"><a href="#list:verify_BST-15" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:verify_BST-16"><a href="#list:verify_BST-16" aria-hidden="true" tabindex="-1"></a>  <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">long</span> INF <span class="op">=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">long</span><span class="op">&gt;::</span>max<span class="op">();</span></span>
<span id="list:verify_BST-17"><a href="#list:verify_BST-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> isValidBST_helper<span class="op">(</span>root<span class="op">,</span> <span class="op">-</span>INF<span class="op">,</span> INF<span class="op">);</span></span>
<span id="list:verify_BST-18"><a href="#list:verify_BST-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="brute-force-3">Brute force</h3>
<p>Another way to solve this problem is to read carefully the definition of BST and realize that, for each node <span class="math inline">\(n\)</span> we need to check if the left subtree contains any element greater than <span class="math inline">\(n\)</span> and whether its right subtree contains any element smaller than <span class="math inline">\(n\)</span>. This problem becomes almost trivial provided two functions are available, <code>min_tree(TreeNode* root)</code> and <code>max_tree(TreeNode* root)</code> for retrieving the min and max value respectively of a tree. The idea above can be implemented as shown in Listing <a href="#list:verify_BST_bruteforce" data-reference-type="ref" data-reference="list:verify_BST_bruteforce">[list:verify_BST_bruteforce]</a></p>
<div class="sourceCode" id="list:verify_BST_rbuteforce" data-language="c++" data-caption="Quadratic solution to the problem of verifying the BST property." label="list:verify_BST_rbuteforce"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:verify_BST_rbuteforce-1"><a href="#list:verify_BST_rbuteforce-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="list:verify_BST_rbuteforce-2"><a href="#list:verify_BST_rbuteforce-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:verify_BST_rbuteforce-3"><a href="#list:verify_BST_rbuteforce-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> tree_min<span class="op">(</span>TreeNode <span class="op">*</span>root<span class="op">)</span></span>
<span id="list:verify_BST_rbuteforce-4"><a href="#list:verify_BST_rbuteforce-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:verify_BST_rbuteforce-5"><a href="#list:verify_BST_rbuteforce-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>root<span class="op">)</span></span>
<span id="list:verify_BST_rbuteforce-6"><a href="#list:verify_BST_rbuteforce-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>max<span class="op">();</span></span>
<span id="list:verify_BST_rbuteforce-7"><a href="#list:verify_BST_rbuteforce-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">std::</span>min<span class="op">({</span>root<span class="op">-&gt;</span>val<span class="op">,</span> tree_min<span class="op">(</span>root<span class="op">-&gt;</span>left<span class="op">),</span> tree_min<span class="op">(</span>root<span class="op">-&gt;</span>right<span class="op">)});</span></span>
<span id="list:verify_BST_rbuteforce-8"><a href="#list:verify_BST_rbuteforce-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:verify_BST_rbuteforce-9"><a href="#list:verify_BST_rbuteforce-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:verify_BST_rbuteforce-10"><a href="#list:verify_BST_rbuteforce-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> tree_max<span class="op">(</span>TreeNode <span class="op">*</span>root<span class="op">)</span></span>
<span id="list:verify_BST_rbuteforce-11"><a href="#list:verify_BST_rbuteforce-11" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:verify_BST_rbuteforce-12"><a href="#list:verify_BST_rbuteforce-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>root<span class="op">)</span></span>
<span id="list:verify_BST_rbuteforce-13"><a href="#list:verify_BST_rbuteforce-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>min<span class="op">();</span></span>
<span id="list:verify_BST_rbuteforce-14"><a href="#list:verify_BST_rbuteforce-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">std::</span>max<span class="op">({</span>root<span class="op">-&gt;</span>val<span class="op">,</span> tree_max<span class="op">(</span>root<span class="op">-&gt;</span>left<span class="op">),</span> tree_max<span class="op">(</span>root<span class="op">-&gt;</span>right<span class="op">)});</span></span>
<span id="list:verify_BST_rbuteforce-15"><a href="#list:verify_BST_rbuteforce-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:verify_BST_rbuteforce-16"><a href="#list:verify_BST_rbuteforce-16" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> isValidBST_min_max<span class="op">(</span>TreeNode <span class="op">*</span>root<span class="op">)</span></span>
<span id="list:verify_BST_rbuteforce-17"><a href="#list:verify_BST_rbuteforce-17" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:verify_BST_rbuteforce-18"><a href="#list:verify_BST_rbuteforce-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>root<span class="op">)</span></span>
<span id="list:verify_BST_rbuteforce-19"><a href="#list:verify_BST_rbuteforce-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:verify_BST_rbuteforce-20"><a href="#list:verify_BST_rbuteforce-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:verify_BST_rbuteforce-21"><a href="#list:verify_BST_rbuteforce-21" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> left_ok <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:verify_BST_rbuteforce-22"><a href="#list:verify_BST_rbuteforce-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>root<span class="op">-&gt;</span>left<span class="op">)</span></span>
<span id="list:verify_BST_rbuteforce-23"><a href="#list:verify_BST_rbuteforce-23" aria-hidden="true" tabindex="-1"></a>    left_ok <span class="op">=</span> tree_max<span class="op">(</span>root<span class="op">-&gt;</span>left<span class="op">)</span> <span class="op">&lt;=</span> root<span class="op">-&gt;</span>val<span class="op">;</span></span>
<span id="list:verify_BST_rbuteforce-24"><a href="#list:verify_BST_rbuteforce-24" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> right_ok <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:verify_BST_rbuteforce-25"><a href="#list:verify_BST_rbuteforce-25" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>root<span class="op">-&gt;</span>right<span class="op">)</span></span>
<span id="list:verify_BST_rbuteforce-26"><a href="#list:verify_BST_rbuteforce-26" aria-hidden="true" tabindex="-1"></a>    right_ok <span class="op">=</span> tree_min<span class="op">(</span>root<span class="op">-&gt;</span>right<span class="op">)</span> <span class="op">&gt;</span> root<span class="op">-&gt;</span>val<span class="op">;</span></span>
<span id="list:verify_BST_rbuteforce-27"><a href="#list:verify_BST_rbuteforce-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:verify_BST_rbuteforce-28"><a href="#list:verify_BST_rbuteforce-28" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">(</span>left_ok <span class="op">&amp;&amp;</span> right_ok<span class="op">)</span></span>
<span id="list:verify_BST_rbuteforce-29"><a href="#list:verify_BST_rbuteforce-29" aria-hidden="true" tabindex="-1"></a>         <span class="op">&amp;&amp;</span> <span class="op">(</span>isValidBST_min_max<span class="op">(</span>root<span class="op">-&gt;</span>left<span class="op">)</span> <span class="op">&amp;&amp;</span> isValidBST_min_max<span class="op">(</span>root<span class="op">-&gt;</span>right<span class="op">));</span></span>
<span id="list:verify_BST_rbuteforce-30"><a href="#list:verify_BST_rbuteforce-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="ch:clone_list_random_pointer">Clone a linked list with random pointer</h1>
<h2 class="unnumbered" id="introduction-19">Introduction</h2>
<p>This section discusses a very cool and interesting problem on linked list. The linked list we are dealing with here is a singly linked one, with an additional pointer that <strong>might</strong> point to another node in the list. The C++ definition of said list is given in Listing <a href="#list:clone_list_random_pointer:list_definition" data-reference-type="ref" data-reference="list:clone_list_random_pointer:list_definition">[list:clone_list_random_pointer:list_definition]</a>. Please note the additional field <code>random</code> which differentiates it from other linked list definitions seen in other chapters (See Capter <a href="#ch:delete_duplicates_list" data-reference-type="ref" data-reference="ch:delete_duplicates_list">21</a> and Listing <a href="#list:delete_duplicates_list:linked_list" data-reference-type="ref" data-reference="list:delete_duplicates_list:linked_list">[list:delete_duplicates_list:linked_list]</a>).</p>
<div class="sourceCode" id="list:delete_duplicates_list:linked_list" data-language="c++" data-caption="Definition of a linked list with a random pointer." label="list:delete_duplicates_list:linked_list"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:delete_duplicates_list:linked_list-1"><a href="#list:delete_duplicates_list:linked_list-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:delete_duplicates_list:linked_list-2"><a href="#list:delete_duplicates_list:linked_list-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> </span>
<span id="list:delete_duplicates_list:linked_list-3"><a href="#list:delete_duplicates_list:linked_list-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Node</span>
<span id="list:delete_duplicates_list:linked_list-4"><a href="#list:delete_duplicates_list:linked_list-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:delete_duplicates_list:linked_list-5"><a href="#list:delete_duplicates_list:linked_list-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="list:delete_duplicates_list:linked_list-6"><a href="#list:delete_duplicates_list:linked_list-6" aria-hidden="true" tabindex="-1"></a>  T val<span class="op">;</span></span>
<span id="list:delete_duplicates_list:linked_list-7"><a href="#list:delete_duplicates_list:linked_list-7" aria-hidden="true" tabindex="-1"></a>  Node <span class="op">*</span>next<span class="op">;</span></span>
<span id="list:delete_duplicates_list:linked_list-8"><a href="#list:delete_duplicates_list:linked_list-8" aria-hidden="true" tabindex="-1"></a>  Node <span class="op">*</span>random<span class="op">;</span></span>
<span id="list:delete_duplicates_list:linked_list-9"><a href="#list:delete_duplicates_list:linked_list-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:delete_duplicates_list:linked_list-10"><a href="#list:delete_duplicates_list:linked_list-10" aria-hidden="true" tabindex="-1"></a>  Node<span class="op">(</span><span class="at">const</span> T <span class="op">&amp;</span>_val<span class="op">)</span></span>
<span id="list:delete_duplicates_list:linked_list-11"><a href="#list:delete_duplicates_list:linked_list-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:delete_duplicates_list:linked_list-12"><a href="#list:delete_duplicates_list:linked_list-12" aria-hidden="true" tabindex="-1"></a>    val    <span class="op">=</span> _val<span class="op">;</span></span>
<span id="list:delete_duplicates_list:linked_list-13"><a href="#list:delete_duplicates_list:linked_list-13" aria-hidden="true" tabindex="-1"></a>    next   <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="list:delete_duplicates_list:linked_list-14"><a href="#list:delete_duplicates_list:linked_list-14" aria-hidden="true" tabindex="-1"></a>    random <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="list:delete_duplicates_list:linked_list-15"><a href="#list:delete_duplicates_list:linked_list-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:delete_duplicates_list:linked_list-16"><a href="#list:delete_duplicates_list:linked_list-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="problem-statement-19">Problem statement</h2>
<div class="exercise">
<p>Given a linked list of the type defined in Listing <a href="#list:clone_list_random_pointer:list_definition" data-reference-type="ref" data-reference="list:clone_list_random_pointer:list_definition">[list:clone_list_random_pointer:list_definition]</a> return a deep-copy of it.</p>
</div>
<p>In this chapter we will be representing graphically a list using a list of pairs of integers. Each pair <span class="math inline">\((v,r)\)</span> represent a node of the list where:</p>
<ul>
<li><p><span class="math inline">\(v\)</span> is the payload of the node</p></li>
<li><p><span class="math inline">\(r\)</span> is the index of the node that the random pointer points to. <span class="math inline">\(-1\)</span> represents <code>nullptr</code>.</p></li>
</ul>
<p>For instance the list: <span class="math inline">\([(7,-1),(13,0),(11,4),(10,2),(1,0)]\)</span> represent the list shown in Figure <a href="#fig:clone_list_random_pointer:list1" data-reference-type="ref" data-reference="fig:clone_list_random_pointer:list1">20.1</a>.</p>
<p><span id="fig:clone_list_random_pointer:list1" label="fig:clone_list_random_pointer:list1">[fig:clone_list_random_pointer:list1]</span> <img src="/home/dspataro/git/algorithm_articles/sources/clone_list_random_pointer/images/random_list_1.png" title="fig:" id="fig:clone_list_random_pointer:list1" alt="Linked list wit random pointer." /></p>
<h2 id="clarification-questions-17">Clarification Questions</h2>
<p>The problem is clearly aimed at testing the list manipulation and it is not really about algorithm design. So question related to the size of the input do not help much. Instead it is better to ask question related to the structure of the list itself to see if there is any pattern in the lists we can take advantage of.</p>
<div class="QandA">
<p>Is it guaranteed that at least one not-null random pointer exists?</p>
<div class="answered">
<p><em>No, all random pointer might be null.</em></p>
</div>
<p>Can a random pointer point to itself?</p>
<div class="answered">
<p><em>Yes, you can have a node pointing to itself.</em></p>
</div>
</div>
<h2 id="clone_list_random_pointer:sec:discussion">Discussion</h2>
<p>The two solutions presented in this chapter are fundamentally different and comes with asymptotic performances differences in memory. The solution presented in Section <a href="#clone_list_random_pointer:sec:bruteforce" data-reference-type="ref" data-reference="clone_list_random_pointer:sec:bruteforce">20.3.1</a> uses additional memory (linear amount) while the second one works in constant time but it is harder to digest and to come up with in the first place.</p>
<h3 id="clone_list_random_pointer:sec:bruteforce">Linear memory solution</h3>
<p>The solution presented in this section can be split into a number of distinct steps:</p>
<ol>
<li><p>Create a copy of the list with all the next and random pointers set to <code>nullptr</code>. Save all the pointers in an <code>std::vector&lt;Node&lt;T&gt;*&gt; ptrs;</code>.</p></li>
<li><p>For each node in the input list, while traversing it, save in a <code>map&lt;Node&lt;T&gt;*, int&gt; P</code> the index of that node in the list. We want to remember for each pointer the index where it appears in the original input list.</p></li>
<li><p>Fix the next pointers of all nodes s.t. <code>ptrs[i]-&gt;next</code> points to <code>ptrs[i+1]</code>. At this point we have a new singly linked list with broken random pointers. Basically an half cloned list.</p></li>
<li><p>At this point we can traverse the original list once again, and if the current node <span class="math inline">\(c\)</span> has a not-null random pointer <span class="math inline">\(c-&gt;p\)</span> we can query <span class="math inline">\(P\)</span> to see which index <code>P[c-&gt;p]</code> has in the input. We know then that we need connect also the corresponding element of <span class="math inline">\(c\)</span> in the copy with the node of index <code>P[c-&gt;p]</code> in the copy.</p></li>
</ol>
<p>The idea above can be implemented as shown in the Listing <a href="#list:clone_list_random_pointer_1" data-reference-type="ref" data-reference="list:clone_list_random_pointer_1">[list:clone_list_random_pointer_1]</a></p>
<div class="sourceCode" id="list:clone_list_random_pointer_1" data-language="c++" data-caption="Linear Memory solution to the problem of copying a linked list with random pointers." label="list:clone_list_random_pointer_1"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:clone_list_random_pointer_1-1"><a href="#list:clone_list_random_pointer_1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:clone_list_random_pointer_1-2"><a href="#list:clone_list_random_pointer_1-2" aria-hidden="true" tabindex="-1"></a>Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>clone_random_list_map<span class="op">(</span>Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>head<span class="op">)</span></span>
<span id="list:clone_list_random_pointer_1-3"><a href="#list:clone_list_random_pointer_1-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:clone_list_random_pointer_1-4"><a href="#list:clone_list_random_pointer_1-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// empty list case</span></span>
<span id="list:clone_list_random_pointer_1-5"><a href="#list:clone_list_random_pointer_1-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>head<span class="op">)</span></span>
<span id="list:clone_list_random_pointer_1-6"><a href="#list:clone_list_random_pointer_1-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="list:clone_list_random_pointer_1-7"><a href="#list:clone_list_random_pointer_1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:clone_list_random_pointer_1-8"><a href="#list:clone_list_random_pointer_1-8" aria-hidden="true" tabindex="-1"></a>  Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>ans <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="list:clone_list_random_pointer_1-9"><a href="#list:clone_list_random_pointer_1-9" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>unordered_map<span class="op">&lt;</span>Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*,</span> <span class="dt">int</span><span class="op">&gt;</span> P<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_1-10"><a href="#list:clone_list_random_pointer_1-10" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span>Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*&gt;</span> ptrs<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_1-11"><a href="#list:clone_list_random_pointer_1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:clone_list_random_pointer_1-12"><a href="#list:clone_list_random_pointer_1-12" aria-hidden="true" tabindex="-1"></a>  Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>t <span class="op">=</span> head<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_1-13"><a href="#list:clone_list_random_pointer_1-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> idx    <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:clone_list_random_pointer_1-14"><a href="#list:clone_list_random_pointer_1-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>t<span class="op">)</span></span>
<span id="list:clone_list_random_pointer_1-15"><a href="#list:clone_list_random_pointer_1-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:clone_list_random_pointer_1-16"><a href="#list:clone_list_random_pointer_1-16" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>n <span class="op">=</span> <span class="kw">new</span> Node<span class="op">&lt;</span>T<span class="op">&gt;(</span>t<span class="op">-&gt;</span>val<span class="op">);</span></span>
<span id="list:clone_list_random_pointer_1-17"><a href="#list:clone_list_random_pointer_1-17" aria-hidden="true" tabindex="-1"></a>    ptrs<span class="op">.</span>push_back<span class="op">(</span>n<span class="op">);</span></span>
<span id="list:clone_list_random_pointer_1-18"><a href="#list:clone_list_random_pointer_1-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>ans<span class="op">)</span></span>
<span id="list:clone_list_random_pointer_1-19"><a href="#list:clone_list_random_pointer_1-19" aria-hidden="true" tabindex="-1"></a>      ans <span class="op">=</span> n<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_1-20"><a href="#list:clone_list_random_pointer_1-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// remember the index of this node t</span></span>
<span id="list:clone_list_random_pointer_1-21"><a href="#list:clone_list_random_pointer_1-21" aria-hidden="true" tabindex="-1"></a>    P<span class="op">[</span>t<span class="op">]</span> <span class="op">=</span> idx<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_1-22"><a href="#list:clone_list_random_pointer_1-22" aria-hidden="true" tabindex="-1"></a>    t    <span class="op">=</span> t<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_1-23"><a href="#list:clone_list_random_pointer_1-23" aria-hidden="true" tabindex="-1"></a>    idx<span class="op">++;</span></span>
<span id="list:clone_list_random_pointer_1-24"><a href="#list:clone_list_random_pointer_1-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:clone_list_random_pointer_1-25"><a href="#list:clone_list_random_pointer_1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:clone_list_random_pointer_1-26"><a href="#list:clone_list_random_pointer_1-26" aria-hidden="true" tabindex="-1"></a>  <span class="co">// connect the copy list forward</span></span>
<span id="list:clone_list_random_pointer_1-27"><a href="#list:clone_list_random_pointer_1-27" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> ptrs<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:clone_list_random_pointer_1-28"><a href="#list:clone_list_random_pointer_1-28" aria-hidden="true" tabindex="-1"></a>    ptrs<span class="op">[</span>i<span class="op">]-&gt;</span>next <span class="op">=</span> ptrs<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="list:clone_list_random_pointer_1-29"><a href="#list:clone_list_random_pointer_1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:clone_list_random_pointer_1-30"><a href="#list:clone_list_random_pointer_1-30" aria-hidden="true" tabindex="-1"></a>  t   <span class="op">=</span> head<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_1-31"><a href="#list:clone_list_random_pointer_1-31" aria-hidden="true" tabindex="-1"></a>  idx <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:clone_list_random_pointer_1-32"><a href="#list:clone_list_random_pointer_1-32" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>t<span class="op">)</span></span>
<span id="list:clone_list_random_pointer_1-33"><a href="#list:clone_list_random_pointer_1-33" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:clone_list_random_pointer_1-34"><a href="#list:clone_list_random_pointer_1-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// which index does t-&gt;random has in the original list?</span></span>
<span id="list:clone_list_random_pointer_1-35"><a href="#list:clone_list_random_pointer_1-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// connect the current node with the P[t-&gt;random]-th node in the copy list</span></span>
<span id="list:clone_list_random_pointer_1-36"><a href="#list:clone_list_random_pointer_1-36" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>rnd <span class="op">=</span> P<span class="op">.</span>find<span class="op">(</span>t<span class="op">-&gt;</span>random<span class="op">)</span> <span class="op">!=</span> P<span class="op">.</span>end<span class="op">()</span> <span class="op">?</span> ptrs<span class="op">[</span>P<span class="op">[</span>t<span class="op">-&gt;</span>random<span class="op">]]</span> <span class="op">:</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="list:clone_list_random_pointer_1-37"><a href="#list:clone_list_random_pointer_1-37" aria-hidden="true" tabindex="-1"></a>    ptrs<span class="op">[</span>idx<span class="op">]-&gt;</span>random <span class="op">=</span> rnd<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_1-38"><a href="#list:clone_list_random_pointer_1-38" aria-hidden="true" tabindex="-1"></a>    idx<span class="op">++;</span></span>
<span id="list:clone_list_random_pointer_1-39"><a href="#list:clone_list_random_pointer_1-39" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> t<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_1-40"><a href="#list:clone_list_random_pointer_1-40" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:clone_list_random_pointer_1-41"><a href="#list:clone_list_random_pointer_1-41" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_1-42"><a href="#list:clone_list_random_pointer_1-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This approach has a complexity of <span class="math inline">\(O(n)\)</span> for both time and space. The time complexity is already optimal as we cannot do better than linear time, considering that to do a copy we need to look at all the nodes at least once. The space complexity can be improved though, and as we will see in Section <a href="#clone_list_random_pointer:sec:interleaved_lists" data-reference-type="ref" data-reference="clone_list_random_pointer:sec:interleaved_lists">20.3.2</a> it can be brought down to constant.</p>
<h3 id="clone_list_random_pointer:sec:interleaved_lists">Constant memory solution</h3>
<h4 id="copy-interleaved-with-the-original-list">Copy interleaved with the original list</h4>
<p>The idea behind the solution presented in this section is to construct the copy such that its nodes are interleaved with the ones from the original list. For instance given the input list<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a>: <span class="math inline">\(A = [(7,-1),(13,0),(11,4),(10,2),(1,0)]\)</span> we want to have an interleaved list that look like the following: <span class="math inline">\(A&#39; = [(7,-1),(7,-1),(13,0),(13,-1),(11,4),,(11,-1),(10,2),(10,-1),(1,0),(1,0)]\)</span> (see Figure <a href="#fig:clone_list_random_pointer:interleaved" data-reference-type="ref" data-reference="fig:clone_list_random_pointer:interleaved">20.2</a>) where every node at even indexes is a copy of its predecessor with a random pointer set to <code>nullptr</code>. See function <code>fix_random_pointers</code> in Listing <a href="#list:clone_list_random_pointer_2" data-reference-type="ref" data-reference="list:clone_list_random_pointer_2">[list:clone_list_random_pointer_2]</a>.</p>
<p><span id="fig:clone_list_random_pointer:interleaved" label="fig:clone_list_random_pointer:interleaved">[fig:clone_list_random_pointer:interleaved]</span> <img src="/home/dspataro/git/algorithm_articles/sources/clone_list_random_pointer/images/random_list_2.png" title="fig:" id="fig:clone_list_random_pointer:interleaved" alt="Intermediate interleaved list." /></p>
<p>In more abstract terms given:</p>
<ul>
<li><p>the input list <span class="math inline">\(A= a_0 \rightarrow a_1 \rightarrow \ldots \rightarrow a{n-1}\)</span></p></li>
<li><p>a copy of A <span class="math inline">\(B = b_0 \rightarrow b_1 \rightarrow \ldots \rightarrow b{n-1}\)</span></p></li>
</ul>
<h4 id="fix-the-random-pointers-in-the-interleaved-list">Fix the random pointers in the interleaved list</h4>
<p>Then we want to get a list <span class="math inline">\(I\)</span> of size <span class="math inline">\(2n\)</span>: <span class="math inline">\(I=a_0 \rightarrow b_0 \rightarrow a_1 \rightarrow b_1 \rightarrow a_2 \rightarrow b_2 \rightarrow \ldots \rightarrow a_{n-1} \rightarrow b_{n-1}\)</span>. Having the two lists arranged this ways is quite useful because we can still visit the original lists and at the same time operate on its mirror one by simply modifying the nodes at odd indexes. An interleaved list has a even number of nodes. All the ones at even positions <span class="math inline">\((0,2,\ldots)\)</span> belong to the original lists while all the nodes with odd indexes <span class="math inline">\((1,3,\ldots)\)</span> to the copy. Given a node <span class="math inline">\(n_{2k}=(x,r)\)</span> at an even index <span class="math inline">\(2k\)</span>, we can fix the random pointer for the clone of this node <span class="math inline">\(n_{2k+1}=(x,-1)\)</span> at index <span class="math inline">\(2k+1\)</span> by simply fixing its random pointer to the value pointed by <span class="math inline">\(n_{2k}\)</span><code>-&gt;random-&gt;next</code>. See Figure <a href="#fig:clone_list_random_pointer:interleaved_fixed" data-reference-type="ref" data-reference="fig:clone_list_random_pointer:interleaved_fixed">20.3</a> where the red lines represent the mirrored for the random pointers in the original list and function <code>split_fix_random_pointers</code> in Listing <a href="#list:clone_list_random_pointer_2" data-reference-type="ref" data-reference="list:clone_list_random_pointer_2">[list:clone_list_random_pointer_2]</a>.</p>
<p><span id="fig:clone_list_random_pointer:interleaved_fixed" label="fig:clone_list_random_pointer:interleaved_fixed">[fig:clone_list_random_pointer:interleaved_fixed]</span> <img src="/home/dspataro/git/algorithm_articles/sources/clone_list_random_pointer/images/random_list_3.png" title="fig:" id="fig:clone_list_random_pointer:interleaved_fixed" alt="Interleaved list with fixed random pointers." /></p>
<h4 id="extract-the-cloned-list">Extract the cloned list</h4>
<p>Once we reach this point we have basically two copies of the original list (with random pointers fixed) interleaved with each other. All is it necessary at this point is pull out the cloned list from the interleaved one. This is easily achievable as all we need to do is to remove all the odd nodes, and in the process connect all together (see function <code>split_list</code> in Listing <a href="#list:clone_list_random_pointer_2" data-reference-type="ref" data-reference="list:clone_list_random_pointer_2">[list:clone_list_random_pointer_2]</a>).</p>
<div class="sourceCode" id="list:clone_list_random_pointer_2" data-language="c++" data-caption="Constant memory solution to the problem of copying a linked list with random pointers using an interleaved list." label="list:clone_list_random_pointer_2"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:clone_list_random_pointer_2-1"><a href="#list:clone_list_random_pointer_2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:clone_list_random_pointer_2-2"><a href="#list:clone_list_random_pointer_2-2" aria-hidden="true" tabindex="-1"></a>Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>interleave_list<span class="op">(</span>Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>head<span class="op">)</span></span>
<span id="list:clone_list_random_pointer_2-3"><a href="#list:clone_list_random_pointer_2-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:clone_list_random_pointer_2-4"><a href="#list:clone_list_random_pointer_2-4" aria-hidden="true" tabindex="-1"></a>  Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>h <span class="op">=</span> head<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_2-5"><a href="#list:clone_list_random_pointer_2-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>h<span class="op">)</span></span>
<span id="list:clone_list_random_pointer_2-6"><a href="#list:clone_list_random_pointer_2-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:clone_list_random_pointer_2-7"><a href="#list:clone_list_random_pointer_2-7" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>next   <span class="op">=</span> h<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_2-8"><a href="#list:clone_list_random_pointer_2-8" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>h_copy <span class="op">=</span> <span class="kw">new</span> Node<span class="op">&lt;</span>T<span class="op">&gt;(</span>h<span class="op">-&gt;</span>val<span class="op">);</span></span>
<span id="list:clone_list_random_pointer_2-9"><a href="#list:clone_list_random_pointer_2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:clone_list_random_pointer_2-10"><a href="#list:clone_list_random_pointer_2-10" aria-hidden="true" tabindex="-1"></a>    h_copy<span class="op">-&gt;</span>next <span class="op">=</span> next<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_2-11"><a href="#list:clone_list_random_pointer_2-11" aria-hidden="true" tabindex="-1"></a>    h<span class="op">-&gt;</span>next      <span class="op">=</span> h_copy<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_2-12"><a href="#list:clone_list_random_pointer_2-12" aria-hidden="true" tabindex="-1"></a>    h            <span class="op">=</span> next<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_2-13"><a href="#list:clone_list_random_pointer_2-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:clone_list_random_pointer_2-14"><a href="#list:clone_list_random_pointer_2-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> head<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_2-15"><a href="#list:clone_list_random_pointer_2-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:clone_list_random_pointer_2-16"><a href="#list:clone_list_random_pointer_2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:clone_list_random_pointer_2-17"><a href="#list:clone_list_random_pointer_2-17" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:clone_list_random_pointer_2-18"><a href="#list:clone_list_random_pointer_2-18" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> fix_random_pointers<span class="op">(</span>Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>head<span class="op">)</span></span>
<span id="list:clone_list_random_pointer_2-19"><a href="#list:clone_list_random_pointer_2-19" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:clone_list_random_pointer_2-20"><a href="#list:clone_list_random_pointer_2-20" aria-hidden="true" tabindex="-1"></a>  Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>o <span class="op">=</span> head<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_2-21"><a href="#list:clone_list_random_pointer_2-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>o<span class="op">)</span></span>
<span id="list:clone_list_random_pointer_2-22"><a href="#list:clone_list_random_pointer_2-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:clone_list_random_pointer_2-23"><a href="#list:clone_list_random_pointer_2-23" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>c <span class="op">=</span> o<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_2-24"><a href="#list:clone_list_random_pointer_2-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>o<span class="op">-&gt;</span>random<span class="op">)</span></span>
<span id="list:clone_list_random_pointer_2-25"><a href="#list:clone_list_random_pointer_2-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:clone_list_random_pointer_2-26"><a href="#list:clone_list_random_pointer_2-26" aria-hidden="true" tabindex="-1"></a>      Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>pointed   <span class="op">=</span> o<span class="op">-&gt;</span>random<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_2-27"><a href="#list:clone_list_random_pointer_2-27" aria-hidden="true" tabindex="-1"></a>      Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>pointed_c <span class="op">=</span> pointed<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_2-28"><a href="#list:clone_list_random_pointer_2-28" aria-hidden="true" tabindex="-1"></a>      c<span class="op">-&gt;</span>random          <span class="op">=</span> pointed_c<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_2-29"><a href="#list:clone_list_random_pointer_2-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:clone_list_random_pointer_2-30"><a href="#list:clone_list_random_pointer_2-30" aria-hidden="true" tabindex="-1"></a>    o <span class="op">=</span> o<span class="op">-&gt;</span>next<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_2-31"><a href="#list:clone_list_random_pointer_2-31" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:clone_list_random_pointer_2-32"><a href="#list:clone_list_random_pointer_2-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:clone_list_random_pointer_2-33"><a href="#list:clone_list_random_pointer_2-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:clone_list_random_pointer_2-34"><a href="#list:clone_list_random_pointer_2-34" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:clone_list_random_pointer_2-35"><a href="#list:clone_list_random_pointer_2-35" aria-hidden="true" tabindex="-1"></a>Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>split_list<span class="op">(</span>Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>head<span class="op">)</span></span>
<span id="list:clone_list_random_pointer_2-36"><a href="#list:clone_list_random_pointer_2-36" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:clone_list_random_pointer_2-37"><a href="#list:clone_list_random_pointer_2-37" aria-hidden="true" tabindex="-1"></a>  Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>o   <span class="op">=</span> head<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_2-38"><a href="#list:clone_list_random_pointer_2-38" aria-hidden="true" tabindex="-1"></a>  Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>ans <span class="op">=</span> head<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_2-39"><a href="#list:clone_list_random_pointer_2-39" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>o<span class="op">)</span></span>
<span id="list:clone_list_random_pointer_2-40"><a href="#list:clone_list_random_pointer_2-40" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:clone_list_random_pointer_2-41"><a href="#list:clone_list_random_pointer_2-41" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>c     <span class="op">=</span> o<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_2-42"><a href="#list:clone_list_random_pointer_2-42" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>cnext <span class="op">=</span> c<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_2-43"><a href="#list:clone_list_random_pointer_2-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:clone_list_random_pointer_2-44"><a href="#list:clone_list_random_pointer_2-44" aria-hidden="true" tabindex="-1"></a>    o<span class="op">-&gt;</span>next <span class="op">=</span> c<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_2-45"><a href="#list:clone_list_random_pointer_2-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>c<span class="op">-&gt;</span>next<span class="op">)</span></span>
<span id="list:clone_list_random_pointer_2-46"><a href="#list:clone_list_random_pointer_2-46" aria-hidden="true" tabindex="-1"></a>      c<span class="op">-&gt;</span>next <span class="op">=</span> c<span class="op">-&gt;</span>next<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_2-47"><a href="#list:clone_list_random_pointer_2-47" aria-hidden="true" tabindex="-1"></a>    o <span class="op">=</span> cnext<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_2-48"><a href="#list:clone_list_random_pointer_2-48" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:clone_list_random_pointer_2-49"><a href="#list:clone_list_random_pointer_2-49" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:clone_list_random_pointer_2-50"><a href="#list:clone_list_random_pointer_2-50" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:clone_list_random_pointer_2-51"><a href="#list:clone_list_random_pointer_2-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:clone_list_random_pointer_2-52"><a href="#list:clone_list_random_pointer_2-52" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:clone_list_random_pointer_2-53"><a href="#list:clone_list_random_pointer_2-53" aria-hidden="true" tabindex="-1"></a>Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>clone_random_list_interleave_lists<span class="op">(</span>Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>head<span class="op">)</span></span>
<span id="list:clone_list_random_pointer_2-54"><a href="#list:clone_list_random_pointer_2-54" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:clone_list_random_pointer_2-55"><a href="#list:clone_list_random_pointer_2-55" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>head<span class="op">)</span></span>
<span id="list:clone_list_random_pointer_2-56"><a href="#list:clone_list_random_pointer_2-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="list:clone_list_random_pointer_2-57"><a href="#list:clone_list_random_pointer_2-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:clone_list_random_pointer_2-58"><a href="#list:clone_list_random_pointer_2-58" aria-hidden="true" tabindex="-1"></a>  interleave_list<span class="op">(</span>head<span class="op">);</span></span>
<span id="list:clone_list_random_pointer_2-59"><a href="#list:clone_list_random_pointer_2-59" aria-hidden="true" tabindex="-1"></a>  fix_random_pointers<span class="op">(</span>head<span class="op">);</span></span>
<span id="list:clone_list_random_pointer_2-60"><a href="#list:clone_list_random_pointer_2-60" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> split_list<span class="op">(</span>head<span class="op">);</span></span>
<span id="list:clone_list_random_pointer_2-61"><a href="#list:clone_list_random_pointer_2-61" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="ch:delete_duplicates_list">Delete duplicates from Linked List</h1>
<h2 class="unnumbered" id="introduction-20">Introduction</h2>
<p>The problem presented in this chapter is an easy one on Linked list that has been asked to preliminary interview steps many times already. It is therefore very important that this problem is understood well and you can implement it quickly and most importantly flawlessly during an interview.</p>
<h2 id="problem-statement-20">Problem statement</h2>
<div class="exercise">
<p>Given a singly linked link <span class="math inline">\(L\)</span> (see definition at Listing <a href="#list:delete_duplicates_list:linked_list" data-reference-type="ref" data-reference="list:delete_duplicates_list:linked_list">[list:delete_duplicates_list:linked_list]</a>), return a linked list with no duplicated.</p>
</div>
<div class="sourceCode" id="list:delete_duplicates_list:linked_list" data-language="c++" data-caption="Singly Linked list definition" label="list:delete_duplicates_list:linked_list"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:delete_duplicates_list:linked_list-1"><a href="#list:delete_duplicates_list:linked_list-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:delete_duplicates_list:linked_list-2"><a href="#list:delete_duplicates_list:linked_list-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node <span class="op">{</span></span>
<span id="list:delete_duplicates_list:linked_list-3"><a href="#list:delete_duplicates_list:linked_list-3" aria-hidden="true" tabindex="-1"></a>    T val<span class="op">;</span></span>
<span id="list:delete_duplicates_list:linked_list-4"><a href="#list:delete_duplicates_list:linked_list-4" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">*</span>next<span class="op">;</span></span>
<span id="list:delete_duplicates_list:linked_list-5"><a href="#list:delete_duplicates_list:linked_list-5" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">(</span>T x<span class="op">)</span> <span class="op">:</span> val<span class="op">(</span>x<span class="op">),</span> next<span class="op">(</span><span class="kw">nullptr</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="list:delete_duplicates_list:linked_list-6"><a href="#list:delete_duplicates_list:linked_list-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<div class="example">
<p><br />
</p>
<ul>
<li><p>Input: <span class="math inline">\(1 \rightarrow 1 \rightarrow 2\)</span></p></li>
<li><p>Output: <span class="math inline">\(1 \rightarrow 2\)</span></p></li>
</ul>
</div>
<div class="example">
<p><br />
</p>
<ul>
<li><p>Input: <span class="math inline">\(1 \rightarrow  2 \rightarrow  2 \rightarrow  2 \rightarrow  2 \rightarrow  3 \rightarrow  4 \rightarrow  4\)</span></p></li>
<li><p>Output: <span class="math inline">\(1 \rightarrow  2 \rightarrow 3 \rightarrow  4\)</span></p></li>
</ul>
</div>
<h2 id="clarification-questions-18">Clarification Questions</h2>
<div class="QandA">
<p>Can the input list be modified?</p>
<div class="answered">
<p><em>Yes.</em></p>
</div>
</div>
<h2 id="delete_duplicates_list:sec:discussion">Discussion</h2>
<p>As you can imagine there are many approaches that can be adopted in order to solve this problem, but we will focus on basically two, with the second being a refinement of the first which will lead to an elegant yet efficient solution.</p>
<h3 id="delete_duplicates_list:sec:bruteforce">Brute-force</h3>
<p>The easiest solution possible consist in:</p>
<ol>
<li><p>Create a vector that basically contains a copy of the list</p></li>
<li><p>Remove duplicates from the vector</p></li>
<li><p>Create a new List with the content of the duplicate free vector</p></li>
</ol>
<p>This solution is straightforward but as you can imagine not optimal. A possible implementation is shown in Listing <a href="#list:delete_duplicates_list_brite_force1" data-reference-type="ref" data-reference="list:delete_duplicates_list_brite_force1">[list:delete_duplicates_list_brite_force1]</a> where for the step <span class="math inline">\(2\)</span> the remove-erase idiom<span class="citation" data-cites="cit::wiki::remove-erase"></span> is used to remove duplicates from the vector(the erase part is actually not necessary in this case).</p>
<div class="sourceCode" id="list:delete_duplicates_list_brite_force1" data-language="c++" data-caption="C++ solution $O(n)$ time and $O(n)$ space solution to the problem of removing duplicates from a Linked List using std::remove." label="list:delete_duplicates_list_brite_force1"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:delete_duplicates_list_brite_force1-1"><a href="#list:delete_duplicates_list_brite_force1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:delete_duplicates_list_brite_force1-2"><a href="#list:delete_duplicates_list_brite_force1-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> list_to_vector<span class="op">(</span>Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>head<span class="op">)</span></span>
<span id="list:delete_duplicates_list_brite_force1-3"><a href="#list:delete_duplicates_list_brite_force1-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:delete_duplicates_list_brite_force1-4"><a href="#list:delete_duplicates_list_brite_force1-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> ans<span class="op">;</span></span>
<span id="list:delete_duplicates_list_brite_force1-5"><a href="#list:delete_duplicates_list_brite_force1-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(;</span> head<span class="op">;</span> head <span class="op">=</span> head<span class="op">-&gt;</span>next<span class="op">)</span></span>
<span id="list:delete_duplicates_list_brite_force1-6"><a href="#list:delete_duplicates_list_brite_force1-6" aria-hidden="true" tabindex="-1"></a>    ans<span class="op">.</span>push_back<span class="op">(</span>head<span class="op">-&gt;</span>val<span class="op">);</span></span>
<span id="list:delete_duplicates_list_brite_force1-7"><a href="#list:delete_duplicates_list_brite_force1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:delete_duplicates_list_brite_force1-8"><a href="#list:delete_duplicates_list_brite_force1-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:delete_duplicates_list_brite_force1-9"><a href="#list:delete_duplicates_list_brite_force1-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:delete_duplicates_list_brite_force1-10"><a href="#list:delete_duplicates_list_brite_force1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:delete_duplicates_list_brite_force1-11"><a href="#list:delete_duplicates_list_brite_force1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:delete_duplicates_list_brite_force1-12"><a href="#list:delete_duplicates_list_brite_force1-12" aria-hidden="true" tabindex="-1"></a>Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>list_from_vector<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">&amp;</span>Vs<span class="op">)</span></span>
<span id="list:delete_duplicates_list_brite_force1-13"><a href="#list:delete_duplicates_list_brite_force1-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:delete_duplicates_list_brite_force1-14"><a href="#list:delete_duplicates_list_brite_force1-14" aria-hidden="true" tabindex="-1"></a>  Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>tail <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="list:delete_duplicates_list_brite_force1-15"><a href="#list:delete_duplicates_list_brite_force1-15" aria-hidden="true" tabindex="-1"></a>  Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>head <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="list:delete_duplicates_list_brite_force1-16"><a href="#list:delete_duplicates_list_brite_force1-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span> v <span class="op">:</span> Vs<span class="op">)</span></span>
<span id="list:delete_duplicates_list_brite_force1-17"><a href="#list:delete_duplicates_list_brite_force1-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:delete_duplicates_list_brite_force1-18"><a href="#list:delete_duplicates_list_brite_force1-18" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>n <span class="op">=</span> <span class="kw">new</span> Node<span class="op">&lt;</span>T<span class="op">&gt;(</span>v<span class="op">);</span></span>
<span id="list:delete_duplicates_list_brite_force1-19"><a href="#list:delete_duplicates_list_brite_force1-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>tail<span class="op">)</span></span>
<span id="list:delete_duplicates_list_brite_force1-20"><a href="#list:delete_duplicates_list_brite_force1-20" aria-hidden="true" tabindex="-1"></a>      head <span class="op">=</span> n<span class="op">;</span></span>
<span id="list:delete_duplicates_list_brite_force1-21"><a href="#list:delete_duplicates_list_brite_force1-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="list:delete_duplicates_list_brite_force1-22"><a href="#list:delete_duplicates_list_brite_force1-22" aria-hidden="true" tabindex="-1"></a>      tail<span class="op">-&gt;</span>next <span class="op">=</span> n<span class="op">;</span></span>
<span id="list:delete_duplicates_list_brite_force1-23"><a href="#list:delete_duplicates_list_brite_force1-23" aria-hidden="true" tabindex="-1"></a>    tail <span class="op">=</span> n<span class="op">;</span></span>
<span id="list:delete_duplicates_list_brite_force1-24"><a href="#list:delete_duplicates_list_brite_force1-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:delete_duplicates_list_brite_force1-25"><a href="#list:delete_duplicates_list_brite_force1-25" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> head<span class="op">;</span></span>
<span id="list:delete_duplicates_list_brite_force1-26"><a href="#list:delete_duplicates_list_brite_force1-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:delete_duplicates_list_brite_force1-27"><a href="#list:delete_duplicates_list_brite_force1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:delete_duplicates_list_brite_force1-28"><a href="#list:delete_duplicates_list_brite_force1-28" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:delete_duplicates_list_brite_force1-29"><a href="#list:delete_duplicates_list_brite_force1-29" aria-hidden="true" tabindex="-1"></a>Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>remove_duplicates_from_linked_list_1<span class="op">(</span>Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>head<span class="op">)</span></span>
<span id="list:delete_duplicates_list_brite_force1-30"><a href="#list:delete_duplicates_list_brite_force1-30" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:delete_duplicates_list_brite_force1-31"><a href="#list:delete_duplicates_list_brite_force1-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> vec_list <span class="op">=</span> list_to_vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>head<span class="op">);</span></span>
<span id="list:delete_duplicates_list_brite_force1-32"><a href="#list:delete_duplicates_list_brite_force1-32" aria-hidden="true" tabindex="-1"></a>  <span class="co">// std::sort(std::begin(vec_list), std::end(vec_list)); //not necessary. List</span></span>
<span id="list:delete_duplicates_list_brite_force1-33"><a href="#list:delete_duplicates_list_brite_force1-33" aria-hidden="true" tabindex="-1"></a>  <span class="co">// is sorted already</span></span>
<span id="list:delete_duplicates_list_brite_force1-34"><a href="#list:delete_duplicates_list_brite_force1-34" aria-hidden="true" tabindex="-1"></a>  vec_list<span class="op">.</span>erase<span class="op">(</span><span class="bu">std::</span>unique<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>vec_list<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>vec_list<span class="op">)),</span></span>
<span id="list:delete_duplicates_list_brite_force1-35"><a href="#list:delete_duplicates_list_brite_force1-35" aria-hidden="true" tabindex="-1"></a>                 <span class="bu">std::</span>end<span class="op">(</span>vec_list<span class="op">));</span></span>
<span id="list:delete_duplicates_list_brite_force1-36"><a href="#list:delete_duplicates_list_brite_force1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:delete_duplicates_list_brite_force1-37"><a href="#list:delete_duplicates_list_brite_force1-37" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> list_from_vector<span class="op">(</span>vec_list<span class="op">);</span></span>
<span id="list:delete_duplicates_list_brite_force1-38"><a href="#list:delete_duplicates_list_brite_force1-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This solution is optimal in time but we are not taking advantage of the fact that the we can modify the list in place and it is not necessary to create a brand new List to be returned.</p>
<h3 id="delete_duplicates_list:sec:linear_space">In-place <span class="math inline">\(O(1)\)</span> space solution</h3>
<p>In the solution describe in Section <a href="#delete_duplicates_list:sec:discussion" data-reference-type="ref" data-reference="delete_duplicates_list:sec:discussion">21.3</a> we did use of additional space to both remove the duplicates and also to avoid the pain of rearranging the input list by creating a brand new list containing no duplicates. It is possible though with a bit of thinking to write a in-place solution that uses no additional space.</p>
<p>The main idea is that since the list is <strong>sorted</strong>, duplicate element will be one after the other, and we can take advantage of this fact by simply ignoring pair of consecutive nodes that have the same payload. Ignored nodes can therefore be deleted. The only complications is that we need to make sure to connect the first occurrence of every Node in the list with each other For this reason we need to therefore remember the first Node of a stride of the same value.</p>
<p>This idea is implemented in Listing <a href="#list:delete_duplicates_list_lineartime" data-reference-type="ref" data-reference="list:delete_duplicates_list_lineartime">[list:delete_duplicates_list_lineartime]</a>. Note that:</p>
<ul>
<li><p>The base case <code>if(!head || !head-&gt;next) return head;</code> is making sure that if we are examining the last element of the list (or an empty list) then there is no duplicate to ignore and thus we can return this element.</p></li>
<li><p>otherwise, we are looking at a list with <strong>at least</strong> two elements. These two elements can be potentially the start of a stride of equal element that we want to ignore. We keep a pointer,<code>Node&lt;T&gt;* head;</code> (which is never modified) to the first element of the stride and advance a second pointer, <code>Node&lt;T&gt;* head_n;</code>, until we either reach the end of the list or we find an element that is different from the first one, <code>while ( head_n &amp;&amp; head -&gt; val == head_n -&gt; val)</code>. All the advanced elements are deleted. At the end of the loop the second pointer is pointing to either:</p>
<ul>
<li><p>An element different than the element pointed by the first one. The stride of equal elements is processed and <code>head-&gt;next</code> can now point to the second pointer.</p></li>
<li><p><code>nullptr</code>. We have reached the end of the input list. We are done.</p></li>
</ul></li>
</ul>
<p>The time and space complexity for this approach are <span class="math inline">\(O(n)\)</span> and <span class="math inline">\(O(1)\)</span>, respectively. All the nodes of the list are visited at most once.</p>
<div class="sourceCode" id="list:delete_duplicates_list_lineartime" data-language="c++" data-caption="C++ solution $O(n)$ time and $O(1)$ space solution to the problem of removing duplicates from a Linked." label="list:delete_duplicates_list_lineartime"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:delete_duplicates_list_lineartime-1"><a href="#list:delete_duplicates_list_lineartime-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:delete_duplicates_list_lineartime-2"><a href="#list:delete_duplicates_list_lineartime-2" aria-hidden="true" tabindex="-1"></a>Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>remove_duplicates_from_linked_list_linear_space<span class="op">(</span>Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>head<span class="op">)</span></span>
<span id="list:delete_duplicates_list_lineartime-3"><a href="#list:delete_duplicates_list_lineartime-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:delete_duplicates_list_lineartime-4"><a href="#list:delete_duplicates_list_lineartime-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>head <span class="op">||</span> <span class="op">!</span>head<span class="op">-&gt;</span>next<span class="op">)</span></span>
<span id="list:delete_duplicates_list_lineartime-5"><a href="#list:delete_duplicates_list_lineartime-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> head<span class="op">;</span></span>
<span id="list:delete_duplicates_list_lineartime-6"><a href="#list:delete_duplicates_list_lineartime-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:delete_duplicates_list_lineartime-7"><a href="#list:delete_duplicates_list_lineartime-7" aria-hidden="true" tabindex="-1"></a>  Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>head_n <span class="op">=</span> head<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:delete_duplicates_list_lineartime-8"><a href="#list:delete_duplicates_list_lineartime-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:delete_duplicates_list_lineartime-9"><a href="#list:delete_duplicates_list_lineartime-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>head <span class="op">&amp;&amp;</span> head_n <span class="op">&amp;&amp;</span> head<span class="op">-&gt;</span>val <span class="op">==</span> head_n<span class="op">-&gt;</span>val<span class="op">)</span></span>
<span id="list:delete_duplicates_list_lineartime-10"><a href="#list:delete_duplicates_list_lineartime-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:delete_duplicates_list_lineartime-11"><a href="#list:delete_duplicates_list_lineartime-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> head_n_n <span class="op">=</span> head_n<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:delete_duplicates_list_lineartime-12"><a href="#list:delete_duplicates_list_lineartime-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">delete</span> head_n<span class="op">;</span></span>
<span id="list:delete_duplicates_list_lineartime-13"><a href="#list:delete_duplicates_list_lineartime-13" aria-hidden="true" tabindex="-1"></a>    head_n <span class="op">=</span> head_n_n<span class="op">;</span></span>
<span id="list:delete_duplicates_list_lineartime-14"><a href="#list:delete_duplicates_list_lineartime-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:delete_duplicates_list_lineartime-15"><a href="#list:delete_duplicates_list_lineartime-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:delete_duplicates_list_lineartime-16"><a href="#list:delete_duplicates_list_lineartime-16" aria-hidden="true" tabindex="-1"></a>  head<span class="op">-&gt;</span>next <span class="op">=</span> remove_duplicates_from_linked_list_linear_space<span class="op">(</span>head_n<span class="op">);</span></span>
<span id="list:delete_duplicates_list_lineartime-17"><a href="#list:delete_duplicates_list_lineartime-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> head<span class="op">;</span></span>
<span id="list:delete_duplicates_list_lineartime-18"><a href="#list:delete_duplicates_list_lineartime-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="common-variations-and-follow-up-questions">Common Variations and follow-up questions</h2>
<p>One follow-up question that the interviewer might be keen to ask is related to the deletion of the duplicate nodes. In the Listing <a href="#list:delete_duplicates_list_lineartime" data-reference-type="ref" data-reference="list:delete_duplicates_list_lineartime">[list:delete_duplicates_list_lineartime]</a> we see that the nodes are deleted using the <code>operator delete</code>, but what if the list was not allocated using <code>operator new</code>? The question is left for the reader.</p>
<div class="exercise">
<p>How would the solution change if the nodes were allocated using a custom allocator? (spoiler, a custom deleter is also needed.)</p>
</div>
<h1 id="ch:random_points_in_circle">Generate points in circle uniformly</h1>
<h2 class="unnumbered" id="introduction-21">Introduction</h2>
<p>The problem described in this Chapter is about generating a (possibly large) number of random points in a circle of a certain radius. Said points need to be generated uniformly. Despite its simplicity the problem still poses some unexpected challenges and difficulties. We will discuss how to approach this problem and also one solution that many candidates provides and that seems just correct but that should absolutely be avoided as it is not correct (spoiler it does not distribute points uniformly). We will also look at some cool figures or points in a circle.</p>
<h2 id="problem-statement-21">Problem statement</h2>
<div class="exercise">
<p>Write a function that, given a circle of radius <span class="math inline">\(r\)</span> and centered at <span class="math inline">\((x,y)\)</span> where <span class="math inline">\(r,x,y \in \mathcal{R}\)</span> returns a uniformly distributed point in the circle.</p>
</div>
<div class="example">
<p><br />
</p>
</div>
<h2 id="clarification-questions-19">Clarification Questions</h2>
<div class="QandA">
<p>What does really mean for the point to be uniformly distributed?</p>
<div class="answered">
<p><em>It means that every point of the circle has the same probability of being picked/generated by the function</em></p>
</div>
</div>
<h2 id="random_points_in_circle:sec:discussion">Discussion</h2>
<p>Before discussing solutions it is worth to mention that the fact that the circle is centered at <span class="math inline">\((x,y)\)</span> does make very little difference and we can continue our discussion as it was centered at <span class="math inline">\((0,0)\)</span>. This is true because all the points we generated can then be translated to <span class="math inline">\((x,y)\)</span> by simply adding <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> to the <span class="math inline">\(x\)</span>-coordinate and <span class="math inline">\(y\)</span>-coordinate of the generated point.</p>
<h3 id="random_points_in_circle:sec:buggy">Polar Coordinates - The wrong approach</h3>
<p>Let’s start by discussing a common approach that comes naturally to mind. One might think that in order to pick a point in the circle is it sufficient to</p>
<ol>
<li><p>Pick a random angle <span class="math inline">\(\theta \in [0, 2\pi[\)</span></p></li>
<li><p>Pick a random radius <span class="math inline">\(\overline{r} \in [0,r]\)</span></p></li>
<li><p>Generate the Cartesian coordinates of the point given the radius and the angle (polar coordinates <span class="citation" data-cites="cit:wiki:polarcoordinates"></span>) as (see Figure <a href="#fig:random_points_in_cirle:polar_coordinates" data-reference-type="ref" data-reference="fig:random_points_in_cirle:polar_coordinates">22.1</a>): <span class="math display">\[\begin{gathered}
		 x=\overline{r}\sin(\theta) \\
		 y=\overline{r}\cos(\theta) 
	\end{gathered}\]</span></p></li>
</ol>
<p><span id="fig:random_points_in_cirle:polar_coordinates" label="fig:random_points_in_cirle:polar_coordinates">[fig:random_points_in_cirle:polar_coordinates]</span> <img src="/home/dspataro/git/algorithm_articles/sources/random_points_in_circle/images/polar-coordinate.png" title="fig:" id="fig:random_points_in_cirle:polar_coordinates" alt="Generation of a random point in polar coordinates given a random angle \theta and a random radius r." /></p>
<p>Despite its simplicity this approach is wrong as it does not produce points distributed uniformly in the circle. Before having a quick look at the mathematical proof it is instructive to have a look Figure <a href="#fig:random_points_in_cirle:buggy" data-reference-type="ref" data-reference="fig:random_points_in_cirle:buggy">22.2</a> which is drawing a large number of points on the circle generated using this buggy solution. As you can see the points are not generated uniformly as their density is higher towards the center. The bottom line is, do not use this solution in an interview. A possible matlab implementation of this buggy approach is shown in Listing <a href="#list:random_points_in_circle:buggy" data-reference-type="ref" data-reference="list:random_points_in_circle:buggy">[list:random_points_in_circle:buggy]</a>.</p>
<div class="sourceCode" id="list:random_points_in_circle:buggy" data-language="Matlab" data-caption="Non-uniform random point in a circle generation using Matlab" label="list:random_points_in_circle:buggy"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="list:random_points_in_circle:buggy-1"><a href="#list:random_points_in_circle:buggy-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> [<span class="va">px</span><span class="op">,</span> <span class="va">py</span>] <span class="op">=</span> <span class="va">buggy_random_point</span>(<span class="va">radius</span><span class="op">,</span> <span class="va">x</span><span class="op">,</span><span class="va">y</span>)</span>
<span id="list:random_points_in_circle:buggy-2"><a href="#list:random_points_in_circle:buggy-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">r</span> <span class="op">=</span> <span class="va">rand</span>()<span class="op">*</span><span class="va">radius</span><span class="op">;</span></span>
<span id="list:random_points_in_circle:buggy-3"><a href="#list:random_points_in_circle:buggy-3" aria-hidden="true" tabindex="-1"></a>  <span class="va">theta</span> <span class="op">=</span> <span class="va">rand</span>()<span class="op">*</span><span class="fl">2</span><span class="op">*</span><span class="va">pi</span><span class="op">;</span></span>
<span id="list:random_points_in_circle:buggy-4"><a href="#list:random_points_in_circle:buggy-4" aria-hidden="true" tabindex="-1"></a>  <span class="va">px</span> <span class="op">=</span> <span class="va">r</span> <span class="op">*</span> <span class="va">sin</span>(<span class="va">theta</span>)<span class="op">;</span></span>
<span id="list:random_points_in_circle:buggy-5"><a href="#list:random_points_in_circle:buggy-5" aria-hidden="true" tabindex="-1"></a>  <span class="va">py</span> <span class="op">=</span> <span class="va">r</span> <span class="op">*</span><span class="va">cos</span>(<span class="va">theta</span>)<span class="op">;</span></span>
<span id="list:random_points_in_circle:buggy-6"><a href="#list:random_points_in_circle:buggy-6" aria-hidden="true" tabindex="-1"></a><span class="va">endfunction</span></span></code></pre></div>
<p><span id="fig:random_points_in_cirle:buggy" label="fig:random_points_in_cirle:buggy">[fig:random_points_in_cirle:buggy]</span> <img src="/home/dspataro/git/algorithm_articles/sources/random_points_in_circle/images/buggy_points.jpg" title="fig:" id="fig:random_points_in_cirle:buggy" alt="Large number of points generated using the approach described in Section 22.3.1. Note that the density of points is not uniform as more points are packed around the center." /></p>
<h3 id="random_points_in_circle:sec:loop">Loop approach</h3>
<p>A good way to make sure that the point density is uniform everywhere on the surface of the circle is to pick a point randomly in an enclosing square and making sure that we discard all the points that lie outside the circle. In other words, we keep asking for a random point <span class="math inline">\((p_x=\text{rand()}, p_y=\text{rand()})\)</span> in the enclosing square until the following is true: <span class="math inline">\(p_x^2 + p_y^2 \leq r\)</span>. This way we are guaranteed to generate uniformly distributed points because we pick those points from a set of points that are already uniformly distributed in a square, and we exclude those which are not inside the circle. This method is also known as exclusion method. Figure <a href="#fig:random_points_in_cirle:loop" data-reference-type="ref" data-reference="fig:random_points_in_cirle:loop">22.3</a> depicts a large number of points generate with this method.</p>
<p>The downside of this method is that we might need to generate a number of points in the square before getting lucky and picking one lying in the circle. We need to make on average <span class="math inline">\(\approx 1.2732\)</span> tries before getting a point in the circle. This number is the ratio between the are of enclosing square and the area of the enclosed circle i.e. <span class="math inline">\(\frac{(2r)^2}{\pi r^2} = \frac{4}{\pi}\)</span>.</p>
<p><span id="fig:random_points_in_cirle:loop" label="fig:random_points_in_cirle:loop">[fig:random_points_in_cirle:loop]</span> <img src="/home/dspataro/git/algorithm_articles/sources/random_points_in_circle/images/loop_points.jpg" title="fig:" id="fig:random_points_in_cirle:loop" alt="Large number of points generated using the approach described in Section 22.3.2." /></p>
<p>A Matlab implementation of this approach is shown in Listing <a href="#list:random_points_in_circle:loop" data-reference-type="ref" data-reference="list:random_points_in_circle:loop">[list:random_points_in_circle:loop]</a>.</p>
<div class="sourceCode" id="list:random_points_in_circle:loop" data-language="Matlab" data-caption="Random point in a circle generation using the exclusion method." label="list:random_points_in_circle:loop"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="list:random_points_in_circle:loop-1"><a href="#list:random_points_in_circle:loop-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> [<span class="va">px</span><span class="op">,</span> <span class="va">py</span><span class="op">,</span> <span class="va">t</span>] <span class="op">=</span> <span class="va">random_point_loop</span>(<span class="va">radius</span><span class="op">,</span> <span class="va">x</span><span class="op">,</span><span class="va">y</span>) </span>
<span id="list:random_points_in_circle:loop-2"><a href="#list:random_points_in_circle:loop-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">px</span> <span class="op">=</span> <span class="fl">100</span><span class="op">;</span></span>
<span id="list:random_points_in_circle:loop-3"><a href="#list:random_points_in_circle:loop-3" aria-hidden="true" tabindex="-1"></a>  <span class="va">py</span> <span class="op">=</span> <span class="fl">100</span><span class="op">;</span></span>
<span id="list:random_points_in_circle:loop-4"><a href="#list:random_points_in_circle:loop-4" aria-hidden="true" tabindex="-1"></a>  <span class="va">t</span><span class="op">=</span><span class="fl">0</span><span class="op">;</span></span>
<span id="list:random_points_in_circle:loop-5"><a href="#list:random_points_in_circle:loop-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">while</span> (<span class="va">px</span><span class="op">*</span><span class="va">px</span> <span class="op">+</span> <span class="va">py</span><span class="op">*</span><span class="va">py</span> <span class="op">&gt;</span> <span class="fl">1</span>)</span>
<span id="list:random_points_in_circle:loop-6"><a href="#list:random_points_in_circle:loop-6" aria-hidden="true" tabindex="-1"></a>     <span class="va">signx</span> <span class="op">=</span> <span class="fl">2</span><span class="op">*</span><span class="va">randi</span>([<span class="fl">0</span><span class="op">,</span><span class="fl">1</span>])<span class="op">-</span><span class="fl">1</span><span class="op">;</span></span>
<span id="list:random_points_in_circle:loop-7"><a href="#list:random_points_in_circle:loop-7" aria-hidden="true" tabindex="-1"></a>     <span class="va">signy</span> <span class="op">=</span> <span class="fl">2</span><span class="op">*</span><span class="va">randi</span>([<span class="fl">0</span><span class="op">,</span><span class="fl">1</span>])<span class="op">-</span><span class="fl">1</span><span class="op">;</span></span>
<span id="list:random_points_in_circle:loop-8"><a href="#list:random_points_in_circle:loop-8" aria-hidden="true" tabindex="-1"></a>     <span class="va">px</span> <span class="op">=</span> <span class="va">rand</span>()<span class="op">*</span><span class="va">radius</span><span class="op">*</span><span class="va">signx</span><span class="op">;</span></span>
<span id="list:random_points_in_circle:loop-9"><a href="#list:random_points_in_circle:loop-9" aria-hidden="true" tabindex="-1"></a>     <span class="va">py</span> <span class="op">=</span> <span class="va">rand</span>()<span class="op">*</span><span class="va">radius</span><span class="op">*</span><span class="va">signy</span><span class="op">;</span></span>
<span id="list:random_points_in_circle:loop-10"><a href="#list:random_points_in_circle:loop-10" aria-hidden="true" tabindex="-1"></a>     <span class="va">t</span><span class="op">=</span><span class="va">t</span><span class="op">+</span><span class="fl">1</span><span class="op">;</span></span>
<span id="list:random_points_in_circle:loop-11"><a href="#list:random_points_in_circle:loop-11" aria-hidden="true" tabindex="-1"></a>  <span class="va">endwhile</span></span>
<span id="list:random_points_in_circle:loop-12"><a href="#list:random_points_in_circle:loop-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:random_points_in_circle:loop-13"><a href="#list:random_points_in_circle:loop-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:random_points_in_circle:loop-14"><a href="#list:random_points_in_circle:loop-14" aria-hidden="true" tabindex="-1"></a><span class="va">endfunction</span></span></code></pre></div>
<h3 id="random_points_in_circle:sec:polar_sqrt">Polar Coordinates - The right approach</h3>
<p>In order for the points to be distributed uniformly it has to be that the average distance between the points has to be the same regardless of how far they lie from the center of the circle. This means that looking at the points generated on a circumference of radius <span class="math inline">\(2\)</span> there has to be twice as many points as the the number of points on a circumference of radius <span class="math inline">\(1\)</span>. Twice as long circumference translates to twice as many points needed to maintain the same density. Another intuitive way of looking at why simply picking a random angle and a random radius is not enough would be to think about having to distribute <span class="math inline">\(10\)</span> points at random on a circle of radius <span class="math inline">\(1\)</span> and <span class="math inline">\(2\)</span>. It is clear that the circumference of radius <span class="math inline">\(2\)</span> would look emptier than the one with radius <span class="math inline">\(1\)</span> simply because there is more circumference to be filled but a constant amount of points.</p>
<p>The fundamental problem with the approch described in Section <a href="#random_points_in_circle:sec:buggy" data-reference-type="ref" data-reference="random_points_in_circle:sec:buggy">22.3.1</a> is that the are of the circle is not uniformly covered. The random radius cuts through the area of the circle and this is the only parameter that affect how the points are going to be distributed across the area of the circle. Therefore we want to focus our attention to how we can pick a better radius by making sure that larger radii are picked more often to accommodate for the larger area they define. In other words, we need to ensure that our random function for the radius picking takes into account the area of our circle.</p>
<p>Consider the area <span class="math inline">\(A\)</span> of a circle of radius <span class="math inline">\(r\)</span> i.e. <span class="math inline">\(A = \pi r^2\)</span>. We can rearrange the formula so that <span class="math inline">\(r = \sqrt{\frac{A}{\pi}}\)</span>. What this formula is really telling us is that the radius is proportial to <span class="math inline">\(\sqrt{A}\)</span>. We have a way of choosing the radius that depends on the area of the circle now. We can simply pick a random area at random and then calculate the radius accordingly. This will make sure that the radius is picked taking into consideration the area of the circle. Figure <a href="#fig:random_points_in_cirle:polar_sqrt" data-reference-type="ref" data-reference="fig:random_points_in_cirle:polar_sqrt">22.4</a> shows many points generate using this method. As you can see the points are generate uniformly across the area of the circle and the picture looks similar to Figure <a href="#fig:random_points_in_cirle:loop" data-reference-type="ref" data-reference="fig:random_points_in_cirle:loop">22.3</a>.</p>
<p>A C++ implementation of this method is shown in Listing <a href="#list:random_points_in_circle:sqrtcpp" data-reference-type="ref" data-reference="list:random_points_in_circle:sqrtcpp">[list:random_points_in_circle:sqrtcpp]</a>. Details on the random number generation in Modern C++ can be found in <span class="citation" data-cites="cit::std::random"></span>.</p>
<div class="sourceCode" id="list:random_points_in_circle:sqrtcpp" data-language="c++" data-caption="C++ implementation of the function for generating a random point in a circle described in Section \ref{random_points_in_circle:sec:polar_sqrt}" label="list:random_points_in_circle:sqrtcpp"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:random_points_in_circle:sqrtcpp-1"><a href="#list:random_points_in_circle:sqrtcpp-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> generate_random_point_in_circle<span class="op">()</span></span>
<span id="list:random_points_in_circle:sqrtcpp-2"><a href="#list:random_points_in_circle:sqrtcpp-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:random_points_in_circle:sqrtcpp-3"><a href="#list:random_points_in_circle:sqrtcpp-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">static</span> <span class="bu">std::</span>uniform_real_distribution<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> dist_radius<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="list:random_points_in_circle:sqrtcpp-4"><a href="#list:random_points_in_circle:sqrtcpp-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">static</span> <span class="bu">std::</span>uniform_real_distribution<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> dist_angle<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">2</span> <span class="op">*</span> M_PI<span class="op">);</span></span>
<span id="list:random_points_in_circle:sqrtcpp-5"><a href="#list:random_points_in_circle:sqrtcpp-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> r     <span class="op">=</span> radius <span class="op">*</span> sqrt<span class="op">(</span>dist_radius<span class="op">(</span>rnd<span class="op">));</span></span>
<span id="list:random_points_in_circle:sqrtcpp-6"><a href="#list:random_points_in_circle:sqrtcpp-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> theta <span class="op">=</span> dist_angle<span class="op">(</span>rnd<span class="op">);</span></span>
<span id="list:random_points_in_circle:sqrtcpp-7"><a href="#list:random_points_in_circle:sqrtcpp-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> x     <span class="op">=</span> r <span class="op">*</span> cos<span class="op">(</span>theta<span class="op">);</span></span>
<span id="list:random_points_in_circle:sqrtcpp-8"><a href="#list:random_points_in_circle:sqrtcpp-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> y     <span class="op">=</span> r <span class="op">*</span> sin<span class="op">(</span>theta<span class="op">);</span></span>
<span id="list:random_points_in_circle:sqrtcpp-9"><a href="#list:random_points_in_circle:sqrtcpp-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">std::</span>make_pair<span class="op">{</span>x <span class="op">+</span> x_center<span class="op">,</span> y <span class="op">+</span> y_center<span class="op">};</span></span>
<span id="list:random_points_in_circle:sqrtcpp-10"><a href="#list:random_points_in_circle:sqrtcpp-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><span id="fig:random_points_in_cirle:polar_sqrt" label="fig:random_points_in_cirle:polar_sqrt">[fig:random_points_in_cirle:polar_sqrt]</span> <img src="/home/dspataro/git/algorithm_articles/sources/random_points_in_circle/images/sqrt_points.jpg" title="fig:" id="fig:random_points_in_cirle:polar_sqrt" alt="Large number of points generated using the approach described in Section 22.3.3." /></p>
<p>A Matlab implementation of this approach is shown in Listing <a href="#list:random_points_in_circle:sqrt" data-reference-type="ref" data-reference="list:random_points_in_circle:sqrt">[list:random_points_in_circle:sqrt]</a>.</p>
<div class="sourceCode" id="list:random_points_in_circle:sqrt" data-language="Matlab" data-caption="Random point in a circle generation using polar coordinates and the $\approx \sqrt{A}$ dependency of the radius on the area of the circle." label="list:random_points_in_circle:sqrt"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="list:random_points_in_circle:sqrt-1"><a href="#list:random_points_in_circle:sqrt-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> [<span class="va">px</span><span class="op">,</span> <span class="va">py</span>] <span class="op">=</span> <span class="va">random_sqrt_area</span>(<span class="va">radius</span><span class="op">,</span> <span class="va">x</span><span class="op">,</span><span class="va">y</span>)</span>
<span id="list:random_points_in_circle:sqrt-2"><a href="#list:random_points_in_circle:sqrt-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">area</span> <span class="op">=</span> <span class="va">pi</span><span class="op">*</span><span class="va">radius</span><span class="op">*</span><span class="va">radius</span><span class="op">*</span><span class="va">rand</span>()<span class="op">;</span> <span class="co">%random area</span></span>
<span id="list:random_points_in_circle:sqrt-3"><a href="#list:random_points_in_circle:sqrt-3" aria-hidden="true" tabindex="-1"></a>  <span class="va">r</span> <span class="op">=</span> <span class="va">sqrt</span>(<span class="va">area</span><span class="op">/</span><span class="va">pi</span>)<span class="op">;</span></span>
<span id="list:random_points_in_circle:sqrt-4"><a href="#list:random_points_in_circle:sqrt-4" aria-hidden="true" tabindex="-1"></a>  <span class="va">theta</span> <span class="op">=</span> <span class="va">rand</span>()<span class="op">*</span><span class="fl">2</span><span class="op">*</span><span class="va">pi</span><span class="op">;</span></span>
<span id="list:random_points_in_circle:sqrt-5"><a href="#list:random_points_in_circle:sqrt-5" aria-hidden="true" tabindex="-1"></a>  <span class="va">px</span> <span class="op">=</span> <span class="va">r</span> <span class="op">*</span> <span class="va">sin</span>(<span class="va">theta</span>)<span class="op">;</span></span>
<span id="list:random_points_in_circle:sqrt-6"><a href="#list:random_points_in_circle:sqrt-6" aria-hidden="true" tabindex="-1"></a>  <span class="va">py</span> <span class="op">=</span> <span class="va">r</span> <span class="op">*</span><span class="va">cos</span>(<span class="va">theta</span>)<span class="op">;</span></span>
<span id="list:random_points_in_circle:sqrt-7"><a href="#list:random_points_in_circle:sqrt-7" aria-hidden="true" tabindex="-1"></a><span class="va">endfunction</span></span></code></pre></div>
<h3 id="conclusion">Conclusion</h3>
<p>We looked into three two viable methods for generating random points withing a circle. The time and space complexity for all the two methods is constant even if the one presented in Section <a href="#random_points_in_circle:sec:polar_sqrt" data-reference-type="ref" data-reference="random_points_in_circle:sec:polar_sqrt">22.3.3</a> would most likely have better performances when included in an hot path i.e. in a loop for the generation of many random points.</p>
<p>All the code used to generate the Figures in this chapter is shown in Listing <a href="#list:random_points_in_circle:drivercode" data-reference-type="ref" data-reference="list:random_points_in_circle:drivercode">[list:random_points_in_circle:drivercode]</a>.</p>
<div class="sourceCode" id="list:random_points_in_circle:drivercode" data-language="Matlab" data-caption="Matlab driver code for the generation of all figures in Chapter \ref{ch:random_points_in_circle}" label="list:random_points_in_circle:drivercode"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="list:random_points_in_circle:drivercode-1"><a href="#list:random_points_in_circle:drivercode-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="va">draw_points</span>(<span class="va">n</span>)</span>
<span id="list:random_points_in_circle:drivercode-2"><a href="#list:random_points_in_circle:drivercode-2" aria-hidden="true" tabindex="-1"></a>   <span class="va">clf</span>(<span class="fl">1</span>)<span class="op">;</span></span>
<span id="list:random_points_in_circle:drivercode-3"><a href="#list:random_points_in_circle:drivercode-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">% n is the total number of points</span></span>
<span id="list:random_points_in_circle:drivercode-4"><a href="#list:random_points_in_circle:drivercode-4" aria-hidden="true" tabindex="-1"></a>  <span class="va">px</span> <span class="op">=</span> <span class="va">zeros</span>(<span class="fl">1</span><span class="op">,</span><span class="va">n</span>)<span class="op">;</span></span>
<span id="list:random_points_in_circle:drivercode-5"><a href="#list:random_points_in_circle:drivercode-5" aria-hidden="true" tabindex="-1"></a>  <span class="va">py</span> <span class="op">=</span> <span class="va">zeros</span>(<span class="fl">1</span><span class="op">,</span><span class="va">n</span>)<span class="op">;</span></span>
<span id="list:random_points_in_circle:drivercode-6"><a href="#list:random_points_in_circle:drivercode-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="list:random_points_in_circle:drivercode-7"><a href="#list:random_points_in_circle:drivercode-7" aria-hidden="true" tabindex="-1"></a>  <span class="va">tries</span> <span class="op">=</span> <span class="fl">0</span><span class="op">;</span></span>
<span id="list:random_points_in_circle:drivercode-8"><a href="#list:random_points_in_circle:drivercode-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">for</span> <span class="va">i</span> <span class="op">=</span><span class="fl">0</span><span class="op">:</span><span class="va">n</span></span>
<span id="list:random_points_in_circle:drivercode-9"><a href="#list:random_points_in_circle:drivercode-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">%[x,y] = buggy_random_point(1,0,0);</span></span>
<span id="list:random_points_in_circle:drivercode-10"><a href="#list:random_points_in_circle:drivercode-10" aria-hidden="true" tabindex="-1"></a>   <span class="co">% [x,y,t] = random_point_loop(1,0,0);</span></span>
<span id="list:random_points_in_circle:drivercode-11"><a href="#list:random_points_in_circle:drivercode-11" aria-hidden="true" tabindex="-1"></a>   [<span class="va">x</span><span class="op">,</span><span class="va">y</span>] <span class="op">=</span> <span class="va">random_sqrt_area</span>(<span class="fl">1</span><span class="op">,</span><span class="fl">0</span><span class="op">,</span><span class="fl">0</span>)<span class="op">;</span></span>
<span id="list:random_points_in_circle:drivercode-12"><a href="#list:random_points_in_circle:drivercode-12" aria-hidden="true" tabindex="-1"></a>   <span class="co">% tries = tries + t;</span></span>
<span id="list:random_points_in_circle:drivercode-13"><a href="#list:random_points_in_circle:drivercode-13" aria-hidden="true" tabindex="-1"></a>    <span class="va">px</span>(<span class="va">i</span><span class="op">+</span><span class="fl">1</span>) <span class="op">=</span> <span class="va">x</span><span class="op">;</span></span>
<span id="list:random_points_in_circle:drivercode-14"><a href="#list:random_points_in_circle:drivercode-14" aria-hidden="true" tabindex="-1"></a>    <span class="va">py</span>(<span class="va">i</span><span class="op">+</span><span class="fl">1</span>) <span class="op">=</span> <span class="va">y</span><span class="op">;</span></span>
<span id="list:random_points_in_circle:drivercode-15"><a href="#list:random_points_in_circle:drivercode-15" aria-hidden="true" tabindex="-1"></a>  <span class="va">endfor</span></span>
<span id="list:random_points_in_circle:drivercode-16"><a href="#list:random_points_in_circle:drivercode-16" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="list:random_points_in_circle:drivercode-17"><a href="#list:random_points_in_circle:drivercode-17" aria-hidden="true" tabindex="-1"></a>  <span class="va">average</span> <span class="op">=</span> <span class="va">tries</span><span class="op">/</span><span class="va">n</span></span>
<span id="list:random_points_in_circle:drivercode-18"><a href="#list:random_points_in_circle:drivercode-18" aria-hidden="true" tabindex="-1"></a> </span>
<span id="list:random_points_in_circle:drivercode-19"><a href="#list:random_points_in_circle:drivercode-19" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="list:random_points_in_circle:drivercode-20"><a href="#list:random_points_in_circle:drivercode-20" aria-hidden="true" tabindex="-1"></a>  <span class="co">% Plot a circle.</span></span>
<span id="list:random_points_in_circle:drivercode-21"><a href="#list:random_points_in_circle:drivercode-21" aria-hidden="true" tabindex="-1"></a>  <span class="va">angles</span> <span class="op">=</span> <span class="va">linspace</span>(<span class="fl">0</span><span class="op">,</span> <span class="fl">2</span><span class="op">*</span><span class="va">pi</span><span class="op">,</span> <span class="va">n</span>)<span class="op">;</span> </span>
<span id="list:random_points_in_circle:drivercode-22"><a href="#list:random_points_in_circle:drivercode-22" aria-hidden="true" tabindex="-1"></a>  <span class="va">radius</span> <span class="op">=</span> <span class="fl">1</span><span class="op">;</span></span>
<span id="list:random_points_in_circle:drivercode-23"><a href="#list:random_points_in_circle:drivercode-23" aria-hidden="true" tabindex="-1"></a>  <span class="va">xCenter</span> <span class="op">=</span> <span class="fl">0</span><span class="op">;</span></span>
<span id="list:random_points_in_circle:drivercode-24"><a href="#list:random_points_in_circle:drivercode-24" aria-hidden="true" tabindex="-1"></a>  <span class="va">yCenter</span> <span class="op">=</span> <span class="fl">0</span><span class="op">;</span></span>
<span id="list:random_points_in_circle:drivercode-25"><a href="#list:random_points_in_circle:drivercode-25" aria-hidden="true" tabindex="-1"></a>  <span class="va">cx</span> <span class="op">=</span> <span class="va">radius</span> <span class="op">*</span> <span class="va">cos</span>(<span class="va">angles</span>) <span class="op">+</span> <span class="va">xCenter</span><span class="op">;</span> </span>
<span id="list:random_points_in_circle:drivercode-26"><a href="#list:random_points_in_circle:drivercode-26" aria-hidden="true" tabindex="-1"></a>  <span class="va">cy</span> <span class="op">=</span> <span class="va">radius</span> <span class="op">*</span> <span class="va">sin</span>(<span class="va">angles</span>) <span class="op">+</span> <span class="va">yCenter</span><span class="op">;</span></span>
<span id="list:random_points_in_circle:drivercode-27"><a href="#list:random_points_in_circle:drivercode-27" aria-hidden="true" tabindex="-1"></a>  <span class="co">% Plot circle.</span></span>
<span id="list:random_points_in_circle:drivercode-28"><a href="#list:random_points_in_circle:drivercode-28" aria-hidden="true" tabindex="-1"></a>  <span class="va">plot</span>(<span class="va">cx</span><span class="op">,</span> <span class="va">cy</span><span class="op">,</span> <span class="ss">&#39;b-&#39;</span><span class="op">,</span> <span class="ss">&#39;LineWidth&#39;</span><span class="op">,</span> <span class="fl">2</span>)<span class="op">;</span></span>
<span id="list:random_points_in_circle:drivercode-29"><a href="#list:random_points_in_circle:drivercode-29" aria-hidden="true" tabindex="-1"></a>  <span class="co">% Plot center.</span></span>
<span id="list:random_points_in_circle:drivercode-30"><a href="#list:random_points_in_circle:drivercode-30" aria-hidden="true" tabindex="-1"></a>  <span class="va">hold</span> <span class="va">on</span><span class="op">;</span></span>
<span id="list:random_points_in_circle:drivercode-31"><a href="#list:random_points_in_circle:drivercode-31" aria-hidden="true" tabindex="-1"></a>  <span class="va">plot</span>(<span class="va">xCenter</span><span class="op">,</span> <span class="va">yCenter</span><span class="op">,</span> <span class="ss">&#39;k+&#39;</span><span class="op">,</span> <span class="ss">&#39;LineWidth&#39;</span><span class="op">,</span> <span class="fl">2</span><span class="op">,</span> <span class="ss">&#39;MarkerSize&#39;</span><span class="op">,</span> <span class="fl">16</span>)<span class="op">;</span></span>
<span id="list:random_points_in_circle:drivercode-32"><a href="#list:random_points_in_circle:drivercode-32" aria-hidden="true" tabindex="-1"></a>  <span class="va">grid</span> <span class="va">on</span><span class="op">;</span></span>
<span id="list:random_points_in_circle:drivercode-33"><a href="#list:random_points_in_circle:drivercode-33" aria-hidden="true" tabindex="-1"></a>  <span class="va">axis</span> <span class="va">equal</span><span class="op">;</span></span>
<span id="list:random_points_in_circle:drivercode-34"><a href="#list:random_points_in_circle:drivercode-34" aria-hidden="true" tabindex="-1"></a>  <span class="va">xlabel</span>(<span class="ss">&#39;X&#39;</span><span class="op">,</span> <span class="ss">&#39;FontSize&#39;</span><span class="op">,</span> <span class="fl">16</span>)<span class="op">;</span></span>
<span id="list:random_points_in_circle:drivercode-35"><a href="#list:random_points_in_circle:drivercode-35" aria-hidden="true" tabindex="-1"></a>  <span class="va">ylabel</span>(<span class="ss">&#39;Y&#39;</span><span class="op">,</span> <span class="ss">&#39;FontSize&#39;</span><span class="op">,</span> <span class="fl">16</span>)<span class="op">;</span></span>
<span id="list:random_points_in_circle:drivercode-36"><a href="#list:random_points_in_circle:drivercode-36" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="list:random_points_in_circle:drivercode-37"><a href="#list:random_points_in_circle:drivercode-37" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="list:random_points_in_circle:drivercode-38"><a href="#list:random_points_in_circle:drivercode-38" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="list:random_points_in_circle:drivercode-39"><a href="#list:random_points_in_circle:drivercode-39" aria-hidden="true" tabindex="-1"></a>  <span class="co">% Plot random points.</span></span>
<span id="list:random_points_in_circle:drivercode-40"><a href="#list:random_points_in_circle:drivercode-40" aria-hidden="true" tabindex="-1"></a>  <span class="va">plot</span>(<span class="va">px</span><span class="op">,</span> <span class="va">py</span><span class="op">,</span> <span class="ss">&#39;r.&#39;</span><span class="op">,</span> <span class="ss">&#39;MarkerSize&#39;</span><span class="op">,</span> <span class="fl">1</span>)<span class="op">;</span></span>
<span id="list:random_points_in_circle:drivercode-41"><a href="#list:random_points_in_circle:drivercode-41" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="list:random_points_in_circle:drivercode-42"><a href="#list:random_points_in_circle:drivercode-42" aria-hidden="true" tabindex="-1"></a> </span>
<span id="list:random_points_in_circle:drivercode-43"><a href="#list:random_points_in_circle:drivercode-43" aria-hidden="true" tabindex="-1"></a>  <span class="va">rectangle</span>(<span class="ss">&#39;Position&#39;</span><span class="op">,</span>[<span class="op">-</span><span class="fl">1</span> <span class="op">-</span><span class="fl">1</span> <span class="fl">2</span> <span class="fl">2</span>]<span class="op">,</span> <span class="ss">&#39;LineWidth&#39;</span><span class="op">,</span><span class="fl">3</span><span class="op">,</span>  <span class="ss">&#39;EdgeColor&#39;</span> <span class="op">,</span> [<span class="fl">0</span> <span class="fl">.5</span> <span class="fl">.5</span>])</span>
<span id="list:random_points_in_circle:drivercode-44"><a href="#list:random_points_in_circle:drivercode-44" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="list:random_points_in_circle:drivercode-45"><a href="#list:random_points_in_circle:drivercode-45" aria-hidden="true" tabindex="-1"></a><span class="va">endfunction</span></span></code></pre></div>
<h1 id="ch:buy_sell_stocks">Best time to buy and sell stock</h1>
<h2 class="unnumbered" id="introduction-22">Introduction</h2>
<p>The problem discussed in this Chapter is considered an easy one and as we will see, it is easily solvable in quadratic time using a brute force algorithm but, the problem is also easy enough to allow for an easy discovery more efficient approaches. This problem is an excellent example of problems that you need to be able to solve fast and it is therefore imperative to get familiar with this type of problems.</p>
<h2 id="sec:buy_sell_stocks:statement1">Problem statement</h2>
<div class="exercise">
<p>You are given prices for a stack for a number <span class="math inline">\(n\)</span> of days. The prices are stored in an array <span class="math inline">\(P\)</span> of length <span class="math inline">\(n\)</span> where each cell <span class="math inline">\(i\)</span> of the array contains the price for the stock on the <span class="math inline">\(i^{th}\)</span> day. You are only permitted to perform <strong>one</strong> buy and <strong>one</strong> sell operations. What is the maximum profit you can achieve given the prices for the stock in <span class="math inline">\(P\)</span>?</p>
<p>You have to perform the buy operation <strong>before</strong> the sell operation. You cannot buy the stock on the day and sell on the .</p>
<div class="example">
<p><br />
Given the array of prices for the stock is: <span class="math inline">\([7,1,5,3,6,4]\)</span>, the answer is <span class="math inline">\(5\)</span>. You can buy on the day and sell on the .</p>
</div>
<div class="example">
<p><br />
Given the array of prices for the stock is: <span class="math inline">\([6,5,4,3,2,1]\)</span>, the answer is <span class="math inline">\(0\)</span>. There is no way you can make a profit higher than <span class="math inline">\(0\)</span> i.e. not buying and not selling.</p>
</div>
</div>
<h2 id="clarification-questions-20">Clarification Questions</h2>
<div class="QandA">
<p>Can you perform the buy and sell operation on the same day?</p>
<div class="answered">
<p><em>Yes, that is possible.</em></p>
</div>
</div>
<h2 id="buy_sell_stocks:sec:discussion">Discussion</h2>
<p>A profit is achieved when a buy and sell transaction are performed with prices <span class="math inline">\(p_b\)</span> and <span class="math inline">\(p_s\)</span> respectively and <span class="math inline">\(p_b \leq p_s\)</span>. In other words we our goal is to buy at a lower price than we well. The maximum profit is obtained whenever the spread between those two prices is maximum i.e. <span class="math inline">\(\max_{}{(p_s - p_b)}\)</span></p>
<h3 id="buy_sell_stocks:sec:bruteforce">Brute-force</h3>
<p>The brute force approach is really straighforward because the only thing we need is to apply the definition of maximum profit we discussed earlier. For all pairs of ordered index <span class="math inline">\(i \leq j\)</span> we can calculate <span class="math inline">\(P_i - P_j\)</span> and return the maximum among all those profit values. Listing <a href="#list:buy_sell_stocks:bruteforce" data-reference-type="ref" data-reference="list:buy_sell_stocks:bruteforce">[list:buy_sell_stocks:bruteforce]</a> shows an implementation of this approach. Note that a profit of <span class="math inline">\(0\)</span> is always possible by either not performing any transaction or simply performing the buy and sell on the same day. Thus <span class="math inline">\(j = i+1\)</span>, because it is pointless to calculate the profit for the same day as we know already it will always be <span class="math inline">\(0\)</span>. For this reason we also limit the buy operation to the day before (<span class="math inline">\(i&lt; n-1\)</span>) the last, because if we want to have any chance of making a profit we need to at least have one day left after the buy to perform the sell operation.</p>
<div class="sourceCode" id="list:buy_sell_stocks:bruteforce" data-language="c++" data-caption="Brute force $O(n^2)$ solution to the problem of buying and selling stock." label="list:buy_sell_stocks:bruteforce"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:buy_sell_stocks:bruteforce-1"><a href="#list:buy_sell_stocks:bruteforce-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> buy_sell_stocks_bruteforce<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>P<span class="op">)</span></span>
<span id="list:buy_sell_stocks:bruteforce-2"><a href="#list:buy_sell_stocks:bruteforce-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:buy_sell_stocks:bruteforce-3"><a href="#list:buy_sell_stocks:bruteforce-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> n <span class="op">=</span> P<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:buy_sell_stocks:bruteforce-4"><a href="#list:buy_sell_stocks:bruteforce-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans     <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:buy_sell_stocks:bruteforce-5"><a href="#list:buy_sell_stocks:bruteforce-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:buy_sell_stocks:bruteforce-6"><a href="#list:buy_sell_stocks:bruteforce-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="list:buy_sell_stocks:bruteforce-7"><a href="#list:buy_sell_stocks:bruteforce-7" aria-hidden="true" tabindex="-1"></a>      ans <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>ans<span class="op">,</span> P<span class="op">[</span>j<span class="op">]</span> <span class="op">-</span> P<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:buy_sell_stocks:bruteforce-8"><a href="#list:buy_sell_stocks:bruteforce-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:buy_sell_stocks:bruteforce-9"><a href="#list:buy_sell_stocks:bruteforce-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="buy_sell_stocks:sec:linear">Linear time solution</h3>
<p>The idea above can be improved if we look at the problem from slightly different perspective. The idea is that we can process the array from the last day to the first and for each of the day calculate the <strong>best</strong> profit can be made by selling in any of the days already processed (which happen later in time).</p>
<p>We keep a variable <span class="math inline">\(b\)</span> with the maximum price seen so far which is initially <span class="math inline">\(-\infty\)</span>. The algorithm starts from day <span class="math inline">\(n\)</span> and for each day checks whether buying that day and selling at the price <span class="math inline">\(b\)</span> (the highest price seen so far) would improve the profit found so far. This approach is correct because the maximum profit happens when the spread between sell and buy price is maximum. The implementation of theidea above is shown in Listing <a href="#list:buy_sell_stocks:linear" data-reference-type="ref" data-reference="list:buy_sell_stocks:linear">[list:buy_sell_stocks:linear]</a>.</p>
<div class="sourceCode" id="list:buy_sell_stocks:linear" data-language="c++" data-caption="Dynamic programming linear time, constant space solution to the problem of buying and selling stock." label="list:buy_sell_stocks:linear"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:buy_sell_stocks:linear-1"><a href="#list:buy_sell_stocks:linear-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> buy_sell_stocks_DP<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>P<span class="op">)</span></span>
<span id="list:buy_sell_stocks:linear-2"><a href="#list:buy_sell_stocks:linear-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:buy_sell_stocks:linear-3"><a href="#list:buy_sell_stocks:linear-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> days     <span class="op">=</span> P<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:buy_sell_stocks:linear-4"><a href="#list:buy_sell_stocks:linear-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> highest_so_far <span class="op">=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>min<span class="op">();</span></span>
<span id="list:buy_sell_stocks:linear-5"><a href="#list:buy_sell_stocks:linear-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans            <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:buy_sell_stocks:linear-6"><a href="#list:buy_sell_stocks:linear-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> days <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span></span>
<span id="list:buy_sell_stocks:linear-7"><a href="#list:buy_sell_stocks:linear-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:buy_sell_stocks:linear-8"><a href="#list:buy_sell_stocks:linear-8" aria-hidden="true" tabindex="-1"></a>    highest_so_far <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>highest_so_far<span class="op">,</span> P<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:buy_sell_stocks:linear-9"><a href="#list:buy_sell_stocks:linear-9" aria-hidden="true" tabindex="-1"></a>    ans            <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>ans<span class="op">,</span> highest_so_far <span class="op">-</span> P<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:buy_sell_stocks:linear-10"><a href="#list:buy_sell_stocks:linear-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:buy_sell_stocks:linear-11"><a href="#list:buy_sell_stocks:linear-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:buy_sell_stocks:linear-12"><a href="#list:buy_sell_stocks:linear-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="sec:buy_sell_stocks:multiple_transaction">Common Variations - Multiple Transactions</h2>
<h3 id="problem-statement-22">Problem statement</h3>
<div class="exercise">
<p>This problem is a variation of the problem presented in Section <a href="#sec:buy_sell_stocks:statement1" data-reference-type="ref" data-reference="sec:buy_sell_stocks:statement1">23.1</a> where we are allowed to make as many transactions as we like. The question remains the same: what is the maximum profit achievable?</p>
<p>Note that you may not engage in multiple transactions at the same time i.e., you must sell the stock before you buy again.</p>
<div class="example">
<p><span id="ex:buy_sell_stocks_2:exmaple1" label="ex:buy_sell_stocks_2:exmaple1">[ex:buy_sell_stocks_2:exmaple1]</span><br />
Given the array of prices for the stock is: <span class="math inline">\([7,1,5,3,6,4]\)</span>, the answer is <span class="math inline">\(7\)</span>. You can buy on the day and sell on the and then engage on a second transaction where you buy on the day and sell on the .</p>
</div>
</div>
<h2 id="buy_sell_stocks_2:sec:discussion">Discussion</h2>
<p>This might seems like an harder problem at first than the version presented in Section <a href="#sec:buy_sell_stocks:statement1" data-reference-type="ref" data-reference="sec:buy_sell_stocks:statement1">23.1</a> but in reality as we will see in Section <a href="#buy_sell_stocks_2:sec:linear" data-reference-type="ref" data-reference="buy_sell_stocks_2:sec:linear">23.7</a> its solution is actually easier.</p>
<h2 id="buy_sell_stocks_2:sec:bruteforce">Brute force solution</h2>
<p>As usual we start our discussion by quickly presenting the brute force solution. In this case this means trying all possible sets of transactions (a valid pair of buy and sell operation not overlapping with any other transaction). We can try all possible sets by using recursion cleverly. However this approach will not take us far because the number of possible sets of transaction grows exponentially. We are showing this approach in Listing <a href="#list:buy_sell_stocks_2:bruteforce" data-reference-type="ref" data-reference="list:buy_sell_stocks_2:bruteforce">[list:buy_sell_stocks_2:bruteforce]</a> only because we think its implementation can be somehow instructive.</p>
<div class="sourceCode" id="list:buy_sell_stocks_2:bruteforce" data-language="c++" data-caption="Bruteforce exponential solution to the problem of buying and selling stock with no limits on the number of transactions." label="list:buy_sell_stocks_2:bruteforce"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:buy_sell_stocks_2:bruteforce-1"><a href="#list:buy_sell_stocks_2:bruteforce-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> buy_sell_stocks_multiple_transactions_exp_helper<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>P<span class="op">,</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-2"><a href="#list:buy_sell_stocks_2:bruteforce-2" aria-hidden="true" tabindex="-1"></a>                                                     <span class="at">const</span> <span class="dt">int</span> start<span class="op">)</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-3"><a href="#list:buy_sell_stocks_2:bruteforce-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-4"><a href="#list:buy_sell_stocks_2:bruteforce-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> <span class="op">*</span>x <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-5"><a href="#list:buy_sell_stocks_2:bruteforce-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans      <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-6"><a href="#list:buy_sell_stocks_2:bruteforce-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> buy_day <span class="op">=</span> start<span class="op">;</span> buy_day <span class="op">&lt;</span> <span class="bu">std::</span>ssize<span class="op">(</span>P<span class="op">)</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> buy_day<span class="op">++)</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-7"><a href="#list:buy_sell_stocks_2:bruteforce-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-8"><a href="#list:buy_sell_stocks_2:bruteforce-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> sell_day <span class="op">=</span> buy_day <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> sell_day <span class="op">&lt;</span> <span class="bu">std::</span>ssize<span class="op">(</span>P<span class="op">);</span> sell_day<span class="op">++)</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-9"><a href="#list:buy_sell_stocks_2:bruteforce-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-10"><a href="#list:buy_sell_stocks_2:bruteforce-10" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>P<span class="op">[</span>buy_day<span class="op">]</span> <span class="op">&lt;</span> P<span class="op">[</span>sell_day<span class="op">])</span>  <span class="co">// pointless to sell otherwise</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-11"><a href="#list:buy_sell_stocks_2:bruteforce-11" aria-hidden="true" tabindex="-1"></a>      <span class="op">{</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-12"><a href="#list:buy_sell_stocks_2:bruteforce-12" aria-hidden="true" tabindex="-1"></a>        x                        <span class="op">=</span> <span class="op">&amp;</span>P<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-13"><a href="#list:buy_sell_stocks_2:bruteforce-13" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="dt">int</span> selling_profit <span class="op">=</span> P<span class="op">[</span>sell_day<span class="op">]</span> <span class="op">-</span> P<span class="op">[</span>buy_day<span class="op">];</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-14"><a href="#list:buy_sell_stocks_2:bruteforce-14" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="dt">int</span> profit_rest_transactions <span class="op">=</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-15"><a href="#list:buy_sell_stocks_2:bruteforce-15" aria-hidden="true" tabindex="-1"></a>            buy_sell_stocks_multiple_transactions_exp_helper<span class="op">(</span>P<span class="op">,</span> sell_day <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-16"><a href="#list:buy_sell_stocks_2:bruteforce-16" aria-hidden="true" tabindex="-1"></a>        ans <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>ans<span class="op">,</span> selling_profit <span class="op">+</span> profit_rest_transactions<span class="op">);</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-17"><a href="#list:buy_sell_stocks_2:bruteforce-17" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-18"><a href="#list:buy_sell_stocks_2:bruteforce-18" aria-hidden="true" tabindex="-1"></a>      <span class="cf">else</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-19"><a href="#list:buy_sell_stocks_2:bruteforce-19" aria-hidden="true" tabindex="-1"></a>      <span class="op">{</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-20"><a href="#list:buy_sell_stocks_2:bruteforce-20" aria-hidden="true" tabindex="-1"></a>        ans <span class="op">=</span> x <span class="op">!=</span> <span class="kw">nullptr</span> <span class="op">?</span> <span class="op">*</span>x <span class="op">:</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-21"><a href="#list:buy_sell_stocks_2:bruteforce-21" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-22"><a href="#list:buy_sell_stocks_2:bruteforce-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-23"><a href="#list:buy_sell_stocks_2:bruteforce-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-24"><a href="#list:buy_sell_stocks_2:bruteforce-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-25"><a href="#list:buy_sell_stocks_2:bruteforce-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-26"><a href="#list:buy_sell_stocks_2:bruteforce-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:buy_sell_stocks_2:bruteforce-27"><a href="#list:buy_sell_stocks_2:bruteforce-27" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> buy_sell_stocks_multiple_transactions_exp<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>P<span class="op">)</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-28"><a href="#list:buy_sell_stocks_2:bruteforce-28" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-29"><a href="#list:buy_sell_stocks_2:bruteforce-29" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> buy_sell_stocks_multiple_transactions_exp_helper<span class="op">(</span>P<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="list:buy_sell_stocks_2:bruteforce-30"><a href="#list:buy_sell_stocks_2:bruteforce-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="buy_sell_stocks_2:sec:linear">Linear time solution</h2>
<p>The idea is simple and it is clearer once we look at prices plotted on a graph. As you can see in Figure <a href="#" data-reference-type="ref" data-reference="">54</a>, the data is made of peaks and valleys (unless the data is fully increasing or decreasing). Those are the point of interests because if we buy at valleys and sell at peaks we are able to obtains the maximum profit. One can simply loop thought the array and identify those peaks and valleys and calculate the total profit as the sum of the profits along those point of interests. For instance w.r.t. the example <a href="#ex:buy_sell_stocks_2:exmaple1" data-reference-type="ref" data-reference="ex:buy_sell_stocks_2:exmaple1">[ex:buy_sell_stocks_2:exmaple1]</a> there are two pairs valley-peak happening at days <span class="math inline">\(2\)</span> and <span class="math inline">\(3\)</span> and days <span class="math inline">\(4\)</span> and <span class="math inline">\(5\)</span>, respectively. But, what is a valley and/or a peak exactly? A day <span class="math inline">\(i\)</span> is a valley if <span class="math inline">\(P_i &lt; P_{i-1}\)</span> and <span class="math inline">\(P_i &gt; P_{i+1}\)</span> while is a peak if <span class="math inline">\(P_i &gt; P_{i-1}\)</span> and <span class="math inline">\(P_i &lt; P_{i+1}\)</span>. So all it is needed is to identify those pairs of valleys and peaks and we are done.</p>
<p>But do we really need to find peaks and valleys? The answer is not as all it is necessary is to make sure we cash at <strong>all</strong> opportunities we have i.e. in all those cases where we can buy at a lower price we sell. Thus we can process days two at the time and, since there is no limit on the number of transactions, simply buy and sell whenever the spread between buy and sell price is convenient.</p>
<p>The idea above can be implemented as shown in Listing <a href="#list:buy_sell_stocks_2:linear" data-reference-type="ref" data-reference="list:buy_sell_stocks_2:linear">[list:buy_sell_stocks_2:linear]</a>.</p>
<div class="sourceCode" id="list:buy_sell_stocks_2:linear" data-language="c++" data-caption="$O(n)$ time and $O(1)$ space solution to the problem of buying and selling stock with no limits on the number of transactions." label="list:buy_sell_stocks_2:linear"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:buy_sell_stocks_2:linear-1"><a href="#list:buy_sell_stocks_2:linear-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> buy_sell_stocks_multiple_transactions_lin<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>P<span class="op">)</span></span>
<span id="list:buy_sell_stocks_2:linear-2"><a href="#list:buy_sell_stocks_2:linear-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:buy_sell_stocks_2:linear-3"><a href="#list:buy_sell_stocks_2:linear-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:buy_sell_stocks_2:linear-4"><a href="#list:buy_sell_stocks_2:linear-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span>P<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:buy_sell_stocks_2:linear-5"><a href="#list:buy_sell_stocks_2:linear-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:buy_sell_stocks_2:linear-6"><a href="#list:buy_sell_stocks_2:linear-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>P<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> P<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">])</span></span>
<span id="list:buy_sell_stocks_2:linear-7"><a href="#list:buy_sell_stocks_2:linear-7" aria-hidden="true" tabindex="-1"></a>      ans <span class="op">+=</span> <span class="op">(</span>P<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">-</span> P<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:buy_sell_stocks_2:linear-8"><a href="#list:buy_sell_stocks_2:linear-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:buy_sell_stocks_2:linear-9"><a href="#list:buy_sell_stocks_2:linear-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:buy_sell_stocks_2:linear-10"><a href="#list:buy_sell_stocks_2:linear-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="ch:cycle_in_list">Find the cycle in a Linked list</h1>
<h2 class="unnumbered" id="introduction-23">Introduction</h2>
<p>The problem described in this chapter is a classical one that has been reported to be asked in in countless coding interviews. The topic of this chapter is linked-lists: linear collections of elements whose order, unlike an array, is not dictated by their ordering in memory. By being one of the most simple and common data structures you can expect them to be as important for your interview preparation.</p>
<p>The major difference that lists offer over conventional arrays is that elements in the list can be efficiently (in constant time) removed and inserted without the need to reorganize and perform a complete restructuring of the whole data <a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a>. Because of this property linked lists are often used to implement more complex data structures where this insertion and deletion cost is crucial, for example associative arrays. There are however quite a few drawbacks associated with them, for instance:</p>
<div class="enumerate*">
<p>memory consumption (as for each node of the list you also pay a price as has to remember the next and/or previous nodes).</p>
<p>they offer sequential access. Accessing a node costs linear time.</p>
<p>cache unfriendly</p>
</div>
<p>. This is the reason why</p>
<p>A linked list is, at a high level of abstraction, a collection of so-called nodes or elements each of them (except the last) containing a pointer to the next one. Each node also carries payload data, which is the information you want ultimately to be stored. The standard linked lists has two special nodes:</p>
<ul>
<li><p>the head that is not pointed by other elements and is the first of the collection.</p></li>
<li><p>the tail, which is a node that has no next element, and is, not surprisingly, the last of the elements.</p></li>
</ul>
<p>In some particular cases during the manipulation of the list you might end up with a broken or corrupted one where the tail node does not exists anymore, meaning that each of the elements in the list is pointing to some other nodes. In this situation a loop forms and the list becomes what it known as a <em>circular</em> list. In this chapter we will investigate how we can find out whether:</p>
<div class="enumerate*">
<p>a list is circular, and when it is,</p>
<p>how to identify the first element of the loop.</p>
</div>
<p>.</p>
<h2 id="problem-statement-23">Problem statement</h2>
<div class="exercise">
<p>Given a singly linked list (definition in Listing <a href="#list:delete_duplicates_list:linked_list" data-reference-type="ref" data-reference="list:delete_duplicates_list:linked_list">[list:delete_duplicates_list:linked_list]</a> at page ) determine whether the list contains a loop.</p>
<ul>
<li><p>If it does, return the the node where the loop starts</p></li>
<li><p>otherwise, return <code>nullptr</code></p></li>
</ul>
<p>For the rest of the chapter we will use an array of integers to represents the nodes of the list and a single integer to represent the node the last element of the list connects to, in order to create a cycle or <span class="math inline">\(-1\)</span> if there is no cycle. For instance the array <span class="math inline">\(L=[1,2,3,4]\)</span> and the integer <span class="math inline">\(2\)</span> represent the list shown in Figure <a href="#fig:cycle_in_list:example1" data-reference-type="ref" data-reference="fig:cycle_in_list:example1">24.1</a>.</p>
<div class="example">
<p><br />
Given the List <span class="math inline">\(\{[1,2,3,4,5],2\}\)</span>, the function returns the address of the node <span class="math inline">\(2\)</span>. See Figure <a href="#fig:cycle_in_list:example1" data-reference-type="ref" data-reference="fig:cycle_in_list:example1">24.1</a>.</p>
</div>
<div class="example">
<p><br />
Given the List <span class="math inline">\(\{[1,2,3,4,5],-1\}\)</span>, the function returns . See Figure <a href="#fig:cycle_in_list:example2" data-reference-type="ref" data-reference="fig:cycle_in_list:example2">24.2</a>.</p>
</div>
</div>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/cycle_in_list/images/list_cycle.jpg" id="fig:cycle_in_list:example1" alt="Example of linked list with a cycle." /><figcaption aria-hidden="true">Example of linked list with a cycle.</figcaption>
</figure>
<p><span id="fig:cycle_in_list:example2" label="fig:cycle_in_list:example2">[fig:cycle_in_list:example2]</span> <img src="/home/dspataro/git/algorithm_articles/sources/cycle_in_list/images/list_no_cycle.jpg" title="fig:" id="fig:cycle_in_list:example2" alt="Example of linked list with no cycle." /></p>
<h2 id="cycle_in_list:sec:discussion">Discussion</h2>
<p>Considering this is a very well-known problem we will not spent time on dwelling on naive brute-force solution, and instead will only concentrate first on an optimal in time solution with linear space, and then we will concentrate on improving it by lowering the space complexity to constant.</p>
<p>All solution implementation in this chapter uses the Linked list definition shown in Listing <a href="#list:cycle_in_list:node_definition" data-reference-type="ref" data-reference="list:cycle_in_list:node_definition">[list:cycle_in_list:node_definition]</a>;</p>
<div class="sourceCode" id="list:cycle_in_list:node_definition" data-language="c++" data-caption="Singly linked-list node definition." label="list:cycle_in_list:node_definition"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:cycle_in_list:node_definition-1"><a href="#list:cycle_in_list:node_definition-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:cycle_in_list:node_definition-2"><a href="#list:cycle_in_list:node_definition-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node</span>
<span id="list:cycle_in_list:node_definition-3"><a href="#list:cycle_in_list:node_definition-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:cycle_in_list:node_definition-4"><a href="#list:cycle_in_list:node_definition-4" aria-hidden="true" tabindex="-1"></a>  T val<span class="op">;</span></span>
<span id="list:cycle_in_list:node_definition-5"><a href="#list:cycle_in_list:node_definition-5" aria-hidden="true" tabindex="-1"></a>  Node <span class="op">*</span>next<span class="op">;</span></span>
<span id="list:cycle_in_list:node_definition-6"><a href="#list:cycle_in_list:node_definition-6" aria-hidden="true" tabindex="-1"></a>  Node<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="list:cycle_in_list:node_definition-7"><a href="#list:cycle_in_list:node_definition-7" aria-hidden="true" tabindex="-1"></a>  Node<span class="op">(</span>T x<span class="op">)</span> <span class="op">:</span> val<span class="op">(</span>x<span class="op">),</span> next<span class="op">(</span><span class="kw">nullptr</span><span class="op">)</span></span>
<span id="list:cycle_in_list:node_definition-8"><a href="#list:cycle_in_list:node_definition-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:cycle_in_list:node_definition-9"><a href="#list:cycle_in_list:node_definition-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:cycle_in_list:node_definition-10"><a href="#list:cycle_in_list:node_definition-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="cycle_in_list:sec:bruteforce">Linear time and space solution</h3>
<p>This problem has many similarities with the problem of finding a duplicate in a collection and can therefore be solved using a similar approach. The idea is to visit the list and store in a hash-set the address of the node <strong>already</strong> visited. While visiting a new node, we first check if that node was already visited, and if yes, it means that we can stop because we found the starting point of a loop. If we reach the end of the list and we were not be able to find a duplicate, then it means there is no loop and we can return <code>nullptr</code>. A possible implementation of this idea is shown in Listing <a href="#list:cycle_in_list:linearspace" data-reference-type="ref" data-reference="list:cycle_in_list:linearspace">[list:cycle_in_list:linearspace]</a>.</p>
<div class="sourceCode" id="list:cycle_in_list:linearspace" data-language="c++" data-caption="Linear time and space solution to the problem of detecting a cycle in a linked list where an hashset is used to remember already visited nodes." label="list:cycle_in_list:linearspace"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:cycle_in_list:linearspace-1"><a href="#list:cycle_in_list:linearspace-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:cycle_in_list:linearspace-2"><a href="#list:cycle_in_list:linearspace-2" aria-hidden="true" tabindex="-1"></a>Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> detect_cycle_linear_time_space<span class="op">(</span>Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> head<span class="op">)</span></span>
<span id="list:cycle_in_list:linearspace-3"><a href="#list:cycle_in_list:linearspace-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:cycle_in_list:linearspace-4"><a href="#list:cycle_in_list:linearspace-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> Node_ptr <span class="op">=</span> Node<span class="op">&lt;</span>T<span class="op">&gt;*;</span></span>
<span id="list:cycle_in_list:linearspace-5"><a href="#list:cycle_in_list:linearspace-5" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>unordered_set<span class="op">&lt;</span>Node_ptr<span class="op">&gt;</span> visited<span class="op">;</span></span>
<span id="list:cycle_in_list:linearspace-6"><a href="#list:cycle_in_list:linearspace-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:cycle_in_list:linearspace-7"><a href="#list:cycle_in_list:linearspace-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>head<span class="op">)</span></span>
<span id="list:cycle_in_list:linearspace-8"><a href="#list:cycle_in_list:linearspace-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:cycle_in_list:linearspace-9"><a href="#list:cycle_in_list:linearspace-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// has the current node already been visited?</span></span>
<span id="list:cycle_in_list:linearspace-10"><a href="#list:cycle_in_list:linearspace-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>visited<span class="op">.</span>find<span class="op">(</span>head<span class="op">)</span> <span class="op">!=</span> visited<span class="op">.</span>end<span class="op">())</span></span>
<span id="list:cycle_in_list:linearspace-11"><a href="#list:cycle_in_list:linearspace-11" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> head<span class="op">;</span></span>
<span id="list:cycle_in_list:linearspace-12"><a href="#list:cycle_in_list:linearspace-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// if not, then remember that we did now</span></span>
<span id="list:cycle_in_list:linearspace-13"><a href="#list:cycle_in_list:linearspace-13" aria-hidden="true" tabindex="-1"></a>    visited<span class="op">.</span>insert<span class="op">(</span>head<span class="op">);</span></span>
<span id="list:cycle_in_list:linearspace-14"><a href="#list:cycle_in_list:linearspace-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// advance one node in the list</span></span>
<span id="list:cycle_in_list:linearspace-15"><a href="#list:cycle_in_list:linearspace-15" aria-hidden="true" tabindex="-1"></a>    head <span class="op">=</span> head<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:cycle_in_list:linearspace-16"><a href="#list:cycle_in_list:linearspace-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:cycle_in_list:linearspace-17"><a href="#list:cycle_in_list:linearspace-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="list:cycle_in_list:linearspace-18"><a href="#list:cycle_in_list:linearspace-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="cycle_in_list:sec:slowfast">Slow and fast pointer solution - Floyd’s algorithm </h3>
<p>This algorithm<span class="citation" data-cites="cit::wiki::floyd"></span> uses the fact that, like clock’s hands, things iterating on a cycle at different speeds will eventually meet at some point in the future. Consider two runner <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span> with velocities <span class="math inline">\(V_1\)</span> and <span class="math inline">\(V_2=2V_1\)</span> respectively (<span class="math inline">\(R_2\)</span> goes twice as fast then <span class="math inline">\(R_1\)</span>), starting their run from the same point in a circular stadium. They will meet again when the slower runner reach the starting point for the second time. Why? By the time the slower one has completed half circle the faster has completed a complete cycle and by the time the slower finishes his run, arriving at the starting point again, the faster has completed a second entire cycle. We can use this fact to detect a cycle in a linked list even if for the cycle detection problem things might be a bit more complicated because the two runners might now start going in loop at the same time (the list potentially has a first part the is not part of the loop as can be seen in Figure <a href="#fig:cycle_in_list:example1" data-reference-type="ref" data-reference="fig:cycle_in_list:example1">24.1</a>).</p>
<p>The rest of the section is a bit technical and you can skip to the implementation shown in Listing <a href="#list:cycle_in_list:constantspace" data-reference-type="ref" data-reference="list:cycle_in_list:constantspace">[list:cycle_in_list:constantspace]</a> which can be self-explanatory considering that in the end the intuition behind the algorithm is quite easy. If you are interested in the details of why it works, read along.</p>
<p>Consider two iterators p,q with velocities <span class="math inline">\(v_p=1\)</span>,<span class="math inline">\(v_q=2\)</span> respectively. Suppose the <strong>cycle</strong>(not the entire list) has length <span class="math inline">\(n\)</span>. We can have two scenarios depending on the index <span class="math inline">\(A\)</span> of the starting node of the cycle:</p>
<ol>
<li><p>the cycle starts at <span class="math inline">\(A &lt; n\)</span>.</p></li>
<li><p>or starts at <span class="math inline">\(A \geq n\)</span>.</p></li>
</ol>
<p>For the case <span class="math inline">\((1)\)</span> when the slower iterator reaches <span class="math inline">\(A\)</span> the faster is at location <span class="math inline">\(2A\)</span> (which might mean that the faster iterator looped around the cycle already). How many iterations <span class="math inline">\(k\)</span> it will take before they meet? And at which node? The situation is described by the following congruences: <span class="math display">\[\begin{aligned}
  A + kv_p &amp;\equiv 2A + k2v_p \Mod{n} \\
  2A + k2v_p &amp;\equiv A + kv_p \;  \Mod{n} \\
  A + k2v_p &amp;\equiv kv_p   \Mod{n} \\
  A +kv_p &amp;\equiv 0   \Mod{n} \\
  A +k &amp;\equiv 0  \Mod{n}\end{aligned}\]</span> which has solution <span class="math inline">\(k = n-A\)</span>. This means that they will meet after <span class="math inline">\(k=n-A\)</span> iterations of the slower iterator, i.e. at <span class="math inline">\(A\)</span> nodes before the beginning of the cycle and we can use this fact to count <span class="math inline">\(A\)</span> nodes from the beginning of the list so to find the starting point of the cycle.</p>
<p>So, once the iterators meet <strong>in the cycle</strong>, we can move the fast iterator back to the beginning of the list and iterate forward one node per step with both iterators until they match again. When we move the fast iterator back at the head of the list, <strong>both iterators are <span class="math inline">\(A\)</span> nodes away from the beginning of the cycle</strong>. Because of this, when we move both of them by one, they will eventually meet exactly at that node <span class="math inline">\(A\)</span> i.e. the beginning of the cycle.</p>
<p>Let’s consider now the case (<span class="math inline">\(2\)</span>) i.e. when <span class="math inline">\(A \geq n\)</span>. This means that by the time the slower iterator reaches the beginning of the cycle the faster one has completed more that a cycle. What will be the starting point for the faster one? We argue that once <span class="math inline">\(p\)</span> reaches <span class="math inline">\(A\)</span>, <span class="math inline">\(q\)</span> is at node <span class="math inline">\(2A\)</span> but since <span class="math inline">\(A &gt; n\)</span>, this means that it will be at position <span class="math inline">\(A + (A \Mod{n})\)</span>. We can now use similar argument to the previous case and write:</p>
<p><span class="math display">\[\begin{aligned}
  A + kv_p &amp;\equiv A + (A \Mod{n}) + (k2v_p \Mod{n}) \\
  A + (A \Mod{n}) + k2v_p &amp;\equiv A + kv_p\;\Mod{n} \\
  (A \Mod{n}) + kv_p \Mod{n} &amp; \equiv 0\Mod{n} \\
  (A \Mod{n}) + k \Mod{n} &amp;\equiv 0 \Mod{n} \: \: \text{  : because  } v_p=1 \\\end{aligned}\]</span> which has solution <span class="math inline">\(k = n-(A \Mod{n})\)</span>. This means that the meeting point is <span class="math inline">\(A \Mod{n}\)</span> nodes before the beginning of the cycle. If we do the same operations as the previous case,(when <span class="math inline">\(A &lt;
n\)</span>), we obtain again, the same result. Iterators will meet at the beginning of the cycle. Why? Well advancing <span class="math inline">\(q\)</span> makes <span class="math inline">\(p\)</span> cycle possibly several times ( remember that <span class="math inline">\(A \geq n\)</span>  ) and it will clearly stops at <span class="math inline">\(A+(n-A \Mod{n}) + A \Mod{n} = A +n \;(mod (n))= A\)</span>. In other words the slower pointer is at first  at node number <span class="math inline">\(A+(n-A \Mod{n})\)</span>. We can write <span class="math inline">\(A
= bn + r\)</span> where <span class="math inline">\(r = A \;\Mod{n}\)</span>. After <span class="math inline">\(A\)</span> advancing steps it will be at location  <span class="math inline">\(A+(n-A
\;\Mod{n}) +bn +r (\Mod{n})\)</span>. Since <span class="math inline">\(bn \; \Mod{n}=0\)</span> the result follows.</p>
<p>As an example consider a list with a cycle of length <span class="math inline">\(n=4\)</span> starting at node number <span class="math inline">\(10\)</span>. The first part of the algorithm tells us that the nodes will meet at node <span class="math inline">\(10 + 4 - 10 \: mod(4) =
12\)</span>. Moving the fast pointer back to the head of the list and iterating one node per time both iterators will lead the slower point to node:</p>
<p>Figure <a href="#fig:cycle_in_list:floyd" data-reference-type="ref" data-reference="fig:cycle_in_list:floyd">[fig:cycle_in_list:floyd]</a> depicts how the algorithm works on a list of <span class="math inline">\(8\)</span> nodes with a cycle of length <span class="math inline">\(4\)</span> starting at node number <span class="math inline">\(4\)</span>. After <span class="math inline">\(5\)</span> steps the slow (<span class="math inline">\(p\)</span>) and fast (<span class="math inline">\(q\)</span>) iterators point to the same node i.e. node number <span class="math inline">\(6\)</span>. After a new phase starts, with the slow pointer being moved to the head of the list and continues with both iterators moving forward by <span class="math inline">\(1\)</span> until they meet again. They will meet again at the beginning of the cycle.</p>
<p>An implementation of the Floyd’s algorithm is shown in Listing <a href="#list:cycle_in_list:constantspace" data-reference-type="ref" data-reference="list:cycle_in_list:constantspace">[list:cycle_in_list:constantspace]</a>.</p>
<div class="sourceCode" id="list:cycle_in_list:constantspace" data-language="c++" data-caption="Floyd&#39;s algorithm, linear time, constant space solution to the problem of detecting a cycle in a linked list." label="list:cycle_in_list:constantspace"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:cycle_in_list:constantspace-1"><a href="#list:cycle_in_list:constantspace-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:cycle_in_list:constantspace-2"><a href="#list:cycle_in_list:constantspace-2" aria-hidden="true" tabindex="-1"></a>Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>detect_cycle_constant_time<span class="op">(</span>Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>head<span class="op">)</span></span>
<span id="list:cycle_in_list:constantspace-3"><a href="#list:cycle_in_list:constantspace-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:cycle_in_list:constantspace-4"><a href="#list:cycle_in_list:constantspace-4" aria-hidden="true" tabindex="-1"></a>  Node<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span>n1<span class="op">,</span> <span class="op">*</span>n2<span class="op">;</span></span>
<span id="list:cycle_in_list:constantspace-5"><a href="#list:cycle_in_list:constantspace-5" aria-hidden="true" tabindex="-1"></a>  n1 <span class="op">=</span> n2 <span class="op">=</span> head<span class="op">;</span></span>
<span id="list:cycle_in_list:constantspace-6"><a href="#list:cycle_in_list:constantspace-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:cycle_in_list:constantspace-7"><a href="#list:cycle_in_list:constantspace-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>n1 <span class="op">&amp;&amp;</span> n2<span class="op">)</span></span>
<span id="list:cycle_in_list:constantspace-8"><a href="#list:cycle_in_list:constantspace-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:cycle_in_list:constantspace-9"><a href="#list:cycle_in_list:constantspace-9" aria-hidden="true" tabindex="-1"></a>    n1 <span class="op">=</span> n1<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:cycle_in_list:constantspace-10"><a href="#list:cycle_in_list:constantspace-10" aria-hidden="true" tabindex="-1"></a>    n2 <span class="op">=</span> n2<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:cycle_in_list:constantspace-11"><a href="#list:cycle_in_list:constantspace-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n2<span class="op">)</span></span>
<span id="list:cycle_in_list:constantspace-12"><a href="#list:cycle_in_list:constantspace-12" aria-hidden="true" tabindex="-1"></a>      n2 <span class="op">=</span> n2<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:cycle_in_list:constantspace-13"><a href="#list:cycle_in_list:constantspace-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="list:cycle_in_list:constantspace-14"><a href="#list:cycle_in_list:constantspace-14" aria-hidden="true" tabindex="-1"></a>      <span class="cf">break</span><span class="op">;</span></span>
<span id="list:cycle_in_list:constantspace-15"><a href="#list:cycle_in_list:constantspace-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:cycle_in_list:constantspace-16"><a href="#list:cycle_in_list:constantspace-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n1 <span class="op">==</span> n2<span class="op">)</span></span>
<span id="list:cycle_in_list:constantspace-17"><a href="#list:cycle_in_list:constantspace-17" aria-hidden="true" tabindex="-1"></a>      <span class="cf">break</span><span class="op">;</span></span>
<span id="list:cycle_in_list:constantspace-18"><a href="#list:cycle_in_list:constantspace-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:cycle_in_list:constantspace-19"><a href="#list:cycle_in_list:constantspace-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">// second phase floys&#39;s algorithm</span></span>
<span id="list:cycle_in_list:constantspace-20"><a href="#list:cycle_in_list:constantspace-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>n1 <span class="op">==</span> n2<span class="op">)</span></span>
<span id="list:cycle_in_list:constantspace-21"><a href="#list:cycle_in_list:constantspace-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:cycle_in_list:constantspace-22"><a href="#list:cycle_in_list:constantspace-22" aria-hidden="true" tabindex="-1"></a>    n2 <span class="op">=</span> head<span class="op">;</span></span>
<span id="list:cycle_in_list:constantspace-23"><a href="#list:cycle_in_list:constantspace-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>n1 <span class="op">!=</span> n2<span class="op">)</span></span>
<span id="list:cycle_in_list:constantspace-24"><a href="#list:cycle_in_list:constantspace-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:cycle_in_list:constantspace-25"><a href="#list:cycle_in_list:constantspace-25" aria-hidden="true" tabindex="-1"></a>      n1 <span class="op">=</span> n1<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:cycle_in_list:constantspace-26"><a href="#list:cycle_in_list:constantspace-26" aria-hidden="true" tabindex="-1"></a>      n2 <span class="op">=</span> n2<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:cycle_in_list:constantspace-27"><a href="#list:cycle_in_list:constantspace-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:cycle_in_list:constantspace-28"><a href="#list:cycle_in_list:constantspace-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> n1<span class="op">;</span></span>
<span id="list:cycle_in_list:constantspace-29"><a href="#list:cycle_in_list:constantspace-29" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:cycle_in_list:constantspace-30"><a href="#list:cycle_in_list:constantspace-30" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="list:cycle_in_list:constantspace-31"><a href="#list:cycle_in_list:constantspace-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/cycle_in_list/images/floyd1.jpg" id="fig:cycle_in_list:floyd1" alt="At the beginning p=q=1. The slow and fast forward: p=p+1, q=q+2." /><figcaption aria-hidden="true">At the beginning <span class="math inline">\(p=q=1\)</span>. The slow and fast forward: <span class="math inline">\(p=p+1\)</span>, <span class="math inline">\(q=q+2\)</span>.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/cycle_in_list/images/floyd2.jpg" id="fig:cycle_in_list:floyd2" alt="p \neq q, thus: p=p+1, q=q+2" /><figcaption aria-hidden="true"><span class="math inline">\(p \neq q\)</span>, thus: <span class="math inline">\(p=p+1\)</span>, <span class="math inline">\(q=q+2\)</span></figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/cycle_in_list/images/floyd3.jpg" id="fig:cycle_in_list:floyd3" alt="p \neq q, thus: p=p+1, q=q+2" /><figcaption aria-hidden="true"><span class="math inline">\(p \neq q\)</span>, thus: <span class="math inline">\(p=p+1\)</span>, <span class="math inline">\(q=q+2\)</span></figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/cycle_in_list/images/floyd4.jpg" id="fig:cycle_in_list:floyd4" alt="p \neq q, thus: p=p+1, q=q+2" /><figcaption aria-hidden="true"><span class="math inline">\(p \neq q\)</span>, thus: <span class="math inline">\(p=p+1\)</span>, <span class="math inline">\(q=q+2\)</span></figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/cycle_in_list/images/floyd5.jpg" id="fig:cycle_in_list:floyd5" alt="p \neq q, thus: p=p+1, q=q+2" /><figcaption aria-hidden="true"><span class="math inline">\(p \neq q\)</span>, thus: <span class="math inline">\(p=p+1\)</span>, <span class="math inline">\(q=q+2\)</span></figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/cycle_in_list/images/floyd6.jpg" id="fig:cycle_in_list:floyd6" alt="p = q. The fast and slow movements stop." /><figcaption aria-hidden="true"><span class="math inline">\(p = q\)</span>. The fast and slow movements stop.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/cycle_in_list/images/floyd7.jpg" id="fig:cycle_in_list:floyd7" alt="p is reset to the beginning of the list. q is not moved. From now on p and q are moved one step at the time." /><figcaption aria-hidden="true"><span class="math inline">\(p\)</span> is reset to the beginning of the list. <span class="math inline">\(q\)</span> is not moved. From now on <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> are moved one step at the time.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/cycle_in_list/images/floyd8.jpg" id="fig:cycle_in_list:floyd8" alt="p \neq q, thus: p=p+1, q=q+1" /><figcaption aria-hidden="true"><span class="math inline">\(p \neq q\)</span>, thus: <span class="math inline">\(p=p+1\)</span>, <span class="math inline">\(q=q+1\)</span></figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/cycle_in_list/images/floyd9.jpg" id="fig:cycle_in_list:floyd9" alt="p \neq q, thus: p=p+1, q=q+1" /><figcaption aria-hidden="true"><span class="math inline">\(p \neq q\)</span>, thus: <span class="math inline">\(p=p+1\)</span>, <span class="math inline">\(q=q+1\)</span></figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/cycle_in_list/images/floyd10.jpg" id="fig:cycle_in_list:floyd10" alt="p = q. The algorithm stops, and both p and q point to the beginning of the cycle." /><figcaption aria-hidden="true"><span class="math inline">\(p = q\)</span>. The algorithm stops, and both <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> point to the beginning of the cycle.</figcaption>
</figure>
<h1 id="ch:list_reverse">Reverse a singly linked list</h1>
<h2 class="unnumbered" id="introduction-24">Introduction</h2>
<p>In this chapter we are going to have a look at a problem that is about reversing a singly linked list. This problem has been asked in coding interviews for a long time. and despite the fact it is among the most basic problems on linked-list out there and despite its popularity and the fact it is about one of the basic fundamental data structures in computer science, it has been proven to be the cause of failure for many software engineers interview. Most often, being unable to solve these problems result in almost immediate rejection.</p>
<p>The problem has a simple definition as it asks us to transform a given list into its reverse. We will discuss how we can approach this problem both in a recursive as well as in an iterative manner. Section <a href="#sec:list_reverse:statement" data-reference-type="ref" data-reference="sec:list_reverse:statement">[sec:list_reverse:statement]</a> will present the formal problem statement and the subsequent sections discuss the details of the solution. Finally in Section <a href="#sec:list_reverse:hard" data-reference-type="ref" data-reference="sec:list_reverse:hard">[sec:list_reverse:hard]</a> we will have a look at the slightly harder variation that if often asked as a follow-up and which solution is left as an exercices.</p>
<h2 id="problem-statement-24">Problem statement</h2>
<div class="exercise">
<p>Create a function that given a singly linked list <span class="math inline">\(L\)</span>, reverses it and return the pointer to the new head of <span class="math inline">\(L\)</span>. <span class="math inline">\(L\)</span> is given as a pointer to the first node of the list. The definition of the node is given in Listing <a href="#list:list_reverse:node_definition" data-reference-type="ref" data-reference="list:list_reverse:node_definition">[list:list_reverse:node_definition]</a>.</p>
<div class="example">
<p><br />
Given the <span class="math inline">\(L = 1 \rightarrow 2 \rightarrow 3 \rightarrow 4 \rightarrow 5\)</span>, the function modifies it into <span class="math inline">\(L = 5 \rightarrow 4 \rightarrow 3 \rightarrow 2 \rightarrow 1\)</span> and returns a pointer to the node <span class="math inline">\(5\)</span>, the new head of the list.</p>
</div>
</div>
<div class="sourceCode" id="list:list_reverse:node_definition" data-language="c++" data-caption="Singly linked-list node definition." label="list:list_reverse:node_definition"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:list_reverse:node_definition-1"><a href="#list:list_reverse:node_definition-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:list_reverse:node_definition-2"><a href="#list:list_reverse:node_definition-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node</span>
<span id="list:list_reverse:node_definition-3"><a href="#list:list_reverse:node_definition-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:list_reverse:node_definition-4"><a href="#list:list_reverse:node_definition-4" aria-hidden="true" tabindex="-1"></a>  T val<span class="op">;</span></span>
<span id="list:list_reverse:node_definition-5"><a href="#list:list_reverse:node_definition-5" aria-hidden="true" tabindex="-1"></a>  Node <span class="op">*</span>next<span class="op">;</span></span>
<span id="list:list_reverse:node_definition-6"><a href="#list:list_reverse:node_definition-6" aria-hidden="true" tabindex="-1"></a>  Node<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="list:list_reverse:node_definition-7"><a href="#list:list_reverse:node_definition-7" aria-hidden="true" tabindex="-1"></a>  Node<span class="op">(</span>T x<span class="op">)</span> <span class="op">:</span> val<span class="op">(</span>x<span class="op">),</span> next<span class="op">(</span><span class="kw">nullptr</span><span class="op">)</span></span>
<span id="list:list_reverse:node_definition-8"><a href="#list:list_reverse:node_definition-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:list_reverse:node_definition-9"><a href="#list:list_reverse:node_definition-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:list_reverse:node_definition-10"><a href="#list:list_reverse:node_definition-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="clarification-questions-21">Clarification Questions</h2>
<div class="QandA">
<p>Can the input list be empty?</p>
<div class="answered">
<p><em>Yes.</em></p>
</div>
<p>Can I assume <span class="math inline">\(L\)</span> is not corrupted by for instance containing cycles?</p>
<div class="answered">
<p><em>Yes, the input list is a singly linked list with no cycles.</em></p>
</div>
</div>
<h2 id="list_reverse:sec:discussion">Discussion</h2>
<p>Solving this problem by using linear additional space is trivial as we can iterate over the list and for each push the address of each of its nodes in a stack. We can then, pop them one at a time while making sure they are connected in the same order they are popped-out. Listing <a href="#list:list_reverse:stack" data-reference-type="ref" data-reference="list:list_reverse:stack">[list:list_reverse:stack]</a> shows a possible implementation of this idea. The time and space complexity of this approach is <span class="math inline">\(O(n)\)</span>.</p>
<div class="sourceCode" id="list:list_reverse:stack" data-language="c++" data-caption="Linear time and space complexity solution using a stack to reverse the nodes in the list." label="list:list_reverse:stack"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:list_reverse:stack-1"><a href="#list:list_reverse:stack-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:list_reverse:stack-2"><a href="#list:list_reverse:stack-2" aria-hidden="true" tabindex="-1"></a>Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> list_reverse_linear_space<span class="op">(</span>Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> L<span class="op">)</span></span>
<span id="list:list_reverse:stack-3"><a href="#list:list_reverse:stack-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:list_reverse:stack-4"><a href="#list:list_reverse:stack-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>L<span class="op">)</span></span>
<span id="list:list_reverse:stack-5"><a href="#list:list_reverse:stack-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="list:list_reverse:stack-6"><a href="#list:list_reverse:stack-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:list_reverse:stack-7"><a href="#list:list_reverse:stack-7" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>stack<span class="op">&lt;</span>Node<span class="op">&lt;</span>T<span class="op">&gt;*&gt;</span> nodes<span class="op">;</span></span>
<span id="list:list_reverse:stack-8"><a href="#list:list_reverse:stack-8" aria-hidden="true" tabindex="-1"></a>  Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> it <span class="op">=</span> L<span class="op">;</span></span>
<span id="list:list_reverse:stack-9"><a href="#list:list_reverse:stack-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>it<span class="op">)</span></span>
<span id="list:list_reverse:stack-10"><a href="#list:list_reverse:stack-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:list_reverse:stack-11"><a href="#list:list_reverse:stack-11" aria-hidden="true" tabindex="-1"></a>    nodes<span class="op">.</span>push<span class="op">(</span>it<span class="op">);</span></span>
<span id="list:list_reverse:stack-12"><a href="#list:list_reverse:stack-12" aria-hidden="true" tabindex="-1"></a>    it <span class="op">=</span> it<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:list_reverse:stack-13"><a href="#list:list_reverse:stack-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:list_reverse:stack-14"><a href="#list:list_reverse:stack-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:list_reverse:stack-15"><a href="#list:list_reverse:stack-15" aria-hidden="true" tabindex="-1"></a>  Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> new_head <span class="op">=</span> nodes<span class="op">.</span>top<span class="op">();</span></span>
<span id="list:list_reverse:stack-16"><a href="#list:list_reverse:stack-16" aria-hidden="true" tabindex="-1"></a>  nodes<span class="op">.</span>pop<span class="op">();</span></span>
<span id="list:list_reverse:stack-17"><a href="#list:list_reverse:stack-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:list_reverse:stack-18"><a href="#list:list_reverse:stack-18" aria-hidden="true" tabindex="-1"></a>  it <span class="op">=</span> new_head<span class="op">;</span></span>
<span id="list:list_reverse:stack-19"><a href="#list:list_reverse:stack-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(!</span>nodes<span class="op">.</span>empty<span class="op">())</span></span>
<span id="list:list_reverse:stack-20"><a href="#list:list_reverse:stack-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:list_reverse:stack-21"><a href="#list:list_reverse:stack-21" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> it_next <span class="op">=</span> nodes<span class="op">.</span>top<span class="op">();</span></span>
<span id="list:list_reverse:stack-22"><a href="#list:list_reverse:stack-22" aria-hidden="true" tabindex="-1"></a>    nodes<span class="op">.</span>pop<span class="op">();</span></span>
<span id="list:list_reverse:stack-23"><a href="#list:list_reverse:stack-23" aria-hidden="true" tabindex="-1"></a>    it<span class="op">-&gt;</span>next <span class="op">=</span> it_next<span class="op">;</span></span>
<span id="list:list_reverse:stack-24"><a href="#list:list_reverse:stack-24" aria-hidden="true" tabindex="-1"></a>    it       <span class="op">=</span> it_next<span class="op">;</span></span>
<span id="list:list_reverse:stack-25"><a href="#list:list_reverse:stack-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:list_reverse:stack-26"><a href="#list:list_reverse:stack-26" aria-hidden="true" tabindex="-1"></a>  it<span class="op">-&gt;</span>next <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="list:list_reverse:stack-27"><a href="#list:list_reverse:stack-27" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> new_head<span class="op">;</span></span>
<span id="list:list_reverse:stack-28"><a href="#list:list_reverse:stack-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We can however avoid using additional space in the form of a and rely on the implicit stack we get when we perform recursive calls. In order to take advantage of it, it is convenient however, to shift our view of the problem and see it as follows. Imagine we have a list such that it is already reversed after its <span class="math inline">\(k^{th}\)</span> node. How can we then reverse the rest of it? Let’s have a look at Figure <a href="#fig:list_reverse:list_reverse_recursive_intermediate" data-reference-type="ref" data-reference="fig:list_reverse:list_reverse_recursive_intermediate">25.1</a> depicting this scenario where <span class="math inline">\(k=4\)</span>. As you can see the list is already reversed from node <span class="math inline">\(5\)</span> onwards and all we have to do if to have it pointing to node <span class="math inline">\(4\)</span> and make <span class="math inline">\(4\)</span> points to nothing. More generically what we want to achieve is to make the node <span class="math inline">\(k+1\)</span> (<span class="math inline">\(L_{k+1}\)</span>) point to the node <span class="math inline">\(k\)</span> (<span class="math inline">\(L_{k+1}\)</span>). We can achieve that by doing: <span class="math inline">\(L_{k} \rightarrow next \rightarrow next= L_{k}(L_{k+1}\)</span>). W.r.t. Figure <a href="#fig:list_reverse:list_reverse_recursive_intermediate" data-reference-type="ref" data-reference="fig:list_reverse:list_reverse_recursive_intermediate">25.1</a> <span class="math inline">\(L_{k} \rightarrow next\)</span> is <span class="math inline">\(5\)</span> and <span class="math inline">\(L_{k} \rightarrow next\)</span> is pointing to nothing. After these operations what we are left with the list shown in Figure <a href="#fig:list_reverse:list_reverse_recursive_intermediate1" data-reference-type="ref" data-reference="fig:list_reverse:list_reverse_recursive_intermediate1">25.2</a>. If we do that for each of the nodes eventually we are left with a reversed list.</p>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/list_reverse/images/list_reverse_recursive_intermediate.jpg" id="fig:list_reverse:list_reverse_recursive_intermediate" alt="Nodes arrangements in the middle of the recursive process for node 5" /><figcaption aria-hidden="true">Nodes arrangements in the middle of the recursive process for node <span class="math inline">\(5\)</span></figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/list_reverse/images/list_reverse_recursive_intermediate1.jpg" id="fig:list_reverse:list_reverse_recursive_intermediate1" alt="Nodes arrangements after performing the recursive call for node 5." /><figcaption aria-hidden="true">Nodes arrangements after performing the recursive call for node <span class="math inline">\(5\)</span>.</figcaption>
</figure>
<p>But what about the new head of the list? What should each recursive call return? This is actually pretty simple. Whenever we reach the end of the list<a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a> we return the current node, which is effectively the new head of the reversed list, and we keep propagating that value for all the recursive calls.</p>
<p>To summarise, for each recursive call we first reverse the rest of the list and we get back the head of the reversed list. We can now take care of reversing the link from the current node to the next and return the head we got back from the recursive call. Listing <a href="#list:list_reverse:recursive" data-reference-type="ref" data-reference="list:list_reverse:recursive">[list:list_reverse:recursive]</a> shows a possible implementation of this idea. Notice that despite this solution does not explicitly use any additional space, it still requires spaces for the activation frames of all the recursive calls. Therefore its complexity remains equivalent to the one of Listing <a href="#list:list_reverse:stack" data-reference-type="ref" data-reference="list:list_reverse:stack">[list:list_reverse:stack]</a>.</p>
<div class="sourceCode" id="list:list_reverse:recursive" data-language="c++" data-caption="Recursive linear time and space complexity solution to reverse the nodes in the list." label="list:list_reverse:recursive"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:list_reverse:recursive-1"><a href="#list:list_reverse:recursive-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:list_reverse:recursive-2"><a href="#list:list_reverse:recursive-2" aria-hidden="true" tabindex="-1"></a>Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> list_reverse_recursive<span class="op">(</span>Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> L<span class="op">)</span></span>
<span id="list:list_reverse:recursive-3"><a href="#list:list_reverse:recursive-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:list_reverse:recursive-4"><a href="#list:list_reverse:recursive-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>L <span class="op">||</span> <span class="op">!(</span>L<span class="op">-&gt;</span>next<span class="op">))</span></span>
<span id="list:list_reverse:recursive-5"><a href="#list:list_reverse:recursive-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> L<span class="op">;</span></span>
<span id="list:list_reverse:recursive-6"><a href="#list:list_reverse:recursive-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:list_reverse:recursive-7"><a href="#list:list_reverse:recursive-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> reverse_next_head <span class="op">=</span> list_reverse_recursive<span class="op">(</span>L<span class="op">-&gt;</span>next<span class="op">);</span></span>
<span id="list:list_reverse:recursive-8"><a href="#list:list_reverse:recursive-8" aria-hidden="true" tabindex="-1"></a>  L<span class="op">-&gt;</span>next<span class="op">-&gt;</span>next          <span class="op">=</span> L<span class="op">;</span></span>
<span id="list:list_reverse:recursive-9"><a href="#list:list_reverse:recursive-9" aria-hidden="true" tabindex="-1"></a>  L<span class="op">-&gt;</span>next                <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="list:list_reverse:recursive-10"><a href="#list:list_reverse:recursive-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> reverse_next_head<span class="op">;</span></span>
<span id="list:list_reverse:recursive-11"><a href="#list:list_reverse:recursive-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="constant-space">Constant space</h3>
<p>It is impossible to solve this problem faster than linear time as each node needs accessed at least once, but we can bring the space complexity down to constant, by reversing the list two nodes at a time from the head to the tail. Assuming <span class="math inline">\(L\)</span> has at least two nodes (if not we are in a trivial case in which the list is already reversed and <span class="math inline">\(L\)</span> is also the head of the reversed list) then we can always maintain two pointers to the current element and its next . We know that points to but what we really want to achieve is pointing to <span class="math inline">\(curr\)</span>. We can take care of that and proceed with moving curr and forward and repeat the process. Eventually we will have reversed all nodes in the list. This process ends whenever we reach the last of the list, which also happen to be the new head of the list.</p>
<p>An implementation of such idea is shown in Listing <a href="#list:list_reverse:constant_space" data-reference-type="ref" data-reference="list:list_reverse:constant_space">[list:list_reverse:constant_space]</a>. Notice that while making point to we also need to remember the element points to, otherwise it would be impossible to move and forward. Figure <a href="#fig:list_reverse:list_reverse_iterative_execution" data-reference-type="ref" data-reference="fig:list_reverse:list_reverse_iterative_execution">[fig:list_reverse:list_reverse_iterative_execution]</a> shows the execution of the algorithm in Listing <a href="#list:list_reverse:constant_space" data-reference-type="ref" data-reference="list:list_reverse:constant_space">[list:list_reverse:constant_space]</a> on a list of <span class="math inline">\(7\)</span> elements.</p>
<div class="sourceCode" id="list:list_reverse:constant_space" data-language="c++" data-caption="Iterative constant space solution to the problem of reversing a list." label="list:list_reverse:constant_space"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:list_reverse:constant_space-1"><a href="#list:list_reverse:constant_space-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:list_reverse:constant_space-2"><a href="#list:list_reverse:constant_space-2" aria-hidden="true" tabindex="-1"></a>Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> list_reverse_constant_space_iterative<span class="op">(</span>Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> L<span class="op">)</span></span>
<span id="list:list_reverse:constant_space-3"><a href="#list:list_reverse:constant_space-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:list_reverse:constant_space-4"><a href="#list:list_reverse:constant_space-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>L <span class="op">||</span> <span class="op">!(</span>L<span class="op">-&gt;</span>next<span class="op">))</span></span>
<span id="list:list_reverse:constant_space-5"><a href="#list:list_reverse:constant_space-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> L<span class="op">;</span></span>
<span id="list:list_reverse:constant_space-6"><a href="#list:list_reverse:constant_space-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:list_reverse:constant_space-7"><a href="#list:list_reverse:constant_space-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> curr      <span class="op">=</span> L<span class="op">;</span></span>
<span id="list:list_reverse:constant_space-8"><a href="#list:list_reverse:constant_space-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> curr_next <span class="op">=</span> curr<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:list_reverse:constant_space-9"><a href="#list:list_reverse:constant_space-9" aria-hidden="true" tabindex="-1"></a>  curr<span class="op">-&gt;</span>next     <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span>  <span class="co">// the first node is the new tail</span></span>
<span id="list:list_reverse:constant_space-10"><a href="#list:list_reverse:constant_space-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>curr <span class="op">&amp;&amp;</span> curr_next<span class="op">)</span></span>
<span id="list:list_reverse:constant_space-11"><a href="#list:list_reverse:constant_space-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:list_reverse:constant_space-12"><a href="#list:list_reverse:constant_space-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> temp       <span class="op">=</span> curr_next<span class="op">-&gt;</span>next<span class="op">;</span>  <span class="co">// needed to move forward curr_next</span></span>
<span id="list:list_reverse:constant_space-13"><a href="#list:list_reverse:constant_space-13" aria-hidden="true" tabindex="-1"></a>    curr_next<span class="op">-&gt;</span>next <span class="op">=</span> curr<span class="op">;</span></span>
<span id="list:list_reverse:constant_space-14"><a href="#list:list_reverse:constant_space-14" aria-hidden="true" tabindex="-1"></a>    curr            <span class="op">=</span> curr_next<span class="op">;</span></span>
<span id="list:list_reverse:constant_space-15"><a href="#list:list_reverse:constant_space-15" aria-hidden="true" tabindex="-1"></a>    curr_next       <span class="op">=</span> temp<span class="op">;</span></span>
<span id="list:list_reverse:constant_space-16"><a href="#list:list_reverse:constant_space-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:list_reverse:constant_space-17"><a href="#list:list_reverse:constant_space-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> curr<span class="op">;</span></span>
<span id="list:list_reverse:constant_space-18"><a href="#list:list_reverse:constant_space-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/list_reverse/images/list_reverse_iterative1.jpg" id="fig:list_reverse:list_reverse_iterative1" alt="Step 1" /><figcaption aria-hidden="true">Step <span class="math inline">\(1\)</span></figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/list_reverse/images/list_reverse_iterative2.jpg" id="fig:list_reverse:list_reverse_iterative1" alt="Step 2" /><figcaption aria-hidden="true">Step <span class="math inline">\(2\)</span></figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/list_reverse/images/list_reverse_iterative3.jpg" id="fig:list_reverse:list_reverse_iterative1" alt="Step 3" /><figcaption aria-hidden="true">Step <span class="math inline">\(3\)</span></figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/list_reverse/images/list_reverse_iterative4.jpg" id="fig:list_reverse:list_reverse_iterative1" alt="Step 4" /><figcaption aria-hidden="true">Step <span class="math inline">\(4\)</span></figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/list_reverse/images/list_reverse_iterative5.jpg" id="fig:list_reverse:list_reverse_iterative1" alt="Step 5" /><figcaption aria-hidden="true">Step <span class="math inline">\(5\)</span></figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/list_reverse/images/list_reverse_iterative6.jpg" id="fig:list_reverse:list_reverse_iterative1" alt="Step 6" /><figcaption aria-hidden="true">Step <span class="math inline">\(6\)</span></figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/list_reverse/images/list_reverse_iterative7.jpg" id="fig:list_reverse:list_reverse_iterative7" alt="Step 7. is the new head of the reversed list." /><figcaption aria-hidden="true">Step <span class="math inline">\(7\)</span>. is the new head of the reversed list.</figcaption>
</figure>
<h2 id="conclusion-1">Conclusion</h2>
<p>In this chapter we discussed three possible approaches to the problem of reversing a singly-linked list. We saw that it is almost trivial when using an iterative approach together with a stack to store the addressed of the list’s nodes. This approach is based on the fact that the ordering of <span class="math inline">\(n\)</span> elements popped from a stack is the reverse of the ordering the elements have been pushed onto.</p>
<p>We then had a look at an alternative solution that is somehow based on the same stack idea, whereas this time we did not use an explicit stack to store the nodes, but we have somehow stored the same information in the call stack of the recursive function.</p>
<p>Lastly we discussed a solution where only a constant space is required. This approach works iteratively from the head to the tail of the list by reversing two nodes at a time.</p>
<h2 id="common-variation---reserve-a-sublist">Common variation - Reserve a sublist</h2>
<h3 id="problem-statement-25">Problem statement</h3>
<div class="exercise">
<p>Create a function that given a singly linked list <span class="math inline">\(L\)</span> and two integers <span class="math inline">\(n \geq  m \geq 0\)</span>, reverses only its nodes from the <span class="math inline">\(m^{th}\)</span> to the <span class="math inline">\(n^{th}\)</span> and return the pointer to the new head of <span class="math inline">\(L\)</span>. As in the other version of this problem discussed above the definition of a node is the same and the list <span class="math inline">\(L\)</span> is given as a pointer to the first node of the list itself.</p>
<div class="example">
<p><br />
Given the <span class="math inline">\(L = 1 \rightarrow 2 \rightarrow 3 \rightarrow 4 \rightarrow 5\)</span>, <span class="math inline">\(m = 3\)</span>, <span class="math inline">\(n = 5\)</span> the function modifies it into <span class="math inline">\(L = 1 \rightarrow 2 \rightarrow 5 \rightarrow 4 \rightarrow 3\)</span> and returns a pointer to the node <span class="math inline">\(1\)</span>.</p>
</div>
<div class="example">
<p><br />
Given the <span class="math inline">\(L = 1 \rightarrow 2 \rightarrow 3 \rightarrow 4 \rightarrow 5\)</span>, <span class="math inline">\(m = 1\)</span>, <span class="math inline">\(n = 2\)</span> the function modifies it into <span class="math inline">\(L = 1 \rightarrow 2 \rightarrow 5 \rightarrow 4 \rightarrow 3\)</span> and returns a pointer to the node <span class="math inline">\(1\)</span>.</p>
</div>
</div>
<h1 id="ch:min_stack">Min stack</h1>
<h2 class="unnumbered" id="introduction-25">Introduction</h2>
<p>This chapter introduces a very popular question among among companies like Yahoo, Amazon, Adobe and Microsoft. The question is very simple and is about designing a data structure for performing stack operations that is also able to keep track of the minimum element that is currently present in the stack. This problem has a simple, short and elegant solution. It is important to learn how to solve it as it is not unlikely you will be asked a very similar problem during the on-line screening steps of the interview process or one of the first on-site.</p>
<h2 id="problem-statement-26">Problem statement</h2>
<div class="exercise">
<p>Design a stack that supports:</p>
<ul>
<li><p><code>push(x)</code>: the element <span class="math inline">\(x\)</span> is pushed onto the stack</p></li>
<li><p><code>pop()</code>: removes the top of the stack</p></li>
<li><p><code>top()</code>: retrieve the top of the stack</p></li>
<li><p><code>get_min()</code>: retrieve the minimum among all elements present in the stack.</p></li>
</ul>
<div class="example">
<p><br />
Suppose the following set of operation on the stack are performed on a newly constructed and empty stack <span class="math inline">\(S\)</span>:</p>
<ul>
<li><p><code>push(1)</code>: <span class="math inline">\(S=[1]\)</span></p></li>
<li><p><code>push(5)</code>: <span class="math inline">\(S=[5,1]\)</span></p></li>
<li><p><code>push(3)</code>: <span class="math inline">\(S=[3,5,1]\)</span></p></li>
<li><p><code>top()</code>: <span class="math inline">\(S=[3,5,1]\)</span>, returns <span class="math inline">\(3\)</span></p></li>
<li><p><code>pop()</code>: <span class="math inline">\(S=[5,1]\)</span></p></li>
<li><p><code>get_min()</code>: <span class="math inline">\(S=[5,1]\)</span>, return <span class="math inline">\(1\)</span></p></li>
<li><p><code>push(0)</code>: <span class="math inline">\(S=[0,5,1]\)</span></p></li>
<li><p><code>get_min()</code>: <span class="math inline">\(S=[0,5,1]\)</span>, returns <span class="math inline">\(0\)</span></p></li>
</ul>
</div>
<div class="example">
<p><br />
Suppose the following set of operation on the stack are performed on a newly constructed and empty stack <span class="math inline">\(S\)</span>:</p>
<ul>
<li><p><code>push(3)</code>: <span class="math inline">\(S=[3]\)</span></p></li>
<li><p><code>push(5)</code>: <span class="math inline">\(S=[5,3]\)</span></p></li>
<li><p><code>push(1)</code>: <span class="math inline">\(S=[1,5,3]\)</span></p></li>
<li><p><code>get_min</code>: <span class="math inline">\(S=[1,5,3]\)</span>, return <span class="math inline">\(1\)</span></p></li>
<li><p><code>pop()</code>: <span class="math inline">\(S=[5,3]\)</span>, returns <span class="math inline">\(3\)</span></p></li>
<li><p><code>get_min()</code>: <span class="math inline">\(S=[5,3]\)</span>, return <span class="math inline">\(3\)</span></p></li>
<li><p><code>pop()</code>: <span class="math inline">\(S=[1]\)</span>, return <span class="math inline">\(1\)</span></p></li>
<li><p><code>pop()</code>: <span class="math inline">\(S=[]\)</span></p></li>
<li><p><code>pop()</code>: raise <code>std::logic_error</code></p></li>
</ul>
</div>
</div>
<h2 id="clarification-questions-22">Clarification Questions</h2>
<div class="QandA">
<p>What should be done when <code>get_min()</code> or <code>top()</code> or <code>pop()</code> are performed on an empty stack?</p>
<div class="answered">
<p><em>You should throw a <code>std::logic_error</code> exception with a sensible and short description.</em></p>
</div>
</div>
<h2 id="min_stack:sec:discussion">Discussion</h2>
<p>This problem can become quite tricky if approached from the wrong angle. We will discuss two solutions to this problem, both of which are good candidates for you to use during an actual interview.</p>
<h3 id="min_stack:sec:double_stack">Linear Space solutions</h3>
<h4 id="min_stack:sec:stackpairs">Stack of pairs</h4>
<p>The first solution we discuss uses an additional space (<span class="math inline">\(2\times\)</span>) to store, for each element of the stack, the information about the minimum among the elements still present in the stack. In order to do so we will will use a stack of <strong>pairs</strong>, where the first item of each pair is the actual element we want to push into out data structure and the second is the minimum value among the elements we have seen so far. Given this set-up the operations can then be implemented as follows:</p>
<ul>
<li><p><code>push(x)</code>. We will store on top of the stack of pair either the pair <span class="math inline">\(\{x,x\}\)</span> if the stack is empty or <code>{std::min(x,get_min())</code>.</p></li>
<li><p><code>top(x)</code> returns the <strong>first</strong> element of the top of the stack of pair if the stack is not empty, otherwise it throws an exception.</p></li>
<li><p><code>pop(x)</code> will call pop on the stack of pairs if the stack is not empty, otherwise raises an exception.</p></li>
<li><p><code>get_min(x)</code> returns the <strong>second</strong> element of the top of the stack of pair if the stack is not empty, otherwise it throws an exception.</p></li>
</ul>
<p>Listing <a href="#list:min_stack:stackpairs" data-reference-type="ref" data-reference="list:min_stack:stackpairs">[list:min_stack:stackpairs]</a> shows a possible implementation of this idea.</p>
<div class="sourceCode" id="list:min_stack:stackpairs" data-language="c++" data-caption="Solution to the problem of designing a min stack using a stack of pairs." label="list:min_stack:stackpairs"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:min_stack:stackpairs-1"><a href="#list:min_stack:stackpairs-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="list:min_stack:stackpairs-2"><a href="#list:min_stack:stackpairs-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> min_stack_stack_pair</span>
<span id="list:min_stack:stackpairs-3"><a href="#list:min_stack:stackpairs-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:min_stack:stackpairs-4"><a href="#list:min_stack:stackpairs-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="list:min_stack:stackpairs-5"><a href="#list:min_stack:stackpairs-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> push<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> x<span class="op">)</span></span>
<span id="list:min_stack:stackpairs-6"><a href="#list:min_stack:stackpairs-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:min_stack:stackpairs-7"><a href="#list:min_stack:stackpairs-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> nm <span class="op">=</span> q<span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">?</span> <span class="bu">std::</span>min<span class="op">(</span>x<span class="op">,</span> getMin<span class="op">())</span> <span class="op">:</span> x<span class="op">;</span></span>
<span id="list:min_stack:stackpairs-8"><a href="#list:min_stack:stackpairs-8" aria-hidden="true" tabindex="-1"></a>    q<span class="op">.</span>push<span class="op">({</span>x<span class="op">,</span> nm<span class="op">});</span></span>
<span id="list:min_stack:stackpairs-9"><a href="#list:min_stack:stackpairs-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:min_stack:stackpairs-10"><a href="#list:min_stack:stackpairs-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_stack:stackpairs-11"><a href="#list:min_stack:stackpairs-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> pop<span class="op">()</span></span>
<span id="list:min_stack:stackpairs-12"><a href="#list:min_stack:stackpairs-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:min_stack:stackpairs-13"><a href="#list:min_stack:stackpairs-13" aria-hidden="true" tabindex="-1"></a>    guard_empty_stack<span class="op">();</span></span>
<span id="list:min_stack:stackpairs-14"><a href="#list:min_stack:stackpairs-14" aria-hidden="true" tabindex="-1"></a>    q<span class="op">.</span>pop<span class="op">();</span></span>
<span id="list:min_stack:stackpairs-15"><a href="#list:min_stack:stackpairs-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:min_stack:stackpairs-16"><a href="#list:min_stack:stackpairs-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_stack:stackpairs-17"><a href="#list:min_stack:stackpairs-17" aria-hidden="true" tabindex="-1"></a>  T top<span class="op">()</span></span>
<span id="list:min_stack:stackpairs-18"><a href="#list:min_stack:stackpairs-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:min_stack:stackpairs-19"><a href="#list:min_stack:stackpairs-19" aria-hidden="true" tabindex="-1"></a>    guard_empty_stack<span class="op">();</span></span>
<span id="list:min_stack:stackpairs-20"><a href="#list:min_stack:stackpairs-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> q<span class="op">.</span>top<span class="op">().</span>first<span class="op">;</span></span>
<span id="list:min_stack:stackpairs-21"><a href="#list:min_stack:stackpairs-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:min_stack:stackpairs-22"><a href="#list:min_stack:stackpairs-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_stack:stackpairs-23"><a href="#list:min_stack:stackpairs-23" aria-hidden="true" tabindex="-1"></a>  T getMin<span class="op">()</span></span>
<span id="list:min_stack:stackpairs-24"><a href="#list:min_stack:stackpairs-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:min_stack:stackpairs-25"><a href="#list:min_stack:stackpairs-25" aria-hidden="true" tabindex="-1"></a>    guard_empty_stack<span class="op">();</span></span>
<span id="list:min_stack:stackpairs-26"><a href="#list:min_stack:stackpairs-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> q<span class="op">.</span>top<span class="op">().</span>second<span class="op">;</span></span>
<span id="list:min_stack:stackpairs-27"><a href="#list:min_stack:stackpairs-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:min_stack:stackpairs-28"><a href="#list:min_stack:stackpairs-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_stack:stackpairs-29"><a href="#list:min_stack:stackpairs-29" aria-hidden="true" tabindex="-1"></a> <span class="kw">protected</span><span class="op">:</span></span>
<span id="list:min_stack:stackpairs-30"><a href="#list:min_stack:stackpairs-30" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> guard_empty_stack<span class="op">()</span></span>
<span id="list:min_stack:stackpairs-31"><a href="#list:min_stack:stackpairs-31" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:min_stack:stackpairs-32"><a href="#list:min_stack:stackpairs-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>q<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:min_stack:stackpairs-33"><a href="#list:min_stack:stackpairs-33" aria-hidden="true" tabindex="-1"></a>      <span class="cf">throw</span> <span class="bu">std::</span>logic_error<span class="op">(</span><span class="st">&quot;Invalid operation on an empty stack&quot;</span><span class="op">);</span></span>
<span id="list:min_stack:stackpairs-34"><a href="#list:min_stack:stackpairs-34" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:min_stack:stackpairs-35"><a href="#list:min_stack:stackpairs-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_stack:stackpairs-36"><a href="#list:min_stack:stackpairs-36" aria-hidden="true" tabindex="-1"></a> <span class="kw">private</span><span class="op">:</span></span>
<span id="list:min_stack:stackpairs-37"><a href="#list:min_stack:stackpairs-37" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>stack<span class="op">&lt;</span><span class="bu">std::</span>pair<span class="op">&lt;</span>T<span class="op">,</span> T<span class="op">&gt;&gt;</span> q<span class="op">;</span></span>
<span id="list:min_stack:stackpairs-38"><a href="#list:min_stack:stackpairs-38" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h4 id="min_stack:sec:twostacks">Two stacks</h4>
<p>The solution presented in Section <a href="#min_stack:sec:stackpairs" data-reference-type="ref" data-reference="min_stack:sec:stackpairs">26.3.1.1</a> can be improved in the average case (even if will remain asymptotically the same in the worst case) by realizing that there is no need to have a copy of the minimum element for each element of the stack. What we really need is to have a second stack that contains the sequence of minimum elements as they are inserted.</p>
<p>We can achieve that by using an additional stack to store the minimums. Every-time we will try to push an element that is lower than the top of this stack, we will push it into Given this additional stack we can implement all the operations as follows:</p>
<ul>
<li><p><code>push(x)</code>. We will store <span class="math inline">\(x\)</span> on top of the stack (where we store the actual elements are they are given to us) and only if <code>x &lt;= get_min()</code> we will also push <span class="math inline">\(x\)</span> to the stack of minimums. This way we keep the information about the current minimum without losing the information about the previous ones, that will be useful whenever in the future will be removed from the stack (if <span class="math inline">\(x\)</span> is the new minimum).</p></li>
<li><p><code>top(x)</code> returns the <strong>first</strong> element of the top of the stack if is not empty, otherwise it throws an exception.</p></li>
<li><p><code>pop(x)</code> if the stack is not empty, it will call pop on the stack, and if the element we are popping is equal to the top of the stack of minimums we will also pop from that stack. We need to react to the fact that the current minimum is changing.</p></li>
<li><p><code>get_min(x)</code> returns the top of the stack (the stack of minimums) if the stack is not empty, otherwise it throws an exception.</p></li>
</ul>
<p>This solution has the advantage of not using as much space as the one presented in Section <a href="#min_stack:sec:stackpairs" data-reference-type="ref" data-reference="min_stack:sec:stackpairs">26.3.1.1</a> when for instance a sequence of increasing number is pushed. In that case the minimum will be the first element, and it will never change. Also note that because of the way the stack of minimum is used, it will always contains a decreasing sequence of values (after all we only push to it if the new element is smaller than the top).</p>
<p>This idea can be implemented as shown in Listing <a href="#list:min_stack:doublestack" data-reference-type="ref" data-reference="list:min_stack:doublestack">[list:min_stack:doublestack]</a></p>
<div class="sourceCode" id="list:min_stack:doublestack" data-language="c++" data-caption="Solution to the problem of designing a min stack using a two stacks." label="list:min_stack:doublestack"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:min_stack:doublestack-1"><a href="#list:min_stack:doublestack-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="list:min_stack:doublestack-2"><a href="#list:min_stack:doublestack-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> min_stack_two_stacks</span>
<span id="list:min_stack:doublestack-3"><a href="#list:min_stack:doublestack-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:min_stack:doublestack-4"><a href="#list:min_stack:doublestack-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="list:min_stack:doublestack-5"><a href="#list:min_stack:doublestack-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> push<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> x<span class="op">)</span></span>
<span id="list:min_stack:doublestack-6"><a href="#list:min_stack:doublestack-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:min_stack:doublestack-7"><a href="#list:min_stack:doublestack-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>x <span class="op">&lt;=</span> getMin<span class="op">()</span> <span class="op">||</span> minimums<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:min_stack:doublestack-8"><a href="#list:min_stack:doublestack-8" aria-hidden="true" tabindex="-1"></a>      minimums<span class="op">.</span>push<span class="op">(</span>x<span class="op">);</span></span>
<span id="list:min_stack:doublestack-9"><a href="#list:min_stack:doublestack-9" aria-hidden="true" tabindex="-1"></a>    elements<span class="op">.</span>push<span class="op">(</span>x<span class="op">);</span></span>
<span id="list:min_stack:doublestack-10"><a href="#list:min_stack:doublestack-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:min_stack:doublestack-11"><a href="#list:min_stack:doublestack-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_stack:doublestack-12"><a href="#list:min_stack:doublestack-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> pop<span class="op">()</span></span>
<span id="list:min_stack:doublestack-13"><a href="#list:min_stack:doublestack-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:min_stack:doublestack-14"><a href="#list:min_stack:doublestack-14" aria-hidden="true" tabindex="-1"></a>    guard_empty_stack<span class="op">();</span></span>
<span id="list:min_stack:doublestack-15"><a href="#list:min_stack:doublestack-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>getMin<span class="op">()</span> <span class="op">==</span> elements<span class="op">.</span>top<span class="op">())</span></span>
<span id="list:min_stack:doublestack-16"><a href="#list:min_stack:doublestack-16" aria-hidden="true" tabindex="-1"></a>      minimums<span class="op">.</span>pop<span class="op">();</span></span>
<span id="list:min_stack:doublestack-17"><a href="#list:min_stack:doublestack-17" aria-hidden="true" tabindex="-1"></a>    elements<span class="op">.</span>pop<span class="op">();</span></span>
<span id="list:min_stack:doublestack-18"><a href="#list:min_stack:doublestack-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:min_stack:doublestack-19"><a href="#list:min_stack:doublestack-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_stack:doublestack-20"><a href="#list:min_stack:doublestack-20" aria-hidden="true" tabindex="-1"></a>  T top<span class="op">()</span></span>
<span id="list:min_stack:doublestack-21"><a href="#list:min_stack:doublestack-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:min_stack:doublestack-22"><a href="#list:min_stack:doublestack-22" aria-hidden="true" tabindex="-1"></a>    guard_empty_stack<span class="op">();</span></span>
<span id="list:min_stack:doublestack-23"><a href="#list:min_stack:doublestack-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> elements<span class="op">.</span>top<span class="op">();</span></span>
<span id="list:min_stack:doublestack-24"><a href="#list:min_stack:doublestack-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:min_stack:doublestack-25"><a href="#list:min_stack:doublestack-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_stack:doublestack-26"><a href="#list:min_stack:doublestack-26" aria-hidden="true" tabindex="-1"></a>  T getMin<span class="op">()</span></span>
<span id="list:min_stack:doublestack-27"><a href="#list:min_stack:doublestack-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:min_stack:doublestack-28"><a href="#list:min_stack:doublestack-28" aria-hidden="true" tabindex="-1"></a>    guard_empty_stack<span class="op">();</span></span>
<span id="list:min_stack:doublestack-29"><a href="#list:min_stack:doublestack-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> minimums<span class="op">.</span>top<span class="op">();</span></span>
<span id="list:min_stack:doublestack-30"><a href="#list:min_stack:doublestack-30" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:min_stack:doublestack-31"><a href="#list:min_stack:doublestack-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_stack:doublestack-32"><a href="#list:min_stack:doublestack-32" aria-hidden="true" tabindex="-1"></a> <span class="kw">protected</span><span class="op">:</span></span>
<span id="list:min_stack:doublestack-33"><a href="#list:min_stack:doublestack-33" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> guard_empty_stack<span class="op">()</span></span>
<span id="list:min_stack:doublestack-34"><a href="#list:min_stack:doublestack-34" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:min_stack:doublestack-35"><a href="#list:min_stack:doublestack-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>elements<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:min_stack:doublestack-36"><a href="#list:min_stack:doublestack-36" aria-hidden="true" tabindex="-1"></a>      <span class="cf">throw</span> <span class="bu">std::</span>logic_error<span class="op">(</span><span class="st">&quot;Invalid operation on an empty stack&quot;</span><span class="op">);</span></span>
<span id="list:min_stack:doublestack-37"><a href="#list:min_stack:doublestack-37" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:min_stack:doublestack-38"><a href="#list:min_stack:doublestack-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_stack:doublestack-39"><a href="#list:min_stack:doublestack-39" aria-hidden="true" tabindex="-1"></a> <span class="kw">private</span><span class="op">:</span></span>
<span id="list:min_stack:doublestack-40"><a href="#list:min_stack:doublestack-40" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>stack<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> elements<span class="op">;</span></span>
<span id="list:min_stack:doublestack-41"><a href="#list:min_stack:doublestack-41" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>stack<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> minimums<span class="op">;</span></span>
<span id="list:min_stack:doublestack-42"><a href="#list:min_stack:doublestack-42" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="min_stack:sec:constantspace">Constant space</h3>
<p>Despite the fact that the solution presented in Section <a href="#min_stack:sec:twostacks" data-reference-type="ref" data-reference="min_stack:sec:twostacks">26.3.1.2</a> is most likely already good enough for any coding interview, we will present here a solution that works only for integral types and that work in constant space. This is a big improvement w.r.t. to the other solutions presented so far, but the downside is that only works for a very limited number of types.</p>
<p>As already discussed, the main challenge of this question is that we need somehow to be able for each element present in the stack to retrieve the current minimum. How can we store such information without using additional space? The answer is that we need to encode such information in the elements themselves.</p>
<p>The idea is simple: We will store the elements in a <code>std::stack</code>, <span class="math inline">\(S\)</span>, and we will also keep track of the <strong>current</strong> minimum element in a variable, <code>min_el</code>. The operations on the data structure can be implemented as follows:</p>
<ul>
<li><p><code>push(x)</code> we have two cases here:</p>
<ol>
<li><p>if the stack is empty: push <span class="math inline">\(x\)</span> to <span class="math inline">\(S\)</span> and set</p></li>
<li><p>otherwise:</p>
<ul>
<li><p>if just push x to <span class="math inline">\(S\)</span> leaving untouched.</p></li>
<li><p>if , push to <span class="math inline">\(S\)</span> and set .</p></li>
</ul></li>
</ol></li>
<li><p><code>pop()</code> two cases here as well depending on the element to be removed <span class="math inline">\(y\)</span> (at the top of the stack):</p>
<ol>
<li><p>if , <span class="math inline">\(y\)</span> is removed from the stack leaving untouched</p></li>
<li><p>otherwise: if , set</p></li>
</ol>
<p>The key idea here is that we can retrieve the the previous minimum element given the current one and the value that is currently on the stack.</p></li>
<li><p><code>top()</code> veri similar to the operation, without the update on the variable</p></li>
<li><p><code>get_min(x)</code>, returns</p></li>
</ul>
<p>When an element <span class="math inline">\(x\)</span> is less than the current minimum i.e. , the value will be inserted in the stack and the minimum set to <span class="math inline">\(x\)</span>. The fact that (remember that ) is really important because, when this element will be popped out from the stack we will be able to tell that the minimum is changing because we will see that and therefore we will update the minimum element accordingly.</p>
<p>The idea above is shown in Listing <a href="#list:min_stack:constspace" data-reference-type="ref" data-reference="list:min_stack:constspace">[list:min_stack:constspace]</a>. Note how the template class will only compile for integral types thanks to <span class="citation" data-cites="cit::std::enableif"></span>.</p>
<div class="sourceCode" id="list:min_stack:constspace" data-language="c++" data-caption="Solution to the problem of designing a min stack of integer working in constant space and linear time." label="list:min_stack:constspace"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:min_stack:constspace-1"><a href="#list:min_stack:constspace-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T<span class="op">,</span></span>
<span id="list:min_stack:constspace-2"><a href="#list:min_stack:constspace-2" aria-hidden="true" tabindex="-1"></a>          <span class="kw">typename</span> <span class="op">=</span> <span class="kw">typename</span> <span class="bu">std::</span>enable_if<span class="op">&lt;</span><span class="bu">std::</span>is_integral<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">&gt;::</span>type<span class="op">&gt;</span></span>
<span id="list:min_stack:constspace-3"><a href="#list:min_stack:constspace-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> min_stack_int_constant_time</span>
<span id="list:min_stack:constspace-4"><a href="#list:min_stack:constspace-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:min_stack:constspace-5"><a href="#list:min_stack:constspace-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="list:min_stack:constspace-6"><a href="#list:min_stack:constspace-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> push<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> x<span class="op">)</span></span>
<span id="list:min_stack:constspace-7"><a href="#list:min_stack:constspace-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:min_stack:constspace-8"><a href="#list:min_stack:constspace-8" aria-hidden="true" tabindex="-1"></a>    T new_min_el <span class="op">=</span> min_el<span class="op">;</span></span>
<span id="list:min_stack:constspace-9"><a href="#list:min_stack:constspace-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>elements<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:min_stack:constspace-10"><a href="#list:min_stack:constspace-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:min_stack:constspace-11"><a href="#list:min_stack:constspace-11" aria-hidden="true" tabindex="-1"></a>      elements<span class="op">.</span>push<span class="op">(</span>x<span class="op">);</span></span>
<span id="list:min_stack:constspace-12"><a href="#list:min_stack:constspace-12" aria-hidden="true" tabindex="-1"></a>      new_min_el <span class="op">=</span> x<span class="op">;</span></span>
<span id="list:min_stack:constspace-13"><a href="#list:min_stack:constspace-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:min_stack:constspace-14"><a href="#list:min_stack:constspace-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_stack:constspace-15"><a href="#list:min_stack:constspace-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>x <span class="op">&lt;</span> elements<span class="op">.</span>top<span class="op">())</span></span>
<span id="list:min_stack:constspace-16"><a href="#list:min_stack:constspace-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:min_stack:constspace-17"><a href="#list:min_stack:constspace-17" aria-hidden="true" tabindex="-1"></a>      elements<span class="op">.</span>push<span class="op">(</span><span class="dv">2</span> <span class="op">*</span> x <span class="op">-</span> min_el<span class="op">);</span></span>
<span id="list:min_stack:constspace-18"><a href="#list:min_stack:constspace-18" aria-hidden="true" tabindex="-1"></a>      new_min_el <span class="op">=</span> x<span class="op">;</span></span>
<span id="list:min_stack:constspace-19"><a href="#list:min_stack:constspace-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:min_stack:constspace-20"><a href="#list:min_stack:constspace-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="list:min_stack:constspace-21"><a href="#list:min_stack:constspace-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:min_stack:constspace-22"><a href="#list:min_stack:constspace-22" aria-hidden="true" tabindex="-1"></a>      elements<span class="op">.</span>push<span class="op">(</span>x<span class="op">);</span></span>
<span id="list:min_stack:constspace-23"><a href="#list:min_stack:constspace-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:min_stack:constspace-24"><a href="#list:min_stack:constspace-24" aria-hidden="true" tabindex="-1"></a>    min_el <span class="op">=</span> new_min_el<span class="op">;</span></span>
<span id="list:min_stack:constspace-25"><a href="#list:min_stack:constspace-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:min_stack:constspace-26"><a href="#list:min_stack:constspace-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_stack:constspace-27"><a href="#list:min_stack:constspace-27" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> pop<span class="op">()</span></span>
<span id="list:min_stack:constspace-28"><a href="#list:min_stack:constspace-28" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:min_stack:constspace-29"><a href="#list:min_stack:constspace-29" aria-hidden="true" tabindex="-1"></a>    guard_empty_stack<span class="op">();</span></span>
<span id="list:min_stack:constspace-30"><a href="#list:min_stack:constspace-30" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> T top_el <span class="op">=</span> elements<span class="op">.</span>top<span class="op">();</span></span>
<span id="list:min_stack:constspace-31"><a href="#list:min_stack:constspace-31" aria-hidden="true" tabindex="-1"></a>    elements<span class="op">.</span>pop<span class="op">();</span></span>
<span id="list:min_stack:constspace-32"><a href="#list:min_stack:constspace-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_stack:constspace-33"><a href="#list:min_stack:constspace-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>top_el <span class="op">&lt;</span> min_el<span class="op">)</span></span>
<span id="list:min_stack:constspace-34"><a href="#list:min_stack:constspace-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:min_stack:constspace-35"><a href="#list:min_stack:constspace-35" aria-hidden="true" tabindex="-1"></a>      min_el <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> min_el <span class="op">-</span> top_el<span class="op">;</span></span>
<span id="list:min_stack:constspace-36"><a href="#list:min_stack:constspace-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:min_stack:constspace-37"><a href="#list:min_stack:constspace-37" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:min_stack:constspace-38"><a href="#list:min_stack:constspace-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_stack:constspace-39"><a href="#list:min_stack:constspace-39" aria-hidden="true" tabindex="-1"></a>  T top<span class="op">()</span></span>
<span id="list:min_stack:constspace-40"><a href="#list:min_stack:constspace-40" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:min_stack:constspace-41"><a href="#list:min_stack:constspace-41" aria-hidden="true" tabindex="-1"></a>    guard_empty_stack<span class="op">();</span></span>
<span id="list:min_stack:constspace-42"><a href="#list:min_stack:constspace-42" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> T top_el <span class="op">=</span> elements<span class="op">.</span>top<span class="op">();</span></span>
<span id="list:min_stack:constspace-43"><a href="#list:min_stack:constspace-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>top_el <span class="op">&gt;=</span> min_el<span class="op">)</span></span>
<span id="list:min_stack:constspace-44"><a href="#list:min_stack:constspace-44" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> top_el<span class="op">;</span></span>
<span id="list:min_stack:constspace-45"><a href="#list:min_stack:constspace-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="list:min_stack:constspace-46"><a href="#list:min_stack:constspace-46" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> min_el<span class="op">;</span></span>
<span id="list:min_stack:constspace-47"><a href="#list:min_stack:constspace-47" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:min_stack:constspace-48"><a href="#list:min_stack:constspace-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_stack:constspace-49"><a href="#list:min_stack:constspace-49" aria-hidden="true" tabindex="-1"></a>  T getMin<span class="op">()</span></span>
<span id="list:min_stack:constspace-50"><a href="#list:min_stack:constspace-50" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:min_stack:constspace-51"><a href="#list:min_stack:constspace-51" aria-hidden="true" tabindex="-1"></a>    guard_empty_stack<span class="op">();</span></span>
<span id="list:min_stack:constspace-52"><a href="#list:min_stack:constspace-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> min_el<span class="op">;</span></span>
<span id="list:min_stack:constspace-53"><a href="#list:min_stack:constspace-53" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:min_stack:constspace-54"><a href="#list:min_stack:constspace-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_stack:constspace-55"><a href="#list:min_stack:constspace-55" aria-hidden="true" tabindex="-1"></a> <span class="kw">protected</span><span class="op">:</span></span>
<span id="list:min_stack:constspace-56"><a href="#list:min_stack:constspace-56" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> guard_empty_stack<span class="op">()</span></span>
<span id="list:min_stack:constspace-57"><a href="#list:min_stack:constspace-57" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:min_stack:constspace-58"><a href="#list:min_stack:constspace-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>elements<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:min_stack:constspace-59"><a href="#list:min_stack:constspace-59" aria-hidden="true" tabindex="-1"></a>      <span class="cf">throw</span> <span class="bu">std::</span>logic_error<span class="op">(</span><span class="st">&quot;Invalid operation on an empty stack&quot;</span><span class="op">);</span></span>
<span id="list:min_stack:constspace-60"><a href="#list:min_stack:constspace-60" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:min_stack:constspace-61"><a href="#list:min_stack:constspace-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_stack:constspace-62"><a href="#list:min_stack:constspace-62" aria-hidden="true" tabindex="-1"></a> <span class="kw">private</span><span class="op">:</span></span>
<span id="list:min_stack:constspace-63"><a href="#list:min_stack:constspace-63" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>stack<span class="op">&lt;</span>T<span class="op">&gt;</span> elements<span class="op">;</span></span>
<span id="list:min_stack:constspace-64"><a href="#list:min_stack:constspace-64" aria-hidden="true" tabindex="-1"></a>  T min_el<span class="op">;</span></span>
<span id="list:min_stack:constspace-65"><a href="#list:min_stack:constspace-65" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="common-variations-2">Common Variations</h3>
<div class="exercise">
<p>Design and implement a max stack data structure supporting the following operations:</p>
<ul>
<li><p><code>push(x)</code>: the element <span class="math inline">\(x\)</span> is pushed onto the stack</p></li>
<li><p><code>pop()</code>: removes the top of the stack</p></li>
<li><p><code>top()</code>: retrieve the top of the stack</p></li>
<li><p><code>get_max()</code>: retrieve the maximum among all elements present in the stack.</p></li>
</ul>
</div>
<h1 id="ch:majority_element">Find the majority element</h1>
<h2 class="unnumbered" id="introduction-26">Introduction</h2>
<p>The problem described in this chapter has been asked at Microsoft, Google, Amazon and Yahoo interview for software engineering position and it is considered a problem of easy/medium difficulty.</p>
<h2 id="problem-statement-27">Problem statement</h2>
<div class="exercise">
<p>Given an array <span class="math inline">\(N\)</span> of size <span class="math inline">\(n\)</span>, find the majority element i.e. that element that appears more than <span class="math inline">\(\floor{\frac{n}{2}}\)</span> times. If such element does not exists, returns <span class="math inline">\(-1\)</span>.</p>
<div class="example">
<p><br />
Given the array <span class="math inline">\([1,2,3,2,2,1,1,1]\)</span>, the function returns <span class="math inline">\(1\)</span> because it appears <span class="math inline">\(4\)</span> times in an array of length <span class="math inline">\(8\)</span>.</p>
</div>
<div class="example">
<p><br />
Given the input array <span class="math inline">\([2, 1, 2]\)</span> the function return <span class="math inline">\(2\)</span> because it is greater than <span class="math inline">\(\frac{3}{2}\)</span>.</p>
</div>
<div class="example">
<p><br />
Given the input array <span class="math inline">\([2, 1, 2,3,4,5]\)</span> the function return <span class="math inline">\(-1\)</span>no element appear more than <span class="math inline">\(3\)</span> times.</p>
</div>
</div>
<h2 id="clarification-questions-23">Clarification Questions</h2>
<div class="QandA">
<p>What are the minimum and maximum value an element of the array can take?</p>
<div class="answered">
<p><em>The minimum and maximum values are <span class="math inline">\([-10^9, 10^9]\)</span>, respectively</em>. This is a good question to ask because if the range is small then we can apply a solution based on bucket counting.</p>
</div>
<p>Can the input array <span class="math inline">\(N\)</span> be modified or shuffled.</p>
<div class="answered">
<p><em>Yes, the input array can be modified.</em></p>
</div>
</div>
<h2 id="majority_element:sec:discussion">Discussion</h2>
<p>We will have a look at three different solution for this problem. We will start our discussion by having a look in section <a href="#majority_element:sec:bruteforce" data-reference-type="ref" data-reference="majority_element:sec:bruteforce">27.3.1</a> at the brute-force approach. Section section <a href="#majority_element:sec:sorting" data-reference-type="ref" data-reference="majority_element:sec:sorting">27.3.3</a> will describe an approach that uses sorting to improve the time complexity on the brute-force approach. Lastly in section <a href="#majority_element:sec:linear" data-reference-type="ref" data-reference="majority_element:sec:linear">27.3.5</a> we will the optimal approach.</p>
<h3 id="majority_element:sec:bruteforce">Brute-force</h3>
<p>The brute force solution is brutally simple and consist in, looping through the array, and for each element counting how many times it occurs in the input array. This approach, despite its simplicity should not be the one provided to the interviewer, as it is far from the optimum and the interviewer is certainly expecting more from us. Listing <a href="#list:majority_element:bruteforce" data-reference-type="ref" data-reference="list:majority_element:bruteforce">[list:majority_element:bruteforce]</a> shows a possible implementation of this idea.</p>
<div class="sourceCode" id="list:majority_element:bruteforce" data-language="c++" data-caption="Sample Caption" label="list:majority_element:bruteforce"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:majority_element:bruteforce-1"><a href="#list:majority_element:bruteforce-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> find_majority_element_brute_force<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> N<span class="op">)</span></span>
<span id="list:majority_element:bruteforce-2"><a href="#list:majority_element:bruteforce-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:majority_element:bruteforce-3"><a href="#list:majority_element:bruteforce-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">size_t</span> threshold <span class="op">=</span> N<span class="op">.</span>size<span class="op">()</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="list:majority_element:bruteforce-4"><a href="#list:majority_element:bruteforce-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span> x <span class="op">:</span> N<span class="op">)</span></span>
<span id="list:majority_element:bruteforce-5"><a href="#list:majority_element:bruteforce-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:majority_element:bruteforce-6"><a href="#list:majority_element:bruteforce-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">size_t</span> countx <span class="op">=</span> <span class="bu">std::</span>count<span class="op">(</span>begin<span class="op">(</span>N<span class="op">),</span> end<span class="op">(</span>N<span class="op">),</span> x<span class="op">);</span></span>
<span id="list:majority_element:bruteforce-7"><a href="#list:majority_element:bruteforce-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>countx <span class="op">&gt;</span> threshold<span class="op">)</span></span>
<span id="list:majority_element:bruteforce-8"><a href="#list:majority_element:bruteforce-8" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> x<span class="op">;</span></span>
<span id="list:majority_element:bruteforce-9"><a href="#list:majority_element:bruteforce-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:majority_element:bruteforce-10"><a href="#list:majority_element:bruteforce-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:majority_element:bruteforce-11"><a href="#list:majority_element:bruteforce-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="majority_element:sec:hashmap">Hash-map approach</h3>
<p>The idea described in section <a href="#majority_element:sec:bruteforce" data-reference-type="ref" data-reference="majority_element:sec:bruteforce">27.3.1</a> can be improved by using an hash-map to store the number of occurrence of each element in the input array. There cannot be more than <span class="math inline">\(n\)</span> different numbers in the the array <span class="math inline">\(N\)</span>, thus with a single pass of the input and with a linear cost in space we can calculate the number of occurrence of each element and check if any of the counters at any points gets higher than <span class="math inline">\(\floor{\frac{n}{2}}\)</span>.</p>
<p>A possible implementation of this approach is shown in Listing <a href="#list:majority_element:hashmap" data-reference-type="ref" data-reference="list:majority_element:hashmap">[list:majority_element:hashmap]</a>. The complexity of this approach is <span class="math inline">\(O(n)\)</span> for both space and time. In-fact, in the worst case all the element of the input array are only read and stored once.</p>
<div class="sourceCode" id="list:majority_element:hashmap" data-language="c++" data-caption="Solution to the problem of finding the majority element in an array using hash-map." label="list:majority_element:hashmap"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:majority_element:hashmap-1"><a href="#list:majority_element:hashmap-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> find_majority_element_hash_map<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> N<span class="op">)</span></span>
<span id="list:majority_element:hashmap-2"><a href="#list:majority_element:hashmap-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:majority_element:hashmap-3"><a href="#list:majority_element:hashmap-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">size_t</span> threshold <span class="op">=</span> N<span class="op">.</span>size<span class="op">()</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="list:majority_element:hashmap-4"><a href="#list:majority_element:hashmap-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:majority_element:hashmap-5"><a href="#list:majority_element:hashmap-5" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>unordered_map<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> C<span class="op">;</span></span>
<span id="list:majority_element:hashmap-6"><a href="#list:majority_element:hashmap-6" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> max_val <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">};</span></span>
<span id="list:majority_element:hashmap-7"><a href="#list:majority_element:hashmap-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span> x <span class="op">:</span> N<span class="op">)</span></span>
<span id="list:majority_element:hashmap-8"><a href="#list:majority_element:hashmap-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:majority_element:hashmap-9"><a href="#list:majority_element:hashmap-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">&amp;</span> countx <span class="op">=</span> C<span class="op">[</span>x<span class="op">];</span></span>
<span id="list:majority_element:hashmap-10"><a href="#list:majority_element:hashmap-10" aria-hidden="true" tabindex="-1"></a>    countx<span class="op">++;</span></span>
<span id="list:majority_element:hashmap-11"><a href="#list:majority_element:hashmap-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>countx <span class="op">&gt;</span> threshold<span class="op">)</span></span>
<span id="list:majority_element:hashmap-12"><a href="#list:majority_element:hashmap-12" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> x<span class="op">;</span></span>
<span id="list:majority_element:hashmap-13"><a href="#list:majority_element:hashmap-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:majority_element:hashmap-14"><a href="#list:majority_element:hashmap-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:majority_element:hashmap-15"><a href="#list:majority_element:hashmap-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="majority_element:sec:sorting">Sorting - Counting</h3>
<p>The approach described in section <a href="#majority_element:sec:hashmap" data-reference-type="ref" data-reference="majority_element:sec:hashmap">27.3.2</a> is definitely faster then the quadratic brute-force but at a linear price in space. In order not to pay the price in space but to lower the time complexity down from quadratic, we could rely on the fact that in a sort collection of elements all equal elements appear grouped together e.g. in <span class="math inline">\([1,1,2,2,3,3,3,4,4,9,9]\)</span>, all the <span class="math inline">\(1\)</span>s appear at the beginning of the array, followed by all the <span class="math inline">\(2\)</span>s, etc. We can then count the number of occurrences of each element in constant space as shown in Listing <a href="#list:majority_element:sorting" data-reference-type="ref" data-reference="list:majority_element:sorting">[list:majority_element:sorting]</a>. The complexity of this approach is bounded by the sorting which costs <span class="math inline">\(O(nlog(n)\)</span> time.</p>
<div class="sourceCode" id="list:majority_element:sorting" data-language="c++" data-caption="Solution  to the problem of finding the majority element in an array using sorting." label="list:majority_element:sorting"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:majority_element:sorting-1"><a href="#list:majority_element:sorting-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> find_majority_element_sorting<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> N<span class="op">)</span></span>
<span id="list:majority_element:sorting-2"><a href="#list:majority_element:sorting-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:majority_element:sorting-3"><a href="#list:majority_element:sorting-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">size_t</span> threshold <span class="op">=</span> N<span class="op">.</span>size<span class="op">()</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="list:majority_element:sorting-4"><a href="#list:majority_element:sorting-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>N<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:majority_element:sorting-5"><a href="#list:majority_element:sorting-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:majority_element:sorting-6"><a href="#list:majority_element:sorting-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:majority_element:sorting-7"><a href="#list:majority_element:sorting-7" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>sort<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>N<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>N<span class="op">));</span></span>
<span id="list:majority_element:sorting-8"><a href="#list:majority_element:sorting-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:majority_element:sorting-9"><a href="#list:majority_element:sorting-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// current.first = number</span></span>
<span id="list:majority_element:sorting-10"><a href="#list:majority_element:sorting-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// number.second = occurrences</span></span>
<span id="list:majority_element:sorting-11"><a href="#list:majority_element:sorting-11" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> current<span class="op">;</span></span>
<span id="list:majority_element:sorting-12"><a href="#list:majority_element:sorting-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span></span>
<span id="list:majority_element:sorting-13"><a href="#list:majority_element:sorting-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:majority_element:sorting-14"><a href="#list:majority_element:sorting-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>N<span class="op">[</span>i<span class="op">]</span> <span class="op">!=</span> current<span class="op">.</span>first <span class="op">||</span> i <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:majority_element:sorting-15"><a href="#list:majority_element:sorting-15" aria-hidden="true" tabindex="-1"></a>      current <span class="op">=</span> <span class="op">{</span>N<span class="op">[</span>i<span class="op">],</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="list:majority_element:sorting-16"><a href="#list:majority_element:sorting-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="list:majority_element:sorting-17"><a href="#list:majority_element:sorting-17" aria-hidden="true" tabindex="-1"></a>      current<span class="op">.</span>second<span class="op">++;</span></span>
<span id="list:majority_element:sorting-18"><a href="#list:majority_element:sorting-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:majority_element:sorting-19"><a href="#list:majority_element:sorting-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>current<span class="op">.</span>second <span class="op">&gt;</span> threshold<span class="op">)</span></span>
<span id="list:majority_element:sorting-20"><a href="#list:majority_element:sorting-20" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> current<span class="op">.</span>first<span class="op">;</span></span>
<span id="list:majority_element:sorting-21"><a href="#list:majority_element:sorting-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:majority_element:sorting-22"><a href="#list:majority_element:sorting-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:majority_element:sorting-23"><a href="#list:majority_element:sorting-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="majority_element:sec:median">Sorting - Median</h3>
<p>There is however, another way of taking advantage of the fact that we have a sorted collection. The key idea here is that if a majority element exists than, this element <strong>must be the median</strong>. After all, by definition , the median if the element that is right in the middle of the sorted collection. Since the majority element will be occupy <strong>more</strong> than half positions of the array, it also occupies the median position. All is necessary after sorting the array, is to check if the median value appear more than <span class="math inline">\(\floor{\frac{n}{2}}\)</span> times. This idea is implemented in Listing <a href="#list:majority_element:median" data-reference-type="ref" data-reference="list:majority_element:median">[list:majority_element:median]</a> and has a complexity of <span class="math inline">\(O(nlog(n)\)</span> due to sorting.</p>
<div class="sourceCode" id="list:majority_element:median" data-language="c++" data-caption="Linear time constant space solution to the problem of finding the majority element in an array." label="list:majority_element:median"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:majority_element:median-1"><a href="#list:majority_element:median-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> find_majority_element_median<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> N<span class="op">)</span></span>
<span id="list:majority_element:median-2"><a href="#list:majority_element:median-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:majority_element:median-3"><a href="#list:majority_element:median-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>N<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:majority_element:median-4"><a href="#list:majority_element:median-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:majority_element:median-5"><a href="#list:majority_element:median-5" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>sort<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>N<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>N<span class="op">));</span></span>
<span id="list:majority_element:median-6"><a href="#list:majority_element:median-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> midpoint <span class="op">=</span> N<span class="op">.</span>size<span class="op">()</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="list:majority_element:median-7"><a href="#list:majority_element:median-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> el       <span class="op">=</span> N<span class="op">[</span>midpoint<span class="op">];</span></span>
<span id="list:majority_element:median-8"><a href="#list:majority_element:median-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:majority_element:median-9"><a href="#list:majority_element:median-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">size_t</span> threshold <span class="op">=</span> N<span class="op">.</span>size<span class="op">()</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="list:majority_element:median-10"><a href="#list:majority_element:median-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>count<span class="op">(</span>begin<span class="op">(</span>N<span class="op">),</span> end<span class="op">(</span>N<span class="op">),</span> el<span class="op">)</span> <span class="op">&gt;</span> threshold<span class="op">)</span></span>
<span id="list:majority_element:median-11"><a href="#list:majority_element:median-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> el<span class="op">;</span></span>
<span id="list:majority_element:median-12"><a href="#list:majority_element:median-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:majority_element:median-13"><a href="#list:majority_element:median-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="majority_element:sec:linear">Boyer-Moore algorithm</h3>
<p>There is however better way of solving this problem in linear time and constant space i.e. using the Boyer-Moore algorithm<span class="citation" data-cites="Boyer1991"></span>.</p>
<p>The algorithm uses two variables to maintain an candidate element <span class="math inline">\(el\)</span> of the sequence and its current count <span class="math inline">\(count=0\)</span> (initialized to <span class="math inline">\(0\)</span>). It processes the elements one by one and will perform the following operations:</p>
<ul>
<li><p>if we are processing the very first element of the sequence or , it will set <span class="math inline">\(count=1\)</span> and <span class="math inline">\(el\)</span> to that element (this is out first candidate).</p></li>
<li><p>otherwise, if the element currently processed is equal to it increments the counter i.e.</p></li>
<li><p>if the element currently processed is different, then it decrements the counter i.e. ;</p></li>
</ul>
<p>At the end of this process the variable will contain a candidate majority element. If the array contains a majority element then <strong>is</strong> the one. The algorithm correctness can be derived from the fact that the counter will be incremented more times than it will be decremented for the majority element. If we cannot assume that a majority element <strong>always</strong> exists then a second pass on the array is then necessary, in order to count the number of occurrences of in the input array.</p>
<p>Listing <a href="#list:majority_element:moore" data-reference-type="ref" data-reference="list:majority_element:moore">[list:majority_element:moore]</a> shows a possible implementation of the Boyer-Moore algorithm. The complexity of this approach is <span class="math inline">\(O(n)\)</span> time and <span class="math inline">\(O(1)\)</span> space because the input array is scanned twice and only two additional integer variables are used.</p>
<div class="sourceCode" id="list:majority_element:moore" data-language="c++" data-caption="Linear time constant space solution to the problem of finding the majority element in an array." label="list:majority_element:moore"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:majority_element:moore-1"><a href="#list:majority_element:moore-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> find_majority_element_linear<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span></span>
<span id="list:majority_element:moore-2"><a href="#list:majority_element:moore-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:majority_element:moore-3"><a href="#list:majority_element:moore-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:majority_element:moore-4"><a href="#list:majority_element:moore-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:majority_element:moore-5"><a href="#list:majority_element:moore-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:majority_element:moore-6"><a href="#list:majority_element:moore-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> el    <span class="op">=</span> nums<span class="op">.</span>front<span class="op">();</span></span>
<span id="list:majority_element:moore-7"><a href="#list:majority_element:moore-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:majority_element:moore-8"><a href="#list:majority_element:moore-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> nums<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span></span>
<span id="list:majority_element:moore-9"><a href="#list:majority_element:moore-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:majority_element:moore-10"><a href="#list:majority_element:moore-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> el<span class="op">)</span></span>
<span id="list:majority_element:moore-11"><a href="#list:majority_element:moore-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:majority_element:moore-12"><a href="#list:majority_element:moore-12" aria-hidden="true" tabindex="-1"></a>      count<span class="op">++;</span></span>
<span id="list:majority_element:moore-13"><a href="#list:majority_element:moore-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:majority_element:moore-14"><a href="#list:majority_element:moore-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="list:majority_element:moore-15"><a href="#list:majority_element:moore-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:majority_element:moore-16"><a href="#list:majority_element:moore-16" aria-hidden="true" tabindex="-1"></a>      count<span class="op">--;</span></span>
<span id="list:majority_element:moore-17"><a href="#list:majority_element:moore-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:majority_element:moore-18"><a href="#list:majority_element:moore-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>count <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:majority_element:moore-19"><a href="#list:majority_element:moore-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:majority_element:moore-20"><a href="#list:majority_element:moore-20" aria-hidden="true" tabindex="-1"></a>      el    <span class="op">=</span> nums<span class="op">[</span>i<span class="op">];</span></span>
<span id="list:majority_element:moore-21"><a href="#list:majority_element:moore-21" aria-hidden="true" tabindex="-1"></a>      count <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:majority_element:moore-22"><a href="#list:majority_element:moore-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:majority_element:moore-23"><a href="#list:majority_element:moore-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:majority_element:moore-24"><a href="#list:majority_element:moore-24" aria-hidden="true" tabindex="-1"></a>  <span class="co">// check that el appears &gt; n/2 times</span></span>
<span id="list:majority_element:moore-25"><a href="#list:majority_element:moore-25" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>count<span class="op">(</span>begin<span class="op">(</span>nums<span class="op">),</span> end<span class="op">(</span>nums<span class="op">),</span> el<span class="op">)</span> <span class="op">&gt;</span> nums<span class="op">.</span>size<span class="op">()</span> <span class="op">/</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="list:majority_element:moore-26"><a href="#list:majority_element:moore-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> el<span class="op">;</span></span>
<span id="list:majority_element:moore-27"><a href="#list:majority_element:moore-27" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:majority_element:moore-28"><a href="#list:majority_element:moore-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="ch:node_from_the_end"><span class="math inline">\(n^{th}\)</span> node from the end</h1>
<h2 class="unnumbered" id="introduction-27">Introduction</h2>
<p>The problem presented in this chapter is a particularly interesting one on Linked List. It has been asked numerous times in companies like Amazon and Google and it is therefore important that we understand and master the solution to this problem.</p>
<h2 id="problem-statement-28">Problem statement</h2>
<div class="exercise">
<p>Given a linked list <span class="math inline">\(L\)</span> (which definition is shown in Listing <a href="#list:delete_duplicates_list:linked_list" data-reference-type="ref" data-reference="list:delete_duplicates_list:linked_list">[list:delete_duplicates_list:linked_list]</a> at page , and an integer <span class="math inline">\(n\)</span> remove the <span class="math inline">\(n^{th}\)</span> node from the end of list.</p>
<div class="example">
<p><br />
Given <span class="math inline">\(L=[1,2,3,4]\)</span>, and <span class="math inline">\(n=2\)</span> the function returns: <span class="math inline">\(L=[1,2,4]\)</span>. See Figure <a href="#fig:node_from_the_end:example1" data-reference-type="ref" data-reference="fig:node_from_the_end:example1">28.1</a>.</p>
</div>
<div class="example">
<p>Given <span class="math inline">\(L=[1,2,3,4]\)</span>, and <span class="math inline">\(n=0\)</span> the function returns: <span class="math inline">\(L=[1,2,4]\)</span>. See Figure <a href="#fig:node_from_the_end:example2" data-reference-type="ref" data-reference="fig:node_from_the_end:example2">28.2</a>.</p>
</div>
</div>
<p><span id="fig:node_from_the_end:example1" label="fig:node_from_the_end:example1">[fig:node_from_the_end:example1]</span> <img src="/home/dspataro/git/algorithm_articles/sources/node_from_the_end/images/example1.png" title="fig:" id="fig:node_from_the_end:example1" alt="Removal of the to last element in a singly linked list of length 4." /></p>
<p><span id="fig:node_from_the_end:example2" label="fig:node_from_the_end:example2">[fig:node_from_the_end:example2]</span> <img src="/home/dspataro/git/algorithm_articles/sources/node_from_the_end/images/example2.png" title="fig:" id="fig:node_from_the_end:example2" alt="Removal of the to last element in a singly linked list of length 4. The head pointer needs to be updated." /></p>
<h2 id="clarification-questions-24">Clarification Questions</h2>
<div class="QandA">
<p>Is <span class="math inline">\(n\)</span> guaranteed to be a valid node in the list?</p>
<div class="answered">
<p><em>Yes you can assume that <span class="math inline">\(n\)</span> is the index of a valid node in the list.</em></p>
</div>
</div>
<h2 id="node_from_the_end:sec:discussion">Discussion</h2>
<p>This problem has two main parts in it:</p>
<ol>
<li><p>Finding out the index of the <span class="math inline">\(n\)</span>-to last node</p></li>
<li><p>Removing a node from the list</p></li>
</ol>
<p>Those tasks are separate and thus we can solve each of them separately and then use the solution to these two subproblems to obtain our final answer.</p>
<h3 id="node_from_the_end:sec:bruteforce">Brute-force</h3>
<p>Finding out the the node to be deleted becomes trivial once we know how long the list is. Therefore the brute-force approach simply performs a first pass in the list and counts how many nodes it is made of i.e. <span class="math inline">\(l\)</span>. Then it performs another pass but it stops at node <span class="math inline">\(l-n\)</span> (the n-to-last node) and removes it. Please note that in order to correctly remove a node from a singly linked list a we need to have a pointer to the node we want to remove as well as a pointer to its predecessor (variable in the code). This approach can be implemented as shown in Listing <a href="#list:node_from_the_end:bruteforce" data-reference-type="ref" data-reference="list:node_from_the_end:bruteforce">[list:node_from_the_end:bruteforce]</a>, and it has a time and space complexity of <span class="math inline">\(O(n)\)</span> and <span class="math inline">\(O(1)\)</span>, respectively.</p>
<div class="sourceCode" id="list:node_from_the_end:bruteforce" data-language="c++" data-caption="Sample Caption" label="list:node_from_the_end:bruteforce"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:node_from_the_end:bruteforce-1"><a href="#list:node_from_the_end:bruteforce-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> list_length<span class="op">(</span>ListNode<span class="op">*</span> head<span class="op">)</span></span>
<span id="list:node_from_the_end:bruteforce-2"><a href="#list:node_from_the_end:bruteforce-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:node_from_the_end:bruteforce-3"><a href="#list:node_from_the_end:bruteforce-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:node_from_the_end:bruteforce-4"><a href="#list:node_from_the_end:bruteforce-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>head<span class="op">)</span></span>
<span id="list:node_from_the_end:bruteforce-5"><a href="#list:node_from_the_end:bruteforce-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:node_from_the_end:bruteforce-6"><a href="#list:node_from_the_end:bruteforce-6" aria-hidden="true" tabindex="-1"></a>    ans<span class="op">++;</span></span>
<span id="list:node_from_the_end:bruteforce-7"><a href="#list:node_from_the_end:bruteforce-7" aria-hidden="true" tabindex="-1"></a>    head <span class="op">=</span> head<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:node_from_the_end:bruteforce-8"><a href="#list:node_from_the_end:bruteforce-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:node_from_the_end:bruteforce-9"><a href="#list:node_from_the_end:bruteforce-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:node_from_the_end:bruteforce-10"><a href="#list:node_from_the_end:bruteforce-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:node_from_the_end:bruteforce-11"><a href="#list:node_from_the_end:bruteforce-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:node_from_the_end:bruteforce-12"><a href="#list:node_from_the_end:bruteforce-12" aria-hidden="true" tabindex="-1"></a>ListNode<span class="op">*</span> remove_nth_node_from_end_bruteforce<span class="op">(</span>ListNode<span class="op">*</span> head<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span></span>
<span id="list:node_from_the_end:bruteforce-13"><a href="#list:node_from_the_end:bruteforce-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:node_from_the_end:bruteforce-14"><a href="#list:node_from_the_end:bruteforce-14" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> length <span class="op">=</span> list_length<span class="op">(</span>head<span class="op">);</span></span>
<span id="list:node_from_the_end:bruteforce-15"><a href="#list:node_from_the_end:bruteforce-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// we can assume it is always valid/positive</span></span>
<span id="list:node_from_the_end:bruteforce-16"><a href="#list:node_from_the_end:bruteforce-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:node_from_the_end:bruteforce-17"><a href="#list:node_from_the_end:bruteforce-17" aria-hidden="true" tabindex="-1"></a>  ListNode <span class="op">*</span>prec <span class="op">=</span> <span class="kw">nullptr</span><span class="op">,</span> <span class="op">*</span>curr <span class="op">=</span> head<span class="op">;</span></span>
<span id="list:node_from_the_end:bruteforce-18"><a href="#list:node_from_the_end:bruteforce-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:node_from_the_end:bruteforce-19"><a href="#list:node_from_the_end:bruteforce-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> index <span class="op">=</span> length <span class="op">-</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:node_from_the_end:bruteforce-20"><a href="#list:node_from_the_end:bruteforce-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>index<span class="op">--)</span></span>
<span id="list:node_from_the_end:bruteforce-21"><a href="#list:node_from_the_end:bruteforce-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:node_from_the_end:bruteforce-22"><a href="#list:node_from_the_end:bruteforce-22" aria-hidden="true" tabindex="-1"></a>    prec <span class="op">=</span> curr<span class="op">;</span></span>
<span id="list:node_from_the_end:bruteforce-23"><a href="#list:node_from_the_end:bruteforce-23" aria-hidden="true" tabindex="-1"></a>    curr <span class="op">=</span> curr<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:node_from_the_end:bruteforce-24"><a href="#list:node_from_the_end:bruteforce-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:node_from_the_end:bruteforce-25"><a href="#list:node_from_the_end:bruteforce-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:node_from_the_end:bruteforce-26"><a href="#list:node_from_the_end:bruteforce-26" aria-hidden="true" tabindex="-1"></a>  ListNode<span class="op">*</span> next <span class="op">=</span> curr<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:node_from_the_end:bruteforce-27"><a href="#list:node_from_the_end:bruteforce-27" aria-hidden="true" tabindex="-1"></a>  ListNode<span class="op">*</span> ans  <span class="op">=</span> head<span class="op">;</span></span>
<span id="list:node_from_the_end:bruteforce-28"><a href="#list:node_from_the_end:bruteforce-28" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>prec<span class="op">)</span></span>
<span id="list:node_from_the_end:bruteforce-29"><a href="#list:node_from_the_end:bruteforce-29" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">=</span> next<span class="op">;</span>  <span class="co">// we are removing the first node</span></span>
<span id="list:node_from_the_end:bruteforce-30"><a href="#list:node_from_the_end:bruteforce-30" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span></span>
<span id="list:node_from_the_end:bruteforce-31"><a href="#list:node_from_the_end:bruteforce-31" aria-hidden="true" tabindex="-1"></a>    prec<span class="op">-&gt;</span>next <span class="op">=</span> next<span class="op">;</span></span>
<span id="list:node_from_the_end:bruteforce-32"><a href="#list:node_from_the_end:bruteforce-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:node_from_the_end:bruteforce-33"><a href="#list:node_from_the_end:bruteforce-33" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:node_from_the_end:bruteforce-34"><a href="#list:node_from_the_end:bruteforce-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="node_from_the_end:sec:twopointers">Two pointers</h3>
<p>There is however another way of solving this problem that is our opinion is slightly better even if it is not in terms of asymptotic complexity. The key issue we have with this problem is that we have to delete a node at index <span class="math inline">\(l-n\)</span> but we have no idea what <span class="math inline">\(l\)</span> is and we do not want to compute it explicitly. What we can do it to loop forward with a pointer <span class="math inline">\(s\)</span> from the head of the list for <span class="math inline">\(n\)</span> nodes. At this point <span class="math inline">\(s\)</span> will be at <span class="math inline">\(n\)</span> node distance from the head and at <span class="math inline">\(l-n\)</span> from the tail. We now have a way of counting <span class="math inline">\(n-l\)</span>. Let <span class="math inline">\(f\)</span> be a pointer to the head of the list: we can advance both <span class="math inline">\(f\)</span> and <span class="math inline">\(s\)</span> until <span class="math inline">\(s\)</span> reaches the end of the list. At that point <span class="math inline">\(s\)</span> had advanced <span class="math inline">\(l-n\)</span> times and <span class="math inline">\(f\)</span>, crucially will be pointing at the node <span class="math inline">\(l-n\)</span> i.e. at the n-to-last node.</p>
<p>This idea is implemented in Listing <a href="#list:node_from_the_end:twopointers" data-reference-type="ref" data-reference="list:node_from_the_end:twopointers">[list:node_from_the_end:twopointers]</a>. Please note that the second , as in the brute-force approach (Listing <a href="#list:node_from_the_end:bruteforce" data-reference-type="ref" data-reference="list:node_from_the_end:bruteforce">[list:node_from_the_end:bruteforce]</a>) also need to keep a pointer to the node proceeding the one that needs to be deleted (pointer <span class="math inline">\(p\)</span> in the code).</p>
<p>The complexity of this implementation is linear in time and constant in space.</p>
<div class="sourceCode" id="list:node_from_the_end:twopointers" data-language="c++" data-caption="Sample Caption" label="list:node_from_the_end:twopointers"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:node_from_the_end:twopointers-1"><a href="#list:node_from_the_end:twopointers-1" aria-hidden="true" tabindex="-1"></a>ListNode <span class="op">*</span>remove_nth_node_from_end_two_pointers<span class="op">(</span>ListNode <span class="op">*</span>head<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span></span>
<span id="list:node_from_the_end:twopointers-2"><a href="#list:node_from_the_end:twopointers-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:node_from_the_end:twopointers-3"><a href="#list:node_from_the_end:twopointers-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:node_from_the_end:twopointers-4"><a href="#list:node_from_the_end:twopointers-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> head<span class="op">;</span></span>
<span id="list:node_from_the_end:twopointers-5"><a href="#list:node_from_the_end:twopointers-5" aria-hidden="true" tabindex="-1"></a>  ListNode <span class="op">*</span>s<span class="op">,</span> <span class="op">*</span>f<span class="op">,</span> <span class="op">*</span>p <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="list:node_from_the_end:twopointers-6"><a href="#list:node_from_the_end:twopointers-6" aria-hidden="true" tabindex="-1"></a>  s <span class="op">=</span> f <span class="op">=</span> head<span class="op">;</span></span>
<span id="list:node_from_the_end:twopointers-7"><a href="#list:node_from_the_end:twopointers-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:node_from_the_end:twopointers-8"><a href="#list:node_from_the_end:twopointers-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// advance s n times</span></span>
<span id="list:node_from_the_end:twopointers-9"><a href="#list:node_from_the_end:twopointers-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>n<span class="op">)</span></span>
<span id="list:node_from_the_end:twopointers-10"><a href="#list:node_from_the_end:twopointers-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:node_from_the_end:twopointers-11"><a href="#list:node_from_the_end:twopointers-11" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> s<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:node_from_the_end:twopointers-12"><a href="#list:node_from_the_end:twopointers-12" aria-hidden="true" tabindex="-1"></a>    n<span class="op">--;</span></span>
<span id="list:node_from_the_end:twopointers-13"><a href="#list:node_from_the_end:twopointers-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:node_from_the_end:twopointers-14"><a href="#list:node_from_the_end:twopointers-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:node_from_the_end:twopointers-15"><a href="#list:node_from_the_end:twopointers-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// now s is at a distance of l-n  from the tail</span></span>
<span id="list:node_from_the_end:twopointers-16"><a href="#list:node_from_the_end:twopointers-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>s<span class="op">)</span></span>
<span id="list:node_from_the_end:twopointers-17"><a href="#list:node_from_the_end:twopointers-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:node_from_the_end:twopointers-18"><a href="#list:node_from_the_end:twopointers-18" aria-hidden="true" tabindex="-1"></a>    ListNode <span class="op">*</span>oldf <span class="op">=</span> f<span class="op">;</span></span>
<span id="list:node_from_the_end:twopointers-19"><a href="#list:node_from_the_end:twopointers-19" aria-hidden="true" tabindex="-1"></a>    f              <span class="op">=</span> f<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:node_from_the_end:twopointers-20"><a href="#list:node_from_the_end:twopointers-20" aria-hidden="true" tabindex="-1"></a>    s              <span class="op">=</span> s<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="list:node_from_the_end:twopointers-21"><a href="#list:node_from_the_end:twopointers-21" aria-hidden="true" tabindex="-1"></a>    p              <span class="op">=</span> oldf<span class="op">;</span></span>
<span id="list:node_from_the_end:twopointers-22"><a href="#list:node_from_the_end:twopointers-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:node_from_the_end:twopointers-23"><a href="#list:node_from_the_end:twopointers-23" aria-hidden="true" tabindex="-1"></a>  <span class="co">// f points to the node l-n of the list</span></span>
<span id="list:node_from_the_end:twopointers-24"><a href="#list:node_from_the_end:twopointers-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:node_from_the_end:twopointers-25"><a href="#list:node_from_the_end:twopointers-25" aria-hidden="true" tabindex="-1"></a>  ListNode <span class="op">*</span>next <span class="op">=</span> f <span class="op">?</span> f<span class="op">-&gt;</span>next <span class="op">:</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="list:node_from_the_end:twopointers-26"><a href="#list:node_from_the_end:twopointers-26" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>p<span class="op">)</span></span>
<span id="list:node_from_the_end:twopointers-27"><a href="#list:node_from_the_end:twopointers-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:node_from_the_end:twopointers-28"><a href="#list:node_from_the_end:twopointers-28" aria-hidden="true" tabindex="-1"></a>    head <span class="op">=</span> next<span class="op">;</span></span>
<span id="list:node_from_the_end:twopointers-29"><a href="#list:node_from_the_end:twopointers-29" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:node_from_the_end:twopointers-30"><a href="#list:node_from_the_end:twopointers-30" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span></span>
<span id="list:node_from_the_end:twopointers-31"><a href="#list:node_from_the_end:twopointers-31" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:node_from_the_end:twopointers-32"><a href="#list:node_from_the_end:twopointers-32" aria-hidden="true" tabindex="-1"></a>    p<span class="op">-&gt;</span>next <span class="op">=</span> next<span class="op">;</span></span>
<span id="list:node_from_the_end:twopointers-33"><a href="#list:node_from_the_end:twopointers-33" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:node_from_the_end:twopointers-34"><a href="#list:node_from_the_end:twopointers-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:node_from_the_end:twopointers-35"><a href="#list:node_from_the_end:twopointers-35" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> head<span class="op">;</span></span>
<span id="list:node_from_the_end:twopointers-36"><a href="#list:node_from_the_end:twopointers-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="common-variation-2">Common Variation</h3>
<h4 id="node_from_the_end:sec:list_midpoint">List midpoint</h4>
<div class="exercise">
<p>Given a linked list <span class="math inline">\(L\)</span> of length <span class="math inline">\(l\)</span> (which definition is shown in Listing <a href="#list:delete_duplicates_list:linked_list" data-reference-type="ref" data-reference="list:delete_duplicates_list:linked_list">[list:delete_duplicates_list:linked_list]</a> at page , return the value of the node at position <span class="math inline">\(\frac{l}{2}\)</span>.</p>
<div class="example">
<p><br />
Given <span class="math inline">\(L=[1,2,3,4]\)</span>, the function returns <span class="math inline">\(2\)</span>.</p>
</div>
<div class="example">
<p>Given <span class="math inline">\(L=[1,5,7,8,9,4,5,6,1,2,4,9,7]\)</span>, the function returns <span class="math inline">\(5\)</span>.</p>
</div>
</div>
<p>This is a very popular variation of the problem described in this chapter. It can be solved using the same methods described in Sections <a href="#node_from_the_end:sec:bruteforce" data-reference-type="ref" data-reference="node_from_the_end:sec:bruteforce">28.3.1</a> and <a href="#node_from_the_end:sec:twopointers" data-reference-type="ref" data-reference="node_from_the_end:sec:twopointers">28.3.2</a> or using an ad-hoc(spoiler: a fast and a slow pointers</p>
<h1 id="ch:valid_parenthesis">Validate Parenthesized String</h1>
<h2 id="problem-statement-29">Problem statement</h2>
<div class="exercise">
<p>Given a string <em>s</em> containing only three types of characters:</p>
<ol>
<li><p><em>(</em></p></li>
<li><p><em>)</em></p></li>
<li><p><em>*</em></p></li>
</ol>
<p>write a function to check whether a string is valid. A string is valid if the following holds:</p>
<ul>
<li><p>Any left parenthesis <em>(</em> must have a corresponding right parenthesis <em>)</em>.</p></li>
<li><p>Any right parenthesis <em>)</em> must have a corresponding left parenthesis <em>)</em>.</p></li>
<li><p>Left parenthesis <em>(</em> must appear before the corresponding right parenthesis <em>)</em>.</p></li>
<li><p>The character <em>*</em> could be treated as a jolly, and can be modified into a single right parenthesis <em>)</em> or a single left parenthesis <em>)</em> or deleted.</p></li>
</ul>
<div class="example">
<p><br />
Given the input string <em>s="(**))"</em> the function returns <strong>true</strong> because it is possible to obtain from <em>s</em> the string <em>(())</em> by deleting the first <em>*</em> and by turning the second one into a left parenthesis <em>)</em>.</p>
</div>
<div class="example">
<p><br />
Given the input string s=<em>"*(*)()(()"</em> the function returns <strong>false</strong> because no matter how the are arranged there is no way to obtain a well balanced string of parenthesis.</p>
</div>
</div>
<h2 id="clarification-questions-25">Clarification Questions</h2>
<div class="QandA">
<p>Is the empty string considered valid?</p>
<div class="answered">
<p><em>An empty string is also valid.</em></p>
</div>
</div>
<h2 id="valid_parenthesis:sec:discussion">Discussion</h2>
<p>This is an extremely interesting and quite challenging problem that can be solved in different ways. We will start by having a look at the brute-force solution in Section <a href="#valid_parenthesis:sec:bruteforce" data-reference-type="ref" data-reference="valid_parenthesis:sec:bruteforce">29.3.1</a> will will allow us to develop a dynamic programming solution that works much better. Section <a href="#valid_parenthesis:sec:linear" data-reference-type="ref" data-reference="valid_parenthesis:sec:linear">29.3.3</a> presents a totally different solution that improves dramatically the time and space complexity compared to the previous approaches. Section <a href="#valid_parenthesis:sec:twostacks" data-reference-type="ref" data-reference="valid_parenthesis:sec:twostacks">[valid_parenthesis:sec:twostacks]</a> presents a linear time and space clever solution based on stacks.</p>
<p>We will highly advice to use the solution shown in Section <a href="#valid_parenthesis:sec:linear" data-reference-type="ref" data-reference="valid_parenthesis:sec:linear">29.3.3</a> as a reference and use that during an actual interview.</p>
<h3 id="valid_parenthesis:sec:bruteforce">Brute-force</h3>
<p>If the input string does not contains wild-cards, this problem is quite trivial and becomes easily solvable by using a stack. When wild-cards are present things can get more complicated because now for each of them there are three options. In the brute-force approach we will try all possible options for all wild-cards. The idea is that the input string <span class="math inline">\(s\)</span> is traversed from left to right. As we traverse the string we will keep track of how many open and closed parenthesis we have encountered. We do this because if at any moment we find that the number of closed parenthesis is greater than the number of open ones, the string is invalid (it violates the constraint that any left parenthesis should appear before any right one). Depending on the character <span class="math inline">\(c\)</span> we are processing:</p>
<ol>
<li><p>If <span class="math inline">\(c\)</span>is a <em>(</em> then we increase the number of open parenthesis found so far and we recursively check the rest of the string.</p></li>
<li><p>Similarly, if <span class="math inline">\(c\)</span> is a <em>)</em> then we increase the number of closed parenthesis and proceed checking the rest of the string.</p></li>
<li><p>If the current character is a <em>*</em> then we have the option to:</p>
<ul>
<li><p>consider it as an open parenthesis</p></li>
<li><p>consider it as a closed parenthesis</p></li>
<li><p>ignore it</p></li>
</ul></li>
</ol>
<p>The recursion terminates when either:</p>
<ul>
<li><p>the number of closed parenthesis is larger than the number of open ones</p></li>
<li><p>we have processed the whole string. In this case we return true only if the number of open parenthesis so far is equal to the closed ones (necessary condition for a well balanced string).</p></li>
</ul>
<p>Listing <a href="#list:valid_parenthesis:bruteforce" data-reference-type="ref" data-reference="list:valid_parenthesis:bruteforce">[list:valid_parenthesis:bruteforce]</a> shows a possible recursive implementation of the idea above. The complexity of this approach is exponential in the number of <em>*</em>, i.e. <span class="math inline">\(O(3^{n})\)</span>, where <span class="math inline">\(n\)</span> is the length of <span class="math inline">\(s\)</span>.</p>
<div class="sourceCode" id="list:valid_parenthesis:bruteforce" data-language="c++" data-caption="Brute-force, exponential time solution to the problem of validating a string of parenthesis with wild-cards." label="list:valid_parenthesis:bruteforce"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:valid_parenthesis:bruteforce-1"><a href="#list:valid_parenthesis:bruteforce-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> validate_parenthesized_string_bruteforce_helper<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span>s<span class="op">,</span></span>
<span id="list:valid_parenthesis:bruteforce-2"><a href="#list:valid_parenthesis:bruteforce-2" aria-hidden="true" tabindex="-1"></a>                                                     <span class="at">const</span> <span class="dt">size_t</span> pos<span class="op">,</span></span>
<span id="list:valid_parenthesis:bruteforce-3"><a href="#list:valid_parenthesis:bruteforce-3" aria-hidden="true" tabindex="-1"></a>                                                     <span class="at">const</span> <span class="dt">int</span> open<span class="op">,</span></span>
<span id="list:valid_parenthesis:bruteforce-4"><a href="#list:valid_parenthesis:bruteforce-4" aria-hidden="true" tabindex="-1"></a>                                                     <span class="at">const</span> <span class="dt">int</span> closed<span class="op">)</span></span>
<span id="list:valid_parenthesis:bruteforce-5"><a href="#list:valid_parenthesis:bruteforce-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:valid_parenthesis:bruteforce-6"><a href="#list:valid_parenthesis:bruteforce-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>pos <span class="op">==</span> s<span class="op">.</span>size<span class="op">())</span></span>
<span id="list:valid_parenthesis:bruteforce-7"><a href="#list:valid_parenthesis:bruteforce-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> open <span class="op">==</span> closed<span class="op">;</span></span>
<span id="list:valid_parenthesis:bruteforce-8"><a href="#list:valid_parenthesis:bruteforce-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:valid_parenthesis:bruteforce-9"><a href="#list:valid_parenthesis:bruteforce-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>closed <span class="op">&gt;</span> open<span class="op">)</span></span>
<span id="list:valid_parenthesis:bruteforce-10"><a href="#list:valid_parenthesis:bruteforce-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:valid_parenthesis:bruteforce-11"><a href="#list:valid_parenthesis:bruteforce-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:valid_parenthesis:bruteforce-12"><a href="#list:valid_parenthesis:bruteforce-12" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">char</span> curr <span class="op">=</span> s<span class="op">[</span>pos<span class="op">];</span></span>
<span id="list:valid_parenthesis:bruteforce-13"><a href="#list:valid_parenthesis:bruteforce-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> ans        <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:valid_parenthesis:bruteforce-14"><a href="#list:valid_parenthesis:bruteforce-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>curr <span class="op">!=</span> <span class="ch">&#39;{&#39;</span><span class="op">)</span>  <span class="co">// either } or *: add a right parenthesis</span></span>
<span id="list:valid_parenthesis:bruteforce-15"><a href="#list:valid_parenthesis:bruteforce-15" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">=</span> validate_parenthesized_string_bruteforce_helper<span class="op">(</span></span>
<span id="list:valid_parenthesis:bruteforce-16"><a href="#list:valid_parenthesis:bruteforce-16" aria-hidden="true" tabindex="-1"></a>        s<span class="op">,</span> pos <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> open<span class="op">,</span> closed <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="list:valid_parenthesis:bruteforce-17"><a href="#list:valid_parenthesis:bruteforce-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:valid_parenthesis:bruteforce-18"><a href="#list:valid_parenthesis:bruteforce-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>curr <span class="op">!=</span> <span class="ch">&#39;}&#39;</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>ans<span class="op">)</span>  <span class="co">// either {} or *: add a left parenthesis</span></span>
<span id="list:valid_parenthesis:bruteforce-19"><a href="#list:valid_parenthesis:bruteforce-19" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">=</span> validate_parenthesized_string_bruteforce_helper<span class="op">(</span></span>
<span id="list:valid_parenthesis:bruteforce-20"><a href="#list:valid_parenthesis:bruteforce-20" aria-hidden="true" tabindex="-1"></a>        s<span class="op">,</span> pos <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> open <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> closed<span class="op">);</span></span>
<span id="list:valid_parenthesis:bruteforce-21"><a href="#list:valid_parenthesis:bruteforce-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:valid_parenthesis:bruteforce-22"><a href="#list:valid_parenthesis:bruteforce-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>curr <span class="op">==</span> <span class="ch">&#39;*&#39;</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>ans<span class="op">)</span>  <span class="co">// if neither { nor } worked, then ignore this *</span></span>
<span id="list:valid_parenthesis:bruteforce-23"><a href="#list:valid_parenthesis:bruteforce-23" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">=</span> validate_parenthesized_string_bruteforce_helper<span class="op">(</span></span>
<span id="list:valid_parenthesis:bruteforce-24"><a href="#list:valid_parenthesis:bruteforce-24" aria-hidden="true" tabindex="-1"></a>        s<span class="op">,</span> pos <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> open<span class="op">,</span> closed<span class="op">);</span></span>
<span id="list:valid_parenthesis:bruteforce-25"><a href="#list:valid_parenthesis:bruteforce-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:valid_parenthesis:bruteforce-26"><a href="#list:valid_parenthesis:bruteforce-26" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:valid_parenthesis:bruteforce-27"><a href="#list:valid_parenthesis:bruteforce-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:valid_parenthesis:bruteforce-28"><a href="#list:valid_parenthesis:bruteforce-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:valid_parenthesis:bruteforce-29"><a href="#list:valid_parenthesis:bruteforce-29" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> validate_parenthesized_string_bruteforce<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span>s<span class="op">)</span></span>
<span id="list:valid_parenthesis:bruteforce-30"><a href="#list:valid_parenthesis:bruteforce-30" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:valid_parenthesis:bruteforce-31"><a href="#list:valid_parenthesis:bruteforce-31" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> validate_parenthesized_string_bruteforce_helper<span class="op">(</span>s<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="list:valid_parenthesis:bruteforce-32"><a href="#list:valid_parenthesis:bruteforce-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="valid_parenthesis:sec:dp">Dynamic Programming</h3>
<p>Another way of solving this problem is to still try all possibilities like in the brute-force solution, but doing it in a smart way, making sure no work is done more than once. In a string of length <span class="math inline">\(n\)</span> there are <span class="math inline">\(O(n^2)\)</span> possible substring. Given a substring starting at <span class="math inline">\(i\)</span> and ending at <span class="math inline">\(j\)</span>, from now on identified by <span class="math inline">\(s(i,j)\)</span> we can solve this problem by processing one character <span class="math inline">\(c\)</span> at the time. A substring <span class="math inline">\(s(i,j)\)</span> is valid when</p>
<ul>
<li><p>if <span class="math inline">\(c\)</span> is an <em>*</em> and <span class="math inline">\(s(i+1,j)\)</span> is valid. We try to ignore the character <span class="math inline">\(c\)</span>.</p></li>
<li><p>if <span class="math inline">\(c\)</span> is either <em>*</em> or <em>(</em>, then we search for a character <span class="math inline">\(k\)</span> in <span class="math inline">\(s(i+1,k)\)</span> s.t. it can be turn into a closing parenthesis. If <span class="math inline">\(k\)</span> exists (in case multiple <span class="math inline">\(k\)</span> exists, then we try all of them) then, <span class="math inline">\(s(i,j)\)</span> is valid if <span class="math inline">\(s(i+1,k-1)\)</span> and <span class="math inline">\(s(k+1,j)\)</span> are valid. Basically what we do here is to match an open parenthesis with a closing one that appears further in the range. Remember that each open parenthesis must be paired up with a closing one.</p></li>
<li><p>if <span class="math inline">\(c\)</span> <em>)</em> we return false because we have in this case an unmatched closing parenthesis.</p></li>
</ul>
<p>The result for a substring <span class="math inline">\(s(i,j)\)</span> is saved in a map, and when the algorithm asks for the validation of the same substring again, the value returned in the map is returned instead of doing the computation again. This technique is called memoization, and allows us to avoid the re-computation of the same subproblem over and over again. The approach described in this section can be implemented as shown in Listing <a href="#list:valid_parenthesis:dp" data-reference-type="ref" data-reference="list:valid_parenthesis:dp">[list:valid_parenthesis:dp]</a> and it has a time complexity of <span class="math inline">\(O(n^3)\)</span>. There are <span class="math inline">\(O(n^2)\)</span> possible substrings and for each of them a work proportional to <span class="math inline">\(n\)</span> is performed. The space complexity is bound by the amount of substrings that we can potentially store in the Hash-set i.e. <span class="math inline">\(O(n^2)\)</span>.</p>
<p>Note that this solution is nothing else than another way of solving this problem by brute-force. In-fact a pure brute-force solution can be obtained by just removing the DP variable and not storing the result of the validation for any intermediate substring. This is very common in many DP solution where the brute-force approach can be easily turned into a faster DP by simply remembering the result of intermediate subproblems (in this case the substring of the input string <span class="math inline">\(s\)</span>).</p>
<p>The DP solution is definitely a better solution than the brute-force but it is still far from the optimal. In the next section we will investigate a much faster solution that has the additional benefit of being also much shorter in length and therefore less error prone than the ones presented so far.</p>
<div class="sourceCode" id="list:valid_parenthesis:dp" data-language="c++" data-caption="Dynamic programming solution to the problem of validating a string of parenthesis with wild-cards." label="list:valid_parenthesis:dp"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:valid_parenthesis:dp-1"><a href="#list:valid_parenthesis:dp-1" aria-hidden="true" tabindex="-1"></a><span class="co">// a pair of indices identifying a substring</span></span>
<span id="list:valid_parenthesis:dp-2"><a href="#list:valid_parenthesis:dp-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> pii <span class="op">=</span> <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;;</span></span>
<span id="list:valid_parenthesis:dp-3"><a href="#list:valid_parenthesis:dp-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:valid_parenthesis:dp-4"><a href="#list:valid_parenthesis:dp-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> pair_hash</span>
<span id="list:valid_parenthesis:dp-5"><a href="#list:valid_parenthesis:dp-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:valid_parenthesis:dp-6"><a href="#list:valid_parenthesis:dp-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T1<span class="op">,</span> <span class="kw">class</span> T2<span class="op">&gt;</span></span>
<span id="list:valid_parenthesis:dp-7"><a href="#list:valid_parenthesis:dp-7" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>size_t<span class="op"> </span><span class="kw">operator</span><span class="op">()(</span><span class="at">const</span> <span class="bu">std::</span>pair<span class="op">&lt;</span>T1<span class="op">,</span> T2<span class="op">&gt;&amp;</span> pair<span class="op">)</span> <span class="at">const</span></span>
<span id="list:valid_parenthesis:dp-8"><a href="#list:valid_parenthesis:dp-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:valid_parenthesis:dp-9"><a href="#list:valid_parenthesis:dp-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>hash<span class="op">&lt;</span>T1<span class="op">&gt;()(</span>pair<span class="op">.</span>first<span class="op">)</span> <span class="op">^</span> <span class="bu">std::</span>hash<span class="op">&lt;</span>T2<span class="op">&gt;()(</span>pair<span class="op">.</span>second<span class="op">);</span></span>
<span id="list:valid_parenthesis:dp-10"><a href="#list:valid_parenthesis:dp-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:valid_parenthesis:dp-11"><a href="#list:valid_parenthesis:dp-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="list:valid_parenthesis:dp-12"><a href="#list:valid_parenthesis:dp-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:valid_parenthesis:dp-13"><a href="#list:valid_parenthesis:dp-13" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> validate_parenthesized_string_DP_helper<span class="op">(</span></span>
<span id="list:valid_parenthesis:dp-14"><a href="#list:valid_parenthesis:dp-14" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> s<span class="op">,</span></span>
<span id="list:valid_parenthesis:dp-15"><a href="#list:valid_parenthesis:dp-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unordered_map<span class="op">&lt;</span>pii<span class="op">,</span> <span class="dt">bool</span><span class="op">,</span> pair_hash<span class="op">&gt;&amp;</span> DP<span class="op">,</span></span>
<span id="list:valid_parenthesis:dp-16"><a href="#list:valid_parenthesis:dp-16" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> pii<span class="op">&amp;</span> substr<span class="op">)</span></span>
<span id="list:valid_parenthesis:dp-17"><a href="#list:valid_parenthesis:dp-17" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:valid_parenthesis:dp-18"><a href="#list:valid_parenthesis:dp-18" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> <span class="op">[</span>i<span class="op">,</span> j<span class="op">]</span> <span class="op">=</span> substr<span class="op">;</span></span>
<span id="list:valid_parenthesis:dp-19"><a href="#list:valid_parenthesis:dp-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> j<span class="op">)</span></span>
<span id="list:valid_parenthesis:dp-20"><a href="#list:valid_parenthesis:dp-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:valid_parenthesis:dp-21"><a href="#list:valid_parenthesis:dp-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// empty string is valid</span></span>
<span id="list:valid_parenthesis:dp-22"><a href="#list:valid_parenthesis:dp-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:valid_parenthesis:dp-23"><a href="#list:valid_parenthesis:dp-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:valid_parenthesis:dp-24"><a href="#list:valid_parenthesis:dp-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:valid_parenthesis:dp-25"><a href="#list:valid_parenthesis:dp-25" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>DP<span class="op">.</span>find<span class="op">(</span>substr<span class="op">)</span> <span class="op">!=</span> DP<span class="op">.</span>end<span class="op">())</span></span>
<span id="list:valid_parenthesis:dp-26"><a href="#list:valid_parenthesis:dp-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> DP<span class="op">[</span>substr<span class="op">];</span></span>
<span id="list:valid_parenthesis:dp-27"><a href="#list:valid_parenthesis:dp-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:valid_parenthesis:dp-28"><a href="#list:valid_parenthesis:dp-28" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> ans     <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:valid_parenthesis:dp-29"><a href="#list:valid_parenthesis:dp-29" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">char</span> c <span class="op">=</span> s<span class="op">[</span>i<span class="op">];</span></span>
<span id="list:valid_parenthesis:dp-30"><a href="#list:valid_parenthesis:dp-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:valid_parenthesis:dp-31"><a href="#list:valid_parenthesis:dp-31" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> <span class="ch">&#39;)&#39;</span><span class="op">)</span></span>
<span id="list:valid_parenthesis:dp-32"><a href="#list:valid_parenthesis:dp-32" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:valid_parenthesis:dp-33"><a href="#list:valid_parenthesis:dp-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:valid_parenthesis:dp-34"><a href="#list:valid_parenthesis:dp-34" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>ans <span class="op">&amp;&amp;</span> c <span class="op">==</span> <span class="ch">&#39;*&#39;</span><span class="op">)</span>  <span class="co">// try ignoring this character</span></span>
<span id="list:valid_parenthesis:dp-35"><a href="#list:valid_parenthesis:dp-35" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">=</span> validate_parenthesized_string_DP_helper<span class="op">(</span>s<span class="op">,</span> DP<span class="op">,</span> <span class="op">{</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> j<span class="op">});</span></span>
<span id="list:valid_parenthesis:dp-36"><a href="#list:valid_parenthesis:dp-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:valid_parenthesis:dp-37"><a href="#list:valid_parenthesis:dp-37" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>ans <span class="op">&amp;&amp;</span> c <span class="op">!=</span> <span class="ch">&#39;)&#39;</span><span class="op">)</span>  <span class="co">// either * or open brackets. Try turning it into a (</span></span>
<span id="list:valid_parenthesis:dp-38"><a href="#list:valid_parenthesis:dp-38" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:valid_parenthesis:dp-39"><a href="#list:valid_parenthesis:dp-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">// find a something that can be turned into a ) further ahead in the</span></span>
<span id="list:valid_parenthesis:dp-40"><a href="#list:valid_parenthesis:dp-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">// string</span></span>
<span id="list:valid_parenthesis:dp-41"><a href="#list:valid_parenthesis:dp-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> <span class="op">!</span>ans <span class="op">&amp;&amp;</span> k <span class="op">&lt;=</span> j<span class="op">;</span> k<span class="op">++)</span></span>
<span id="list:valid_parenthesis:dp-42"><a href="#list:valid_parenthesis:dp-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:valid_parenthesis:dp-43"><a href="#list:valid_parenthesis:dp-43" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>s<span class="op">[</span>k<span class="op">]</span> <span class="op">==</span> <span class="ch">&#39;)&#39;</span> <span class="op">||</span> s<span class="op">[</span>k<span class="op">]</span> <span class="op">==</span> <span class="ch">&#39;*&#39;</span><span class="op">)</span></span>
<span id="list:valid_parenthesis:dp-44"><a href="#list:valid_parenthesis:dp-44" aria-hidden="true" tabindex="-1"></a>      <span class="op">{</span></span>
<span id="list:valid_parenthesis:dp-45"><a href="#list:valid_parenthesis:dp-45" aria-hidden="true" tabindex="-1"></a>        <span class="co">// validate the two resulting substring from pairing char i and k</span></span>
<span id="list:valid_parenthesis:dp-46"><a href="#list:valid_parenthesis:dp-46" aria-hidden="true" tabindex="-1"></a>        ans <span class="op">=</span> validate_parenthesized_string_DP_helper<span class="op">(</span>s<span class="op">,</span> DP<span class="op">,</span> <span class="op">{</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> k <span class="op">-</span> <span class="dv">1</span><span class="op">})</span></span>
<span id="list:valid_parenthesis:dp-47"><a href="#list:valid_parenthesis:dp-47" aria-hidden="true" tabindex="-1"></a>              <span class="op">&amp;&amp;</span> <span class="op">(</span>validate_parenthesized_string_DP_helper<span class="op">(</span>s<span class="op">,</span> DP<span class="op">,</span> <span class="op">{</span>k <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> j<span class="op">}));</span></span>
<span id="list:valid_parenthesis:dp-48"><a href="#list:valid_parenthesis:dp-48" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="list:valid_parenthesis:dp-49"><a href="#list:valid_parenthesis:dp-49" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:valid_parenthesis:dp-50"><a href="#list:valid_parenthesis:dp-50" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:valid_parenthesis:dp-51"><a href="#list:valid_parenthesis:dp-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:valid_parenthesis:dp-52"><a href="#list:valid_parenthesis:dp-52" aria-hidden="true" tabindex="-1"></a>  DP<span class="op">[</span>substr<span class="op">]</span> <span class="op">=</span> ans<span class="op">;</span></span>
<span id="list:valid_parenthesis:dp-53"><a href="#list:valid_parenthesis:dp-53" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:valid_parenthesis:dp-54"><a href="#list:valid_parenthesis:dp-54" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:valid_parenthesis:dp-55"><a href="#list:valid_parenthesis:dp-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:valid_parenthesis:dp-56"><a href="#list:valid_parenthesis:dp-56" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> validate_parenthesized_string_DP<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> s<span class="op">)</span></span>
<span id="list:valid_parenthesis:dp-57"><a href="#list:valid_parenthesis:dp-57" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:valid_parenthesis:dp-58"><a href="#list:valid_parenthesis:dp-58" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>unordered_map<span class="op">&lt;</span>pii<span class="op">,</span> <span class="dt">bool</span><span class="op">,</span> pair_hash<span class="op">&gt;</span> DP<span class="op">;</span></span>
<span id="list:valid_parenthesis:dp-59"><a href="#list:valid_parenthesis:dp-59" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> size <span class="op">=</span> s<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:valid_parenthesis:dp-60"><a href="#list:valid_parenthesis:dp-60" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> validate_parenthesized_string_DP_helper<span class="op">(</span>s<span class="op">,</span> DP<span class="op">,</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> size<span class="op">});</span></span>
<span id="list:valid_parenthesis:dp-61"><a href="#list:valid_parenthesis:dp-61" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Also note that the structure is necessary so that the knows how to correctly calculate a hash value for s.</p>
<h3 id="valid_parenthesis:sec:linear">Greedy - Linear time</h3>
<p>The two previous approaches do much more than the problem asks for. They not only are able to determine whether the input string is valid or not, but they actually also calculate one. They solve the problem by manufacturing a valid string by trying out all possibilities until either one or none of them is good. What if we can come up with a way of determining whether the input string can be turned into a good one without having to actually come up with a specific valid string obtainable from the input? This is the idea behind the solution presented in this section.</p>
<p>The main idea is that for a valid string it has to be true that the balance between open <span class="math inline">\(o\)</span> and closed <span class="math inline">\(c\)</span> parenthesis is perfect i.e. <span class="math inline">\(o-c=0\)</span> has to hold. <span class="math inline">\(o-c=0\)</span> represents the number of open unmatched open parenthesis. Because the can be either a or a we cannot simply loop through the string and count the number of open and closed parenthesis. What we can do is to store all possible values <strong>for</strong> <span class="math inline">\(o-c\)</span> parenthesis that can be obtained. As we will see this values change in a fairly predictably way depending on what character we process. For instance given the input string when processing the <span class="math inline">\(i^{th}\)</span> character, the number of <span class="math inline">\(c-o\)</span> possible values <span class="math inline">\(P\)</span> can be:</p>
<ol>
<li><p><span class="math inline">\(P=\{1\}\)</span></p></li>
<li><p><span class="math inline">\(P=\{0,1,2\}\)</span> because considering only the first two character of <span class="math inline">\(s\)</span> we can obtain</p>
<ul>
<li><p>by turning the into a .</p></li>
<li><p>by deleting the .</p></li>
<li><p>by turning the into a .</p></li>
</ul></li>
<li><p><span class="math inline">\(P=\{1,2,3\}\)</span> because considering only the first three character of <span class="math inline">\(s\)</span> we can obtain</p>
<ul>
<li><p>by turning the into a</p></li>
<li><p>by deleting the .</p></li>
<li><p>by turning the into a</p></li>
</ul></li>
<li><p><span class="math inline">\(P=\{0,1,2\}\)</span> because considering only the first four character of <span class="math inline">\(s\)</span> we can obtain</p>
<ul>
<li><p>by turning the into a</p></li>
<li><p>by deleting the</p></li>
<li><p>by turning the into a .</p></li>
</ul></li>
<li><p><span class="math inline">\(P=\{-1,0,1,2,3\}\)</span> because considering only the first four character of <span class="math inline">\(s\)</span> we can obtain</p>
<ul>
<li><p>by turning the first into a and deleting the second one.</p></li>
<li><p>by deleting both the</p></li>
<li><p>by turning both the into a .</p></li>
<li><p>finally we can obtain <span class="math inline">\(-1\)</span> with this string by turning both the into a .</p></li>
</ul></li>
</ol>
<p>Note that values in the list <span class="math inline">\(P\)</span> can be obtained with different combinations of substitutions and that <span class="math inline">\(P\)</span> is always made of contiguous element. This last piece of information is important because it allows us to describe <span class="math inline">\(P\)</span> by only using its maximum and minimum value. We are interested in seeing whether at the end of the process we can obtain a value of <span class="math inline">\(0\)</span> meaning that the string is balanced. Note that if the maximum value at any point goes under <span class="math inline">\(0\)</span> it means that we reached a place where we have an excess of closed parenthesis that we cannot fix using all the asterics we encountered so far. For instance consider the string . When processing the element number the max and min values for the difference between the open and closed parenthesis will be:</p>
<ol>
<li><p><span class="math inline">\((1,1)\)</span></p></li>
<li><p><span class="math inline">\((0,2)\)</span></p></li>
<li><p><span class="math inline">\((-1,1)\)</span></p></li>
<li><p><span class="math inline">\((-2,0)\)</span></p></li>
<li><p><span class="math inline">\((-2,-1)\)</span></p></li>
</ol>
<p>When we reach the character the maximum number of open parenthesis we can obtain in the best case is <span class="math inline">\(-1\)</span>, meaning that we are short one for a balanced string. This mean that the string, as it is is invalid because there is an excess of closed parenthesis. This is a violation of the rule stating that every closed parenthesis must have a proceeding open one.</p>
<p>We can use the idea described above to derive an algorithm that works as follows: Let , respectively be the smallest and largest possible number of open left brackets after processing the <span class="math inline">\(i^{th}\)</span> character in the string <span class="math inline">\(s\)</span>.</p>
<p>If we encounter:</p>
<ul>
<li><p>a left parenthesis , then we can increment both and .</p></li>
<li><p>similarly, a right parenthesis , then we can decrement both and .</p></li>
<li><p>an asterix we can choose to either consider this as an open parenthesis (increasing the max number of obtainable open ones), delete it (leaving the balance unvaried) or convert it into a closed parenthesis (reducing )</p></li>
</ul>
<p>If at any point the maximum number of open parenthesis falls under <span class="math inline">\(0\)</span> then we are forced to consider the string invalid, for the reason we pointed out earlier (at least an unmatched closed parenthesis). Similarly we need to make sure that does not go below zero, because we do not need to consider strings which have this count of open parenthesis as they would invalid for the same reason as above.</p>
<p>When all the characters are processed, the only thing that is left to check is that <span class="math inline">\(0\)</span> is contained in the range defined by and . If it is, it means that exists a way to turn the string into a valid one, otherwise it is impossible (imagine the case where meaning that no matter what we do, the minimum amount of open parenthesis we end up with is still more than one meaning that there is at least one unmatched open parenthesis.</p>
<p>Listing <a href="#list:valid_parenthesis:linear" data-reference-type="ref" data-reference="list:valid_parenthesis:linear">[list:valid_parenthesis:linear]</a> shows a possible implementation of this idea. Note how every decrement of is guarded by a check, so to avoid that it goes below <span class="math inline">\(0\)</span>.</p>
<div class="sourceCode" id="list:valid_parenthesis:linear" data-language="c++" data-caption="Linear time constant space solution to the problem of validating a string of parenthesis with wild-cards." label="list:valid_parenthesis:linear"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:valid_parenthesis:linear-1"><a href="#list:valid_parenthesis:linear-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> validate_parenthesized_string_linear<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span>s<span class="op">)</span></span>
<span id="list:valid_parenthesis:linear-2"><a href="#list:valid_parenthesis:linear-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:valid_parenthesis:linear-3"><a href="#list:valid_parenthesis:linear-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> min<span class="op">,</span> max<span class="op">;</span></span>
<span id="list:valid_parenthesis:linear-4"><a href="#list:valid_parenthesis:linear-4" aria-hidden="true" tabindex="-1"></a>  min <span class="op">=</span> max <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:valid_parenthesis:linear-5"><a href="#list:valid_parenthesis:linear-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="dt">char</span> c <span class="op">:</span> s<span class="op">)</span></span>
<span id="list:valid_parenthesis:linear-6"><a href="#list:valid_parenthesis:linear-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:valid_parenthesis:linear-7"><a href="#list:valid_parenthesis:linear-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> <span class="ch">&#39;(&#39;</span><span class="op">)</span></span>
<span id="list:valid_parenthesis:linear-8"><a href="#list:valid_parenthesis:linear-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:valid_parenthesis:linear-9"><a href="#list:valid_parenthesis:linear-9" aria-hidden="true" tabindex="-1"></a>      min<span class="op">++;</span></span>
<span id="list:valid_parenthesis:linear-10"><a href="#list:valid_parenthesis:linear-10" aria-hidden="true" tabindex="-1"></a>      max<span class="op">++;</span></span>
<span id="list:valid_parenthesis:linear-11"><a href="#list:valid_parenthesis:linear-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:valid_parenthesis:linear-12"><a href="#list:valid_parenthesis:linear-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> <span class="ch">&#39;)&#39;</span><span class="op">)</span></span>
<span id="list:valid_parenthesis:linear-13"><a href="#list:valid_parenthesis:linear-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:valid_parenthesis:linear-14"><a href="#list:valid_parenthesis:linear-14" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>min <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:valid_parenthesis:linear-15"><a href="#list:valid_parenthesis:linear-15" aria-hidden="true" tabindex="-1"></a>        min<span class="op">--;</span></span>
<span id="list:valid_parenthesis:linear-16"><a href="#list:valid_parenthesis:linear-16" aria-hidden="true" tabindex="-1"></a>      max<span class="op">--;</span></span>
<span id="list:valid_parenthesis:linear-17"><a href="#list:valid_parenthesis:linear-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:valid_parenthesis:linear-18"><a href="#list:valid_parenthesis:linear-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>c <span class="op">==</span> <span class="ch">&#39;*&#39;</span><span class="op">)</span></span>
<span id="list:valid_parenthesis:linear-19"><a href="#list:valid_parenthesis:linear-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:valid_parenthesis:linear-20"><a href="#list:valid_parenthesis:linear-20" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>min <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:valid_parenthesis:linear-21"><a href="#list:valid_parenthesis:linear-21" aria-hidden="true" tabindex="-1"></a>        min<span class="op">--;</span></span>
<span id="list:valid_parenthesis:linear-22"><a href="#list:valid_parenthesis:linear-22" aria-hidden="true" tabindex="-1"></a>      max<span class="op">++;</span></span>
<span id="list:valid_parenthesis:linear-23"><a href="#list:valid_parenthesis:linear-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:valid_parenthesis:linear-24"><a href="#list:valid_parenthesis:linear-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>max <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:valid_parenthesis:linear-25"><a href="#list:valid_parenthesis:linear-25" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:valid_parenthesis:linear-26"><a href="#list:valid_parenthesis:linear-26" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:valid_parenthesis:linear-27"><a href="#list:valid_parenthesis:linear-27" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> min <span class="op">==</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:valid_parenthesis:linear-28"><a href="#list:valid_parenthesis:linear-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="ch:tree_diameter">Tree Diameter</h1>
<h2 class="unnumbered" id="introduction-28">Introduction</h2>
<p>The problem described in this chapter is quite simple and can be solved very elegantly and very quickly considering it can be coded in an handful of lines. Therefore it is really important we understand all the pieces that make up the solution for this one so we will be able to sort this out fast during an interivew.</p>
<h2 id="problem-statement-30">Problem statement</h2>
<div class="exercise">
<p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. The length of path between two nodes is the number of edges that you need to traverse to go from one to the other. The definition of the tree is shown in Listing <a href="#list:verify_BST:tree_structure" data-reference-type="ref" data-reference="list:verify_BST:tree_structure">[list:verify_BST:tree_structure]</a>.</p>
<div class="example">
<p><br />
Given the binary tree shown in Figure <a href="#fig:tree_diameter:example1" data-reference-type="ref" data-reference="fig:tree_diameter:example1">30.1</a> the function return <span class="math inline">\(7\)</span>. One path of such length is from node <span class="math inline">\(10\)</span> to node <span class="math inline">\(7\)</span> or <span class="math inline">\(8\)</span>.</p>
</div>
</div>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/tree_diameter/images/example1.png" id="fig:tree_diameter:example1" alt="Visual representation of the example 1 of the problem calculating the tree of a diameter." /><figcaption aria-hidden="true">Visual representation of the example <span class="math inline">\(1\)</span> of the problem calculating the tree of a diameter.</figcaption>
</figure>
<h2 id="tree_diameter:sec:discussion">Discussion</h2>
<h3 id="tree_diameter:sec:bruteforce">Brute-force</h3>
<p>In order to solve this problem we will be first tackiling a different one i.e. finding the depth of a tree. We will subsequently use the solution to this problem to compute the solution for the main one. Why is the depth of the binary tree important for determing the tree diameter? Let’s start by saying that the height of a binary tree is the longest path from the root to a leaf. The tree diameter can be found by visiting the tree one node at the time and for each node <span class="math inline">\(n\)</span> calculating the longest path between two leafs by a path passing <span class="math inline">\(n\)</span>. For instance considering the Figure <a href="#fig:tree_diameter:example1" data-reference-type="ref" data-reference="fig:tree_diameter:example1">30.1</a> the height of the subtree rooted at node <span class="math inline">\(5\)</span> is <span class="math inline">\(2\)</span> while the height for the node rooted at <span class="math inline">\(6\)</span> is <span class="math inline">\(1\)</span>. Given the heights for node <span class="math inline">\(5\)</span> and <span class="math inline">\(6\)</span> we can calculate the length of the longest path between between two leaves the passing through node <span class="math inline">\(2\)</span>: <span class="math inline">\(3\)</span>(height of node <span class="math inline">\(5\)</span>) <span class="math inline">\(+2\)</span>(height of node <span class="math inline">\(6\)</span>). So given a node <span class="math inline">\(n\)</span> and the height of its left and right subtrees <span class="math inline">\(h_l\)</span> and <span class="math inline">\(h_r\)</span>, respectively, the leght of the longest path between two leafs passing through <span class="math inline">\(n\)</span> can be calculated using the following procedure:</p>
<ul>
<li><p>calculate <span class="math inline">\(h_l\)</span>, height of the left subtree of <span class="math inline">\(n\)</span></p></li>
<li><p>calculate <span class="math inline">\(h_r\)</span>,, height of the right subtree of <span class="math inline">\(n\)</span></p></li>
<li><p><span class="math inline">\(d=h_l+h_r\)</span></p></li>
<li><p>if the left subtree of <span class="math inline">\(n\)</span> is not null, add <span class="math inline">\(1\)</span> to <span class="math inline">\(d\)</span>: <span class="math inline">\(d=d+1\)</span> (we need to account for the arc going from <span class="math inline">\(n\)</span> to the left subtree)</p></li>
<li><p>similarly for the right subtree, if it is not null, add <span class="math inline">\(1\)</span> to <span class="math inline">\(d\)</span>: <span class="math inline">\(d=d+1\)</span>.</p></li>
</ul>
<p>The height of a tree can be easily calculated using the recursive function in Listing <a href="#list:tree_diameter:diameter" data-reference-type="ref" data-reference="list:tree_diameter:diameter">[list:tree_diameter:diameter]</a>.</p>
<p>To summarize: the diameter of a tree <span class="math inline">\(T\)</span> is the largest of the following quantities:</p>
<ul>
<li><p>the diameter of <span class="math inline">\(T\)</span>’s left subtree</p></li>
<li><p>the diameter of <span class="math inline">\(T\)</span>’s right subtree</p></li>
<li><p>the longest path between leaves that goes through the root of <span class="math inline">\(T\)</span> (this can be computed from the heights of the subtrees of <span class="math inline">\(T\)</span>)</p></li>
</ul>
<p>Listing <a href="#list:tree_diameter:diameter" data-reference-type="ref" data-reference="list:tree_diameter:diameter">[list:tree_diameter:diameter]</a> shows a recursive implementation of this idea. The complexity of this approach is <span class="math inline">\(O(n^2)\)</span> where <span class="math inline">\(n\)</span> is the number of node in the tree. Why is that the case? Consider a list like tree <span class="math inline">\(T_1\)</span>. It’s height is <span class="math inline">\(n\)</span>, and each call to diameter involves a call to which has a linear complexity. So for each node we need to do linear work. We can do better than this with if we are willing to sacrifice some space for time.</p>
<div class="sourceCode" id="list:tree_diameter:diameter" data-language="c++" data-caption="Sample Caption" label="list:tree_diameter:diameter"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:tree_diameter:diameter-1"><a href="#list:tree_diameter:diameter-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> depth<span class="op">(</span>Node<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;*</span> root<span class="op">)</span></span>
<span id="list:tree_diameter:diameter-2"><a href="#list:tree_diameter:diameter-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:tree_diameter:diameter-3"><a href="#list:tree_diameter:diameter-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>root<span class="op">)</span></span>
<span id="list:tree_diameter:diameter-4"><a href="#list:tree_diameter:diameter-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:tree_diameter:diameter-5"><a href="#list:tree_diameter:diameter-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:tree_diameter:diameter-6"><a href="#list:tree_diameter:diameter-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>root<span class="op">-&gt;</span>left<span class="op">)</span></span>
<span id="list:tree_diameter:diameter-7"><a href="#list:tree_diameter:diameter-7" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> depth<span class="op">(</span>root<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="list:tree_diameter:diameter-8"><a href="#list:tree_diameter:diameter-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>root<span class="op">-&gt;</span>right<span class="op">)</span></span>
<span id="list:tree_diameter:diameter-9"><a href="#list:tree_diameter:diameter-9" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>ans<span class="op">,</span> <span class="dv">1</span> <span class="op">+</span> depth<span class="op">(</span>root<span class="op">-&gt;</span>right<span class="op">));</span></span>
<span id="list:tree_diameter:diameter-10"><a href="#list:tree_diameter:diameter-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:tree_diameter:diameter-11"><a href="#list:tree_diameter:diameter-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:tree_diameter:diameter-12"><a href="#list:tree_diameter:diameter-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:tree_diameter:diameter-13"><a href="#list:tree_diameter:diameter-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> diameter_of_binary_tree_quadratic<span class="op">(</span>Node<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;*</span> root<span class="op">)</span></span>
<span id="list:tree_diameter:diameter-14"><a href="#list:tree_diameter:diameter-14" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:tree_diameter:diameter-15"><a href="#list:tree_diameter:diameter-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>root<span class="op">)</span></span>
<span id="list:tree_diameter:diameter-16"><a href="#list:tree_diameter:diameter-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:tree_diameter:diameter-17"><a href="#list:tree_diameter:diameter-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> l<span class="op">,</span> r<span class="op">;</span></span>
<span id="list:tree_diameter:diameter-18"><a href="#list:tree_diameter:diameter-18" aria-hidden="true" tabindex="-1"></a>  l <span class="op">=</span> r <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:tree_diameter:diameter-19"><a href="#list:tree_diameter:diameter-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>root<span class="op">-&gt;</span>left<span class="op">)</span></span>
<span id="list:tree_diameter:diameter-20"><a href="#list:tree_diameter:diameter-20" aria-hidden="true" tabindex="-1"></a>    l <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> depth<span class="op">(</span>root<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="list:tree_diameter:diameter-21"><a href="#list:tree_diameter:diameter-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>root<span class="op">-&gt;</span>right<span class="op">)</span></span>
<span id="list:tree_diameter:diameter-22"><a href="#list:tree_diameter:diameter-22" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> depth<span class="op">(</span>root<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="list:tree_diameter:diameter-23"><a href="#list:tree_diameter:diameter-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">std::</span>max<span class="op">(</span></span>
<span id="list:tree_diameter:diameter-24"><a href="#list:tree_diameter:diameter-24" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>max<span class="op">(</span>l <span class="op">+</span> r<span class="op">,</span> diameter_of_binary_tree_quadratic<span class="op">(</span>root<span class="op">-&gt;</span>left<span class="op">)),</span></span>
<span id="list:tree_diameter:diameter-25"><a href="#list:tree_diameter:diameter-25" aria-hidden="true" tabindex="-1"></a>      diameter_of_binary_tree_quadratic<span class="op">(</span>root<span class="op">-&gt;</span>right<span class="op">));</span></span>
<span id="list:tree_diameter:diameter-26"><a href="#list:tree_diameter:diameter-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="tree_diameter:sec:linear">Linear time and space</h3>
<p>The key idea allowing us to go from quadratic to linear time is to realize that in order to calculate the height of a node we also need to calculate the height of all of its descendants. Therefore while we calculate the height of a node, we can save the height for all its descendants so that we do not have to recalculate it over and over. If we inspect the function in Listing <a href="#list:tree_diameter:diameter" data-reference-type="ref" data-reference="list:tree_diameter:diameter">[list:tree_diameter:diameter]</a> we can notice that in order to calculate the height of the current node we also calculate the height of its left and right child! Therefore all it is necessary is to cache the result of height and use the cache in the shown in Listing <a href="#list:tree_diameter:linear" data-reference-type="ref" data-reference="list:tree_diameter:linear">[list:tree_diameter:linear]</a>. This solution has linear complexity because we will the full visit of the tree will only be done once and then all subsequents queries to will be available in the cache.</p>
<div class="sourceCode" id="list:tree_diameter:linear" data-language="c++" data-caption="Sample Caption" label="list:tree_diameter:linear"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:tree_diameter:linear-1"><a href="#list:tree_diameter:linear-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> depth<span class="op">(</span>Node<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;*</span> root<span class="op">)</span></span>
<span id="list:tree_diameter:linear-2"><a href="#list:tree_diameter:linear-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:tree_diameter:linear-3"><a href="#list:tree_diameter:linear-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>root<span class="op">)</span></span>
<span id="list:tree_diameter:linear-4"><a href="#list:tree_diameter:linear-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:tree_diameter:linear-5"><a href="#list:tree_diameter:linear-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:tree_diameter:linear-6"><a href="#list:tree_diameter:linear-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>root<span class="op">-&gt;</span>left<span class="op">)</span></span>
<span id="list:tree_diameter:linear-7"><a href="#list:tree_diameter:linear-7" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> depth<span class="op">(</span>root<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="list:tree_diameter:linear-8"><a href="#list:tree_diameter:linear-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>root<span class="op">-&gt;</span>right<span class="op">)</span></span>
<span id="list:tree_diameter:linear-9"><a href="#list:tree_diameter:linear-9" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>ans<span class="op">,</span> <span class="dv">1</span> <span class="op">+</span> depth<span class="op">(</span>root<span class="op">-&gt;</span>right<span class="op">));</span></span>
<span id="list:tree_diameter:linear-10"><a href="#list:tree_diameter:linear-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:tree_diameter:linear-11"><a href="#list:tree_diameter:linear-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:tree_diameter:linear-12"><a href="#list:tree_diameter:linear-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:tree_diameter:linear-13"><a href="#list:tree_diameter:linear-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> diameter_of_binary_tree_quadratic<span class="op">(</span>Node<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;*</span> root<span class="op">)</span></span>
<span id="list:tree_diameter:linear-14"><a href="#list:tree_diameter:linear-14" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:tree_diameter:linear-15"><a href="#list:tree_diameter:linear-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>root<span class="op">)</span></span>
<span id="list:tree_diameter:linear-16"><a href="#list:tree_diameter:linear-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:tree_diameter:linear-17"><a href="#list:tree_diameter:linear-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> l<span class="op">,</span> r<span class="op">;</span></span>
<span id="list:tree_diameter:linear-18"><a href="#list:tree_diameter:linear-18" aria-hidden="true" tabindex="-1"></a>  l <span class="op">=</span> r <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:tree_diameter:linear-19"><a href="#list:tree_diameter:linear-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>root<span class="op">-&gt;</span>left<span class="op">)</span></span>
<span id="list:tree_diameter:linear-20"><a href="#list:tree_diameter:linear-20" aria-hidden="true" tabindex="-1"></a>    l <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> depth<span class="op">(</span>root<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="list:tree_diameter:linear-21"><a href="#list:tree_diameter:linear-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>root<span class="op">-&gt;</span>right<span class="op">)</span></span>
<span id="list:tree_diameter:linear-22"><a href="#list:tree_diameter:linear-22" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> depth<span class="op">(</span>root<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="list:tree_diameter:linear-23"><a href="#list:tree_diameter:linear-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">std::</span>max<span class="op">(</span></span>
<span id="list:tree_diameter:linear-24"><a href="#list:tree_diameter:linear-24" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>max<span class="op">(</span>l <span class="op">+</span> r<span class="op">,</span> diameter_of_binary_tree_quadratic<span class="op">(</span>root<span class="op">-&gt;</span>left<span class="op">)),</span></span>
<span id="list:tree_diameter:linear-25"><a href="#list:tree_diameter:linear-25" aria-hidden="true" tabindex="-1"></a>      diameter_of_binary_tree_quadratic<span class="op">(</span>root<span class="op">-&gt;</span>right<span class="op">));</span></span>
<span id="list:tree_diameter:linear-26"><a href="#list:tree_diameter:linear-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="ch:square_in_matrix">Largest square in a binary matrix</h1>
<h2 class="unnumbered" id="introduction-29">Introduction</h2>
<p>Imagine you are given a black and white image represented as a boolean matrix of size <span class="math inline">\(N\times M\)</span> where <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span> in the matrix correspond to a black and white pixel respectively. Such kind of image are less uncommon that might be thought at first because they are often the output of digital image processing algorithms such as masking or thresholding. Further analyzing this kind of images often requires to identify homogeneous portions of the image. The problem described in this chapter deals with a simple type of image processing algorithm that involves determining the size of the largest square area of white pixel of a binary bitmap. We will walk through a number of solutions, starting from a naive brute-force one, to a more sophisticated, more complex and definitely more efficine one.</p>
<h2 id="problem-statement-31">Problem statement</h2>
<div class="exercise">
<p>Given a 2D boolean matrix <span class="math inline">\(M\)</span>, return the area of the largest square containing only one cells.</p>
<div class="example">
<p><br />
Given the following matrix the function returns <span class="math inline">\(9\)</span>. The largest square has side lenght of <span class="math inline">\(3\)</span> and the coordinate of the top-left corner are <span class="math inline">\((2,1)\)</span>. Cells belonging to the largest square are highlighted.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">0</th>
<th style="text-align: left;">0</th>
<th style="text-align: left;">1</th>
<th style="text-align: left;">1</th>
<th style="text-align: left;">1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">0</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">0</td>
<td style="text-align: left;"><strong>1</strong></td>
<td style="text-align: left;"><strong>1</strong></td>
<td style="text-align: left;"><strong>1</strong></td>
<td style="text-align: left;">0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">1</td>
<td style="text-align: left;"><strong>1</strong></td>
<td style="text-align: left;"><strong>1</strong></td>
<td style="text-align: left;"><strong>1</strong></td>
<td style="text-align: left;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">1</td>
<td style="text-align: left;"><strong>1</strong></td>
<td style="text-align: left;"><strong>1</strong></td>
<td style="text-align: left;"><strong>1</strong></td>
<td style="text-align: left;">0</td>
</tr>
</tbody>
</table>
</div>
<div class="example">
<p><br />
Given the following matrix the function returns <span class="math inline">\(4\)</span>. The side of the largest square is <span class="math inline">\(2\)</span> and the top-left coordinates are <span class="math inline">\((2,2)\)</span>. Cells belonging to the largest square are highlighted.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">1</th>
<th style="text-align: left;">0</th>
<th style="text-align: left;">1</th>
<th style="text-align: left;">0</th>
<th style="text-align: left;">0</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;"><strong>1</strong></td>
<td style="text-align: left;"><strong>1</strong></td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">1</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;"><strong>1</strong></td>
<td style="text-align: left;"><strong>1</strong></td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">1</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">0</td>
</tr>
</tbody>
</table>
</div>
</div>
<h2 id="square_in_matrix:sec:discussion">Discussion</h2>
<p>In the next section we will analyze a number of possible approaches to this problem. We start by looking at a few brute-force approaches so to then move towards more elaborate and more time and space efficient dynamic programming solutions</p>
<h3 id="brute-force-4">Brute-force</h3>
<h4 id="square_in_matrix:sec:incremental_side">Incremental side</h4>
<p>The first brute-force approach consists of trying to find the largest square made entirely of set (i.e. holding a value of <span class="math inline">\(1\)</span>) cell by visiting each set cell and by treating it as if it was the top-left corner of a square. Because calculating the largest square having that cell as top-left corner is easy the answer to the problem is just the largest value over all the set cells in the matrix. In order to find out what the value of the largest square having cell <span class="math inline">\((x,y)\)</span> as top-left corner we can try build squares of incrementally larger sides around it, starting from side lenght <span class="math inline">\(1\)</span>. At first we try to build a square of size <span class="math inline">\(1\)</span>. If that is possible we try size <span class="math inline">\(2\)</span>, then <span class="math inline">\(3\)</span>, and so on, until it is impossible or we hit the boundaries of the matrix. The answer for the cell <span class="math inline">\((x,y)\)</span> is the last value for a side for which we were able to construct a square. Consider for instance Figure <a href="#fig:square_in_matrix:squa_matrix_incremental" data-reference-type="ref" data-reference="fig:square_in_matrix:squa_matrix_incremental">31.3</a> where in order to find the value of the largest square can be built from cell <span class="math inline">\((0,1)\)</span>, all squares highlighted have to be fully checked. This approach is clearly correct because eventually we find all squares in the matrix, and has a complexity of (assuming, with no loss in generality, <span class="math inline">\(N \leq M\)</span>) <span class="math inline">\(O(N^4M)\)</span>. This is because there are <span class="math inline">\(O(NM)\)</span> possible starting point for a square, <span class="math inline">\(O(N)\)</span> possible values for the side value and checking whether a square is valid costs <span class="math inline">\(O(N^2)\)</span> (all cells in the square needs to be checked). A possible implementation of this idea is shown in the Listing <a href="#list:square_in_matrix:bruteforce1" data-reference-type="ref" data-reference="list:square_in_matrix:bruteforce1">[list:square_in_matrix:bruteforce1]</a>.</p>
<div class="sourceCode" id="list:square_in_matrix:bruteforce1" data-language="c++" data-caption="Brute force soltuion solution to the \textit{square in matrix} problem using incremental side probing." label="list:square_in_matrix:bruteforce1"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:square_in_matrix:bruteforce1-1"><a href="#list:square_in_matrix:bruteforce1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:square_in_matrix:bruteforce1-2"><a href="#list:square_in_matrix:bruteforce1-2" aria-hidden="true" tabindex="-1"></a><span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="dt">int</span> largerSquareFrom<span class="op">(</span></span>
<span id="list:square_in_matrix:bruteforce1-3"><a href="#list:square_in_matrix:bruteforce1-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> matrix<span class="op">,</span></span>
<span id="list:square_in_matrix:bruteforce1-4"><a href="#list:square_in_matrix:bruteforce1-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">size_t</span><span class="op">,</span> <span class="dt">size_t</span><span class="op">&gt;&amp;</span> top_left_corner<span class="op">,</span></span>
<span id="list:square_in_matrix:bruteforce1-5"><a href="#list:square_in_matrix:bruteforce1-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">size_t</span> rows<span class="op">,</span></span>
<span id="list:square_in_matrix:bruteforce1-6"><a href="#list:square_in_matrix:bruteforce1-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">size_t</span> cols<span class="op">)</span></span>
<span id="list:square_in_matrix:bruteforce1-7"><a href="#list:square_in_matrix:bruteforce1-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:square_in_matrix:bruteforce1-8"><a href="#list:square_in_matrix:bruteforce1-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> <span class="op">[</span>x<span class="op">,</span> y<span class="op">]</span> <span class="op">=</span> top_left_corner<span class="op">;</span></span>
<span id="list:square_in_matrix:bruteforce1-9"><a href="#list:square_in_matrix:bruteforce1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:square_in_matrix:bruteforce1-10"><a href="#list:square_in_matrix:bruteforce1-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> k     <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:square_in_matrix:bruteforce1-11"><a href="#list:square_in_matrix:bruteforce1-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> good <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:square_in_matrix:bruteforce1-12"><a href="#list:square_in_matrix:bruteforce1-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>good <span class="op">&amp;&amp;</span> <span class="op">((</span>x <span class="op">+</span> k<span class="op">)</span> <span class="op">&lt;</span> rows<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">((</span>y <span class="op">+</span> k<span class="op">)</span> <span class="op">&lt;</span> cols<span class="op">))</span></span>
<span id="list:square_in_matrix:bruteforce1-13"><a href="#list:square_in_matrix:bruteforce1-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:square_in_matrix:bruteforce1-14"><a href="#list:square_in_matrix:bruteforce1-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> x<span class="op">;</span> good <span class="op">&amp;&amp;</span> i <span class="op">&lt;=</span> x <span class="op">+</span> k<span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:square_in_matrix:bruteforce1-15"><a href="#list:square_in_matrix:bruteforce1-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:square_in_matrix:bruteforce1-16"><a href="#list:square_in_matrix:bruteforce1-16" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> j <span class="op">=</span> y<span class="op">;</span> good <span class="op">&amp;&amp;</span> j <span class="op">&lt;=</span> y <span class="op">+</span> k<span class="op">;</span> j<span class="op">++)</span></span>
<span id="list:square_in_matrix:bruteforce1-17"><a href="#list:square_in_matrix:bruteforce1-17" aria-hidden="true" tabindex="-1"></a>      <span class="op">{</span></span>
<span id="list:square_in_matrix:bruteforce1-18"><a href="#list:square_in_matrix:bruteforce1-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>matrix<span class="op">[</span>i<span class="op">][</span>j<span class="op">])</span></span>
<span id="list:square_in_matrix:bruteforce1-19"><a href="#list:square_in_matrix:bruteforce1-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="list:square_in_matrix:bruteforce1-20"><a href="#list:square_in_matrix:bruteforce1-20" aria-hidden="true" tabindex="-1"></a>          <span class="cf">return</span> k<span class="op">;</span></span>
<span id="list:square_in_matrix:bruteforce1-21"><a href="#list:square_in_matrix:bruteforce1-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="list:square_in_matrix:bruteforce1-22"><a href="#list:square_in_matrix:bruteforce1-22" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="list:square_in_matrix:bruteforce1-23"><a href="#list:square_in_matrix:bruteforce1-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:square_in_matrix:bruteforce1-24"><a href="#list:square_in_matrix:bruteforce1-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span>k<span class="op">;</span></span>
<span id="list:square_in_matrix:bruteforce1-25"><a href="#list:square_in_matrix:bruteforce1-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:square_in_matrix:bruteforce1-26"><a href="#list:square_in_matrix:bruteforce1-26" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> k<span class="op">;</span></span>
<span id="list:square_in_matrix:bruteforce1-27"><a href="#list:square_in_matrix:bruteforce1-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:square_in_matrix:bruteforce1-28"><a href="#list:square_in_matrix:bruteforce1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:square_in_matrix:bruteforce1-29"><a href="#list:square_in_matrix:bruteforce1-29" aria-hidden="true" tabindex="-1"></a><span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="dt">int</span> maximal_square_brute_force_1<span class="op">(</span></span>
<span id="list:square_in_matrix:bruteforce1-30"><a href="#list:square_in_matrix:bruteforce1-30" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> matrix<span class="op">)</span></span>
<span id="list:square_in_matrix:bruteforce1-31"><a href="#list:square_in_matrix:bruteforce1-31" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:square_in_matrix:bruteforce1-32"><a href="#list:square_in_matrix:bruteforce1-32" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>matrix<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;=</span> <span class="dv">0</span> <span class="op">||</span> matrix<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">()</span> <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:square_in_matrix:bruteforce1-33"><a href="#list:square_in_matrix:bruteforce1-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:square_in_matrix:bruteforce1-34"><a href="#list:square_in_matrix:bruteforce1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:square_in_matrix:bruteforce1-35"><a href="#list:square_in_matrix:bruteforce1-35" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> rows <span class="op">=</span> matrix<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:square_in_matrix:bruteforce1-36"><a href="#list:square_in_matrix:bruteforce1-36" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> cols <span class="op">=</span> matrix<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">();</span></span>
<span id="list:square_in_matrix:bruteforce1-37"><a href="#list:square_in_matrix:bruteforce1-37" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans         <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:square_in_matrix:bruteforce1-38"><a href="#list:square_in_matrix:bruteforce1-38" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> rows<span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:square_in_matrix:bruteforce1-39"><a href="#list:square_in_matrix:bruteforce1-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> cols<span class="op">;</span> j<span class="op">++)</span></span>
<span id="list:square_in_matrix:bruteforce1-40"><a href="#list:square_in_matrix:bruteforce1-40" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>matrix<span class="op">[</span>i<span class="op">][</span>j<span class="op">])</span></span>
<span id="list:square_in_matrix:bruteforce1-41"><a href="#list:square_in_matrix:bruteforce1-41" aria-hidden="true" tabindex="-1"></a>        ans <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>ans<span class="op">,</span> largerSquareFrom<span class="op">(</span>matrix<span class="op">,</span> <span class="op">{</span>i<span class="op">,</span> j<span class="op">},</span> rows<span class="op">,</span> cols<span class="op">));</span></span>
<span id="list:square_in_matrix:bruteforce1-42"><a href="#list:square_in_matrix:bruteforce1-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:square_in_matrix:bruteforce1-43"><a href="#list:square_in_matrix:bruteforce1-43" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans <span class="op">*</span> ans<span class="op">;</span></span>
<span id="list:square_in_matrix:bruteforce1-44"><a href="#list:square_in_matrix:bruteforce1-44" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><span id="fig:square_in_matrix:squa_matrix_incremental" label="fig:square_in_matrix:squa_matrix_incremental">[fig:square_in_matrix:squa_matrix_incremental]</span> <img src="/home/dspataro/git/algorithm_articles/sources/square_in_matrix/images/squa_matrix_incremental.jpg" title="fig:" id="fig:square_in_matrix:squa_matrix_incremental" alt="This figure shows the squares that are checked by the brute-force approach for solving the square in matrix problem. From the cell (0,1) we first try to build a square of side 2, and when that is verified to be possible, a square of size 3 is tried. This also succeed and so a square of side 4 is checked, with a negative outcome. Thus 3 is the largest square having cell (0,1) as top left corner. " /></p>
<h4 id="walking-diagonally">Walking diagonally</h4>
<p>The idea presented in the Section <a href="#square_in_matrix:sec:incremental_side" data-reference-type="ref" data-reference="square_in_matrix:sec:incremental_side">31.2.1.1</a> can be significantly improved by noticing that is it really not necessary to check, given a cell <span class="math inline">\((x,y)\)</span> squares of all possible side lenghts having it as top left corner, fully and one after the other. The idea is that we can walk diagonally (towards the bottom-right cell) from a cell <span class="math inline">\((x,y)\)</span> (by incrementing both <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>) and, for every step <span class="math inline">\(i\)</span> we take, we check whether all the elements to the left of <span class="math inline">\((x+i,
y+i)\)</span> and to the right of <span class="math inline">\(y\)</span> are set, and also whether all the cells in the columns above <span class="math inline">\((x+i,
y+i)\)</span> and below the cell <span class="math inline">\((x,y+i)\)</span> are set (see Figure <a href="#fig:square_in_matrix:squa_matrix_diagonal" data-reference-type="ref" data-reference="fig:square_in_matrix:squa_matrix_diagonal">[fig:square_in_matrix:squa_matrix_diagonal]</a>). If both conditions are true it means that we can construct a square of side <span class="math inline">\(i\)</span>. We can then proceed one step further until a <span class="math inline">\(0\)</span> is found among the checked cells on the left or above of <span class="math inline">\((x,y)\)</span>. If we were able to perform <span class="math inline">\(t\)</span> diagonal steps, it means we have found out that the largest square having <span class="math inline">\((x,y)\)</span> as top-left corner has an area of <span class="math inline">\(t^2\)</span>. The final answer is the largest value we calculated this way across all cell that are set. See Figure <a href="#fig:square_in_matrix:squa_matrix_diagonal" data-reference-type="ref" data-reference="fig:square_in_matrix:squa_matrix_diagonal">[fig:square_in_matrix:squa_matrix_diagonal]</a> where the numbers represents the cells that are checked during the corrensponding step. Every highlighted square depicts one of the squares that is checked by the algorithm.</p>
<p>The time complexity of this approach is <span class="math inline">\(O(N^3M)\)</span>, lower than the previous solution. As shown in Section <a href="#square_in_matrix:sec:incremental_side" data-reference-type="ref" data-reference="square_in_matrix:sec:incremental_side">31.2.1.1</a>, there are <span class="math inline">\(O(NM)\)</span> potential top-left corner for a square and for each of them <span class="math inline">\(O(N)\)</span> diagonal steps. Each diagonal steps costs <span class="math inline">\(O(N)\)</span> as in the worst case we must check one entire row and column. Thus the complexity of calculating the value of the largest square having a certain cell as top-left corner is <span class="math inline">\(O(N^2)\)</span> (See Figure <a href="#fig:square_in_matrix:square_matrix_diagonal" data-reference-type="ref" data-reference="fig:square_in_matrix:square_matrix_diagonal">31.2</a> where you can see that no cell is checked twice during this step).</p>
<p>Listing <a href="#list:square_in_matrix_diagonal" data-reference-type="ref" data-reference="list:square_in_matrix_diagonal">[list:square_in_matrix_diagonal]</a> shows a possible implementation of the idea described here. Note how Listings <a href="#list:square_in_matrix_diagonal" data-reference-type="ref" data-reference="list:square_in_matrix_diagonal">[list:square_in_matrix_diagonal]</a> and <a href="#list:square_in_matrix:bruteforce1" data-reference-type="ref" data-reference="list:square_in_matrix:bruteforce1">[list:square_in_matrix:bruteforce1]</a> for both the solutions proposed so far are very similar, with the only difference being in how the size of the largest square constructible from a certain top-left cell is computed.</p>
<p><span id="fig:square_in_matrix:square_matrix_diagonal" label="fig:square_in_matrix:square_matrix_diagonal">[fig:square_in_matrix:square_matrix_diagonal]</span> <img src="/home/dspataro/git/algorithm_articles/sources/square_in_matrix/images/square_matrix_diagonal.jpg" title="fig:" id="fig:square_in_matrix:square_matrix_diagonal" alt="This figure depicts the process of calculating the value of the side of the largest square having as a top-left corner cell (0,1). Each cell is labeled with a number representing the step at which that cell is checked. Note that no cell is checked twice." /></p>
<div class="sourceCode" id="list:square_in_matrix_diagonal" data-language="c++" data-caption="C++ brute force solution using diagonal steps for solving the \textit{square in matrix} problem." label="list:square_in_matrix_diagonal"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:square_in_matrix_diagonal-1"><a href="#list:square_in_matrix_diagonal-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:square_in_matrix_diagonal-2"><a href="#list:square_in_matrix_diagonal-2" aria-hidden="true" tabindex="-1"></a><span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="dt">int</span> largerSquareFrom<span class="op">(</span></span>
<span id="list:square_in_matrix_diagonal-3"><a href="#list:square_in_matrix_diagonal-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> matrix<span class="op">,</span></span>
<span id="list:square_in_matrix_diagonal-4"><a href="#list:square_in_matrix_diagonal-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">size_t</span><span class="op">,</span> <span class="dt">size_t</span><span class="op">&gt;&amp;</span> top_left_corner<span class="op">,</span></span>
<span id="list:square_in_matrix_diagonal-5"><a href="#list:square_in_matrix_diagonal-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">size_t</span> rows<span class="op">,</span></span>
<span id="list:square_in_matrix_diagonal-6"><a href="#list:square_in_matrix_diagonal-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">size_t</span> cols<span class="op">)</span></span>
<span id="list:square_in_matrix_diagonal-7"><a href="#list:square_in_matrix_diagonal-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:square_in_matrix_diagonal-8"><a href="#list:square_in_matrix_diagonal-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> <span class="op">[</span>x<span class="op">,</span> y<span class="op">]</span> <span class="op">=</span> top_left_corner<span class="op">;</span></span>
<span id="list:square_in_matrix_diagonal-9"><a href="#list:square_in_matrix_diagonal-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:square_in_matrix_diagonal-10"><a href="#list:square_in_matrix_diagonal-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> k     <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:square_in_matrix_diagonal-11"><a href="#list:square_in_matrix_diagonal-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> good <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:square_in_matrix_diagonal-12"><a href="#list:square_in_matrix_diagonal-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>good <span class="op">&amp;&amp;</span> <span class="op">((</span>x <span class="op">+</span> k<span class="op">)</span> <span class="op">&lt;</span> rows<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">((</span>y <span class="op">+</span> k<span class="op">)</span> <span class="op">&lt;</span> cols<span class="op">))</span></span>
<span id="list:square_in_matrix_diagonal-13"><a href="#list:square_in_matrix_diagonal-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:square_in_matrix_diagonal-14"><a href="#list:square_in_matrix_diagonal-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> x<span class="op">;</span> good <span class="op">&amp;&amp;</span> i <span class="op">&lt;=</span> x <span class="op">+</span> k<span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:square_in_matrix_diagonal-15"><a href="#list:square_in_matrix_diagonal-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:square_in_matrix_diagonal-16"><a href="#list:square_in_matrix_diagonal-16" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> j <span class="op">=</span> y<span class="op">;</span> good <span class="op">&amp;&amp;</span> j <span class="op">&lt;=</span> y <span class="op">+</span> k<span class="op">;</span> j<span class="op">++)</span></span>
<span id="list:square_in_matrix_diagonal-17"><a href="#list:square_in_matrix_diagonal-17" aria-hidden="true" tabindex="-1"></a>      <span class="op">{</span></span>
<span id="list:square_in_matrix_diagonal-18"><a href="#list:square_in_matrix_diagonal-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>matrix<span class="op">[</span>i<span class="op">][</span>j<span class="op">])</span></span>
<span id="list:square_in_matrix_diagonal-19"><a href="#list:square_in_matrix_diagonal-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="list:square_in_matrix_diagonal-20"><a href="#list:square_in_matrix_diagonal-20" aria-hidden="true" tabindex="-1"></a>          <span class="cf">return</span> k<span class="op">;</span></span>
<span id="list:square_in_matrix_diagonal-21"><a href="#list:square_in_matrix_diagonal-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="list:square_in_matrix_diagonal-22"><a href="#list:square_in_matrix_diagonal-22" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="list:square_in_matrix_diagonal-23"><a href="#list:square_in_matrix_diagonal-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:square_in_matrix_diagonal-24"><a href="#list:square_in_matrix_diagonal-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span>k<span class="op">;</span></span>
<span id="list:square_in_matrix_diagonal-25"><a href="#list:square_in_matrix_diagonal-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:square_in_matrix_diagonal-26"><a href="#list:square_in_matrix_diagonal-26" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> k<span class="op">;</span></span>
<span id="list:square_in_matrix_diagonal-27"><a href="#list:square_in_matrix_diagonal-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:square_in_matrix_diagonal-28"><a href="#list:square_in_matrix_diagonal-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:square_in_matrix_diagonal-29"><a href="#list:square_in_matrix_diagonal-29" aria-hidden="true" tabindex="-1"></a><span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="dt">int</span> maximal_square_brute_force_1<span class="op">(</span></span>
<span id="list:square_in_matrix_diagonal-30"><a href="#list:square_in_matrix_diagonal-30" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> matrix<span class="op">)</span></span>
<span id="list:square_in_matrix_diagonal-31"><a href="#list:square_in_matrix_diagonal-31" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:square_in_matrix_diagonal-32"><a href="#list:square_in_matrix_diagonal-32" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>matrix<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;=</span> <span class="dv">0</span> <span class="op">||</span> matrix<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">()</span> <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:square_in_matrix_diagonal-33"><a href="#list:square_in_matrix_diagonal-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:square_in_matrix_diagonal-34"><a href="#list:square_in_matrix_diagonal-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:square_in_matrix_diagonal-35"><a href="#list:square_in_matrix_diagonal-35" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> rows <span class="op">=</span> matrix<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:square_in_matrix_diagonal-36"><a href="#list:square_in_matrix_diagonal-36" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> cols <span class="op">=</span> matrix<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">();</span></span>
<span id="list:square_in_matrix_diagonal-37"><a href="#list:square_in_matrix_diagonal-37" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans         <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:square_in_matrix_diagonal-38"><a href="#list:square_in_matrix_diagonal-38" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> rows<span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:square_in_matrix_diagonal-39"><a href="#list:square_in_matrix_diagonal-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> cols<span class="op">;</span> j<span class="op">++)</span></span>
<span id="list:square_in_matrix_diagonal-40"><a href="#list:square_in_matrix_diagonal-40" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>matrix<span class="op">[</span>i<span class="op">][</span>j<span class="op">])</span></span>
<span id="list:square_in_matrix_diagonal-41"><a href="#list:square_in_matrix_diagonal-41" aria-hidden="true" tabindex="-1"></a>        ans <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>ans<span class="op">,</span> largerSquareFrom<span class="op">(</span>matrix<span class="op">,</span> <span class="op">{</span>i<span class="op">,</span> j<span class="op">},</span> rows<span class="op">,</span> cols<span class="op">));</span></span>
<span id="list:square_in_matrix_diagonal-42"><a href="#list:square_in_matrix_diagonal-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:square_in_matrix_diagonal-43"><a href="#list:square_in_matrix_diagonal-43" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans <span class="op">*</span> ans<span class="op">;</span></span>
<span id="list:square_in_matrix_diagonal-44"><a href="#list:square_in_matrix_diagonal-44" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="dynamic-programming">Dynamic programming</h3>
<h4 id="sec:square_in_matrix:DP">General Idea</h4>
<p>Turns out that this problem can be solved faster than <span class="math inline">\(O(N^3M)\)</span> time and in this Section we will see how with the help of dynamic programming. The gist of the idea is based on the fact for any square of size <span class="math inline">\(k\times k\)</span> having as bottom-left corner the cell <span class="math inline">\((x,y)\)</span> has a top, top-left and left subsquares of size <span class="math inline">\((k-1)\times (k-1)\)</span>. As an example see Figure <a href="#/home/dspataro/git/algorithm_articles/sources/square_in_matrix/images/square_decomposition" data-reference-type="ref" data-reference="/home/dspataro/git/algorithm_articles/sources/square_in_matrix/images/square_decomposition">[/home/dspataro/git/algorithm_articles/sources/square_in_matrix/images/square_decomposition]</a> which shows a square of size <span class="math inline">\(3\times 3\)</span> decomoposed into <span class="math inline">\(3\)</span>, <span class="math inline">\(2\times 2\)</span> subsquares.</p>
<p><span id="fig:square_in_matrix:squa_matrix_incremental" label="fig:square_in_matrix:squa_matrix_incremental">[fig:square_in_matrix:squa_matrix_incremental]</span> <img src="/home/dspataro/git/algorithm_articles/sources/square_in_matrix/images/square_decomposition.jpg" title="fig:" id="fig:square_in_matrix:squa_matrix_incremental" alt="This figure shows how a square of side 3 can be decomposed into three smaller subsquares of side 2." /></p>
<p>.</p>
<p>Suppose <span class="math inline">\(DP(i,j)\)</span> is a function returning the size of the largest square having the cell <span class="math inline">\((i,j)\)</span> as its bottom-right corner (what discussed in this Section can be easily adapted to that <span class="math inline">\((i,j)\)</span> is the top-left corner). Clearly the values of <span class="math inline">\(DP(0,j) \: : 0 \leq j \leq M\)</span> (all the cells belonging to the first row) and <span class="math inline">\(DP(i,0) \: : 0 \leq i \leq N\)</span> (all the cells of the first column) are the same as the values in the input matrix (either 1 or 0 depending whether on the corresponding value in the input matrix <span class="math inline">\(M\)</span>). This is explained by the fact that a cell in the first row or column lack one or more of the subsquares described above. For instance for a cell in the first row, the top subsquare is missing (as there are no cells above it) and thus is impossible to construct a square having a side larger than <span class="math inline">\(1\)</span> starting from it. For all the other (internal) cells the value of <span class="math inline">\(DP\)</span> can be easily calculated by using the Equation <a href="#eq:square_in_matrix_DPformula" data-reference-type="ref" data-reference="eq:square_in_matrix_DPformula">[eq:square_in_matrix_DPformula]</a>. The formula is basically stating that if we have a cell <span class="math inline">\((i,j)\)</span> set to <span class="math inline">\(1\)</span> then, from it we can construct a larger square whose size depend on the size of the smallest square among the neighboring subsquares. <span class="math display">\[\label{eq:square_in_matrix_DPformula}
	DP(i,j) = min\{DP(i-1,j),DP(i-1,j-1), DP(i,j-1)\} +1\]</span> Figure <a href="#fig:square_in_matrix:square_DP_example" data-reference-type="ref" data-reference="fig:square_in_matrix:square_DP_example">31.4</a> shows the idea above in practice. The value <span class="math inline">\(2\)</span> in <span class="math inline">\(DP(1,3)\)</span>, <span class="math inline">\(DP(1,2)\)</span> and <span class="math inline">\(DP(2,2)\)</span> signifies that there is a square of size <span class="math inline">\(2\times 2\)</span> up to (having that cell as bottom-right corner) those cell in the original matrix. By combining those <span class="math inline">\(3\)</span> squares with the set cell at location <span class="math inline">\((2,3)\)</span> we can build a larger square of size <span class="math inline">\(3\times 3\)</span>. Now consider the value of <span class="math inline">\(DP(3,4)=3\)</span>. The entries for the neighboring cells <span class="math inline">\(DP(3,4)=3\)</span> and <span class="math inline">\(DP(3,4)=3\)</span> implies that a square of side <span class="math inline">\(3\times 3\)</span> exists up to their indices, but the entry at location <span class="math inline">\(DP(2,4)=1\)</span> indicates that up to that cell only a square of size <span class="math inline">\(1\times 1\)</span> exists and this prevents cell <span class="math inline">\((3,4)\)</span> to have a maximum square size larger than <span class="math inline">\(2\)</span> (in other words, making a square of size <span class="math inline">\(3\)</span> from <span class="math inline">\((3,4)\)</span> is limited by the cells above it).</p>
<p><span id="fig:square_in_matrix:square_DP_example" label="fig:square_in_matrix:square_DP_example">[fig:square_in_matrix:square_DP_example]</span> <img src="/home/dspataro/git/algorithm_articles/sources/square_in_matrix/images/square_DP_example.jpg" title="fig:" id="fig:square_in_matrix:square_DP_example" alt="This figure shows the values the of each cell in the original matrix and the corrensponding values for the largest square having that cell as bottom-right corner. Colors are used to highlight the cells that are part of the same square. Note how the cell holding a 3 in the bold frame denote that a square of side 3 can be constructed from it with cells belonging to the top (in red), top-left (purple) and green (right). " /></p>
<p>The function DP in Equation <a href="#eq:square_in_matrix_DPformula" data-reference-type="ref" data-reference="eq:square_in_matrix_DPformula">[eq:square_in_matrix_DPformula]</a> is recursive and when drawing its recursion tree, as shown in Figure <a href="#fig:square_in_matrix:recursiontree" data-reference-type="ref" data-reference="fig:square_in_matrix:recursiontree">31.5</a> (which depicts depicts part of the recursion tree for <span class="math inline">\(DP(3,3)\)</span>), we can easily see that:</p>
<ul>
<li><p>the tree is complete and therefore has an exponential number of nodes.</p></li>
<li><p>there are duplicate nodes.</p></li>
</ul>
<p>The number of possible unique function calls to DP is bounded by the values of its parameters which is far less than exponential. In-fact it is proportional to <span class="math inline">\(N \times M\)</span> (the size of the input matrix) as there are only <span class="math inline">\(N\)</span> possible value for <span class="math inline">\(i\)</span> and <span class="math inline">\(M\)</span> possible values for <span class="math inline">\(j\)</span> in <span class="math inline">\(DP(i,j)\)</span>. Therefore the only way for the recursion tree to have an exponential number of nodes is for some of them to be duplicates. Given this fact we can conclude that the problem exposes both the property of <strong>optimal substructure</strong>, because it can be solved by optimally solve smaller subproblems, and has <strong>overlapping subproblems</strong>. Therefore, we can employ dynamic programming and solve each subproblem only once. In the Sections <a href="#sec:square_in_matrix:top_down" data-reference-type="ref" data-reference="sec:square_in_matrix:top_down">31.2.2.2</a> <a href="#sec:square_in_matrix:bottom-up" data-reference-type="ref" data-reference="sec:square_in_matrix:bottom-up">31.2.2.3</a> we will go throught the details of the two ways of implementing dynamic programming algorithm</p>
<ul>
<li><p>top-down</p></li>
<li><p>bottom-up</p></li>
</ul>
<p><span id="fig:square_in_matrix:recursiontree" label="fig:square_in_matrix:recursiontree">[fig:square_in_matrix:recursiontree]</span> <img src="/home/dspataro/git/algorithm_articles/sources/square_in_matrix/images/recursiontree.jpg" title="fig:" id="fig:square_in_matrix:recursiontree" alt="This figure is an example of recursion tree for the Equation [eq:square_in_matrix_DPformula]. Note that the nodes are duplicates (they are denoted by the same color). " /></p>
<h4 id="sec:square_in_matrix:top_down">Top-Down</h4>
<p>This is probably the easiest way of implementing the dynamic programming solution for this problem described in Section <a href="#sec:square_in_matrix:DP" data-reference-type="ref" data-reference="sec:square_in_matrix:DP">31.2.2.1</a> as we can translate directly the Equation <a href="#eq:square_in_matrix_DPformula" data-reference-type="ref" data-reference="eq:square_in_matrix_DPformula">[eq:square_in_matrix_DPformula]</a> to a recursive function. The i mpolrtant trick allowing us to implement it efficiently is to remember the solution to a subproblem by using a cache (which can easily be a 2D matrix or anything that can allow us to map <span class="math inline">\((i,j)\)</span> to a integer, like an hashmap) as shown in Listing <a href="#list:square_in_matrix_top_down" data-reference-type="ref" data-reference="list:square_in_matrix_top_down">[list:square_in_matrix_top_down]</a>. As you can see, in the implementation showed here we use as a cache a <code>std::unordered_map&lt;Cell, int&gt;</code> (where <code>Cell</code> is just an alias for <code>std::tuple&lt;int,int&gt;</code>) where the functor <code>CellHash</code> is the type we provide to <code>std::unordere_map</code> so it knows how to hash a <code>Cell</code>. The main driver function is the function <code>int maximal_square_in_matrix_top_down(const vector&lt;vector&lt;int&gt;&gt;&amp; matrix)</code> which operates in a similar manner as the other solution seen so far, and calculates the final results by looping over all cells of the matrix and for each of them calculates the largest square having that cell as a bottom-right corner. The most important part of the code is the recursive function which takes as input the original matrix, the cache (by reference because it needs to update it along the way) the for which it operates on and the and of the input matrix (we are passing it along so we avoid retrieving it from the object for every invokation).</p>
<p>This function which has two bases cases:</p>
<ol>
<li><p>when the current cell has value of <span class="math inline">\(0\)</span> no square can have it as bottom right corner, so <span class="math inline">\(0\)</span> is returned.</p></li>
<li><p>when we ask for the maximal square from a cell that is outside the bounds of the original matrix we simply return <span class="math inline">\(0\)</span>. Such cell does not exists, so we cannot have a square having it as a bottom-right corner.</p></li>
<li><p>when the value for a cell has been already calculated and it is thus already in the we avoid the expensive work and simply return the value in the cache. This is how duplicate work is avoided.</p></li>
</ol>
<p>If none of the base-cases conditions are true then, as per the description of the Equation <a href="#eq:square_in_matrix_DPformula" data-reference-type="ref" data-reference="eq:square_in_matrix_DPformula">[eq:square_in_matrix_DPformula]</a>, we calculate the maximal square recursively calling on the cells immediately:</p>
<ul>
<li><p>above:</p></li>
<li><p>to the left:</p></li>
<li><p>to the top-left:</p></li>
</ul>
<p>When the values for all the recursive calls above is finally calculated we save it in the cache before returning it to the caller so it will be available on subsequent calls.</p>
<p>The complexity of this implementation is <span class="math inline">\(O(NM)\)</span> because the function is executed only <span class="math inline">\(O(NM)\)</span> times (you can verify this by printing the after the bases cases in and see that no duplicates appear in the list).</p>
<div class="sourceCode" id="list:square_in_matrix_top_down" data-language="c++" data-caption="C++ dynamic programming top-down solution for solving the
				 \textit{square in matrix} problem." label="list:square_in_matrix_top_down"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:square_in_matrix_top_down-1"><a href="#list:square_in_matrix_top_down-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:square_in_matrix_top_down-2"><a href="#list:square_in_matrix_top_down-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> Cell <span class="op">=</span> <span class="bu">std::</span>tuple<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;;</span></span>
<span id="list:square_in_matrix_top_down-3"><a href="#list:square_in_matrix_top_down-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:square_in_matrix_top_down-4"><a href="#list:square_in_matrix_top_down-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> CellHash <span class="op">:</span> <span class="kw">public</span> <span class="bu">std::</span>unary_function<span class="op">&lt;</span>Cell<span class="op">,</span> <span class="bu">std::</span>size_t<span class="op">&gt;</span></span>
<span id="list:square_in_matrix_top_down-5"><a href="#list:square_in_matrix_top_down-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:square_in_matrix_top_down-6"><a href="#list:square_in_matrix_top_down-6" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>size_t<span class="op"> </span><span class="kw">operator</span><span class="op">()(</span><span class="at">const</span> Cell<span class="op">&amp;</span> k<span class="op">)</span> <span class="at">const</span></span>
<span id="list:square_in_matrix_top_down-7"><a href="#list:square_in_matrix_top_down-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:square_in_matrix_top_down-8"><a href="#list:square_in_matrix_top_down-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>k<span class="op">)</span> <span class="op">^</span> <span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;(</span>k<span class="op">);</span></span>
<span id="list:square_in_matrix_top_down-9"><a href="#list:square_in_matrix_top_down-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:square_in_matrix_top_down-10"><a href="#list:square_in_matrix_top_down-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="list:square_in_matrix_top_down-11"><a href="#list:square_in_matrix_top_down-11" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> Cache <span class="op">=</span> <span class="bu">std::</span>unordered_map<span class="op">&lt;</span>Cell<span class="op">,</span> <span class="dt">int</span><span class="op">,</span> CellHash<span class="op">&gt;;</span></span>
<span id="list:square_in_matrix_top_down-12"><a href="#list:square_in_matrix_top_down-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:square_in_matrix_top_down-13"><a href="#list:square_in_matrix_top_down-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maximal_square_in_matrix_top_down_helper<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> matrix<span class="op">,</span></span>
<span id="list:square_in_matrix_top_down-14"><a href="#list:square_in_matrix_top_down-14" aria-hidden="true" tabindex="-1"></a>                                             Cache<span class="op">&amp;</span> cache<span class="op">,</span></span>
<span id="list:square_in_matrix_top_down-15"><a href="#list:square_in_matrix_top_down-15" aria-hidden="true" tabindex="-1"></a>                                             <span class="at">const</span> Cell cell<span class="op">,</span></span>
<span id="list:square_in_matrix_top_down-16"><a href="#list:square_in_matrix_top_down-16" aria-hidden="true" tabindex="-1"></a>                                             <span class="at">const</span> <span class="dt">size_t</span> rows<span class="op">,</span></span>
<span id="list:square_in_matrix_top_down-17"><a href="#list:square_in_matrix_top_down-17" aria-hidden="true" tabindex="-1"></a>                                             <span class="at">const</span> <span class="dt">size_t</span> cols<span class="op">)</span></span>
<span id="list:square_in_matrix_top_down-18"><a href="#list:square_in_matrix_top_down-18" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:square_in_matrix_top_down-19"><a href="#list:square_in_matrix_top_down-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> <span class="op">[</span>i<span class="op">,</span> j<span class="op">]</span> <span class="op">=</span> cell<span class="op">;</span></span>
<span id="list:square_in_matrix_top_down-20"><a href="#list:square_in_matrix_top_down-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:square_in_matrix_top_down-21"><a href="#list:square_in_matrix_top_down-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">((</span>i <span class="op">&gt;=</span> rows <span class="op">||</span> j <span class="op">&gt;=</span> cols<span class="op">)</span> <span class="op">||</span> <span class="op">(!</span>matrix<span class="op">[</span>i<span class="op">][</span>j<span class="op">]))</span></span>
<span id="list:square_in_matrix_top_down-22"><a href="#list:square_in_matrix_top_down-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:square_in_matrix_top_down-23"><a href="#list:square_in_matrix_top_down-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:square_in_matrix_top_down-24"><a href="#list:square_in_matrix_top_down-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>cache<span class="op">.</span>contains<span class="op">(</span>cell<span class="op">))</span></span>
<span id="list:square_in_matrix_top_down-25"><a href="#list:square_in_matrix_top_down-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cache<span class="op">[</span>cell<span class="op">];</span></span>
<span id="list:square_in_matrix_top_down-26"><a href="#list:square_in_matrix_top_down-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:square_in_matrix_top_down-27"><a href="#list:square_in_matrix_top_down-27" aria-hidden="true" tabindex="-1"></a>  <span class="co">// uncomment the line below to verify no work for the same cell is done</span></span>
<span id="list:square_in_matrix_top_down-28"><a href="#list:square_in_matrix_top_down-28" aria-hidden="true" tabindex="-1"></a>  <span class="co">// twice std::format(&quot;Recursive call for ({0:d},(1:d})\n&quot;, i,j);</span></span>
<span id="list:square_in_matrix_top_down-29"><a href="#list:square_in_matrix_top_down-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:square_in_matrix_top_down-30"><a href="#list:square_in_matrix_top_down-30" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> ans <span class="op">=</span> <span class="bu">std::</span>min<span class="op">({</span>maximal_square_in_matrix_top_down_helper<span class="op">(</span></span>
<span id="list:square_in_matrix_top_down-31"><a href="#list:square_in_matrix_top_down-31" aria-hidden="true" tabindex="-1"></a>                                matrix<span class="op">,</span> cache<span class="op">,</span> Cell<span class="op">{</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> j<span class="op">},</span> rows<span class="op">,</span> cols<span class="op">),</span></span>
<span id="list:square_in_matrix_top_down-32"><a href="#list:square_in_matrix_top_down-32" aria-hidden="true" tabindex="-1"></a>                            maximal_square_in_matrix_top_down_helper<span class="op">(</span></span>
<span id="list:square_in_matrix_top_down-33"><a href="#list:square_in_matrix_top_down-33" aria-hidden="true" tabindex="-1"></a>                                matrix<span class="op">,</span> cache<span class="op">,</span> Cell<span class="op">{</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> j <span class="op">-</span> <span class="dv">1</span><span class="op">},</span> rows<span class="op">,</span> cols<span class="op">),</span></span>
<span id="list:square_in_matrix_top_down-34"><a href="#list:square_in_matrix_top_down-34" aria-hidden="true" tabindex="-1"></a>                            maximal_square_in_matrix_top_down_helper<span class="op">(</span></span>
<span id="list:square_in_matrix_top_down-35"><a href="#list:square_in_matrix_top_down-35" aria-hidden="true" tabindex="-1"></a>                                matrix<span class="op">,</span> cache<span class="op">,</span> Cell<span class="op">{</span>i<span class="op">,</span> j <span class="op">-</span> <span class="dv">1</span><span class="op">},</span> rows<span class="op">,</span> cols<span class="op">)})</span></span>
<span id="list:square_in_matrix_top_down-36"><a href="#list:square_in_matrix_top_down-36" aria-hidden="true" tabindex="-1"></a>                  <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:square_in_matrix_top_down-37"><a href="#list:square_in_matrix_top_down-37" aria-hidden="true" tabindex="-1"></a>  cache<span class="op">[</span>cell<span class="op">]</span> <span class="op">=</span> ans<span class="op">;</span></span>
<span id="list:square_in_matrix_top_down-38"><a href="#list:square_in_matrix_top_down-38" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:square_in_matrix_top_down-39"><a href="#list:square_in_matrix_top_down-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:square_in_matrix_top_down-40"><a href="#list:square_in_matrix_top_down-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:square_in_matrix_top_down-41"><a href="#list:square_in_matrix_top_down-41" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maximal_square_in_matrix_top_down<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> matrix<span class="op">)</span></span>
<span id="list:square_in_matrix_top_down-42"><a href="#list:square_in_matrix_top_down-42" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:square_in_matrix_top_down-43"><a href="#list:square_in_matrix_top_down-43" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>matrix<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;=</span> <span class="dv">0</span> <span class="op">||</span> matrix<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">()</span> <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:square_in_matrix_top_down-44"><a href="#list:square_in_matrix_top_down-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:square_in_matrix_top_down-45"><a href="#list:square_in_matrix_top_down-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:square_in_matrix_top_down-46"><a href="#list:square_in_matrix_top_down-46" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> rows <span class="op">=</span> matrix<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:square_in_matrix_top_down-47"><a href="#list:square_in_matrix_top_down-47" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> cols <span class="op">=</span> matrix<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">();</span></span>
<span id="list:square_in_matrix_top_down-48"><a href="#list:square_in_matrix_top_down-48" aria-hidden="true" tabindex="-1"></a>  Cache cache<span class="op">;</span></span>
<span id="list:square_in_matrix_top_down-49"><a href="#list:square_in_matrix_top_down-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:square_in_matrix_top_down-50"><a href="#list:square_in_matrix_top_down-50" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:square_in_matrix_top_down-51"><a href="#list:square_in_matrix_top_down-51" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> rows<span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:square_in_matrix_top_down-52"><a href="#list:square_in_matrix_top_down-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> cols<span class="op">;</span> j<span class="op">++)</span></span>
<span id="list:square_in_matrix_top_down-53"><a href="#list:square_in_matrix_top_down-53" aria-hidden="true" tabindex="-1"></a>      ans <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>ans<span class="op">,</span></span>
<span id="list:square_in_matrix_top_down-54"><a href="#list:square_in_matrix_top_down-54" aria-hidden="true" tabindex="-1"></a>                     maximal_square_in_matrix_top_down_helper<span class="op">(</span></span>
<span id="list:square_in_matrix_top_down-55"><a href="#list:square_in_matrix_top_down-55" aria-hidden="true" tabindex="-1"></a>                         matrix<span class="op">,</span> cache<span class="op">,</span> Cell<span class="op">{</span>i<span class="op">,</span> j<span class="op">},</span> rows<span class="op">,</span> cols<span class="op">));</span></span>
<span id="list:square_in_matrix_top_down-56"><a href="#list:square_in_matrix_top_down-56" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans <span class="op">*</span> ans<span class="op">;</span></span>
<span id="list:square_in_matrix_top_down-57"><a href="#list:square_in_matrix_top_down-57" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="sec:square_in_matrix:bottom-up">Bottom-up</h4>
<p>The other way of implmeneting a dynamic programming algorithm is by using a bottom-up approach. The idea is in this case to start to filling the cache with values we know upfront without doing any work. We have already mentioned some of those values namely the ones beloning to cells of the first row and columns. Once those values are in the cache we can then proceed calculating the values for the second row. According to the Equation <a href="#eq:square_in_matrix_DPformula" data-reference-type="ref" data-reference="eq:square_in_matrix_DPformula">[eq:square_in_matrix_DPformula]</a> in order to calculate <span class="math inline">\(DP(1,1)\)</span>, the values for <span class="math inline">\(DP(0,1)\)</span>, <span class="math inline">\(DP(1,0)\)</span> and <span class="math inline">\(DP(0,0)\)</span> are needed. Because they all belong to either the first or second row, and because values for cells in those locations are already in the cache we can calculate <span class="math inline">\(DP(1,1)\)</span>. When <span class="math inline">\(DP(1,1)\)</span> is in the cache, then we can calculate also <span class="math inline">\(DP(1,2)\)</span> and so on for all the cells in the row. The same reasoning can be applied to the rest of the rows. Eventually the cache will be filled completely and thus the answer is just the largest value in the cache.</p>
<p>Listing <a href="#list:square_in_matrix_bottom_up" data-reference-type="ref" data-reference="list:square_in_matrix_bottom_up">[list:square_in_matrix_bottom_up]</a> shows a possible implementation of such idea.</p>
<div class="sourceCode" id="list:square_in_matrix_bottom_up" data-language="c++" data-caption="C++ dynamic programming bottom-up solution for solving the
				 \textit{square in matrix} problem." label="list:square_in_matrix_bottom_up"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:square_in_matrix_bottom_up-1"><a href="#list:square_in_matrix_bottom_up-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maximal_square_in_matrix_bottom_up<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> matrix<span class="op">)</span></span>
<span id="list:square_in_matrix_bottom_up-2"><a href="#list:square_in_matrix_bottom_up-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:square_in_matrix_bottom_up-3"><a href="#list:square_in_matrix_bottom_up-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>matrix<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;=</span> <span class="dv">0</span> <span class="op">||</span> matrix<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">()</span> <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:square_in_matrix_bottom_up-4"><a href="#list:square_in_matrix_bottom_up-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:square_in_matrix_bottom_up-5"><a href="#list:square_in_matrix_bottom_up-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:square_in_matrix_bottom_up-6"><a href="#list:square_in_matrix_bottom_up-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> rows <span class="op">=</span> matrix<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:square_in_matrix_bottom_up-7"><a href="#list:square_in_matrix_bottom_up-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> cols <span class="op">=</span> matrix<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">();</span></span>
<span id="list:square_in_matrix_bottom_up-8"><a href="#list:square_in_matrix_bottom_up-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// first row and first column have the same values as in the original</span></span>
<span id="list:square_in_matrix_bottom_up-9"><a href="#list:square_in_matrix_bottom_up-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// input matrix</span></span>
<span id="list:square_in_matrix_bottom_up-10"><a href="#list:square_in_matrix_bottom_up-10" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> cache<span class="op">(</span>matrix<span class="op">);</span></span>
<span id="list:square_in_matrix_bottom_up-11"><a href="#list:square_in_matrix_bottom_up-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:square_in_matrix_bottom_up-12"><a href="#list:square_in_matrix_bottom_up-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// is there a 1 in the first row?</span></span>
<span id="list:square_in_matrix_bottom_up-13"><a href="#list:square_in_matrix_bottom_up-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span></span>
<span id="list:square_in_matrix_bottom_up-14"><a href="#list:square_in_matrix_bottom_up-14" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>find<span class="op">(</span>begin<span class="op">(</span>matrix<span class="op">[</span><span class="dv">0</span><span class="op">]),</span> end<span class="op">(</span>matrix<span class="op">[</span><span class="dv">0</span><span class="op">]),</span> <span class="dv">1</span><span class="op">)</span> <span class="op">!=</span> end<span class="op">(</span>matrix<span class="op">[</span><span class="dv">0</span><span class="op">])</span> <span class="op">?</span> <span class="dv">1</span> <span class="op">:</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:square_in_matrix_bottom_up-15"><a href="#list:square_in_matrix_bottom_up-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:square_in_matrix_bottom_up-16"><a href="#list:square_in_matrix_bottom_up-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">// is there a 1 in the first column?</span></span>
<span id="list:square_in_matrix_bottom_up-17"><a href="#list:square_in_matrix_bottom_up-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> rows<span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:square_in_matrix_bottom_up-18"><a href="#list:square_in_matrix_bottom_up-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:square_in_matrix_bottom_up-19"><a href="#list:square_in_matrix_bottom_up-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>matrix<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">])</span></span>
<span id="list:square_in_matrix_bottom_up-20"><a href="#list:square_in_matrix_bottom_up-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:square_in_matrix_bottom_up-21"><a href="#list:square_in_matrix_bottom_up-21" aria-hidden="true" tabindex="-1"></a>      ans <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:square_in_matrix_bottom_up-22"><a href="#list:square_in_matrix_bottom_up-22" aria-hidden="true" tabindex="-1"></a>      <span class="cf">break</span><span class="op">;</span></span>
<span id="list:square_in_matrix_bottom_up-23"><a href="#list:square_in_matrix_bottom_up-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:square_in_matrix_bottom_up-24"><a href="#list:square_in_matrix_bottom_up-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:square_in_matrix_bottom_up-25"><a href="#list:square_in_matrix_bottom_up-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:square_in_matrix_bottom_up-26"><a href="#list:square_in_matrix_bottom_up-26" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> rows<span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:square_in_matrix_bottom_up-27"><a href="#list:square_in_matrix_bottom_up-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:square_in_matrix_bottom_up-28"><a href="#list:square_in_matrix_bottom_up-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> cols<span class="op">;</span> j<span class="op">++)</span></span>
<span id="list:square_in_matrix_bottom_up-29"><a href="#list:square_in_matrix_bottom_up-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:square_in_matrix_bottom_up-30"><a href="#list:square_in_matrix_bottom_up-30" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>matrix<span class="op">[</span>i<span class="op">][</span>j<span class="op">])</span></span>
<span id="list:square_in_matrix_bottom_up-31"><a href="#list:square_in_matrix_bottom_up-31" aria-hidden="true" tabindex="-1"></a>      <span class="op">{</span></span>
<span id="list:square_in_matrix_bottom_up-32"><a href="#list:square_in_matrix_bottom_up-32" aria-hidden="true" tabindex="-1"></a>        cache<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span></span>
<span id="list:square_in_matrix_bottom_up-33"><a href="#list:square_in_matrix_bottom_up-33" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>min<span class="op">({</span>cache<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> cache<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> cache<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]})</span></span>
<span id="list:square_in_matrix_bottom_up-34"><a href="#list:square_in_matrix_bottom_up-34" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:square_in_matrix_bottom_up-35"><a href="#list:square_in_matrix_bottom_up-35" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="list:square_in_matrix_bottom_up-36"><a href="#list:square_in_matrix_bottom_up-36" aria-hidden="true" tabindex="-1"></a>      ans <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>ans<span class="op">,</span> cache<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="list:square_in_matrix_bottom_up-37"><a href="#list:square_in_matrix_bottom_up-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:square_in_matrix_bottom_up-38"><a href="#list:square_in_matrix_bottom_up-38" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:square_in_matrix_bottom_up-39"><a href="#list:square_in_matrix_bottom_up-39" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans <span class="op">*</span> ans<span class="op">;</span></span>
<span id="list:square_in_matrix_bottom_up-40"><a href="#list:square_in_matrix_bottom_up-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This implementation initializes the variable with <span class="math inline">\(1\)</span> or <span class="math inline">\(0\)</span> depending if there is a cell set in the first row or column or not. The rest of the code loops from the the rest of the cells starting from cell <span class="math inline">\((1,1)\)</span> and avoiding the first row and column because as stated before the values for these cells are known upfront. For each of these cells the final value is calculated by using Equation <a href="#eq:square_in_matrix_DPformula" data-reference-type="ref" data-reference="eq:square_in_matrix_DPformula">[eq:square_in_matrix_DPformula]</a>.</p>
<p>The complexity is of the code in Linst <a href="#list:square_in_matrix_bottom_up" data-reference-type="ref" data-reference="list:square_in_matrix_bottom_up">[list:square_in_matrix_bottom_up]</a> is clearly <span class="math inline">\(O(NM)\)</span> (probably more obvious in here than in the top-down solution).</p>
<h2 id="conclusion-2">Conclusion</h2>
<h1 id="ch:sudoku">Sudoku</h1>
<h2 class="unnumbered" id="introduction-30">Introduction</h2>
<p>The game of <em>Sudoku</em><a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a> has gained extreme popularity during the last 20 years or so, at the level there are countless websites and magazines dedicated to it. It is a mathematical-logic-based number-placement puzzle game where the objective is to fill a nine-by-nine (9x9) grid (subdivided in <span class="math inline">\(3\times3\)</span> subgrids) with digits so that each:</p>
<ul>
<li><p><strong>row</strong>,</p></li>
<li><p><strong>column</strong>,</p></li>
<li><p><span class="math inline">\(3\times3\)</span> <strong>subsquare section</strong></p></li>
</ul>
<p>contain number between <span class="math inline">\(1\)</span> and <span class="math inline">\(9\)</span>, with the constraint that each number can appear only once in each section. The puzzle is given as a incomplete grid where only some of the cells are filled.</p>
<p>This chapter describes how to write a very basic and simple sudoku solver based on backtracking that can be implemented fast enough during a programming interview. Having played this puzzle before might help during the interview but it is not fundamental because the rules are easy enough to understand in the span of a couple of minutes.</p>
<h2 id="problem-statement-32">Problem statement</h2>
<div class="exercise">
<p>Write a function that takes as an input a sudoku grid and returns its solution. The input sudoku grid is given as a string of lenght <span class="math inline">\(81\)</span> representing the grid in a row-major manner<a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a> where empty cells are represented by the character ’0’.</p>
</div>
<h2 id="clarification-questions-26">Clarification Questions</h2>
<div class="QandA">
<p>Is the input string guaranteed to only contains numeric charaters and be the right size?</p>
<div class="answered">
<p><em>Yes the string is guaranteed to be encoding a valid sudoku</em></p>
</div>
</div>
<h2 id="sudoku:sec:discussion">Discussion</h2>
<p>The general problem of solving a sudoku (of size <span class="math inline">\(n\times m\)</span>) is NP-complete<a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a> and thus an efficient (polynomial-time) solution is not yet known. The naive bruteforce algorithm would have to try each available number across all empty cells and therefore would have a runtime complexity of <span class="math inline">\(O(N^{(N^2)})\)</span>, where <span class="math inline">\(N\)</span> is size of the Sudoku puzzle. For a classic <span class="math inline">\(9 \times 9\)</span> puzzle <span class="math inline">\(N = 9\)</span> and the number of operations required would be at most <span class="math inline">\(2
\times 10^{77}\)</span> operations to find a solution which would make this approach pretty-much impractical.</p>
<p>In practice the number of operations vary hugely according to the difficulty of the puzzle itself and especially according to the number of given clues which in turn limit the options for each empty cell. Clues reduces the number of possible states the grid can be and in which the rules of the puzzle are not violated. The more clues the more are those invalid states. An algorithm can take advantage of that and avoid those states. For example, a <span class="math inline">\(17\)</span>-clue puzzle with diagonal symmetry is one of the hardest to solve due to the large number of candidates and branches<a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a>.</p>
<h3 id="sudoku:sec:bruteforce">Backtacking</h3>
<p>Backtracking is therefore a good approach to use to solve this problem considering that the problem has the following characteristics:</p>
<ul>
<li><p>potentially large puzzle-states search space</p></li>
<li><p>many <em>invalid</em> states we can skip visiting</p></li>
</ul>
<p>For a more detailed explanation of backtracking see <span class="citation" data-cites="backtracking"></span>.</p>
<p>In a nutshell the solution proposed in this section works by visiting the empty cells starting from the first one from the lest, filling it in with a feasible digit i.e. a digit that does not take the grid to an invalid state, and proceed to do the same thing for every other cell left empty. If at any point for an empty cell there is no digit it can contain than a backtracking step occurs. The choice for the previous cell is then changed and the whole process repeats until either all the empty cells are filled (in this case we have a valid solution) or there is no more options for the very first cell (in this case the puzzle has no solution and it is invalid). A backtracking solution would solve a puzzle by placing the digit ’1’ in the first empty cell and checking if it is allowed to be there i.e. no rules are broken. If there are no violations (checking row, column, and box constraints) then the algorithm advances to the next cell and places a ’1’ in the next empty cell. When checking for violations, if it is discovered that the "1" is not allowed, the value is advanced to "2". If a cell is discovered where none of the 9 digits is allowed, then the algorithm leaves that cell blank and moves <strong>back</strong> to the previous cell. The value in that cell is then incremented by one and the whole process repeats. Clearly, this method will eventually find a solution if the puzzle is valid because all possible valid state for the grid will be visited.</p>
<p>Listing <a href="#list:sudoku" data-reference-type="ref" data-reference="list:sudoku">[list:sudoku]</a> shows a possible implementation of the backttracking idea described above. The public interfact of the SudokuSolver class consists only of a constructor <code>SudokuSolver::SudokuSolver(std :: string</code> taking a a sole input a <code>std::string</code>, the problem input, and the <code>std::strings SudokuSolver::solve()</code> function that is responsible for returning the solution. The constructor is responsible for analyzing the input and storing in a vector (<code>std :: vector &lt; int &gt;blankCells</code>) the indices of all the empty cells i.e. the cells the backtracking function is going to try to fill.</p>
<p>The core implementation function is the <code>bool solve\_helper(const int i)</code> recursive function that takes an input an integer <code>cell</code> representing the index of an empty cell in the input string. The base case for this function is when <code>i &gt;= blankCells . size ()</code> i.e. there is no more empty cell to be filled. The rest of the function is pretty straightforward because it only consists of a loop trying all possible numbers for that cell from ’1’ to ’9’. Whether or not a number can be inserted in a cell is asserted by the <code>canInsert(char x, int pos)</code> function that is responsible for deciding whether a character <code>x</code> can be places at a certain cell <code>pos</code>. THe check is performed by checking whether any of the rules described above would be broken by having <code>x</code> at cell <code>pos</code>. If no rules are broken then the function <code>solve_helper</code> calls itself recursively on the <strong>next</strong> empty cells i.e. <code>cell+1</code>. If none of the values tried in the loop yield a valid solution then the function returns false (no value can be inserted at this location without violating one or more rules).</p>
<p>Because the input is a linear representation of a grid, which is a 2D structure, and the constraints of the puzzle are for 2D portion of the grid itself, the code is further complicated by calculation that are necessary for the functions <code>canInsertInRow</code>, <code>canInsertInCol</code> and <code>canInsertInSquare</code> to be able to map the cells belonging to the same row, column or subsquare to the input 1D input string. The functions <code>getRow</code>, <code>getCol</code>, <code>getSubsquare</code> are used to, given a index in the 1D input string, retrieve the corrensponding row, column and subsquare index in the 2D grid. These functions are used in the <code>canInsertInRow</code>, <code>canInsertInCol</code> and <code>canInsertInSquare</code> functions that are responsible to verify that the constraints on the row, column and subsquare, respectively, are not violated when we try to insert a certain value in a cell. In order to do that they need to be able to able to calculate the indices of all cells belonging to the same row, columns and subsquare. Specifically:</p>
<ul>
<li><p>the <code>canInsertInRow</code> function checks all the cells belonging to the same row. Given a row <span class="math inline">\(r\)</span> then all <span class="math inline">\(9\)</span> cells belonging to it have indices in the range <span class="math inline">\([9r,9(r+1)]\)</span>(See Figure <a href="#fig:sudoku:getRow" data-reference-type="ref" data-reference="fig:sudoku:getRow">[fig:sudoku:getRow]</a>).</p></li>
<li><p>Things complicates a bit when it comes to checking cells in the same column, in the function <code>canInsertInRow</code>. The column <span class="math inline">\(c\)</span> to which a cell in the input string with index <span class="math inline">\(x\)</span> belongs can be found by using the following formula: <span class="math inline">\(c = x \Mod{9}\)</span>. This means that the very first cells in the input belonging to column <span class="math inline">\(c\)</span> is located at index <span class="math inline">\(c\)</span> and all subsequents cells of the column are distanced <span class="math inline">\(9\)</span> cells from each other. More formally, the index for the the <span class="math inline">\(k^{th}\)</span> cell of the column, in the input string is: <span class="math inline">\(P(k,c) = 9k+c\)</span>.</p></li>
<li><p>The hardest check is possibly the one that involves subsquares in the <code>canInsertInSquare(char x, int s)</code> function because in order to check whether it is possible to insert the value <span class="math inline">\(x\)</span> in the subsquare <span class="math inline">\(s\)</span> it has to compare <span class="math inline">\(x\)</span> to all the other non-empty cells of the same subsquare. This goal is accomplished in two steps:</p>
<ol>
<li><p>First, the index of the <span class="math inline">\(F(s)\)</span> top left corner of the subsquare <span class="math inline">\(s\)</span> is calculated by using the following formula: <span class="math inline">\(F(s) = (27 \floor{\frac{s}{3}}) + (3\times (s \mod{3}))\)</span>. In order to understand the formula, we need first to note that there subsquares are organized into <span class="math inline">\(3\)</span> rows each of size <span class="math inline">\(3\)</span> (for a total of 9 subsquares, see Figure <a href="#fig:sudoku:" data-reference-type="ref" data-reference="fig:sudoku:">[fig:sudoku:]</a>). Clearly each subsquare contains <span class="math inline">\(9\)</span> cells, and thus, a full row of subsquares contains <span class="math inline">\(3\times9 =27\)</span> cells. <span class="math inline">\(\frac{s}{3}\)</span> is a value representing how many full subsquares row comes before <span class="math inline">\(s\)</span>. Clearly we can skip all the cells belonging to those subsquare, because all cells in them come before <span class="math inline">\(F(s)\)</span>. The value <span class="math inline">\((27 \floor{\frac{s}{3}})\)</span> is thus an index pointing to a cell at the beginning of the row where <span class="math inline">\(F(s)\)</span> is located. All we need to do now is to advance to the correct subsquare in the row and we can do that by looking at the position of the subsquare <strong>in the row</strong> which clearly is <span class="math inline">\((s \Mod{3})\)</span>; <span class="math inline">\(s\)</span> can either be either on the left (<span class="math inline">\((s \Mod{3})=0\)</span>), center (<span class="math inline">\((s \Mod{3})=1\)</span>) or on the right side of the row (<span class="math inline">\((s \Mod{3})=2\)</span>). Because each subsequare has width of <span class="math inline">\(3\)</span> we can jump to the correct location by using <span class="math inline">\(3\times  (s \Mod{3}))\)</span>.</p></li>
<li><p>once <span class="math inline">\(F(s)\)</span> is known then is it easy to retrieve the indices of all the cells in the subsquare considering that by using the ideas adopted for <code>canInsertInRow</code> and <code>canInsertInCol</code>.</p></li>
</ol></li>
</ul>
<div class="sourceCode" id="list:sudoku" data-language="c++" data-caption="Backtracking solution to the Sudoku problem." label="list:sudoku"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:sudoku-1"><a href="#list:sudoku-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;optional&gt;</span></span>
<span id="list:sudoku-2"><a href="#list:sudoku-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SudokuSolver</span>
<span id="list:sudoku-3"><a href="#list:sudoku-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:sudoku-4"><a href="#list:sudoku-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="list:sudoku-5"><a href="#list:sudoku-5" aria-hidden="true" tabindex="-1"></a>  SudokuSolver<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span>_problem<span class="op">)</span> <span class="op">:</span> problem<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>_problem<span class="op">))</span></span>
<span id="list:sudoku-6"><a href="#list:sudoku-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:sudoku-7"><a href="#list:sudoku-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>problem<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">81</span><span class="op">);</span></span>
<span id="list:sudoku-8"><a href="#list:sudoku-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:sudoku-9"><a href="#list:sudoku-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> solve<span class="op">()</span></span>
<span id="list:sudoku-10"><a href="#list:sudoku-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:sudoku-11"><a href="#list:sudoku-11" aria-hidden="true" tabindex="-1"></a>    printSudoku<span class="op">();</span></span>
<span id="list:sudoku-12"><a href="#list:sudoku-12" aria-hidden="true" tabindex="-1"></a>    getBlankCells<span class="op">();</span></span>
<span id="list:sudoku-13"><a href="#list:sudoku-13" aria-hidden="true" tabindex="-1"></a>    solve_helper<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="list:sudoku-14"><a href="#list:sudoku-14" aria-hidden="true" tabindex="-1"></a>    printSudoku<span class="op">();</span></span>
<span id="list:sudoku-15"><a href="#list:sudoku-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> problem<span class="op">;</span></span>
<span id="list:sudoku-16"><a href="#list:sudoku-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:sudoku-17"><a href="#list:sudoku-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:sudoku-18"><a href="#list:sudoku-18" aria-hidden="true" tabindex="-1"></a> <span class="kw">private</span><span class="op">:</span></span>
<span id="list:sudoku-19"><a href="#list:sudoku-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> getBlankCells<span class="op">()</span></span>
<span id="list:sudoku-20"><a href="#list:sudoku-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:sudoku-21"><a href="#list:sudoku-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> problem<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span></span>
<span id="list:sudoku-22"><a href="#list:sudoku-22" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>problem<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> <span class="ch">&#39;0&#39;</span><span class="op">)</span></span>
<span id="list:sudoku-23"><a href="#list:sudoku-23" aria-hidden="true" tabindex="-1"></a>        blankCells<span class="op">.</span>push_back<span class="op">(</span>i<span class="op">);</span></span>
<span id="list:sudoku-24"><a href="#list:sudoku-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:sudoku-25"><a href="#list:sudoku-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:sudoku-26"><a href="#list:sudoku-26" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span> intToChar<span class="op">(</span><span class="at">const</span> <span class="dt">char</span> num<span class="op">)</span></span>
<span id="list:sudoku-27"><a href="#list:sudoku-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:sudoku-28"><a href="#list:sudoku-28" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>num <span class="op">&gt;=</span> <span class="ch">&#39;0&#39;</span> <span class="op">&amp;&amp;</span> num <span class="op">&lt;=</span> <span class="ch">&#39;9&#39;</span><span class="op">);</span></span>
<span id="list:sudoku-29"><a href="#list:sudoku-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> num<span class="op">;</span></span>
<span id="list:sudoku-30"><a href="#list:sudoku-30" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:sudoku-31"><a href="#list:sudoku-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:sudoku-32"><a href="#list:sudoku-32" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> canInsertInRow<span class="op">(</span><span class="at">const</span> <span class="kw">auto</span> x<span class="op">,</span> <span class="at">const</span> <span class="kw">auto</span> row<span class="op">)</span></span>
<span id="list:sudoku-33"><a href="#list:sudoku-33" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:sudoku-34"><a href="#list:sudoku-34" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>row <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> row <span class="op">&lt;</span> <span class="dv">9</span><span class="op">);</span></span>
<span id="list:sudoku-35"><a href="#list:sudoku-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> start <span class="op">=</span> <span class="bu">std::</span>begin<span class="op">(</span>problem<span class="op">)</span> <span class="op">+</span> <span class="dv">9</span> <span class="op">*</span> row<span class="op">;</span></span>
<span id="list:sudoku-36"><a href="#list:sudoku-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> end   <span class="op">=</span> start <span class="op">+</span> <span class="dv">9</span><span class="op">;</span></span>
<span id="list:sudoku-37"><a href="#list:sudoku-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> find<span class="op">(</span>start<span class="op">,</span> end<span class="op">,</span> intToChar<span class="op">(</span>x<span class="op">))</span> <span class="op">==</span> end<span class="op">;</span></span>
<span id="list:sudoku-38"><a href="#list:sudoku-38" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:sudoku-39"><a href="#list:sudoku-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:sudoku-40"><a href="#list:sudoku-40" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> canInsertInCol<span class="op">(</span><span class="at">const</span> <span class="kw">auto</span> x<span class="op">,</span> <span class="at">const</span> <span class="kw">auto</span> column<span class="op">)</span></span>
<span id="list:sudoku-41"><a href="#list:sudoku-41" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:sudoku-42"><a href="#list:sudoku-42" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> curr <span class="op">=</span> column<span class="op">;</span></span>
<span id="list:sudoku-43"><a href="#list:sudoku-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>curr <span class="op">&lt;</span> <span class="dv">81</span><span class="op">)</span></span>
<span id="list:sudoku-44"><a href="#list:sudoku-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:sudoku-45"><a href="#list:sudoku-45" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>problem<span class="op">[</span>curr<span class="op">]</span> <span class="op">==</span> intToChar<span class="op">(</span>x<span class="op">))</span></span>
<span id="list:sudoku-46"><a href="#list:sudoku-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:sudoku-47"><a href="#list:sudoku-47" aria-hidden="true" tabindex="-1"></a>      curr <span class="op">+=</span> <span class="dv">9</span><span class="op">;</span></span>
<span id="list:sudoku-48"><a href="#list:sudoku-48" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:sudoku-49"><a href="#list:sudoku-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:sudoku-50"><a href="#list:sudoku-50" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:sudoku-51"><a href="#list:sudoku-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:sudoku-52"><a href="#list:sudoku-52" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> canInsertInSquare<span class="op">(</span><span class="at">const</span> <span class="kw">auto</span> x<span class="op">,</span> <span class="at">const</span> <span class="kw">auto</span> square<span class="op">)</span></span>
<span id="list:sudoku-53"><a href="#list:sudoku-53" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:sudoku-54"><a href="#list:sudoku-54" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> start_cell <span class="op">=</span> <span class="op">(</span><span class="dv">3</span> <span class="op">*</span> <span class="dv">9</span> <span class="op">*</span> <span class="op">(</span>square <span class="op">/</span> <span class="dv">3</span><span class="op">))</span> <span class="op">+</span> <span class="op">(</span><span class="dv">3</span> <span class="op">*</span> <span class="op">(</span>square <span class="op">%</span> <span class="dv">3</span><span class="op">));</span></span>
<span id="list:sudoku-55"><a href="#list:sudoku-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:sudoku-56"><a href="#list:sudoku-56" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:sudoku-57"><a href="#list:sudoku-57" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="dt">bool</span> found <span class="op">=</span> <span class="op">(</span>problem<span class="op">[</span>start_cell <span class="op">+</span> i <span class="op">*</span> <span class="dv">9</span><span class="op">]</span> <span class="op">==</span> intToChar<span class="op">(</span>x<span class="op">))</span></span>
<span id="list:sudoku-58"><a href="#list:sudoku-58" aria-hidden="true" tabindex="-1"></a>                         <span class="op">||</span> <span class="op">(</span>problem<span class="op">[</span>start_cell <span class="op">+</span> i <span class="op">*</span> <span class="dv">9</span> <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> intToChar<span class="op">(</span>x<span class="op">))</span></span>
<span id="list:sudoku-59"><a href="#list:sudoku-59" aria-hidden="true" tabindex="-1"></a>                         <span class="op">||</span> <span class="op">(</span>problem<span class="op">[</span>start_cell <span class="op">+</span> i <span class="op">*</span> <span class="dv">9</span> <span class="op">+</span> <span class="dv">2</span><span class="op">]</span> <span class="op">==</span> intToChar<span class="op">(</span>x<span class="op">));</span></span>
<span id="list:sudoku-60"><a href="#list:sudoku-60" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>found<span class="op">)</span></span>
<span id="list:sudoku-61"><a href="#list:sudoku-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:sudoku-62"><a href="#list:sudoku-62" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:sudoku-63"><a href="#list:sudoku-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:sudoku-64"><a href="#list:sudoku-64" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:sudoku-65"><a href="#list:sudoku-65" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> canInsert<span class="op">(</span><span class="at">const</span> <span class="kw">auto</span> x<span class="op">,</span> <span class="at">const</span> <span class="kw">auto</span> pos<span class="op">)</span></span>
<span id="list:sudoku-66"><a href="#list:sudoku-66" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:sudoku-67"><a href="#list:sudoku-67" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> row    <span class="op">=</span> pos <span class="op">/</span> <span class="dv">9</span><span class="op">;</span></span>
<span id="list:sudoku-68"><a href="#list:sudoku-68" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> col    <span class="op">=</span> pos <span class="op">%</span> <span class="dv">9</span><span class="op">;</span></span>
<span id="list:sudoku-69"><a href="#list:sudoku-69" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> square <span class="op">=</span> <span class="op">(</span>row <span class="op">/</span> <span class="dv">3</span><span class="op">)</span> <span class="op">*</span> <span class="dv">3</span> <span class="op">+</span> <span class="op">(</span>col <span class="op">/</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="list:sudoku-70"><a href="#list:sudoku-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> canInsertInRow<span class="op">(</span>x<span class="op">,</span> row<span class="op">)</span> <span class="op">&amp;&amp;</span> canInsertInCol<span class="op">(</span>x<span class="op">,</span> col<span class="op">)</span></span>
<span id="list:sudoku-71"><a href="#list:sudoku-71" aria-hidden="true" tabindex="-1"></a>           <span class="op">&amp;&amp;</span> canInsertInSquare<span class="op">(</span>x<span class="op">,</span> square<span class="op">);</span></span>
<span id="list:sudoku-72"><a href="#list:sudoku-72" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:sudoku-73"><a href="#list:sudoku-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:sudoku-74"><a href="#list:sudoku-74" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> printSudoku<span class="op">()</span></span>
<span id="list:sudoku-75"><a href="#list:sudoku-75" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:sudoku-76"><a href="#list:sudoku-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">9</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:sudoku-77"><a href="#list:sudoku-77" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:sudoku-78"><a href="#list:sudoku-78" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">9</span><span class="op">;</span> j<span class="op">++)</span></span>
<span id="list:sudoku-79"><a href="#list:sudoku-79" aria-hidden="true" tabindex="-1"></a>      <span class="op">{</span></span>
<span id="list:sudoku-80"><a href="#list:sudoku-80" aria-hidden="true" tabindex="-1"></a>        cout <span class="op">&lt;&lt;</span> problem<span class="op">[</span>i <span class="op">*</span> <span class="dv">9</span> <span class="op">+</span> j<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="st">&quot; &quot;</span><span class="op">;</span></span>
<span id="list:sudoku-81"><a href="#list:sudoku-81" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="list:sudoku-82"><a href="#list:sudoku-82" aria-hidden="true" tabindex="-1"></a>      cout <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="list:sudoku-83"><a href="#list:sudoku-83" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:sudoku-84"><a href="#list:sudoku-84" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:sudoku-85"><a href="#list:sudoku-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:sudoku-86"><a href="#list:sudoku-86" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> solve_helper<span class="op">(</span><span class="at">const</span> <span class="dt">int</span> i<span class="op">)</span></span>
<span id="list:sudoku-87"><a href="#list:sudoku-87" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:sudoku-88"><a href="#list:sudoku-88" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> blankCells<span class="op">.</span>size<span class="op">())</span></span>
<span id="list:sudoku-89"><a href="#list:sudoku-89" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:sudoku-90"><a href="#list:sudoku-90" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:sudoku-91"><a href="#list:sudoku-91" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:sudoku-92"><a href="#list:sudoku-92" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> pos <span class="op">=</span> blankCells<span class="op">[</span>i<span class="op">];</span></span>
<span id="list:sudoku-93"><a href="#list:sudoku-93" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> pos <span class="op">&lt;&lt;</span> <span class="st">&quot; +++++++   &quot;</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="list:sudoku-94"><a href="#list:sudoku-94" aria-hidden="true" tabindex="-1"></a>    <span class="co">// printSudoku();</span></span>
<span id="list:sudoku-95"><a href="#list:sudoku-95" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  cout&lt;&lt;endl;</span></span>
<span id="list:sudoku-96"><a href="#list:sudoku-96" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">char</span> x <span class="op">=</span> <span class="ch">&#39;1&#39;</span><span class="op">;</span> x <span class="op">&lt;=</span> <span class="ch">&#39;9&#39;</span><span class="op">;</span> x<span class="op">++)</span></span>
<span id="list:sudoku-97"><a href="#list:sudoku-97" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:sudoku-98"><a href="#list:sudoku-98" aria-hidden="true" tabindex="-1"></a>      problem<span class="op">[</span>pos<span class="op">]</span> <span class="op">=</span> <span class="ch">&#39;0&#39;</span><span class="op">;</span></span>
<span id="list:sudoku-99"><a href="#list:sudoku-99" aria-hidden="true" tabindex="-1"></a>      <span class="co">/* if(pos == 27)</span></span>
<span id="list:sudoku-100"><a href="#list:sudoku-100" aria-hidden="true" tabindex="-1"></a><span class="co">           cout&lt;&lt;&quot;here&quot;;*/</span></span>
<span id="list:sudoku-101"><a href="#list:sudoku-101" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>canInsert<span class="op">(</span>x<span class="op">,</span> pos<span class="op">))</span></span>
<span id="list:sudoku-102"><a href="#list:sudoku-102" aria-hidden="true" tabindex="-1"></a>      <span class="op">{</span></span>
<span id="list:sudoku-103"><a href="#list:sudoku-103" aria-hidden="true" tabindex="-1"></a>        problem<span class="op">[</span>pos<span class="op">]</span> <span class="op">=</span> x<span class="op">;</span></span>
<span id="list:sudoku-104"><a href="#list:sudoku-104" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>solve_helper<span class="op">(</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">))</span></span>
<span id="list:sudoku-105"><a href="#list:sudoku-105" aria-hidden="true" tabindex="-1"></a>          <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:sudoku-106"><a href="#list:sudoku-106" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="list:sudoku-107"><a href="#list:sudoku-107" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:sudoku-108"><a href="#list:sudoku-108" aria-hidden="true" tabindex="-1"></a>    problem<span class="op">[</span>pos<span class="op">]</span> <span class="op">=</span> <span class="ch">&#39;0&#39;</span><span class="op">;</span></span>
<span id="list:sudoku-109"><a href="#list:sudoku-109" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:sudoku-110"><a href="#list:sudoku-110" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:sudoku-111"><a href="#list:sudoku-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:sudoku-112"><a href="#list:sudoku-112" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>string<span class="op"> </span>problem<span class="op">;</span></span>
<span id="list:sudoku-113"><a href="#list:sudoku-113" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> blankCells<span class="op">;</span></span>
<span id="list:sudoku-114"><a href="#list:sudoku-114" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="list:sudoku-115"><a href="#list:sudoku-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:sudoku-116"><a href="#list:sudoku-116" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string<span class="op"> </span>solve_sudoku_backtracking<span class="op">(</span><span class="bu">std::</span>string<span class="op">&amp;</span> sudoku<span class="op">)</span></span>
<span id="list:sudoku-117"><a href="#list:sudoku-117" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:sudoku-118"><a href="#list:sudoku-118" aria-hidden="true" tabindex="-1"></a>  SudokuSolver solver<span class="op">(</span>sudoku<span class="op">);</span></span>
<span id="list:sudoku-119"><a href="#list:sudoku-119" aria-hidden="true" tabindex="-1"></a>  solver<span class="op">.</span>solve<span class="op">();</span></span>
<span id="list:sudoku-120"><a href="#list:sudoku-120" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> solver<span class="op">.</span>solve<span class="op">();</span></span>
<span id="list:sudoku-121"><a href="#list:sudoku-121" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="conclusion-3">Conclusion</h2>
<h1 id="ch:can_jump">Jump Game</h1>
<h2 class="unnumbered" id="introduction-31">Introduction</h2>
<p>In this problem we are going to investigate whether a solution exists for a game played in an array where you are the only player and you are initially located at the first cell of it. Your goal is to get to the last cell by jumping from a cell to another a number of times. The array contains information about the length of the jump you can take from a cell.</p>
<p>There are a number of possible solutions to this problem and in this Chapter we will discuss two of them. In particular:</p>
<ul>
<li><p>In Section <a href="#can_jump:sec:backtracking" data-reference-type="ref" data-reference="can_jump:sec:backtracking">33.2</a> we take a look at an approach that is possibly the most intuitive, where we try all possible jumps in a backtracking-like manner.</p></li>
<li><p>In Section <a href="#can_jump:sec:DFS" data-reference-type="ref" data-reference="can_jump:sec:DFS">33.3</a> we will refine the solution of Section <a href="#can_jump:sec:backtracking" data-reference-type="ref" data-reference="can_jump:sec:backtracking">33.2</a> into an efficient one that uses a clever insight to visit the cell efficiently.</p></li>
<li><p>Finally, in Section <a href="#can_jump:sec:greedy" data-reference-type="ref" data-reference="can_jump:sec:greedy">33.4</a> we will discuss an efficient and concise greedy solution.</p></li>
</ul>
<h2 id="problem-statement-33">Problem statement</h2>
<div class="exercise">
<p>Write a function that takes as input an array <span class="math inline">\(I\)</span> of non-negative integers. You are initially positioned at the beginning of the array (at index <span class="math inline">\(0\)</span>) and your goal is to jump from cell to cell to the end of the array (cell <span class="math inline">\(|I|-1\)</span>). If you are in the at index <span class="math inline">\(j\)</span> you are allowed to jump to all cells within the following range: <span class="math inline">\([j-I_i,j+I_i]\)</span> (each cell of the array contains the information about the longest jump you can take from there). The function should return true if you are able to reach the last cell of the array, false otherwise.</p>
<div class="example">
<p><br />
Given <span class="math inline">\(I=[2,3,1,1,4]\)</span> the function retuns <strong>true</strong>. You jump from cell <span class="math inline">\(0\)</span> to <span class="math inline">\(1\)</span> and then take a <span class="math inline">\(3\)</span> cells wide jump to the end of the array. See Figure <a href="#fig:can_jump:example1" data-reference-type="ref" data-reference="fig:can_jump:example1">33.1</a>. <span id="ex:can_jump_example1" label="ex:can_jump_example1">[ex:can_jump_example1]</span></p>
</div>
<div class="example">
<p><br />
Given <span class="math inline">\(I=[3,2,1,0,4]\)</span> the function retuns <strong>false</strong> because it is impossible to reach any cells with index higher than <span class="math inline">\(3\)</span>. See Figure <a href="#fig:can_jump:example2" data-reference-type="ref" data-reference="fig:can_jump:example2">33.2</a>: there is not incoming edge for the node with label <span class="math inline">\(4\)</span>. <span id="ex:can_jump_example2" label="ex:can_jump_example2">[ex:can_jump_example2]</span></p>
</div>
</div>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/can_jump/images/can_jump_example1.jpg" id="fig:can_jump:example1" alt="Visual representation (implicit graph) of the problem instance of Example [ex:can_jump_example1]." /><figcaption aria-hidden="true">Visual representation (implicit graph) of the problem instance of Example <a href="#ex:can_jump_example1" data-reference-type="ref" data-reference="ex:can_jump_example1">[ex:can_jump_example1]</a>.</figcaption>
</figure>
<p>. <span id="fig:can_jump:example1" label="fig:can_jump:example1">[fig:can_jump:example1]</span></p>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/can_jump/images/example2.jpg" id="fig:can_jump:example2" alt="Visual representation (implicit graph) of the problem instance of Example [ex:can_jump_example2]." /><figcaption aria-hidden="true">Visual representation (implicit graph) of the problem instance of Example <a href="#ex:can_jump_example2" data-reference-type="ref" data-reference="ex:can_jump_example2">[ex:can_jump_example2]</a>.</figcaption>
</figure>
<p>. <span id="fig:can_jump:example2" label="fig:can_jump:example2">[fig:can_jump:example2]</span></p>
<h2 id="can_jump:sec:backtracking">Backtracking</h2>
<p>The first solution that we will investigate is one based on an idea similar to the DFS where we <span class="math inline">\(I\)</span> is treated as an implicit graph where each cell (a node) is connected to all the others cells can be reached by jumping from it. The set of cells you can reach from a given cell <span class="math inline">\(c\)</span> is identified by the length of the jump you can perform from <span class="math inline">\(c\)</span> which is stored within <span class="math inline">\(c\)</span> itself. The idea is to use DFS to check whether there the last node of the graph is connected with the first one. In other words, whether there is a path from the first to the last node. We can proceed by adopting a recursive approach where we try to visit all the nodes that we can reach from the node we currently occupy and to continue this process until either we have reached the last node or there is no more jump we can try, meaning in that case, that there is no way to reach the last node (the last node is disconnected). Because the implicit graph is not guaranteed to be acyclic, in order to make this approach work we need to make sure is that we not jump back and forth from a cell to another in a cycle. This can happen if for instance you jump from a cell <span class="math inline">\(0\)</span> to cell <span class="math inline">\(1\)</span> and then back to cell <span class="math inline">\(0\)</span>. In order to overcome this issue we can only perform forward jumps so that it will be impossible to be stuck in a cycle and still manage to find an answer. When you jump to a cell <span class="math inline">\(i\)</span> from a cell <span class="math inline">\(j\)</span> s.t. <span class="math inline">\(j &lt; i\)</span> (you performed a forward jump) you know that you can also visit all cells <span class="math inline">\(j \leq
k \leq i\)</span> (all the cells in between <span class="math inline">\(j\)</span> and <span class="math inline">\(i\)</span>). If you only jump forward you are not going to need to visit any cell <span class="math inline">\(j \leq k \leq i\)</span> using backward jumps as they are visited anyway when processing cells <span class="math inline">\(j\)</span> by performing forward jumps from it. An implementation of this idea is shown in Listing <a href="#list:can_jump1_1" data-reference-type="ref" data-reference="list:can_jump1_1">[list:can_jump1_1]</a>. This approach is correct and it will eventually finds a solution, but it is extremely inefficient. Its complexity is exponential in time as potentially the same cells are visited over and over<a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a> and constant in space<a href="#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a>.</p>
<div class="sourceCode" id="list:can_jump1_1" data-language="c++" data-caption="Exponential time solution to the \textit{jump game} problem where only forward jumps are performed." label="list:can_jump1_1"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:can_jump1_1-1"><a href="#list:can_jump1_1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> can_jump_DFS_forward_only_helper<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">,</span> <span class="at">const</span> <span class="dt">int</span> n<span class="op">)</span></span>
<span id="list:can_jump1_1-2"><a href="#list:can_jump1_1-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:can_jump1_1-3"><a href="#list:can_jump1_1-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> tgt <span class="op">=</span> nums<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:can_jump1_1-4"><a href="#list:can_jump1_1-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> tgt<span class="op">)</span></span>
<span id="list:can_jump1_1-5"><a href="#list:can_jump1_1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:can_jump1_1-6"><a href="#list:can_jump1_1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:can_jump1_1-7"><a href="#list:can_jump1_1-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> r <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>tgt<span class="op">,</span> n <span class="op">+</span> nums<span class="op">[</span>n<span class="op">]);</span></span>
<span id="list:can_jump1_1-8"><a href="#list:can_jump1_1-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> r<span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:can_jump1_1-9"><a href="#list:can_jump1_1-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:can_jump1_1-10"><a href="#list:can_jump1_1-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>can_jump_DFS_forward_only_helper<span class="op">(</span>nums<span class="op">,</span> i<span class="op">))</span></span>
<span id="list:can_jump1_1-11"><a href="#list:can_jump1_1-11" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:can_jump1_1-12"><a href="#list:can_jump1_1-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:can_jump1_1-13"><a href="#list:can_jump1_1-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:can_jump1_1-14"><a href="#list:can_jump1_1-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:can_jump1_1-15"><a href="#list:can_jump1_1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:can_jump1_1-16"><a href="#list:can_jump1_1-16" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> can_jump_DFS_forward_only<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span></span>
<span id="list:can_jump1_1-17"><a href="#list:can_jump1_1-17" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:can_jump1_1-18"><a href="#list:can_jump1_1-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> can_jump_DFS_forward_only_helper<span class="op">(</span>nums<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="list:can_jump1_1-19"><a href="#list:can_jump1_1-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="can_jump:sec:DFS">DFS</h2>
<p>Another option for solving the cycle problem arising from the algorithm described in Section <a href="#can_jump:sec:backtracking" data-reference-type="ref" data-reference="can_jump:sec:backtracking">33.2</a> (this solution can be in-fact thought as an optimized backtracking) is to keep track of the cells that we have already visited and everytime we are about to perform a jump to a cell we first check whether that cell has been visited already in the past and if it had, the jump is discarded and not performed. No cells is actually visited twice this way, and as a consequence the complexity is in this case <span class="math inline">\(O(|I|^2)\)</span>. In the worst-case you must check for each cell whether all the other cells have been already visited. Listing <a href="#list:can_jump1" data-reference-type="ref" data-reference="list:can_jump1">[list:can_jump1]</a> shows an implementation of this idea.</p>
<div class="sourceCode" id="list:can_jump1" data-language="c++" data-caption="Quadratic time and linear space DFS solution to the \textit{jump game} problem using a visited array." label="list:can_jump1"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:can_jump1-1"><a href="#list:can_jump1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> can_jump_DFS_helper<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">,</span></span>
<span id="list:can_jump1-2"><a href="#list:can_jump1-2" aria-hidden="true" tabindex="-1"></a>                         vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;&amp;</span> visited<span class="op">,</span></span>
<span id="list:can_jump1-3"><a href="#list:can_jump1-3" aria-hidden="true" tabindex="-1"></a>                         <span class="at">const</span> <span class="dt">int</span> n<span class="op">)</span></span>
<span id="list:can_jump1-4"><a href="#list:can_jump1-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:can_jump1-5"><a href="#list:can_jump1-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> tgt <span class="op">=</span> nums<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:can_jump1-6"><a href="#list:can_jump1-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> tgt<span class="op">)</span></span>
<span id="list:can_jump1-7"><a href="#list:can_jump1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:can_jump1-8"><a href="#list:can_jump1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:can_jump1-9"><a href="#list:can_jump1-9" aria-hidden="true" tabindex="-1"></a>  visited<span class="op">[</span>n<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:can_jump1-10"><a href="#list:can_jump1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:can_jump1-11"><a href="#list:can_jump1-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> l          <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span><span class="dv">0</span><span class="op">,</span> n <span class="op">-</span> nums<span class="op">[</span>n<span class="op">]);</span></span>
<span id="list:can_jump1-12"><a href="#list:can_jump1-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> r          <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>tgt<span class="op">,</span> n <span class="op">+</span> nums<span class="op">[</span>n<span class="op">]);</span></span>
<span id="list:can_jump1-13"><a href="#list:can_jump1-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> sol_found <span class="op">=</span> <span class="op">(</span>r <span class="op">==</span> tgt<span class="op">);</span></span>
<span id="list:can_jump1-14"><a href="#list:can_jump1-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> l<span class="op">;</span> i <span class="op">&lt;=</span> r <span class="op">&amp;&amp;</span> <span class="op">!</span>sol_found<span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:can_jump1-15"><a href="#list:can_jump1-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:can_jump1-16"><a href="#list:can_jump1-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>visited<span class="op">[</span>i<span class="op">])</span></span>
<span id="list:can_jump1-17"><a href="#list:can_jump1-17" aria-hidden="true" tabindex="-1"></a>      <span class="cf">continue</span><span class="op">;</span></span>
<span id="list:can_jump1-18"><a href="#list:can_jump1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:can_jump1-19"><a href="#list:can_jump1-19" aria-hidden="true" tabindex="-1"></a>    sol_found <span class="op">=</span> can_jump_DFS_helper<span class="op">(</span>nums<span class="op">,</span> visited<span class="op">,</span> i<span class="op">);</span></span>
<span id="list:can_jump1-20"><a href="#list:can_jump1-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:can_jump1-21"><a href="#list:can_jump1-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> sol_found<span class="op">;</span></span>
<span id="list:can_jump1-22"><a href="#list:can_jump1-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:can_jump1-23"><a href="#list:can_jump1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:can_jump1-24"><a href="#list:can_jump1-24" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> can_jump_DFS<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span></span>
<span id="list:can_jump1-25"><a href="#list:can_jump1-25" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:can_jump1-26"><a href="#list:can_jump1-26" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span> visited<span class="op">(</span>nums<span class="op">.</span>size<span class="op">(),</span> <span class="kw">false</span><span class="op">);</span></span>
<span id="list:can_jump1-27"><a href="#list:can_jump1-27" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> can_jump_DFS_helper<span class="op">(</span>nums<span class="op">,</span> visited<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="list:can_jump1-28"><a href="#list:can_jump1-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice that one optimization from which this solution (and perhaps also Listing <a href="#list:can_jump1_1" data-reference-type="ref" data-reference="list:can_jump1_1">[list:can_jump1_1]</a>) can benefit would be to always try to jump the longest distance possible. Despite this would not change their asymptotic complexity, in practice this might be faster.</p>
<h2 id="can_jump:sec:greedy">Greedy</h2>
<p>There is however a much faster solution to this problem that is based on the idea that we can return true if we can jump from the cell at index <span class="math inline">\(0\)</span> to a cell from which we can reach the end of the array. If we apply the same reasoning to generic index <span class="math inline">\(i\)</span> we end up with basically a dynamic programming approach that, given <span class="math inline">\(G(x)\)</span> is <span class="math inline">\(1\)</span> if you can reach the end of the array from the cell <span class="math inline">\(x\)</span> and <span class="math inline">\(0\)</span> otherwise, is based on the following recursive formula: <span class="math display">\[\begin{cases}
		G(|I|-1) = 1 \\
		G(x) = 1 \: \: \text{if} \: \: \exists \: y &gt; x \:\: \text{s.t.} \:\: y &lt; (x+I_x) \: \: \text{and} \: \:G(y) = 1\\
		\text{otherwise} \: \: G(x) = 0
	 \end{cases}
	\label{eq:can_jump:dpformula}\]</span> Equation <a href="#eq:can_jump:dpformula" data-reference-type="ref" data-reference="eq:can_jump:dpformula">[eq:can_jump:dpformula]</a> shows that a possible implementation would start processing cells from the last to the first and that for each element a linear time lookup for a suitable cell <span class="math inline">\(y\)</span> might be needed. Therefore the complexity of this solution is quadratic in time. However we can drastically lower its complexity by noticing that when processing cell <span class="math inline">\(x\)</span> all we care about is whether the closest cell to the right from which you can reach the end of the array is reachable from <span class="math inline">\(x\)</span>. We can carry this information into a variable <span class="math inline">\(m\)</span> down from cell <span class="math inline">\(|I|-1\)</span> to cell <span class="math inline">\(0\)</span> and update it after a cell is processed and this would effectively allow us to have a linear time solution.</p>
<p>To summarize the linear time solution for this problem works as follows: We iterate the array <span class="math inline">\(I\)</span> right-to-left and for each cell <span class="math inline">\(x\)</span> we check whether we can reach <span class="math inline">\(m\)</span> jumping from <span class="math inline">\(x\)</span>. If we can then <span class="math inline">\(x\)</span> is the new leftmost cell from which we can reach the end of the array, thus <span class="math inline">\(m = x\)</span>. Otherwise we continue by processing cell <span class="math inline">\(x-1\)</span> in a similar manner. Eventually we will have processed all cells and therefore we can return true if <span class="math inline">\(m = 0\)</span> meaning that cell <span class="math inline">\(0\)</span> is the leftmost cell from which we can jump to location <span class="math inline">\(|I|-1\)</span>, and false otherwise.</p>
<div class="sourceCode" id="list:can_jump" data-language="c++" data-caption="Greedy solution where we use the fact that the DP solution described by Equation \ref{eq:can_jump:dpformula} can be optimized if we only consider if it is possible to reach the closest cell from which we can jump to the end of the array." label="list:can_jump"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:can_jump-1"><a href="#list:can_jump-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> can_jump_linear<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span></span>
<span id="list:can_jump-2"><a href="#list:can_jump-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:can_jump-3"><a href="#list:can_jump-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> size <span class="op">=</span> nums<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:can_jump-4"><a href="#list:can_jump-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> m          <span class="op">=</span> size <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:can_jump-5"><a href="#list:can_jump-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> i <span class="op">=</span> size <span class="op">-</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span></span>
<span id="list:can_jump-6"><a href="#list:can_jump-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:can_jump-7"><a href="#list:can_jump-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> max_reach <span class="op">=</span> i <span class="op">+</span> nums<span class="op">[</span>i<span class="op">];</span></span>
<span id="list:can_jump-8"><a href="#list:can_jump-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>max_reach <span class="op">&gt;=</span> m<span class="op">)</span></span>
<span id="list:can_jump-9"><a href="#list:can_jump-9" aria-hidden="true" tabindex="-1"></a>      m <span class="op">=</span> i<span class="op">;</span></span>
<span id="list:can_jump-10"><a href="#list:can_jump-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:can_jump-11"><a href="#list:can_jump-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> m <span class="op">==</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:can_jump-12"><a href="#list:can_jump-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="ch:kth_largest_in_stream"><span class="math inline">\(k^{th}\)</span> largest in a stream</h1>
<h2 class="unnumbered" id="introduction-32">Introduction</h2>
<p>This chapter deals with a problem where the input data is not statically provided all at once but it is instead given as a continuous stream of data. These kind of algorithm are common in real life and they are becoming increasingly important in fields like medicine (where data from wearable devices is used to provide real-time insights on the patient health conditions), or finance where an enormous amount of data (usually provided from the exchanges) is used to perform high-frequency trading. We are going to study a coding interview question that has been quite popular during the last couple of years and that asks you to design a data structure that is able to deal with a stream of integers and can keep track of the <span class="math inline">\(k^{th}\)</span> largest element seen so far. We are going to present and discuss three solution based on the same fundamental idea (discussed in Section <a href="#kth_largest_in_stream:sec:discussion" data-reference-type="ref" data-reference="kth_largest_in_stream:sec:discussion">34.3</a>) that are built around three different data structures:</p>
<div class="enumerate*">
<p>a simple array (in Section <a href="#kth_largest_in_stream:sec:bruteforce" data-reference-type="ref" data-reference="kth_largest_in_stream:sec:bruteforce">34.3.1</a>),</p>
<p>a self balancing binary search tree (in Section <a href="#kth_largest_in_stream:sec:map" data-reference-type="ref" data-reference="kth_largest_in_stream:sec:map">34.3.2</a>) and, finally</p>
<p>a heap (in Section <a href="#kth_largest_in_stream:sec:heap" data-reference-type="ref" data-reference="kth_largest_in_stream:sec:heap">[kth_largest_in_stream:sec:heap]</a>).</p>
</div>
<p>.</p>
<h2 id="problem-statement-34">Problem statement</h2>
<div class="exercise">
<p>Design a class which task accept a stream of integers one number at the time and to return the <span class="math inline">\(k^{th}\)</span> largest integer seen so far in the stream. The class has two public functions having the following signatures:</p>
<ol>
<li><p>: the array contains the first elements of the stream. This function will be called only once upon initialization.</p></li>
<li><p>: this function accept an new element from the stream and returns the <span class="math inline">\(k^{th}\)</span> largest numbers seen so far.</p></li>
</ol>
<p>Notice that you can assume that the function is called only once before any call of to the function .</p>
<div class="example">
<p><br />
Given <span class="math inline">\(K=4\)</span> and the initial array <span class="math inline">\(I=\{1,2,3\}\)</span>, the function behave as follows:</p>
<ul>
<li><p>returns <span class="math inline">\(1\)</span></p></li>
<li><p>returns <span class="math inline">\(1\)</span></p></li>
<li><p>returns <span class="math inline">\(1\)</span></p></li>
<li><p>returns <span class="math inline">\(2\)</span></p></li>
<li><p>returns <span class="math inline">\(2\)</span></p></li>
</ul>
</div>
<div class="example">
<p><br />
Given <span class="math inline">\(K=4\)</span> and the initial array <span class="math inline">\(I\{1,2,3,4,50,100,150,200\}\)</span> the function behave as follows:</p>
<ul>
<li><p>returns <span class="math inline">\(50\)</span></p></li>
<li><p>returns <span class="math inline">\(100\)</span></p></li>
<li><p>returns <span class="math inline">\(100\)</span></p></li>
<li><p>returns <span class="math inline">\(110\)</span></p></li>
<li><p>returns <span class="math inline">\(150\)</span></p></li>
<li><p>returns <span class="math inline">\(180\)</span></p></li>
</ul>
<p><span id="ex:kthlargest_in_stream:example2" label="ex:kthlargest_in_stream:example2">[ex:kthlargest_in_stream:example2]</span></p>
</div>
</div>
<h2 id="clarification-questions-27">Clarification Questions</h2>
<div class="QandA">
<p>What should the function return if the stream counted less than <span class="math inline">\(K\)</span> elements?</p>
<div class="answered">
<p><em>You can assume that the largest <span class="math inline">\(k^{th}\)</span> elements exists when is called.</em></p>
</div>
<p>Is there a limit to the size of the array <span class="math inline">\(I\)</span>?</p>
<div class="answered">
<p><em>No.</em></p>
</div>
</div>
<h2 id="kth_largest_in_stream:sec:discussion">Discussion</h2>
<p>There are two phases associated with this class:</p>
<ol>
<li><p>the initialization phase where an initial input array <span class="math inline">\(I\)</span> is provided to the class. Because when calling the <span class="math inline">\(k^{th}\)</span> largest value exists, then we can deduce that the size of the vector <span class="math inline">\(I\)</span> is at least <span class="math inline">\(K-1\)</span> otherwise, the first call of could not possibly return the correct value. This operations is guaranteed to happen one time only before any call to .</p></li>
<li><p>the stream elements processing phase where the class is ready to accept a new number form the stream and return the answer.</p></li>
</ol>
<p>The key idea to attack this problem is that during the initialization phase when the initialization array comes in, we are forced to remember the largest elements in it. In particular if <span class="math inline">\(|I| \geq K\)</span> then we can throw away all the elements that are not among the <span class="math inline">\(K\)</span> largest and keep the rest (this should be self-explanatory as those elements will never be used as a return value of as there are already <span class="math inline">\(K\)</span> values larger than all of them), otherwise we can remember <span class="math inline">\(I\)</span> as it is (and in this case we know that <span class="math inline">\(|I| = K-1\)</span>). One might think that is not necessary to remember all <span class="math inline">\(K\)</span> largest numbers seen so far and that is in fact only necessary to remember the <span class="math inline">\(K^{th}\)</span> largest element. We will use Example <a href="#ex:kthlargest_in_stream:example2" data-reference-type="ref" data-reference="ex:kthlargest_in_stream:example2">[ex:kthlargest_in_stream:example2]</a> as a simple counterexample to shows why this approach leads incorrect results. First of all, after the initialization phase the largest number (<span class="math inline">\(K=4\)</span> in this example) is <span class="math inline">\(50\)</span>. Then, after the call to the largest number is not changed and the function still returns <span class="math inline">\(50\)</span>. But when is called, then <span class="math inline">\(50\)</span> suddenly becomes the largest number and here it is when remembering the other numbers larger than <span class="math inline">\(50\)</span> becomes important. Without them we would not be able now to return the correct value i.e. <span class="math inline">\(100\)</span>.</p>
<p>In short it becomes clear that in order to be able to always give an answer we need to store and keep track of all the <span class="math inline">\(K\)</span> largest numbers seen so far. But where and how exactly can we do that? Let’s name the set of the largest <span class="math inline">\(K\)</span> numbers seen so far <span class="math inline">\(L^K\)</span>. Moreover let <span class="math inline">\(m\)</span> be the smallest element in <span class="math inline">\(L^K\)</span>; <span class="math inline">\(m = \min_{} (L^K)\)</span>. When a new number <span class="math inline">\(n\)</span> arrives, we can do one of the following operations depending on its value:</p>
<ul>
<li><p>if <span class="math inline">\(|L^K| &lt; K\)</span> we simply insert <span class="math inline">\(n\)</span> in <span class="math inline">\(L^K\)</span> and return.</p></li>
<li><p>otherwise, if <span class="math inline">\(n \leq m\)</span> then, <span class="math inline">\(n\)</span> can be ignored as it has not influence among the elements of <span class="math inline">\(L^K\)</span>.</p></li>
<li><p>otherwise (<span class="math inline">\(n &gt; m\)</span>), <span class="math inline">\(m\)</span> can be safely removed from <span class="math inline">\(L^K\)</span> as it would become the <span class="math inline">\(K-1^{th}\)</span> largest after the addition of <span class="math inline">\(n\)</span>. The new element <span class="math inline">\(n\)</span> can be inserted in <span class="math inline">\(L^K\)</span>.</p></li>
</ul>
<p>Notice that the size of <span class="math inline">\(L^K\)</span> never changes after it reaches <span class="math inline">\(K\)</span>. The way we decide to store <span class="math inline">\(L^K\)</span> has a big influence to the cost of the operations listed above namely:</p>
<div class="enumerate*">
<p>find the minimum element (<span class="math inline">\(m\)</span>)</p>
<p>remove the minimum element (<span class="math inline">\(m\)</span>)</p>
<p>insert a new element (<span class="math inline">\(n\)</span>)</p>
</div>
<p>. In the following Section we will investigate three data structures that can be used those hold the values of <span class="math inline">\(L^K\)</span>.</p>
<h3 id="kth_largest_in_stream:sec:bruteforce">Array based solution</h3>
<p>In this section we present a solution where the elements of <span class="math inline">\(L^K\)</span> are stored in a sorted array. We will see that this is probably not the best idea as, when a new element <span class="math inline">\(n\)</span> arrives the whole array needs to be rearranged and that can be a costly operation. In particular let’s have a look at how both the and function can be implemented:</p>
<dl>
<dt><code>initialize(I,K)</code>:</dt>
<dd><p>The initialization phase has to filter the largest <span class="math inline">\(K\)</span> elements out of the initialization array <span class="math inline">\(I\)</span>. This can be done by sorting <span class="math inline">\(I\)</span> in ascending order first and then copying in <span class="math inline">\(L^K\)</span> only the first of its <span class="math inline">\(K\)</span> elements (the <span class="math inline">\(K\)</span> largest). The same can be obtained by using a partial sort algorithm which makes sure that the largest <span class="math inline">\(K\)</span> elements are at the front of the array but given no guarantees on the relative ordering of the rest of the array. The complexity of this operation is <span class="math inline">\(O(|I| log(|I|))\)</span> if the whole array <span class="math inline">\(I\)</span> is sorted but when a partial sort algorithm is used then the costs becomes <span class="math inline">\(O(|I| log(K))\)</span>.</p>
</dd>
<dt><code>add(n)</code>:</dt>
<dd><p>When <span class="math inline">\(|L^K|&lt;K\)</span> or <span class="math inline">\(n\)</span> is inserted in <span class="math inline">\(L^K\)</span>. But if <span class="math inline">\(n&gt;m\)</span> then <span class="math inline">\(m\)</span> is substituted by <span class="math inline">\(n\)</span> (thus effectively removing <span class="math inline">\(m\)</span>) and subsequentially the ordering of <span class="math inline">\(L^K\)</span> is restored. When this happen we will be in a situation where the <span class="math inline">\(L^K\)</span> is sorted except for <span class="math inline">\(n\)</span> that might not be in the right position (for instance when <span class="math inline">\(n\)</span> would be the largest element of <span class="math inline">\(L^K\)</span>). So restoring the order on <span class="math inline">\(L^K\)</span> can be achieved either by:</p>
<ul>
<li><p>fully sorting <span class="math inline">\(L^K\)</span>. In this case the complexity of is <span class="math inline">\(O(K log(K))\)</span></p></li>
<li><p>by moving the newly inserted element from the first location of the array up, by swapping it with its subsequent element, until it reaches the correct position. This operation is analogous to how the insertion sort algorithm operates. The cost of this operation is <span class="math inline">\(O(K)\)</span>. In the worst case we need to bubble up <span class="math inline">\(n\)</span> up to the last cell of the array (when <span class="math inline">\(n\)</span> is effectively the largest element of <span class="math inline">\(L^K\)</span>) by performing <span class="math inline">\(K-1\)</span> swap operations.</p></li>
</ul>
</dd>
</dl>
<p>Listing <a href="#list:kth_largest_in_stream:array" data-reference-type="ref" data-reference="list:kth_largest_in_stream:array">[list:kth_largest_in_stream:array]</a> shows an implementation where the initialization phase is perfomed using a normal sort and the add is implemented by using an approach aĺa insertion-sort.</p>
<div class="sourceCode" id="list:kth_largest_in_stream:array" data-language="c++" data-caption="Solution to the \textit{$k^{th}$ largest element in a stream problem} using arrays" label="list:kth_largest_in_stream:array"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:kth_largest_in_stream:array-1"><a href="#list:kth_largest_in_stream:array-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> KthLargestInStreamArray <span class="op">:</span> IKThLargestInStream</span>
<span id="list:kth_largest_in_stream:array-2"><a href="#list:kth_largest_in_stream:array-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:kth_largest_in_stream:array-3"><a href="#list:kth_largest_in_stream:array-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="list:kth_largest_in_stream:array-4"><a href="#list:kth_largest_in_stream:array-4" aria-hidden="true" tabindex="-1"></a>  KthLargestInStreamArray<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="list:kth_largest_in_stream:array-5"><a href="#list:kth_largest_in_stream:array-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> initialize<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> initArray<span class="op">,</span> <span class="at">const</span> <span class="dt">size_t</span> K<span class="op">)</span> <span class="kw">override</span></span>
<span id="list:kth_largest_in_stream:array-6"><a href="#list:kth_largest_in_stream:array-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:kth_largest_in_stream:array-7"><a href="#list:kth_largest_in_stream:array-7" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_values</span> <span class="op">=</span> initArray<span class="op">;</span></span>
<span id="list:kth_largest_in_stream:array-8"><a href="#list:kth_largest_in_stream:array-8" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_k</span>      <span class="op">=</span> K<span class="op">;</span></span>
<span id="list:kth_largest_in_stream:array-9"><a href="#list:kth_largest_in_stream:array-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>sort<span class="op">(</span>begin<span class="op">(</span><span class="va">m_values</span><span class="op">),</span> end<span class="op">(</span><span class="va">m_values</span><span class="op">));</span></span>
<span id="list:kth_largest_in_stream:array-10"><a href="#list:kth_largest_in_stream:array-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> start <span class="op">=</span> begin<span class="op">(</span><span class="va">m_values</span><span class="op">);</span></span>
<span id="list:kth_largest_in_stream:array-11"><a href="#list:kth_largest_in_stream:array-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> end   <span class="op">=</span> <span class="va">m_values</span><span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;=</span> K</span>
<span id="list:kth_largest_in_stream:array-12"><a href="#list:kth_largest_in_stream:array-12" aria-hidden="true" tabindex="-1"></a>                           <span class="op">?</span> <span class="va">m_values</span><span class="op">.</span>begin<span class="op">()</span> <span class="op">+</span> <span class="op">(</span><span class="va">m_values</span><span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> K<span class="op">)</span></span>
<span id="list:kth_largest_in_stream:array-13"><a href="#list:kth_largest_in_stream:array-13" aria-hidden="true" tabindex="-1"></a>                           <span class="op">:</span> <span class="va">m_values</span><span class="op">.</span>begin<span class="op">();</span></span>
<span id="list:kth_largest_in_stream:array-14"><a href="#list:kth_largest_in_stream:array-14" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_values</span><span class="op">.</span>erase<span class="op">(</span>start<span class="op">,</span> end<span class="op">);</span></span>
<span id="list:kth_largest_in_stream:array-15"><a href="#list:kth_largest_in_stream:array-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="list:kth_largest_in_stream:array-16"><a href="#list:kth_largest_in_stream:array-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:kth_largest_in_stream:array-17"><a href="#list:kth_largest_in_stream:array-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> add<span class="op">(</span><span class="at">const</span> <span class="dt">int</span> n<span class="op">)</span> <span class="kw">override</span></span>
<span id="list:kth_largest_in_stream:array-18"><a href="#list:kth_largest_in_stream:array-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:kth_largest_in_stream:array-19"><a href="#list:kth_largest_in_stream:array-19" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span><span class="va">m_values</span><span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="va">m_k</span><span class="op">);</span></span>
<span id="list:kth_largest_in_stream:array-20"><a href="#list:kth_largest_in_stream:array-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;</span> <span class="va">m_values</span><span class="op">.</span>front<span class="op">())</span></span>
<span id="list:kth_largest_in_stream:array-21"><a href="#list:kth_largest_in_stream:array-21" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="va">m_values</span><span class="op">.</span>front<span class="op">();</span></span>
<span id="list:kth_largest_in_stream:array-22"><a href="#list:kth_largest_in_stream:array-22" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_values</span><span class="op">.</span>front<span class="op">()</span> <span class="op">=</span> n<span class="op">;</span></span>
<span id="list:kth_largest_in_stream:array-23"><a href="#list:kth_largest_in_stream:array-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> it          <span class="op">=</span> begin<span class="op">(</span><span class="va">m_values</span><span class="op">);</span></span>
<span id="list:kth_largest_in_stream:array-24"><a href="#list:kth_largest_in_stream:array-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> itn         <span class="op">=</span> <span class="bu">std::</span>next<span class="op">(</span>it<span class="op">);</span></span>
<span id="list:kth_largest_in_stream:array-25"><a href="#list:kth_largest_in_stream:array-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>itn <span class="op">!=</span> end<span class="op">(</span><span class="va">m_values</span><span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">*</span>it <span class="op">&gt;</span> <span class="op">*</span>itn<span class="op">)</span></span>
<span id="list:kth_largest_in_stream:array-26"><a href="#list:kth_largest_in_stream:array-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:kth_largest_in_stream:array-27"><a href="#list:kth_largest_in_stream:array-27" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>iter_swap<span class="op">(</span>it<span class="op">,</span> itn<span class="op">);</span></span>
<span id="list:kth_largest_in_stream:array-28"><a href="#list:kth_largest_in_stream:array-28" aria-hidden="true" tabindex="-1"></a>      it  <span class="op">=</span> itn<span class="op">;</span></span>
<span id="list:kth_largest_in_stream:array-29"><a href="#list:kth_largest_in_stream:array-29" aria-hidden="true" tabindex="-1"></a>      itn <span class="op">=</span> <span class="bu">std::</span>next<span class="op">(</span>it<span class="op">);</span></span>
<span id="list:kth_largest_in_stream:array-30"><a href="#list:kth_largest_in_stream:array-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:kth_largest_in_stream:array-31"><a href="#list:kth_largest_in_stream:array-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">m_values</span><span class="op">.</span>front<span class="op">();</span></span>
<span id="list:kth_largest_in_stream:array-32"><a href="#list:kth_largest_in_stream:array-32" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="list:kth_largest_in_stream:array-33"><a href="#list:kth_largest_in_stream:array-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:kth_largest_in_stream:array-34"><a href="#list:kth_largest_in_stream:array-34" aria-hidden="true" tabindex="-1"></a> <span class="kw">private</span><span class="op">:</span></span>
<span id="list:kth_largest_in_stream:array-35"><a href="#list:kth_largest_in_stream:array-35" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="va">m_values</span><span class="op">;</span></span>
<span id="list:kth_largest_in_stream:array-36"><a href="#list:kth_largest_in_stream:array-36" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> <span class="va">m_k</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:kth_largest_in_stream:array-37"><a href="#list:kth_largest_in_stream:array-37" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="kth_largest_in_stream:sec:map">Ordered set</h3>
<p>If instead of an array we use a data structure <a href="#fn23" class="footnote-ref" id="fnref23" role="doc-noteref"><sup>23</sup></a>that allow us to perform insert/search and min operations runs in <span class="math inline">\(log\)</span> and constant time, respectively, then we can substantially improve the time complexity of the solution shown in Section <a href="#kth_largest_in_stream:sec:bruteforce" data-reference-type="ref" data-reference="kth_largest_in_stream:sec:bruteforce">34.3.1</a>.</p>
<p>Let’s have a look in more details at how the two operations look like in this case:</p>
<dl>
<dt><code>initialize(I,K)</code>:</dt>
<dd><p>Recall that the final goal of this operation is to keep only the largest <span class="math inline">\(K\)</span> elements of <span class="math inline">\(I\)</span>. This can be easily achieved in <span class="math inline">\(O(|I|log(K))\)</span> by looking at each element of <span class="math inline">\(I\)</span>, say <span class="math inline">\(I_j\)</span> individually, and inserting it into <span class="math inline">\(L^K\)</span> if:</p>
<ul>
<li><p>the size of <span class="math inline">\(|L^K| &lt; K\)</span> or</p></li>
<li><p>if <span class="math inline">\(I_j\)</span> is greater than the smallest element of <span class="math inline">\(L^K\)</span>. Additionally in this case, if after the insertion we have that <span class="math inline">\(|L^K|  &gt; K\)</span> then the current smallest element in <span class="math inline">\(L^K\)</span> is removed so to make sure that <span class="math inline">\(|L^K|=K\)</span>.</p></li>
</ul>
<p>Because there are <span class="math inline">\(O(|I|)\)</span> elements that can potentially go in <span class="math inline">\(L^K\)</span> and each insertion costs <span class="math inline">\(O(log(K))\)</span> then the final complexity if <span class="math inline">\(O(|I|log(K))\)</span>. Notice that it is not much better than the array solution in this case.</p>
</dd>
<dt><code>add(n)</code>:</dt>
<dd><p>This is where we see the advantages of having the elements of <span class="math inline">\(L^K\)</span> not stored in a plain array. Like in the array solution, we compare <span class="math inline">\(n\)</span> with the smallest element in <span class="math inline">\(L^K\)</span>, <span class="math inline">\(m\)</span>, and insert <span class="math inline">\(n\)</span> in <span class="math inline">\(L^K\)</span> only if <span class="math inline">\(n&gt;m\)</span>. But because the ordered multiset support the and operations in <span class="math inline">\(O(log)\)</span> and <span class="math inline">\(O(1)\)</span> time, respectively, then the complexity of this operation if <span class="math inline">\(O(log(K))\)</span>. Quite an improvement w.r.t. the array solution.</p>
</dd>
</dl>
<p>Listing <a href="#list:kth_largest_in_stream:set" data-reference-type="ref" data-reference="list:kth_largest_in_stream:set">[list:kth_largest_in_stream:set]</a> shows a possible implementation of this idea using a ordered multiset (we use the C++ STL implementation named ).</p>
<div class="sourceCode" id="list:kth_largest_in_stream:set" data-language="c++" data-caption="Solution to the \textit{$k^{th}$ largest element in a stream problem} using \inline{std::multiset}" label="list:kth_largest_in_stream:set"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:kth_largest_in_stream:set-1"><a href="#list:kth_largest_in_stream:set-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:kth_largest_in_stream:set-2"><a href="#list:kth_largest_in_stream:set-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;IKThLargestInStream.h&quot;</span></span>
<span id="list:kth_largest_in_stream:set-3"><a href="#list:kth_largest_in_stream:set-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:kth_largest_in_stream:set-4"><a href="#list:kth_largest_in_stream:set-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> KthLargestInStreamMap <span class="op">:</span> IKThLargestInStream</span>
<span id="list:kth_largest_in_stream:set-5"><a href="#list:kth_largest_in_stream:set-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:kth_largest_in_stream:set-6"><a href="#list:kth_largest_in_stream:set-6" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="list:kth_largest_in_stream:set-7"><a href="#list:kth_largest_in_stream:set-7" aria-hidden="true" tabindex="-1"></a>  KthLargestInStreamMap<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="list:kth_largest_in_stream:set-8"><a href="#list:kth_largest_in_stream:set-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> initialize<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> initArray<span class="op">,</span> <span class="at">const</span> <span class="dt">size_t</span> K<span class="op">)</span> <span class="kw">override</span></span>
<span id="list:kth_largest_in_stream:set-9"><a href="#list:kth_largest_in_stream:set-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:kth_largest_in_stream:set-10"><a href="#list:kth_largest_in_stream:set-10" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>K <span class="op">&lt;=</span> initArray<span class="op">.</span>size<span class="op">());</span></span>
<span id="list:kth_largest_in_stream:set-11"><a href="#list:kth_largest_in_stream:set-11" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_k</span> <span class="op">=</span> K<span class="op">;</span></span>
<span id="list:kth_largest_in_stream:set-12"><a href="#list:kth_largest_in_stream:set-12" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_values</span><span class="op">.</span>insert<span class="op">(</span>begin<span class="op">(</span>initArray<span class="op">),</span> end<span class="op">(</span>initArray<span class="op">));</span></span>
<span id="list:kth_largest_in_stream:set-13"><a href="#list:kth_largest_in_stream:set-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:kth_largest_in_stream:set-14"><a href="#list:kth_largest_in_stream:set-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> it <span class="op">=</span> begin<span class="op">(</span><span class="va">m_values</span><span class="op">);</span></span>
<span id="list:kth_largest_in_stream:set-15"><a href="#list:kth_largest_in_stream:set-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="va">m_values</span><span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;</span> K<span class="op">)</span></span>
<span id="list:kth_largest_in_stream:set-16"><a href="#list:kth_largest_in_stream:set-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:kth_largest_in_stream:set-17"><a href="#list:kth_largest_in_stream:set-17" aria-hidden="true" tabindex="-1"></a>      it <span class="op">=</span> <span class="va">m_values</span><span class="op">.</span>erase<span class="op">(</span>it<span class="op">);</span></span>
<span id="list:kth_largest_in_stream:set-18"><a href="#list:kth_largest_in_stream:set-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:kth_largest_in_stream:set-19"><a href="#list:kth_largest_in_stream:set-19" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span><span class="va">m_k</span> <span class="op">==</span> K<span class="op">);</span></span>
<span id="list:kth_largest_in_stream:set-20"><a href="#list:kth_largest_in_stream:set-20" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>K <span class="op">==</span> <span class="va">m_values</span><span class="op">.</span>size<span class="op">());</span></span>
<span id="list:kth_largest_in_stream:set-21"><a href="#list:kth_largest_in_stream:set-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:kth_largest_in_stream:set-22"><a href="#list:kth_largest_in_stream:set-22" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> add<span class="op">(</span><span class="at">const</span> <span class="dt">int</span> n<span class="op">)</span> <span class="kw">override</span></span>
<span id="list:kth_largest_in_stream:set-23"><a href="#list:kth_largest_in_stream:set-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:kth_largest_in_stream:set-24"><a href="#list:kth_largest_in_stream:set-24" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span><span class="va">m_k</span> <span class="op">==</span> <span class="va">m_values</span><span class="op">.</span>size<span class="op">());</span></span>
<span id="list:kth_largest_in_stream:set-25"><a href="#list:kth_largest_in_stream:set-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:kth_largest_in_stream:set-26"><a href="#list:kth_largest_in_stream:set-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&gt;</span> <span class="op">*(</span><span class="va">m_values</span><span class="op">.</span>begin<span class="op">()))</span></span>
<span id="list:kth_largest_in_stream:set-27"><a href="#list:kth_largest_in_stream:set-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:kth_largest_in_stream:set-28"><a href="#list:kth_largest_in_stream:set-28" aria-hidden="true" tabindex="-1"></a>      <span class="va">m_values</span><span class="op">.</span>insert<span class="op">(</span>n<span class="op">);</span></span>
<span id="list:kth_largest_in_stream:set-29"><a href="#list:kth_largest_in_stream:set-29" aria-hidden="true" tabindex="-1"></a>      <span class="va">m_values</span><span class="op">.</span>erase<span class="op">(</span><span class="va">m_values</span><span class="op">.</span>begin<span class="op">());</span></span>
<span id="list:kth_largest_in_stream:set-30"><a href="#list:kth_largest_in_stream:set-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:kth_largest_in_stream:set-31"><a href="#list:kth_largest_in_stream:set-31" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span><span class="va">m_k</span> <span class="op">==</span> <span class="va">m_values</span><span class="op">.</span>size<span class="op">());</span></span>
<span id="list:kth_largest_in_stream:set-32"><a href="#list:kth_largest_in_stream:set-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*(</span><span class="va">m_values</span><span class="op">.</span>begin<span class="op">());</span></span>
<span id="list:kth_largest_in_stream:set-33"><a href="#list:kth_largest_in_stream:set-33" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:kth_largest_in_stream:set-34"><a href="#list:kth_largest_in_stream:set-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:kth_largest_in_stream:set-35"><a href="#list:kth_largest_in_stream:set-35" aria-hidden="true" tabindex="-1"></a> <span class="kw">private</span><span class="op">:</span></span>
<span id="list:kth_largest_in_stream:set-36"><a href="#list:kth_largest_in_stream:set-36" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>multiset<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="va">m_values</span><span class="op">;</span></span>
<span id="list:kth_largest_in_stream:set-37"><a href="#list:kth_largest_in_stream:set-37" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> <span class="va">m_k</span><span class="op">;</span></span>
<span id="list:kth_largest_in_stream:set-38"><a href="#list:kth_largest_in_stream:set-38" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>In Listing <a href="#" data-reference-type="ref" data-reference="">54</a> you can see an implementation using a heap instead. Notice that there is not a dedicated class in C++ for heaps but instead, we can use an array as a container for the elements and then manipulate it by using the heap dedicated functions:</p>
<ul>
<li><p>, to arrange the elements of an array into a heap</p></li>
<li><p>, to add an element to an array assembled by</p></li>
<li><p>, to remove the smallest element from the heap.</p></li>
</ul>
<p>Also notice that Listing <a href="#list:kth_largest_in_stream:heap" data-reference-type="ref" data-reference="list:kth_largest_in_stream:heap">[list:kth_largest_in_stream:heap]</a> uses a slightly different strategy for implementing the two class functions. Specifically</p>
<dl>
<dt><code>initialize(I,K)</code>:</dt>
<dd><p>We insert the first <span class="math inline">\(K\)</span> elements of <span class="math inline">\(I\)</span> into an array that we immediately turn into a heap (using ). At this point we call for all the remaining elements of <span class="math inline">\(I\)</span>.</p>
</dd>
<dt><code>add(n)</code>:</dt>
<dd><p>as for the other solution when <span class="math inline">\(n &lt; m\)</span> the function simply returns the smallest element of <span class="math inline">\(L^K\)</span>. On the other hand when this is not the case, it removed the smallest element of the heap by calling <a href="#fn24" class="footnote-ref" id="fnref24" role="doc-noteref"><sup>24</sup></a> and inserts <span class="math inline">\(n\)</span> by using <a href="#fn25" class="footnote-ref" id="fnref25" role="doc-noteref"><sup>25</sup></a>.</p>
</dd>
</dl>
<div class="sourceCode" id="list:kth_largest_in_stream:heap" data-language="c++" data-caption="Solution to the \textit{$k^{th}$ largest element in a stream problem} using a heap" label="list:kth_largest_in_stream:heap"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:kth_largest_in_stream:heap-1"><a href="#list:kth_largest_in_stream:heap-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;IKThLargestInStream.h&quot;</span></span>
<span id="list:kth_largest_in_stream:heap-2"><a href="#list:kth_largest_in_stream:heap-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:kth_largest_in_stream:heap-3"><a href="#list:kth_largest_in_stream:heap-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> KthLargestInStreamHeap <span class="op">:</span> IKThLargestInStream</span>
<span id="list:kth_largest_in_stream:heap-4"><a href="#list:kth_largest_in_stream:heap-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:kth_largest_in_stream:heap-5"><a href="#list:kth_largest_in_stream:heap-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="list:kth_largest_in_stream:heap-6"><a href="#list:kth_largest_in_stream:heap-6" aria-hidden="true" tabindex="-1"></a>  KthLargestInStreamHeap<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="list:kth_largest_in_stream:heap-7"><a href="#list:kth_largest_in_stream:heap-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> initialize<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> initArray<span class="op">,</span> <span class="at">const</span> <span class="dt">size_t</span> K<span class="op">)</span> <span class="kw">override</span></span>
<span id="list:kth_largest_in_stream:heap-8"><a href="#list:kth_largest_in_stream:heap-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:kth_largest_in_stream:heap-9"><a href="#list:kth_largest_in_stream:heap-9" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>K <span class="op">&lt;=</span> initArray<span class="op">.</span>size<span class="op">());</span></span>
<span id="list:kth_largest_in_stream:heap-10"><a href="#list:kth_largest_in_stream:heap-10" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_k</span> <span class="op">=</span> K<span class="op">;</span></span>
<span id="list:kth_largest_in_stream:heap-11"><a href="#list:kth_largest_in_stream:heap-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:kth_largest_in_stream:heap-12"><a href="#list:kth_largest_in_stream:heap-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> s <span class="op">=</span> begin<span class="op">(</span>initArray<span class="op">);</span></span>
<span id="list:kth_largest_in_stream:heap-13"><a href="#list:kth_largest_in_stream:heap-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> e <span class="op">=</span> begin<span class="op">(</span>initArray<span class="op">)</span> <span class="op">+</span> K<span class="op">;</span></span>
<span id="list:kth_largest_in_stream:heap-14"><a href="#list:kth_largest_in_stream:heap-14" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_values_heap</span><span class="op">.</span>insert<span class="op">(</span>begin<span class="op">(</span><span class="va">m_values_heap</span><span class="op">),</span> s<span class="op">,</span> e<span class="op">);</span></span>
<span id="list:kth_largest_in_stream:heap-15"><a href="#list:kth_largest_in_stream:heap-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>make_heap<span class="op">(</span>begin<span class="op">(</span><span class="va">m_values_heap</span><span class="op">),</span> end<span class="op">(</span><span class="va">m_values_heap</span><span class="op">),</span> <span class="bu">std::</span>greater<span class="op">&lt;&gt;());</span></span>
<span id="list:kth_largest_in_stream:heap-16"><a href="#list:kth_largest_in_stream:heap-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:kth_largest_in_stream:heap-17"><a href="#list:kth_largest_in_stream:heap-17" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>K <span class="op">==</span> <span class="va">m_values_heap</span><span class="op">.</span>size<span class="op">());</span></span>
<span id="list:kth_largest_in_stream:heap-18"><a href="#list:kth_largest_in_stream:heap-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:kth_largest_in_stream:heap-19"><a href="#list:kth_largest_in_stream:heap-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>e <span class="op">!=</span> end<span class="op">(</span>initArray<span class="op">))</span></span>
<span id="list:kth_largest_in_stream:heap-20"><a href="#list:kth_largest_in_stream:heap-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:kth_largest_in_stream:heap-21"><a href="#list:kth_largest_in_stream:heap-21" aria-hidden="true" tabindex="-1"></a>      add<span class="op">(*</span>e<span class="op">);</span></span>
<span id="list:kth_largest_in_stream:heap-22"><a href="#list:kth_largest_in_stream:heap-22" aria-hidden="true" tabindex="-1"></a>      <span class="op">++</span>e<span class="op">;</span></span>
<span id="list:kth_largest_in_stream:heap-23"><a href="#list:kth_largest_in_stream:heap-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:kth_largest_in_stream:heap-24"><a href="#list:kth_largest_in_stream:heap-24" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>K <span class="op">==</span> <span class="va">m_values_heap</span><span class="op">.</span>size<span class="op">());</span></span>
<span id="list:kth_largest_in_stream:heap-25"><a href="#list:kth_largest_in_stream:heap-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:kth_largest_in_stream:heap-26"><a href="#list:kth_largest_in_stream:heap-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:kth_largest_in_stream:heap-27"><a href="#list:kth_largest_in_stream:heap-27" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> add<span class="op">(</span><span class="at">const</span> <span class="dt">int</span> n<span class="op">)</span> <span class="kw">override</span></span>
<span id="list:kth_largest_in_stream:heap-28"><a href="#list:kth_largest_in_stream:heap-28" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:kth_largest_in_stream:heap-29"><a href="#list:kth_largest_in_stream:heap-29" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span><span class="va">m_k</span> <span class="op">==</span> <span class="va">m_values_heap</span><span class="op">.</span>size<span class="op">());</span></span>
<span id="list:kth_largest_in_stream:heap-30"><a href="#list:kth_largest_in_stream:heap-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="va">m_values_heap</span><span class="op">.</span>front<span class="op">())</span></span>
<span id="list:kth_largest_in_stream:heap-31"><a href="#list:kth_largest_in_stream:heap-31" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="va">m_values_heap</span><span class="op">.</span>front<span class="op">();</span></span>
<span id="list:kth_largest_in_stream:heap-32"><a href="#list:kth_largest_in_stream:heap-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>pop_heap<span class="op">(</span>begin<span class="op">(</span><span class="va">m_values_heap</span><span class="op">),</span> end<span class="op">(</span><span class="va">m_values_heap</span><span class="op">),</span> <span class="bu">std::</span>greater<span class="op">&lt;&gt;());</span></span>
<span id="list:kth_largest_in_stream:heap-33"><a href="#list:kth_largest_in_stream:heap-33" aria-hidden="true" tabindex="-1"></a>    <span class="va">m_values_heap</span><span class="op">.</span>back<span class="op">()</span> <span class="op">=</span> n<span class="op">;</span></span>
<span id="list:kth_largest_in_stream:heap-34"><a href="#list:kth_largest_in_stream:heap-34" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>push_heap<span class="op">(</span>begin<span class="op">(</span><span class="va">m_values_heap</span><span class="op">),</span> end<span class="op">(</span><span class="va">m_values_heap</span><span class="op">),</span> <span class="bu">std::</span>greater<span class="op">&lt;&gt;());</span></span>
<span id="list:kth_largest_in_stream:heap-35"><a href="#list:kth_largest_in_stream:heap-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:kth_largest_in_stream:heap-36"><a href="#list:kth_largest_in_stream:heap-36" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span><span class="va">m_k</span> <span class="op">==</span> <span class="va">m_values_heap</span><span class="op">.</span>size<span class="op">());</span></span>
<span id="list:kth_largest_in_stream:heap-37"><a href="#list:kth_largest_in_stream:heap-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">m_values_heap</span><span class="op">.</span>front<span class="op">();</span></span>
<span id="list:kth_largest_in_stream:heap-38"><a href="#list:kth_largest_in_stream:heap-38" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:kth_largest_in_stream:heap-39"><a href="#list:kth_largest_in_stream:heap-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:kth_largest_in_stream:heap-40"><a href="#list:kth_largest_in_stream:heap-40" aria-hidden="true" tabindex="-1"></a> <span class="kw">private</span><span class="op">:</span></span>
<span id="list:kth_largest_in_stream:heap-41"><a href="#list:kth_largest_in_stream:heap-41" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="va">m_values_heap</span><span class="op">;</span></span>
<span id="list:kth_largest_in_stream:heap-42"><a href="#list:kth_largest_in_stream:heap-42" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> <span class="va">m_k</span><span class="op">;</span></span>
<span id="list:kth_largest_in_stream:heap-43"><a href="#list:kth_largest_in_stream:heap-43" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h1 id="ch:find_k_closest_in_array">Find the <span class="math inline">\(K\)</span> closest elements</h1>
<h2 class="unnumbered" id="introduction-33">Introduction</h2>
<p>In this chapter we are going to discuss a problem that asks you to return a subset of a given input array. We will investigate two solutions: one that is based on sorting and the other on binary search with the latter being more efficient than the former because we will make good use of the fact that the input is going to be provided already sorted. As we will see the solution based on sorting is going to be almost trivial to and we will be able to derive it directly from the problem statement while the solution based on binary search requires slightly more brain work and typing to get it right. We will present two different implementations of the binary search solution:</p>
<div class="enumerate*">
<p>the first based entirely the C++ STL,</p>
<p>and the other where we will code the binary search algorithm explicitly.</p>
</div>
<h2 id="problem-statement-35">Problem statement</h2>
<div class="exercise">
<p>Write a function that takes as input</p>
<div class="itemize*">
<p>a sorted array <span class="math inline">\(I\)</span> and two integers</p>
<p><span class="math inline">\(k\)</span> and</p>
<p><span class="math inline">\(x\)</span>,</p>
</div>
<p>and returns an array, sorted in ascending order, containing the <span class="math inline">\(k\)</span> elements that are closest to <span class="math inline">\(x\)</span> in <span class="math inline">\(I\)</span>. Note that: given two elements <span class="math inline">\(y\)</span>, and <span class="math inline">\(z\)</span>, <span class="math inline">\(y\)</span> is closer to <span class="math inline">\(x\)</span> than <span class="math inline">\(z\)</span> if: <span class="math display">\[|x-y| &lt; |x-z|
	\label{eq:kclosest_in_array:sort_criteria}\]</span></p>
<div class="example">
<p><br />
Given</p>
<div class="itemize*">
<p><span class="math inline">\(I = \{1,2,3,4,5\}\)</span>,</p>
<p><span class="math inline">\(k=4\)</span> and</p>
<p><span class="math inline">\(x=3\)</span>,</p>
</div>
<p>the function returns: <span class="math inline">\(\{2,3,4,5\}\)</span></p>
</div>
<div class="example">
<p><br />
Given</p>
<div class="itemize*">
<p><span class="math inline">\(I = \{1,2,3,4,5\}\)</span>,</p>
<p><span class="math inline">\(k=4\)</span> and</p>
<p><span class="math inline">\(x=-1\)</span>,</p>
</div>
<p>the function returns: <span class="math inline">\(\{1,2,3,4\}\)</span></p>
</div>
<div class="example">
<p><br />
Given</p>
<div class="itemize*">
<p><span class="math inline">\(I = \{12,16,26,30,35,39,42,46,48,50,53,55,56\}\)</span>,</p>
<p><span class="math inline">\(k=5\)</span> and</p>
<p><span class="math inline">\(x=36\)</span>,</p>
</div>
<p>the function returns: <span class="math inline">\(\{26,30,35,39,42\}\)</span></p>
</div>
</div>
<h2 id="clarification-questions-28">Clarification Questions</h2>
<div class="QandA">
<p>What should be the function behavior when resolving ties? What do to when you have two elements that are at the same distance from <span class="math inline">\(x\)</span>?</p>
<div class="answered">
<p><em>The function should always favor the smaller element in case of a tie.</em></p>
</div>
<p>Is I guaranteed to be sorted in ascending order?</p>
<div class="answered">
<p><em>Yes you can assume <span class="math inline">\(I\)</span> to always sorted in ascending order.</em></p>
</div>
</div>
<h2 id="sec:find_k_closest_in_array:sorting">Sorting</h2>
<p>A solution that almost immediately follows from the problem statement is based on the idea of sorting the elements of <span class="math inline">\(I\)</span> according to the criteria shown in Equation <a href="#eq:kclosest_in_array:sort_criteria" data-reference-type="ref" data-reference="eq:kclosest_in_array:sort_criteria">[eq:kclosest_in_array:sort_criteria]</a>. The idea is that if <span class="math inline">\(I\)</span> is sorted according to the absolute value of the different between each number of <span class="math inline">\(I\)</span> and <span class="math inline">\(x\)</span> then, the closest number to <span class="math inline">\(x\)</span> will be located, after the sorting at the front of <span class="math inline">\(I\)</span>. All is necessary at that point is to copy the first <span class="math inline">\(K\)</span> element of <span class="math inline">\(I\)</span> into the return array. Listing <a href="#list:find_k_closest_in_array1" data-reference-type="ref" data-reference="list:find_k_closest_in_array1">[list:find_k_closest_in_array1]</a> shows a possible implementation of such idea.</p>
<div class="sourceCode" id="list:find_k_closest_in_array1" data-language="c++" data-caption="Solution to the problem of finding the $k$ closest element using sorting." label="list:find_k_closest_in_array1"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:find_k_closest_in_array1-1"><a href="#list:find_k_closest_in_array1-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> kth_closest_in_array_sorting<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> I<span class="op">,</span></span>
<span id="list:find_k_closest_in_array1-2"><a href="#list:find_k_closest_in_array1-2" aria-hidden="true" tabindex="-1"></a>                                              <span class="at">const</span> <span class="dt">int</span> k<span class="op">,</span></span>
<span id="list:find_k_closest_in_array1-3"><a href="#list:find_k_closest_in_array1-3" aria-hidden="true" tabindex="-1"></a>                                              <span class="at">const</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="list:find_k_closest_in_array1-4"><a href="#list:find_k_closest_in_array1-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:find_k_closest_in_array1-5"><a href="#list:find_k_closest_in_array1-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>I<span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;=</span> k<span class="op">);</span></span>
<span id="list:find_k_closest_in_array1-6"><a href="#list:find_k_closest_in_array1-6" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>sort<span class="op">(</span>begin<span class="op">(</span>I<span class="op">),</span> end<span class="op">(</span>I<span class="op">),</span> <span class="op">[</span>x<span class="op">](</span><span class="at">const</span> <span class="kw">auto</span> y<span class="op">,</span> <span class="at">const</span> <span class="kw">auto</span> z<span class="op">)</span> <span class="op">{</span></span>
<span id="list:find_k_closest_in_array1-7"><a href="#list:find_k_closest_in_array1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>abs<span class="op">(</span>x <span class="op">-</span> y<span class="op">)</span> <span class="op">&lt;</span> <span class="bu">std::</span>abs<span class="op">(</span>x <span class="op">-</span> z<span class="op">);</span></span>
<span id="list:find_k_closest_in_array1-8"><a href="#list:find_k_closest_in_array1-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">});</span></span>
<span id="list:find_k_closest_in_array1-9"><a href="#list:find_k_closest_in_array1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:find_k_closest_in_array1-10"><a href="#list:find_k_closest_in_array1-10" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> ans<span class="op">{</span>begin<span class="op">(</span>I<span class="op">),</span> begin<span class="op">(</span>I<span class="op">)</span> <span class="op">+</span> k<span class="op">};</span></span>
<span id="list:find_k_closest_in_array1-11"><a href="#list:find_k_closest_in_array1-11" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>sort<span class="op">(</span>begin<span class="op">(</span>ans<span class="op">),</span> end<span class="op">(</span>ans<span class="op">));</span></span>
<span id="list:find_k_closest_in_array1-12"><a href="#list:find_k_closest_in_array1-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:find_k_closest_in_array1-13"><a href="#list:find_k_closest_in_array1-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Please note that as in all cases where you actually do not need to have the whole array sorted you can use partial sorting instead of full-fledged sorting. In all cases where <span class="math inline">\(k\)</span> is smaller that <span class="math inline">\(n\)</span> the complexity is going to be slightly better as we will go from the <span class="math inline">\(O(nlog(n))\)</span> of the normal sorting to <span class="math inline">\(O(nlog(k))\)</span> of the partial sort. Fortunately, making this change in C++ is extremely easily and it is only matter of calling instead of as shown in Listing <a href="#list:find_k_closest_in_array2" data-reference-type="ref" data-reference="list:find_k_closest_in_array2">[list:find_k_closest_in_array2]</a>.</p>
<div class="sourceCode" id="list:find_k_closest_in_array1" data-language="c++" data-caption="Solution to the problem of finding the $k$ closest element using sorting." label="list:find_k_closest_in_array1"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:find_k_closest_in_array1-1"><a href="#list:find_k_closest_in_array1-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> kth_closest_in_array_partial_sorting<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> I<span class="op">,</span></span>
<span id="list:find_k_closest_in_array1-2"><a href="#list:find_k_closest_in_array1-2" aria-hidden="true" tabindex="-1"></a>                                                      <span class="at">const</span> <span class="dt">int</span> k<span class="op">,</span></span>
<span id="list:find_k_closest_in_array1-3"><a href="#list:find_k_closest_in_array1-3" aria-hidden="true" tabindex="-1"></a>                                                      <span class="at">const</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="list:find_k_closest_in_array1-4"><a href="#list:find_k_closest_in_array1-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:find_k_closest_in_array1-5"><a href="#list:find_k_closest_in_array1-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>I<span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;=</span> k<span class="op">);</span></span>
<span id="list:find_k_closest_in_array1-6"><a href="#list:find_k_closest_in_array1-6" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>partial_sort<span class="op">(</span></span>
<span id="list:find_k_closest_in_array1-7"><a href="#list:find_k_closest_in_array1-7" aria-hidden="true" tabindex="-1"></a>      begin<span class="op">(</span>I<span class="op">),</span> begin<span class="op">(</span>I<span class="op">)</span> <span class="op">+</span> k<span class="op">,</span> end<span class="op">(</span>I<span class="op">),</span> <span class="op">[</span>x<span class="op">](</span><span class="at">const</span> <span class="kw">auto</span> y<span class="op">,</span> <span class="at">const</span> <span class="kw">auto</span> z<span class="op">)</span> <span class="op">{</span></span>
<span id="list:find_k_closest_in_array1-8"><a href="#list:find_k_closest_in_array1-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>abs<span class="op">(</span>x <span class="op">-</span> y<span class="op">)</span> <span class="op">&lt;</span> <span class="bu">std::</span>abs<span class="op">(</span>x <span class="op">-</span> z<span class="op">);</span></span>
<span id="list:find_k_closest_in_array1-9"><a href="#list:find_k_closest_in_array1-9" aria-hidden="true" tabindex="-1"></a>      <span class="op">});</span></span>
<span id="list:find_k_closest_in_array1-10"><a href="#list:find_k_closest_in_array1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:find_k_closest_in_array1-11"><a href="#list:find_k_closest_in_array1-11" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> ans<span class="op">{</span>begin<span class="op">(</span>I<span class="op">),</span> begin<span class="op">(</span>I<span class="op">)</span> <span class="op">+</span> k<span class="op">};</span></span>
<span id="list:find_k_closest_in_array1-12"><a href="#list:find_k_closest_in_array1-12" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>sort<span class="op">(</span>begin<span class="op">(</span>ans<span class="op">),</span> end<span class="op">(</span>ans<span class="op">));</span></span>
<span id="list:find_k_closest_in_array1-13"><a href="#list:find_k_closest_in_array1-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:find_k_closest_in_array1-14"><a href="#list:find_k_closest_in_array1-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="find_k_closest_in_array:sec:binary_search">Binary Search</h3>
<p>The problem description clearly state the fact that the input array is sorted but, the solution we devised in Section <a href="#sec:find_k_closest_in_array:sorting" data-reference-type="ref" data-reference="sec:find_k_closest_in_array:sorting">35.3</a> is not taking advantage of it at all. In fact all it does is invalidating the original ordering so to enforce a different one. Everytime the problem statement mention that some input is sorted, you should think how to use such constraint to device a more efficient solution rather than questioning whether that information is useful or not because no useless information is part of the problem statement. Usually when sorted input is involved, there are a bunch of algorithms that should come to mind immediately. Out of this set, binary search is probably going to be one of the firsts. But how can binary search be applied to this problem?</p>
<p>Let’s take a step back and try to analyze the problem for a slightly different angle. In particular, let’s discuss the case where <span class="math inline">\(x \in \: I\)</span>. In this case we know for sure that <span class="math inline">\(x\)</span> is going to be part of the output vector. Because the input is sorted we can use binary search to search for <span class="math inline">\(x\)</span> in <span class="math inline">\(I\)</span>. Once we have identified the index <span class="math inline">\(j\)</span> such that <span class="math inline">\(I_j = x\)</span> we know that the closest element to <span class="math inline">\(x\)</span> must either be at index <span class="math inline">\(j+1\)</span> or <span class="math inline">\(j-1\)</span> <a href="#fn26" class="footnote-ref" id="fnref26" role="doc-noteref"><sup>26</sup></a>. Therefore once <span class="math inline">\(x\)</span> has been identified we can select a range of <span class="math inline">\(k\)</span> elements "centered" at <span class="math inline">\(j\)</span>. Said range can be found by using a two pointers tecnique. We start by initializing two pointers <span class="math inline">\(l = j\)</span> and <span class="math inline">\(r = j\)</span>. THen until <span class="math inline">\(r-l+1
	&lt; k\)</span> we do one of the following operations:</p>
<ul>
<li><p>if <span class="math inline">\(l = 0\)</span> then <span class="math inline">\(r = r+1\)</span></p></li>
<li><p>if <span class="math inline">\(r = |I|\)</span> then <span class="math inline">\(l = l-1\)</span></p></li>
<li><p>if<span class="math inline">\(x-I_{l-1} &gt; I_{r+1}-x\)</span> then <span class="math inline">\(r = r+1\)</span>. The range is enlarged at the its right end side.</p></li>
<li><p>symmetrically for the left side: if <span class="math inline">\(x-I_{l-1} &gt; I_{r+1}-x\)</span> then <span class="math inline">\(l + l+1\)</span>. The range is enlarged at its left end side.</p></li>
</ul>
<p>In other words once <span class="math inline">\(x\)</span> has been found, we incrementally include elements around it, by always choosing between the closest numbers to <span class="math inline">\(x\)</span> between the numbers pointed by the two pointers.</p>
<p>This approach can be easily extended to the case where <span class="math inline">\(x\)</span> is not present in the input array as it also work when we try to build the range of elements to be returned around the closest element to <span class="math inline">\(x\)</span> in the array. Turns out that binary search can be used to find such an element (we even have STL support for such operation). In particular we can use it to identify the index of the first element that is larger or equal than <span class="math inline">\(x\)</span>: a value that is commonly known as <em>lower bound</em>. Armed with this information let’s have a look at Listing <a href="#list:find_k_closest_in_array2" data-reference-type="ref" data-reference="list:find_k_closest_in_array2">[list:find_k_closest_in_array2]</a> showing the implementation of the idea above where we use the STL function to find the index <span class="math inline">\(o\)</span> of the first element greater or equal than <span class="math inline">\(x\)</span>. We then compare such value with the value at index <span class="math inline">\(p = o-1\)</span> (if exists) and we promote <span class="math inline">\(o\)</span> or <span class="math inline">\(p\)</span> to be the index to closest element to <span class="math inline">\(x\)</span> in the array depending on their absolute difference to <span class="math inline">\(x\)</span>. The closest of the two to <span class="math inline">\(x\)</span> is chosen to be the designated starting value for the algorithm described above.</p>
<div class="sourceCode" id="list:find_k_closest_in_array2" data-language="c++" data-caption="Solution to the problem of finding the $k$ closest element using \inline{std::lower\_bound}." label="list:find_k_closest_in_array2"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:find_k_closest_in_array2-1"><a href="#list:find_k_closest_in_array2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Iterator<span class="op">&gt;</span></span>
<span id="list:find_k_closest_in_array2-2"><a href="#list:find_k_closest_in_array2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> find_range<span class="op">(</span></span>
<span id="list:find_k_closest_in_array2-3"><a href="#list:find_k_closest_in_array2-3" aria-hidden="true" tabindex="-1"></a>    Iterator begin<span class="op">,</span> Iterator end<span class="op">,</span> Iterator closest<span class="op">,</span> <span class="dt">int</span> k<span class="op">,</span> <span class="at">const</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="list:find_k_closest_in_array2-4"><a href="#list:find_k_closest_in_array2-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:find_k_closest_in_array2-5"><a href="#list:find_k_closest_in_array2-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>begin <span class="op">&lt;</span> end<span class="op">);</span></span>
<span id="list:find_k_closest_in_array2-6"><a href="#list:find_k_closest_in_array2-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>closest <span class="op">&gt;=</span> begin<span class="op">);</span></span>
<span id="list:find_k_closest_in_array2-7"><a href="#list:find_k_closest_in_array2-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>closest <span class="op">&lt;</span> end<span class="op">);</span></span>
<span id="list:find_k_closest_in_array2-8"><a href="#list:find_k_closest_in_array2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:find_k_closest_in_array2-9"><a href="#list:find_k_closest_in_array2-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> l          <span class="op">=</span> closest<span class="op">;</span></span>
<span id="list:find_k_closest_in_array2-10"><a href="#list:find_k_closest_in_array2-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> r          <span class="op">=</span> l <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:find_k_closest_in_array2-11"><a href="#list:find_k_closest_in_array2-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> difference <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> <span class="kw">auto</span> x<span class="op">,</span> <span class="at">const</span> <span class="kw">auto</span> y<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="bu">std::</span>abs<span class="op">(</span>x <span class="op">-</span> y<span class="op">);</span> <span class="op">};</span></span>
<span id="list:find_k_closest_in_array2-12"><a href="#list:find_k_closest_in_array2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:find_k_closest_in_array2-13"><a href="#list:find_k_closest_in_array2-13" aria-hidden="true" tabindex="-1"></a>  k<span class="op">--;</span>  <span class="co">// closest is already included in the range</span></span>
<span id="list:find_k_closest_in_array2-14"><a href="#list:find_k_closest_in_array2-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>k <span class="op">&amp;&amp;</span> l <span class="op">&gt;</span> begin <span class="op">&amp;&amp;</span> r <span class="op">&lt;</span> end<span class="op">)</span></span>
<span id="list:find_k_closest_in_array2-15"><a href="#list:find_k_closest_in_array2-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:find_k_closest_in_array2-16"><a href="#list:find_k_closest_in_array2-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>difference<span class="op">(*(</span>l <span class="op">-</span> <span class="dv">1</span><span class="op">),</span> x<span class="op">)</span> <span class="op">&lt;=</span> difference<span class="op">(*</span>r<span class="op">,</span> x<span class="op">))</span></span>
<span id="list:find_k_closest_in_array2-17"><a href="#list:find_k_closest_in_array2-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:find_k_closest_in_array2-18"><a href="#list:find_k_closest_in_array2-18" aria-hidden="true" tabindex="-1"></a>      l<span class="op">--;</span></span>
<span id="list:find_k_closest_in_array2-19"><a href="#list:find_k_closest_in_array2-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:find_k_closest_in_array2-20"><a href="#list:find_k_closest_in_array2-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="list:find_k_closest_in_array2-21"><a href="#list:find_k_closest_in_array2-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:find_k_closest_in_array2-22"><a href="#list:find_k_closest_in_array2-22" aria-hidden="true" tabindex="-1"></a>      r<span class="op">++;</span></span>
<span id="list:find_k_closest_in_array2-23"><a href="#list:find_k_closest_in_array2-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:find_k_closest_in_array2-24"><a href="#list:find_k_closest_in_array2-24" aria-hidden="true" tabindex="-1"></a>    k<span class="op">--;</span></span>
<span id="list:find_k_closest_in_array2-25"><a href="#list:find_k_closest_in_array2-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:find_k_closest_in_array2-26"><a href="#list:find_k_closest_in_array2-26" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>k <span class="op">&amp;&amp;</span> l <span class="op">&gt;</span> begin<span class="op">)</span></span>
<span id="list:find_k_closest_in_array2-27"><a href="#list:find_k_closest_in_array2-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:find_k_closest_in_array2-28"><a href="#list:find_k_closest_in_array2-28" aria-hidden="true" tabindex="-1"></a>    l<span class="op">--;</span></span>
<span id="list:find_k_closest_in_array2-29"><a href="#list:find_k_closest_in_array2-29" aria-hidden="true" tabindex="-1"></a>    k<span class="op">--;</span></span>
<span id="list:find_k_closest_in_array2-30"><a href="#list:find_k_closest_in_array2-30" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:find_k_closest_in_array2-31"><a href="#list:find_k_closest_in_array2-31" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>k <span class="op">&amp;&amp;</span> r <span class="op">&lt;</span> end<span class="op">)</span></span>
<span id="list:find_k_closest_in_array2-32"><a href="#list:find_k_closest_in_array2-32" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:find_k_closest_in_array2-33"><a href="#list:find_k_closest_in_array2-33" aria-hidden="true" tabindex="-1"></a>    r<span class="op">++;</span></span>
<span id="list:find_k_closest_in_array2-34"><a href="#list:find_k_closest_in_array2-34" aria-hidden="true" tabindex="-1"></a>    k<span class="op">--;</span></span>
<span id="list:find_k_closest_in_array2-35"><a href="#list:find_k_closest_in_array2-35" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:find_k_closest_in_array2-36"><a href="#list:find_k_closest_in_array2-36" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>k <span class="op">==</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="list:find_k_closest_in_array2-37"><a href="#list:find_k_closest_in_array2-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:find_k_closest_in_array2-38"><a href="#list:find_k_closest_in_array2-38" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">std::</span>make_tuple<span class="op">(</span>l<span class="op">,</span> r<span class="op">);</span></span>
<span id="list:find_k_closest_in_array2-39"><a href="#list:find_k_closest_in_array2-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:find_k_closest_in_array2-40"><a href="#list:find_k_closest_in_array2-40" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> kth_closest_in_array_binary_search_lower_bound<span class="op">(</span></span>
<span id="list:find_k_closest_in_array2-41"><a href="#list:find_k_closest_in_array2-41" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> I<span class="op">,</span> <span class="at">const</span> <span class="dt">int</span> k<span class="op">,</span> <span class="at">const</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="list:find_k_closest_in_array2-42"><a href="#list:find_k_closest_in_array2-42" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:find_k_closest_in_array2-43"><a href="#list:find_k_closest_in_array2-43" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> closest <span class="op">=</span> <span class="bu">std::</span>lower_bound<span class="op">(</span>begin<span class="op">(</span>I<span class="op">),</span> end<span class="op">(</span>I<span class="op">),</span> x<span class="op">);</span></span>
<span id="list:find_k_closest_in_array2-44"><a href="#list:find_k_closest_in_array2-44" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> prec <span class="op">=</span> <span class="bu">std::</span>prev<span class="op">(</span>closest<span class="op">);</span></span>
<span id="list:find_k_closest_in_array2-45"><a href="#list:find_k_closest_in_array2-45" aria-hidden="true" tabindex="-1"></a>      closest <span class="op">!=</span> begin<span class="op">(</span>I<span class="op">)</span> <span class="op">&amp;&amp;</span> closest <span class="op">!=</span> end<span class="op">(</span>I<span class="op">)</span></span>
<span id="list:find_k_closest_in_array2-46"><a href="#list:find_k_closest_in_array2-46" aria-hidden="true" tabindex="-1"></a>      <span class="op">&amp;&amp;</span> <span class="op">(</span><span class="bu">std::</span>abs<span class="op">(*</span>closest <span class="op">-</span> x<span class="op">)</span> <span class="op">&gt;=</span> <span class="bu">std::</span>abs<span class="op">(*</span>prec <span class="op">-</span> x<span class="op">)))</span></span>
<span id="list:find_k_closest_in_array2-47"><a href="#list:find_k_closest_in_array2-47" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:find_k_closest_in_array2-48"><a href="#list:find_k_closest_in_array2-48" aria-hidden="true" tabindex="-1"></a>    closest <span class="op">=</span> prec<span class="op">;</span></span>
<span id="list:find_k_closest_in_array2-49"><a href="#list:find_k_closest_in_array2-49" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:find_k_closest_in_array2-50"><a href="#list:find_k_closest_in_array2-50" aria-hidden="true" tabindex="-1"></a>  <span class="co">// if no element is larger than x</span></span>
<span id="list:find_k_closest_in_array2-51"><a href="#list:find_k_closest_in_array2-51" aria-hidden="true" tabindex="-1"></a>  <span class="co">// then the closest to it is the largest in I</span></span>
<span id="list:find_k_closest_in_array2-52"><a href="#list:find_k_closest_in_array2-52" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>closest <span class="op">==</span> end<span class="op">(</span>I<span class="op">))</span></span>
<span id="list:find_k_closest_in_array2-53"><a href="#list:find_k_closest_in_array2-53" aria-hidden="true" tabindex="-1"></a>    closest <span class="op">=</span> <span class="bu">std::</span>prev<span class="op">(</span>end<span class="op">(</span>I<span class="op">));</span></span>
<span id="list:find_k_closest_in_array2-54"><a href="#list:find_k_closest_in_array2-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:find_k_closest_in_array2-55"><a href="#list:find_k_closest_in_array2-55" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> <span class="op">[</span>l<span class="op">,</span> r<span class="op">]</span> <span class="op">=</span> find_range<span class="op">(</span>begin<span class="op">(</span>I<span class="op">),</span> end<span class="op">(</span>I<span class="op">),</span> closest<span class="op">,</span> k<span class="op">,</span> x<span class="op">);</span></span>
<span id="list:find_k_closest_in_array2-56"><a href="#list:find_k_closest_in_array2-56" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>l<span class="op">,</span> r<span class="op">);</span></span>
<span id="list:find_k_closest_in_array2-57"><a href="#list:find_k_closest_in_array2-57" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>For completeness, in Listing <a href="#list:find_k_closest_in_array:binary_lower_bound" data-reference-type="ref" data-reference="list:find_k_closest_in_array:binary_lower_bound">[list:find_k_closest_in_array:binary_lower_bound]</a> we also show an implementation of "in-house" version of . You might be asked to show you can code binary search.</p>
<div class="sourceCode" id="list:find_k_closest_in_array:binary_lower_bound" data-language="c++" data-caption="Implementation of a function for the calculation of the \textit{lower\_bound} that can be using in substitution of \inline{std::lower\_bound} in Listing \ref{list:find_k_closest_in_array2}." label="list:find_k_closest_in_array:binary_lower_bound"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:find_k_closest_in_array:binary_lower_bound-1"><a href="#list:find_k_closest_in_array:binary_lower_bound-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:find_k_closest_in_array:binary_lower_bound-2"><a href="#list:find_k_closest_in_array:binary_lower_bound-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> It<span class="op">,</span> <span class="kw">typename</span> Target <span class="op">=</span> <span class="kw">typename</span> It<span class="op">::</span><span class="dt">value_type</span><span class="op">&gt;</span></span>
<span id="list:find_k_closest_in_array:binary_lower_bound-3"><a href="#list:find_k_closest_in_array:binary_lower_bound-3" aria-hidden="true" tabindex="-1"></a>It my_lower_bound<span class="op">(</span><span class="at">const</span> It<span class="op">&amp;</span> begin<span class="op">,</span> <span class="at">const</span> It<span class="op">&amp;</span> end<span class="op">,</span> <span class="at">const</span> Target<span class="op">&amp;</span> target<span class="op">)</span></span>
<span id="list:find_k_closest_in_array:binary_lower_bound-4"><a href="#list:find_k_closest_in_array:binary_lower_bound-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:find_k_closest_in_array:binary_lower_bound-5"><a href="#list:find_k_closest_in_array:binary_lower_bound-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> l <span class="op">=</span> begin<span class="op">;</span></span>
<span id="list:find_k_closest_in_array:binary_lower_bound-6"><a href="#list:find_k_closest_in_array:binary_lower_bound-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> r <span class="op">=</span> end<span class="op">;</span></span>
<span id="list:find_k_closest_in_array:binary_lower_bound-7"><a href="#list:find_k_closest_in_array:binary_lower_bound-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>l <span class="op">&lt;</span> r<span class="op">)</span></span>
<span id="list:find_k_closest_in_array:binary_lower_bound-8"><a href="#list:find_k_closest_in_array:binary_lower_bound-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:find_k_closest_in_array:binary_lower_bound-9"><a href="#list:find_k_closest_in_array:binary_lower_bound-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> mid <span class="op">=</span> l <span class="op">+</span> <span class="bu">std::</span>distance<span class="op">(</span>l<span class="op">,</span> r<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="list:find_k_closest_in_array:binary_lower_bound-10"><a href="#list:find_k_closest_in_array:binary_lower_bound-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:find_k_closest_in_array:binary_lower_bound-11"><a href="#list:find_k_closest_in_array:binary_lower_bound-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(*</span>mid <span class="op">&lt;</span> target<span class="op">)</span></span>
<span id="list:find_k_closest_in_array:binary_lower_bound-12"><a href="#list:find_k_closest_in_array:binary_lower_bound-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:find_k_closest_in_array:binary_lower_bound-13"><a href="#list:find_k_closest_in_array:binary_lower_bound-13" aria-hidden="true" tabindex="-1"></a>      l <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:find_k_closest_in_array:binary_lower_bound-14"><a href="#list:find_k_closest_in_array:binary_lower_bound-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:find_k_closest_in_array:binary_lower_bound-15"><a href="#list:find_k_closest_in_array:binary_lower_bound-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="list:find_k_closest_in_array:binary_lower_bound-16"><a href="#list:find_k_closest_in_array:binary_lower_bound-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:find_k_closest_in_array:binary_lower_bound-17"><a href="#list:find_k_closest_in_array:binary_lower_bound-17" aria-hidden="true" tabindex="-1"></a>      r <span class="op">=</span> mid<span class="op">;</span></span>
<span id="list:find_k_closest_in_array:binary_lower_bound-18"><a href="#list:find_k_closest_in_array:binary_lower_bound-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:find_k_closest_in_array:binary_lower_bound-19"><a href="#list:find_k_closest_in_array:binary_lower_bound-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:find_k_closest_in_array:binary_lower_bound-20"><a href="#list:find_k_closest_in_array:binary_lower_bound-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> l<span class="op">;</span></span>
<span id="list:find_k_closest_in_array:binary_lower_bound-21"><a href="#list:find_k_closest_in_array:binary_lower_bound-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="ch:mirror_binary_tree">Binary Tree mirroring</h1>
<h2 class="unnumbered" id="introduction-34">Introduction</h2>
<p>Binary trees are one of the most taught and discussed data structures in computer science courses. A binary tree is a tree-like data structure where each node has at most two children, which we refeer to as right and left children. Trees have been used in computer science for a long time as a mean to accessing data stored within the nodes that are usually arranged in some particular way such that operations like searching for sorting can be performed more efficiently. Examples of such special kind of trees are:</p>
<div class="itemize*">
<p>binary search tree,</p>
<p>binary heap</p>
</div>
<p>But binary trees are often also used to model data haveing an inherently bifurcating structure, where the organization of data into left and right is part of the information we are representing<a href="#fn27" class="footnote-ref" id="fnref27" role="doc-noteref"><sup>27</sup></a>. A tree is recursive a data structure because you can think of it as either being:</p>
<ul>
<li><p>an empty tree</p></li>
<li><p>or a node having a binary tree as left and right children.</p></li>
</ul>
<p>There are many recursive fundamental algorithms on trees described in the literature that built around this definition, and you can expect recursive solutions to questions about trees to be an effective tool during coding interviews. The problem discussed in this chapter is about the manipulation of a binary tree into another binary tree such that the latter is a mirror image of the former. As we will see this question is quite vague as it will be quite unclear what being a mirror really means and it will be imperative for you to clear this aspect up by asking relevant questions and creating a few examples cases (which we provide later in this chapter) that make clear to you what the interviewer is expecting.</p>
<p>The tree definition that we will use thoroughout the chapter is shown in Listing <a href="#list:binary_tree_definition" data-reference-type="ref" data-reference="list:binary_tree_definition">[list:binary_tree_definition]</a>.</p>
<div class="sourceCode" id="list:binary_tree_definition" data-language="c++" data-caption="Definition of the tree data structure using in Chapter \ref{ch:mirror_binary_tree}." label="list:binary_tree_definition"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:binary_tree_definition-1"><a href="#list:binary_tree_definition-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef TEST_MIRROR_BINARY_TREE_BINARY_TREE</span></span>
<span id="list:binary_tree_definition-2"><a href="#list:binary_tree_definition-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define TEST_MIRROR_BINARY_TREE_BINARY_TREE</span></span>
<span id="list:binary_tree_definition-3"><a href="#list:binary_tree_definition-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:binary_tree_definition-4"><a href="#list:binary_tree_definition-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:binary_tree_definition-5"><a href="#list:binary_tree_definition-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node</span>
<span id="list:binary_tree_definition-6"><a href="#list:binary_tree_definition-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:binary_tree_definition-7"><a href="#list:binary_tree_definition-7" aria-hidden="true" tabindex="-1"></a>  Node<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="list:binary_tree_definition-8"><a href="#list:binary_tree_definition-8" aria-hidden="true" tabindex="-1"></a>  Node<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> val<span class="op">)</span> <span class="op">:</span> payload<span class="op">(</span>val<span class="op">),</span> left<span class="op">(</span><span class="kw">nullptr</span><span class="op">),</span> right<span class="op">(</span><span class="kw">nullptr</span><span class="op">){};</span></span>
<span id="list:binary_tree_definition-9"><a href="#list:binary_tree_definition-9" aria-hidden="true" tabindex="-1"></a>  Node <span class="op">*</span>left <span class="op">=</span> <span class="kw">nullptr</span><span class="op">,</span> <span class="op">*</span>right <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="list:binary_tree_definition-10"><a href="#list:binary_tree_definition-10" aria-hidden="true" tabindex="-1"></a>  T payload<span class="op">{};</span></span>
<span id="list:binary_tree_definition-11"><a href="#list:binary_tree_definition-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="list:binary_tree_definition-12"><a href="#list:binary_tree_definition-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:binary_tree_definition-13"><a href="#list:binary_tree_definition-13" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif </span><span class="co">/* TEST_MIRROR_BINARY_TREE_BINARY_TREE */</span></span></code></pre></div>
<h2 id="problem-statement-36">Problem statement</h2>
<div class="exercise">
<p>Write a function that given a binary tree, return mirror copy of it.</p>
<div class="example">
<p><br />
Given the binary tree shown in Figure <a href="#fig:mirro_binary_tree:example1" data-reference-type="ref" data-reference="fig:mirro_binary_tree:example1">36.1</a> the function returns a tree like the one in Figure <a href="#fig:mirro_binary_tree:example1_1" data-reference-type="ref" data-reference="fig:mirro_binary_tree:example1_1">36.2</a> <span id="ex:mirro_binary_tree:example1" label="ex:mirro_binary_tree:example1">[ex:mirro_binary_tree:example1]</span>.</p>
</div>
<div class="example">
<p><br />
Given the binary tree shown in Figure <a href="#fig:mirro_binary_tree:example2" data-reference-type="ref" data-reference="fig:mirro_binary_tree:example2">36.3</a> the function returns a tree like the one in Figure <a href="#fig:mirro_binary_tree:example2_1" data-reference-type="ref" data-reference="fig:mirro_binary_tree:example2_1">36.4</a> <span id="ex:mirro_binary_tree:example2" label="ex:mirro_binary_tree:example2">[ex:mirro_binary_tree:example2]</span></p>
</div>
<div class="example">
<p><br />
Given the binary tree shown in Figure <a href="#fig:mirro_binary_tree:example3" data-reference-type="ref" data-reference="fig:mirro_binary_tree:example3">36.5</a> the function returns a tree like the one in Figure <a href="#fig:mirro_binary_tree:example3_1" data-reference-type="ref" data-reference="fig:mirro_binary_tree:example3_1">36.6</a> <span id="ex:mirro_binary_tree:example3" label="ex:mirro_binary_tree:example3">[ex:mirro_binary_tree:example3]</span></p>
</div>
</div>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/mirror_binary_tree/images/example1.jpg" id="fig:mirro_binary_tree:example1" alt="Input binary tree for the Example [ex:mirro_binary_tree:example1]." /><figcaption aria-hidden="true">Input binary tree for the Example <a href="#ex:mirro_binary_tree:example1" data-reference-type="ref" data-reference="ex:mirro_binary_tree:example1">[ex:mirro_binary_tree:example1]</a>.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/mirror_binary_tree/images/example1_1.jpg" id="fig:mirro_binary_tree:example1_1" alt="Output binary tree for the Example [ex:mirro_binary_tree:example1]." /><figcaption aria-hidden="true">Output binary tree for the Example <a href="#ex:mirro_binary_tree:example1" data-reference-type="ref" data-reference="ex:mirro_binary_tree:example1">[ex:mirro_binary_tree:example1]</a>.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/mirror_binary_tree/images/example2.jpg" id="fig:mirro_binary_tree:example2" alt="Input binary tree for the Example [ex:mirro_binary_tree:example2]." /><figcaption aria-hidden="true">Input binary tree for the Example <a href="#ex:mirro_binary_tree:example2" data-reference-type="ref" data-reference="ex:mirro_binary_tree:example2">[ex:mirro_binary_tree:example2]</a>.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/mirror_binary_tree/images/example2_1.jpg" id="fig:mirro_binary_tree:example2_1" alt="Output binary tree for the Example [ex:mirro_binary_tree:example2]." /><figcaption aria-hidden="true">Output binary tree for the Example <a href="#ex:mirro_binary_tree:example2" data-reference-type="ref" data-reference="ex:mirro_binary_tree:example2">[ex:mirro_binary_tree:example2]</a>.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/mirror_binary_tree/images/example3.jpg" id="fig:mirro_binary_tree:example3" alt="Input binary tree for the Example [ex:mirro_binary_tree:example3]." /><figcaption aria-hidden="true">Input binary tree for the Example <a href="#ex:mirro_binary_tree:example3" data-reference-type="ref" data-reference="ex:mirro_binary_tree:example3">[ex:mirro_binary_tree:example3]</a>.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/mirror_binary_tree/images/example3_1.jpg" id="fig:mirro_binary_tree:example3_1" alt="Output binary tree for the Example [ex:mirro_binary_tree:example3]." /><figcaption aria-hidden="true">Output binary tree for the Example <a href="#ex:mirro_binary_tree:example3" data-reference-type="ref" data-reference="ex:mirro_binary_tree:example3">[ex:mirro_binary_tree:example3]</a>.</figcaption>
</figure>
<h2 id="mirror_binary_tree:sec:discussion">Discussion</h2>
<p>Let’s start our discussion by trying to understand how a mirror copy of a tree really looks like. If we have a tree <span class="math inline">\(T\)</span> rooted at node <span class="math inline">\(n\)</span> then its mirror image can be defined as follows:</p>
<ul>
<li><p><strong>if <span class="math inline">\(n\)</span> has no children:</strong> return <span class="math inline">\(T\)</span>. See Figures <a href="#fig:mirro_binary_tree:leaf" data-reference-type="ref" data-reference="fig:mirro_binary_tree:leaf">36.7</a> and <a href="#fig:mirro_binary_tree:leaf_mirror" data-reference-type="ref" data-reference="fig:mirro_binary_tree:leaf_mirror">36.8</a>.</p></li>
<li><p><strong>if <span class="math inline">\(n\)</span> has one only the left child <span class="math inline">\(n_l\)</span>:</strong> return <span class="math inline">\(T\)</span> having as left child the a mirrored copy of <span class="math inline">\(n_l\)</span>. See Figures <a href="#fig:mirro_binary_tree:single_left" data-reference-type="ref" data-reference="fig:mirro_binary_tree:single_left">36.11</a> and <a href="#fig:mirro_binary_tree:single_left_mirror" data-reference-type="ref" data-reference="fig:mirro_binary_tree:single_left_mirror">36.12</a>.</p></li>
<li><p><strong>if <span class="math inline">\(n\)</span> has one only the left child <span class="math inline">\(n_r\)</span>:</strong> return <span class="math inline">\(T\)</span> having as right child the a mirrored copy of <span class="math inline">\(n_r\)</span>. See Figures <a href="#fig:mirro_binary_tree:single_right" data-reference-type="ref" data-reference="fig:mirro_binary_tree:single_right">36.9</a> and <a href="#fig:mirro_binary_tree:single_right_mirror" data-reference-type="ref" data-reference="fig:mirro_binary_tree:single_right_mirror">36.10</a>.</p></li>
<li><p><strong>if <span class="math inline">\(n\)</span> has both children:</strong> return <span class="math inline">\(T\)</span> having as left child the mirrored copy of its right child <span class="math inline">\(n_r\)</span> and, as right child the mirrored copy of its left child <span class="math inline">\(n_l\)</span>. See Figures <a href="#fig:mirro_binary_tree:tree_only_both_children" data-reference-type="ref" data-reference="fig:mirro_binary_tree:tree_only_both_children">36.13</a> and <a href="#fig:mirro_binary_tree:tree_only_both_children_mirror" data-reference-type="ref" data-reference="fig:mirro_binary_tree:tree_only_both_children_mirror">36.14</a>. Another example of this case can be found in the node <span class="math inline">\(5\)</span> in the Example <a href="#ex:mirro_binary_tree:example1" data-reference-type="ref" data-reference="ex:mirro_binary_tree:example1">[ex:mirro_binary_tree:example1]</a> where its left and right children are first mirrored individually and then swapped.</p></li>
</ul>
<p>This recursive definition can be refined into the following simple idea: In order to create the mirror image of a tree <span class="math inline">\(T\)</span> rooted at <span class="math inline">\(n\)</span> we can first mirror its children individually and only after swap them. Given that we can turn a tree into its mirror image all is necessary is to first create a copy of the origin tree and then mirror it (remember that the problem is asking to return a copy). Listing <a href="#list:mirror_binary_tree1" data-reference-type="ref" data-reference="list:mirror_binary_tree1">[list:mirror_binary_tree1]</a> shows a recursive implementation of such idea.</p>
<div class="sourceCode" id="list:mirror_binary_tree1" data-language="c++" data-caption="Solution to the problem of creating a mirror of a binary tree. Works by first creating a copy of the original tree and only then performing the mirroring." label="list:mirror_binary_tree1"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:mirror_binary_tree1-1"><a href="#list:mirror_binary_tree1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;binary_tree.h&quot;</span></span>
<span id="list:mirror_binary_tree1-2"><a href="#list:mirror_binary_tree1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:mirror_binary_tree1-3"><a href="#list:mirror_binary_tree1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:mirror_binary_tree1-4"><a href="#list:mirror_binary_tree1-4" aria-hidden="true" tabindex="-1"></a>Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> copy_binary_tree<span class="op">(</span><span class="at">const</span> Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> <span class="at">const</span> root<span class="op">)</span></span>
<span id="list:mirror_binary_tree1-5"><a href="#list:mirror_binary_tree1-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:mirror_binary_tree1-6"><a href="#list:mirror_binary_tree1-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>root<span class="op">)</span></span>
<span id="list:mirror_binary_tree1-7"><a href="#list:mirror_binary_tree1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="list:mirror_binary_tree1-8"><a href="#list:mirror_binary_tree1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:mirror_binary_tree1-9"><a href="#list:mirror_binary_tree1-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> root_copy   <span class="op">=</span> <span class="kw">new</span> Node<span class="op">&lt;</span>T<span class="op">&gt;(</span>root<span class="op">-&gt;</span>payload<span class="op">);</span></span>
<span id="list:mirror_binary_tree1-10"><a href="#list:mirror_binary_tree1-10" aria-hidden="true" tabindex="-1"></a>  root_copy<span class="op">-&gt;</span>left  <span class="op">=</span> copy_binary_tree<span class="op">(</span>root<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="list:mirror_binary_tree1-11"><a href="#list:mirror_binary_tree1-11" aria-hidden="true" tabindex="-1"></a>  root_copy<span class="op">-&gt;</span>right <span class="op">=</span> copy_binary_tree<span class="op">(</span>root<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="list:mirror_binary_tree1-12"><a href="#list:mirror_binary_tree1-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> root_copy<span class="op">;</span></span>
<span id="list:mirror_binary_tree1-13"><a href="#list:mirror_binary_tree1-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:mirror_binary_tree1-14"><a href="#list:mirror_binary_tree1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:mirror_binary_tree1-15"><a href="#list:mirror_binary_tree1-15" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:mirror_binary_tree1-16"><a href="#list:mirror_binary_tree1-16" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> mirror_binary_tree_in_place<span class="op">(</span>Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> <span class="at">const</span> node<span class="op">)</span></span>
<span id="list:mirror_binary_tree1-17"><a href="#list:mirror_binary_tree1-17" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:mirror_binary_tree1-18"><a href="#list:mirror_binary_tree1-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> <span class="bu">std::</span>swap<span class="op">;</span></span>
<span id="list:mirror_binary_tree1-19"><a href="#list:mirror_binary_tree1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:mirror_binary_tree1-20"><a href="#list:mirror_binary_tree1-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>node<span class="op">)</span></span>
<span id="list:mirror_binary_tree1-21"><a href="#list:mirror_binary_tree1-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="list:mirror_binary_tree1-22"><a href="#list:mirror_binary_tree1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:mirror_binary_tree1-23"><a href="#list:mirror_binary_tree1-23" aria-hidden="true" tabindex="-1"></a>  mirror_binary_tree_in_place<span class="op">(</span>node<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="list:mirror_binary_tree1-24"><a href="#list:mirror_binary_tree1-24" aria-hidden="true" tabindex="-1"></a>  mirror_binary_tree_in_place<span class="op">(</span>node<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="list:mirror_binary_tree1-25"><a href="#list:mirror_binary_tree1-25" aria-hidden="true" tabindex="-1"></a>  swap<span class="op">(</span>node<span class="op">-&gt;</span>left<span class="op">,</span> node<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="list:mirror_binary_tree1-26"><a href="#list:mirror_binary_tree1-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:mirror_binary_tree1-27"><a href="#list:mirror_binary_tree1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:mirror_binary_tree1-28"><a href="#list:mirror_binary_tree1-28" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:mirror_binary_tree1-29"><a href="#list:mirror_binary_tree1-29" aria-hidden="true" tabindex="-1"></a>Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> mirror_binary_tree<span class="op">(</span><span class="at">const</span> Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> <span class="at">const</span> root<span class="op">)</span></span>
<span id="list:mirror_binary_tree1-30"><a href="#list:mirror_binary_tree1-30" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:mirror_binary_tree1-31"><a href="#list:mirror_binary_tree1-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span><span class="op">&amp;&amp;</span> tree_copy <span class="op">=</span> copy_binary_tree<span class="op">(</span>root<span class="op">);</span></span>
<span id="list:mirror_binary_tree1-32"><a href="#list:mirror_binary_tree1-32" aria-hidden="true" tabindex="-1"></a>  mirror_binary_tree_in_place<span class="op">(</span>tree_copy<span class="op">);</span></span>
<span id="list:mirror_binary_tree1-33"><a href="#list:mirror_binary_tree1-33" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> tree_copy<span class="op">;</span></span>
<span id="list:mirror_binary_tree1-34"><a href="#list:mirror_binary_tree1-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The complexity of the code above is <span class="math inline">\(O(n)\)</span> where <span class="math inline">\(n\)</span> is the number of nodes in <span class="math inline">\(T\)</span>. However, despite it simplify the reasoning and the implementation, splitting the copy and the mirroring steps, is not optimal as we need to traverse the whole tree twice. We can create the copy on the fly as we visit <span class="math inline">\(T\)</span> as shown in Listing <a href="#list:mirror_binary_tree2" data-reference-type="ref" data-reference="list:mirror_binary_tree2">[list:mirror_binary_tree2]</a>. This approach does not lower the asymptotic complexity but, it effectively means that we only need to traverse the original tree only once instead of twice.</p>
<div class="sourceCode" id="list:mirror_binary_tree2" data-language="c++" data-caption="Solution to the problem of creating a mirror of a binary tree. The copy and the mirroring are performed simultaneously while visiting $T$." label="list:mirror_binary_tree2"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:mirror_binary_tree2-1"><a href="#list:mirror_binary_tree2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:mirror_binary_tree2-2"><a href="#list:mirror_binary_tree2-2" aria-hidden="true" tabindex="-1"></a>Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> mirror_binary_tree_on_the_fly<span class="op">(</span>Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> <span class="at">const</span> node<span class="op">)</span></span>
<span id="list:mirror_binary_tree2-3"><a href="#list:mirror_binary_tree2-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:mirror_binary_tree2-4"><a href="#list:mirror_binary_tree2-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>node<span class="op">)</span></span>
<span id="list:mirror_binary_tree2-5"><a href="#list:mirror_binary_tree2-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="list:mirror_binary_tree2-6"><a href="#list:mirror_binary_tree2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:mirror_binary_tree2-7"><a href="#list:mirror_binary_tree2-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> root_mirror   <span class="op">=</span> <span class="kw">new</span> Node<span class="op">&lt;</span>T<span class="op">&gt;(</span>node<span class="op">-&gt;</span>payload<span class="op">);</span></span>
<span id="list:mirror_binary_tree2-8"><a href="#list:mirror_binary_tree2-8" aria-hidden="true" tabindex="-1"></a>  root_mirror<span class="op">-&gt;</span>right <span class="op">=</span> mirror_binary_tree_on_the_fly<span class="op">(</span>node<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="list:mirror_binary_tree2-9"><a href="#list:mirror_binary_tree2-9" aria-hidden="true" tabindex="-1"></a>  root_mirror<span class="op">-&gt;</span>left  <span class="op">=</span> mirror_binary_tree_on_the_fly<span class="op">(</span>node<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="list:mirror_binary_tree2-10"><a href="#list:mirror_binary_tree2-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> root_mirror<span class="op">;</span></span>
<span id="list:mirror_binary_tree2-11"><a href="#list:mirror_binary_tree2-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/mirror_binary_tree/images/leaf.jpg" id="fig:mirro_binary_tree:leaf" alt="Example of single node tree." /><figcaption aria-hidden="true">Example of single node tree.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/mirror_binary_tree/images/leaf.jpg" id="fig:mirro_binary_tree:leaf_mirror" alt="Mirror image of the tree in Figure 36.7." /><figcaption aria-hidden="true">Mirror image of the tree in Figure <a href="#fig:mirro_binary_tree:leaf" data-reference-type="ref" data-reference="fig:mirro_binary_tree:leaf">36.7</a>.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/mirror_binary_tree/images/tree_only_right_child.jpg" id="fig:mirro_binary_tree:single_right" alt="Example of node with a single child: the right one." /><figcaption aria-hidden="true">Example of node with a single child: the right one.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/mirror_binary_tree/images/tree_only_right_child_mirror.jpg" id="fig:mirro_binary_tree:single_right_mirror" alt="Mirror image of the tree in Figure 36.9." /><figcaption aria-hidden="true">Mirror image of the tree in Figure <a href="#fig:mirro_binary_tree:single_right" data-reference-type="ref" data-reference="fig:mirro_binary_tree:single_right">36.9</a>.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/mirror_binary_tree/images/tree_only_right_child_mirror.jpg" id="fig:mirro_binary_tree:single_left" alt="Example of node with a single child: the left one." /><figcaption aria-hidden="true">Example of node with a single child: the left one.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/mirror_binary_tree/images/tree_only_right_child.jpg" id="fig:mirro_binary_tree:single_left_mirror" alt="Mirror image of the tree in Figure 36.9." /><figcaption aria-hidden="true">Mirror image of the tree in Figure <a href="#fig:mirro_binary_tree:single_right" data-reference-type="ref" data-reference="fig:mirro_binary_tree:single_right">36.9</a>.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/mirror_binary_tree/images/tree_only_both_children.jpg" id="fig:mirro_binary_tree:tree_only_both_children" alt="Example of node with a single child: the left one." /><figcaption aria-hidden="true">Example of node with a single child: the left one.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/mirror_binary_tree/images/tree_only_both_children_mirror.jpg" id="fig:mirro_binary_tree:tree_only_both_children_mirror" alt="Mirror image of the tree in Figure 36.13." /><figcaption aria-hidden="true">Mirror image of the tree in Figure <a href="#fig:mirro_binary_tree:tree_only_both_children" data-reference-type="ref" data-reference="fig:mirro_binary_tree:tree_only_both_children">36.13</a>.</figcaption>
</figure>
<h1 id="ch:number_islands">Count the number of islands</h1>
<p>In this chapter we are going to discuss a classical interview problem question. The problem asks you to count the number islands on a map that is given to you as a 2D boolean matrix. There are many version of the statements for this problem, some with for instance more wordy and playful background story and others where the map is given to you as graph of some sort. Thankfully all of those versions can be solved with the approaches we will present below. The solutions presented are based on textbook graph visiting algorithms.</p>
<h2 id="problem-statement-37">Problem statement</h2>
<div class="exercise">
<p>Write a function that given a <span class="math inline">\(2\)</span>D boolean matrix counts the number of islands in the grid. Cells in the input matrix containing a <span class="math inline">\(1\)</span> represent land while <span class="math inline">\(0\)</span> water. An island is a group of adjacent land cells. Every cell in the input matrix can be adjacent to the <span class="math inline">\(4\)</span> cells that are next to it on the same row or column.</p>
<p>The input grid is a 2D of size <span class="math inline">\(n\times m\)</span>.</p>
<div class="example">
<p><br />
Given the following input grid (depicted in Figure <a href="#fig:number_islands:example1" data-reference-type="ref" data-reference="fig:number_islands:example1">37.1</a>) the function return <span class="math inline">\(4\)</span>. The text representation of this example is given below where <span class="math inline">\(1\)</span> represents land, and a <span class="math inline">\(0\)</span> water:</p>
<pre><code>	1110000
	0100000
	0110110
	0010110
	0100000
	0110010
	0011000
	</code></pre>
</div>
</div>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/number_islands/images/example1.png" id="fig:number_islands:example1" alt="Visual representation of the example 1 for the problem of counting the number of islands in a map. Cells belonging to the same island share the same color." /><figcaption aria-hidden="true">Visual representation of the example 1 for the problem of counting the number of islands in a map. Cells belonging to the same island share the same color.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/number_islands/images/visited.png" id="fig:number_islands:example1_visited" alt="Visual representation of the example 1 after visiting the cells of the first island." /><figcaption aria-hidden="true">Visual representation of the example 1 after visiting the cells of the first island.</figcaption>
</figure>
<h2 id="clarification-questions-29">Clarification Questions</h2>
<div class="QandA">
<p>Can <span class="math inline">\(n\)</span> or <span class="math inline">\(m\)</span> be <span class="math inline">\(0\)</span>?</p>
<div class="answered">
<p><em>Yes, the map can be empty</em></p>
</div>
<p>Can the input grid be modified?</p>
<div class="answered">
<p><em>Yes, the input matrix is not read-only.</em></p>
</div>
</div>
<h2 id="number_islands:sec:discussion">Discussion</h2>
<p>In simple words what this problem is asking us is to identify the numbers of clusters of <span class="math inline">\(1\)</span>s in the input matrix. One way to do so is by looping thought the map one cell at a time until we find a <span class="math inline">\(1\)</span>, let’s say at cell <span class="math inline">\((i,j)\)</span>. Because this particular <span class="math inline">\(1\)</span> must be part of an island, then what we can do is to start exploring the island one cell at a time, moving from a <span class="math inline">\(1\)</span> to an adjacent one, until there is no more <span class="math inline">\(1\)</span>s we have not already visited. When we visit a land cell we mark it as "visited". This will be useful because, when we resume our normal linear scanning of the map, we want to make sure we do not count the visited cells as being the starting point of an uncounted island. For instance w.r.t. the example in Figure <a href="#fig:number_islands:example1" data-reference-type="ref" data-reference="fig:number_islands:example1">37.1</a> we can start our visit at cell <span class="math inline">\((0,0)\)</span> which is a <span class="math inline">\(1\)</span> and it is not visited yet. This means that this particular cell is part of a island that we did not count yet. At this point we can start visiting the cells adjacent to <span class="math inline">\((0,0)\)</span> i.e. cells: <span class="math inline">\((0,0), (0,1), (0,2), (1,1), (2,1), (2,2), (3,2)\)</span>. When a cell is visited is marked as shown in Figure <a href="#fig:number_islands:visited" data-reference-type="ref" data-reference="fig:number_islands:visited">[fig:number_islands:visited]</a> by the red cross <span style="color: 860000"><span class="math inline">\(\times\)</span></span> and after all of its neighboring land cell are visited similarly in a recursive manner. When we have exhausted all the cells of the island <span class="math inline">\((0,0)\)</span> is part of, we can resume our linear search remembering we have explored an additional island.</p>
<p>The visit can be performed using a BFS or DFS approach. In the following section we will shown a recursive and iterative implementation of the DFS approach. We prefer the DFS approach to the BSF mostly because it is easier to code recursively. The iterative version (in Listing <a href="#sec:num_island:recursive" data-reference-type="ref" data-reference="sec:num_island:recursive">37.3.0.2</a>) however, can be turned into a BFS quite easily by just changing the policy of the order with which cells are decided to be visited.</p>
<h4 id="sec:num_island:iterative">DFS iterative</h4>
<p>Listing <a href="#list:number_islands:iterative" data-reference-type="ref" data-reference="list:number_islands:iterative">[list:number_islands:iterative]</a> shows a possible iterative implementation of the DFS approach described above. Note that the core of the algorithm is the function that uses a stack to keep track of the cells that are still to be visited. For each cell that is actually visited we will also try to visit all pieces of yet unvisited land in all four directions (up, down, left and right). We do so by adding them to the pile of cells to be visited. When a cell is actually visited, it is marked as so in its corresponding cell of the array . When there is no more land left in the stack it means that the island has been completely visited and we can return. Once it complete its execution the function returns the control back in the double loop of the function which will skip all the visited cells and we will trigger another invocation of as soon as another unvisited <span class="math inline">\(1\)</span> cell is found. That <span class="math inline">\(1\)</span> has to be part of a not yet unaccounted island together with all its adjacents land cells.</p>
<p>Also please note how the if at line <span class="math inline">\(22\)</span> takes care of not visiting cells that are outside the boundaries of the map, cells that are not land or already visited because this would lead to out-of-bound errors, incorrect results and infinite loops, respectively.</p>
<p>The complexity of this implementation in Listing <a href="#list:number_islands:iterative" data-reference-type="ref" data-reference="list:number_islands:iterative">[list:number_islands:iterative]</a> is <span class="math inline">\(O(n\times m)\)</span> for both time and space because we visit the whole map at least once and we use space proportional to <span class="math inline">\(n\times m\)</span> for the array .</p>
<div class="sourceCode" id="list:number_islands:iterative" data-language="c++" data-caption="Iterative DFS solution to the problem of counting the number of islands in a map." label="list:number_islands:iterative"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:number_islands:iterative-1"><a href="#list:number_islands:iterative-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> cell <span class="op">=</span> <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;;</span></span>
<span id="list:number_islands:iterative-2"><a href="#list:number_islands:iterative-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> visit<span class="op">(</span><span class="at">const</span> cell<span class="op">&amp;</span> c<span class="op">,</span></span>
<span id="list:number_islands:iterative-3"><a href="#list:number_islands:iterative-3" aria-hidden="true" tabindex="-1"></a>           <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;&gt;&amp;</span> grid<span class="op">,</span></span>
<span id="list:number_islands:iterative-4"><a href="#list:number_islands:iterative-4" aria-hidden="true" tabindex="-1"></a>           <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;&gt;&amp;</span> visited<span class="op">)</span></span>
<span id="list:number_islands:iterative-5"><a href="#list:number_islands:iterative-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:number_islands:iterative-6"><a href="#list:number_islands:iterative-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> n <span class="op">=</span> grid<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:number_islands:iterative-7"><a href="#list:number_islands:iterative-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> m <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">();</span></span>
<span id="list:number_islands:iterative-8"><a href="#list:number_islands:iterative-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:number_islands:iterative-9"><a href="#list:number_islands:iterative-9" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>stack<span class="op">&lt;</span>cell<span class="op">&gt;</span> S<span class="op">;</span></span>
<span id="list:number_islands:iterative-10"><a href="#list:number_islands:iterative-10" aria-hidden="true" tabindex="-1"></a>  S<span class="op">.</span>push<span class="op">(</span>c<span class="op">);</span></span>
<span id="list:number_islands:iterative-11"><a href="#list:number_islands:iterative-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(!</span>S<span class="op">.</span>empty<span class="op">())</span></span>
<span id="list:number_islands:iterative-12"><a href="#list:number_islands:iterative-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:number_islands:iterative-13"><a href="#list:number_islands:iterative-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> p <span class="op">=</span> S<span class="op">.</span>top<span class="op">();</span></span>
<span id="list:number_islands:iterative-14"><a href="#list:number_islands:iterative-14" aria-hidden="true" tabindex="-1"></a>    S<span class="op">.</span>pop<span class="op">();</span></span>
<span id="list:number_islands:iterative-15"><a href="#list:number_islands:iterative-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:number_islands:iterative-16"><a href="#list:number_islands:iterative-16" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> <span class="op">[</span>x<span class="op">,</span> y<span class="op">]</span> <span class="op">=</span> p<span class="op">;</span></span>
<span id="list:number_islands:iterative-17"><a href="#list:number_islands:iterative-17" aria-hidden="true" tabindex="-1"></a>    visited<span class="op">[</span>x<span class="op">][</span>y<span class="op">]</span>     <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:number_islands:iterative-18"><a href="#list:number_islands:iterative-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:number_islands:iterative-19"><a href="#list:number_islands:iterative-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="bu">std::</span>array<span class="op">&lt;</span>cell<span class="op">,</span> <span class="dv">4</span><span class="op">&gt;</span> cross <span class="op">=</span> <span class="op">{</span></span>
<span id="list:number_islands:iterative-20"><a href="#list:number_islands:iterative-20" aria-hidden="true" tabindex="-1"></a>        cell<span class="op">{-</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span> cell<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span> cell<span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">},</span> cell<span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">}};</span></span>
<span id="list:number_islands:iterative-21"><a href="#list:number_islands:iterative-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> inc <span class="op">:</span> cross<span class="op">)</span></span>
<span id="list:number_islands:iterative-22"><a href="#list:number_islands:iterative-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:number_islands:iterative-23"><a href="#list:number_islands:iterative-23" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> nx <span class="op">=</span> x <span class="op">+</span> inc<span class="op">.</span>first<span class="op">;</span></span>
<span id="list:number_islands:iterative-24"><a href="#list:number_islands:iterative-24" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> ny <span class="op">=</span> y <span class="op">+</span> inc<span class="op">.</span>second<span class="op">;</span></span>
<span id="list:number_islands:iterative-25"><a href="#list:number_islands:iterative-25" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>nx <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> nx <span class="op">&lt;</span> n <span class="op">&amp;&amp;</span> ny <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> ny <span class="op">&lt;</span> m <span class="op">&amp;&amp;</span> grid<span class="op">[</span>nx<span class="op">][</span>ny<span class="op">]</span></span>
<span id="list:number_islands:iterative-26"><a href="#list:number_islands:iterative-26" aria-hidden="true" tabindex="-1"></a>          <span class="op">&amp;&amp;</span> <span class="op">!</span>visited<span class="op">[</span>nx<span class="op">][</span>ny<span class="op">])</span></span>
<span id="list:number_islands:iterative-27"><a href="#list:number_islands:iterative-27" aria-hidden="true" tabindex="-1"></a>      <span class="op">{</span></span>
<span id="list:number_islands:iterative-28"><a href="#list:number_islands:iterative-28" aria-hidden="true" tabindex="-1"></a>        S<span class="op">.</span>push<span class="op">({</span>nx<span class="op">,</span> ny<span class="op">});</span></span>
<span id="list:number_islands:iterative-29"><a href="#list:number_islands:iterative-29" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="list:number_islands:iterative-30"><a href="#list:number_islands:iterative-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:number_islands:iterative-31"><a href="#list:number_islands:iterative-31" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:number_islands:iterative-32"><a href="#list:number_islands:iterative-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:number_islands:iterative-33"><a href="#list:number_islands:iterative-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:number_islands:iterative-34"><a href="#list:number_islands:iterative-34" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> count_island_iterative_DFS<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;&gt;&amp;</span> grid<span class="op">)</span></span>
<span id="list:number_islands:iterative-35"><a href="#list:number_islands:iterative-35" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:number_islands:iterative-36"><a href="#list:number_islands:iterative-36" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>grid<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:number_islands:iterative-37"><a href="#list:number_islands:iterative-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:number_islands:iterative-38"><a href="#list:number_islands:iterative-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:number_islands:iterative-39"><a href="#list:number_islands:iterative-39" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> n <span class="op">=</span> grid<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:number_islands:iterative-40"><a href="#list:number_islands:iterative-40" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> m <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">();</span></span>
<span id="list:number_islands:iterative-41"><a href="#list:number_islands:iterative-41" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans     <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:number_islands:iterative-42"><a href="#list:number_islands:iterative-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:number_islands:iterative-43"><a href="#list:number_islands:iterative-43" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;&gt;</span> visited<span class="op">(</span>n<span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;(</span>m<span class="op">,</span> <span class="kw">false</span><span class="op">));</span></span>
<span id="list:number_islands:iterative-44"><a href="#list:number_islands:iterative-44" aria-hidden="true" tabindex="-1"></a>  <span class="co">// search for a piece of unvisited land</span></span>
<span id="list:number_islands:iterative-45"><a href="#list:number_islands:iterative-45" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:number_islands:iterative-46"><a href="#list:number_islands:iterative-46" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:number_islands:iterative-47"><a href="#list:number_islands:iterative-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> m<span class="op">;</span> j<span class="op">++)</span></span>
<span id="list:number_islands:iterative-48"><a href="#list:number_islands:iterative-48" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:number_islands:iterative-49"><a href="#list:number_islands:iterative-49" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(!</span>grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">||</span> visited<span class="op">[</span>i<span class="op">][</span>j<span class="op">])</span></span>
<span id="list:number_islands:iterative-50"><a href="#list:number_islands:iterative-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span><span class="op">;</span></span>
<span id="list:number_islands:iterative-51"><a href="#list:number_islands:iterative-51" aria-hidden="true" tabindex="-1"></a>      <span class="co">// found one, mark as visited all the piece of</span></span>
<span id="list:number_islands:iterative-52"><a href="#list:number_islands:iterative-52" aria-hidden="true" tabindex="-1"></a>      <span class="co">// land you can reach from here</span></span>
<span id="list:number_islands:iterative-53"><a href="#list:number_islands:iterative-53" aria-hidden="true" tabindex="-1"></a>      ans<span class="op">++;</span></span>
<span id="list:number_islands:iterative-54"><a href="#list:number_islands:iterative-54" aria-hidden="true" tabindex="-1"></a>      visit<span class="op">({</span>i<span class="op">,</span> j<span class="op">},</span> grid<span class="op">,</span> visited<span class="op">);</span></span>
<span id="list:number_islands:iterative-55"><a href="#list:number_islands:iterative-55" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:number_islands:iterative-56"><a href="#list:number_islands:iterative-56" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:number_islands:iterative-57"><a href="#list:number_islands:iterative-57" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:number_islands:iterative-58"><a href="#list:number_islands:iterative-58" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>But, do we really need to have a dedicated matrix just to store the information about which cell is visited? Turns out that we can store that information in-place in the input matrix. All is necessary, when marking a cell visited, is turning the value in the input grid (which is modifiable) for that cell from land (<span class="math inline">\(1\)</span>) to water (<span class="math inline">\(0\)</span>) and that cell will never be considered part of an island in the future. If we do that, the space complexity does not change because we still use space to store the cells to be visited in the stack, but the amount of space used will be lower in practice and the overall solution will look cleaner and simpler which is always a plus during an interview.</p>
<div class="sourceCode" id="list:number_islands:iterative_1" data-language="c++" data-caption="Alternative iterative DFS solution, without dedicated space for marking visited cells,  to the problem of counting the number of islands in a map." label="list:number_islands:iterative_1"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:number_islands:iterative_1-1"><a href="#list:number_islands:iterative_1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> cell <span class="op">=</span> <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;;</span></span>
<span id="list:number_islands:iterative_1-2"><a href="#list:number_islands:iterative_1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:number_islands:iterative_1-3"><a href="#list:number_islands:iterative_1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> visit<span class="op">(</span><span class="at">const</span> cell<span class="op">&amp;</span> c<span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;&gt;&amp;</span> grid<span class="op">)</span></span>
<span id="list:number_islands:iterative_1-4"><a href="#list:number_islands:iterative_1-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:number_islands:iterative_1-5"><a href="#list:number_islands:iterative_1-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> n <span class="op">=</span> grid<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:number_islands:iterative_1-6"><a href="#list:number_islands:iterative_1-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> m <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">();</span></span>
<span id="list:number_islands:iterative_1-7"><a href="#list:number_islands:iterative_1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:number_islands:iterative_1-8"><a href="#list:number_islands:iterative_1-8" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>stack<span class="op">&lt;</span>cell<span class="op">&gt;</span> S<span class="op">;</span></span>
<span id="list:number_islands:iterative_1-9"><a href="#list:number_islands:iterative_1-9" aria-hidden="true" tabindex="-1"></a>  S<span class="op">.</span>push<span class="op">(</span>c<span class="op">);</span></span>
<span id="list:number_islands:iterative_1-10"><a href="#list:number_islands:iterative_1-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(!</span>S<span class="op">.</span>empty<span class="op">())</span></span>
<span id="list:number_islands:iterative_1-11"><a href="#list:number_islands:iterative_1-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:number_islands:iterative_1-12"><a href="#list:number_islands:iterative_1-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> p <span class="op">=</span> S<span class="op">.</span>top<span class="op">();</span></span>
<span id="list:number_islands:iterative_1-13"><a href="#list:number_islands:iterative_1-13" aria-hidden="true" tabindex="-1"></a>    S<span class="op">.</span>pop<span class="op">();</span></span>
<span id="list:number_islands:iterative_1-14"><a href="#list:number_islands:iterative_1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:number_islands:iterative_1-15"><a href="#list:number_islands:iterative_1-15" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> <span class="op">[</span>x<span class="op">,</span> y<span class="op">]</span> <span class="op">=</span> p<span class="op">;</span></span>
<span id="list:number_islands:iterative_1-16"><a href="#list:number_islands:iterative_1-16" aria-hidden="true" tabindex="-1"></a>    grid<span class="op">[</span>x<span class="op">][</span>y<span class="op">]</span>        <span class="op">=</span> <span class="kw">false</span><span class="op">;</span>  <span class="co">// mark the original map</span></span>
<span id="list:number_islands:iterative_1-17"><a href="#list:number_islands:iterative_1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:number_islands:iterative_1-18"><a href="#list:number_islands:iterative_1-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="bu">std::</span>array<span class="op">&lt;</span>cell<span class="op">,</span> <span class="dv">4</span><span class="op">&gt;</span> cross <span class="op">=</span> <span class="op">{</span></span>
<span id="list:number_islands:iterative_1-19"><a href="#list:number_islands:iterative_1-19" aria-hidden="true" tabindex="-1"></a>        cell<span class="op">{-</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span> cell<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span> cell<span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">},</span> cell<span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">}};</span></span>
<span id="list:number_islands:iterative_1-20"><a href="#list:number_islands:iterative_1-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> inc <span class="op">:</span> cross<span class="op">)</span></span>
<span id="list:number_islands:iterative_1-21"><a href="#list:number_islands:iterative_1-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:number_islands:iterative_1-22"><a href="#list:number_islands:iterative_1-22" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> nx <span class="op">=</span> x <span class="op">+</span> inc<span class="op">.</span>first<span class="op">;</span></span>
<span id="list:number_islands:iterative_1-23"><a href="#list:number_islands:iterative_1-23" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> ny <span class="op">=</span> y <span class="op">+</span> inc<span class="op">.</span>second<span class="op">;</span></span>
<span id="list:number_islands:iterative_1-24"><a href="#list:number_islands:iterative_1-24" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>nx <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> nx <span class="op">&lt;</span> n <span class="op">&amp;&amp;</span> ny <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> ny <span class="op">&lt;</span> m <span class="op">&amp;&amp;</span> grid<span class="op">[</span>nx<span class="op">][</span>ny<span class="op">])</span></span>
<span id="list:number_islands:iterative_1-25"><a href="#list:number_islands:iterative_1-25" aria-hidden="true" tabindex="-1"></a>      <span class="op">{</span></span>
<span id="list:number_islands:iterative_1-26"><a href="#list:number_islands:iterative_1-26" aria-hidden="true" tabindex="-1"></a>        S<span class="op">.</span>push<span class="op">({</span>nx<span class="op">,</span> ny<span class="op">});</span></span>
<span id="list:number_islands:iterative_1-27"><a href="#list:number_islands:iterative_1-27" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="list:number_islands:iterative_1-28"><a href="#list:number_islands:iterative_1-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// for</span></span>
<span id="list:number_islands:iterative_1-29"><a href="#list:number_islands:iterative_1-29" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>    <span class="co">// while</span></span>
<span id="list:number_islands:iterative_1-30"><a href="#list:number_islands:iterative_1-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:number_islands:iterative_1-31"><a href="#list:number_islands:iterative_1-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:number_islands:iterative_1-32"><a href="#list:number_islands:iterative_1-32" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> count_island_iterative_DFS_improved<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;&gt;&amp;</span> grid<span class="op">)</span></span>
<span id="list:number_islands:iterative_1-33"><a href="#list:number_islands:iterative_1-33" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:number_islands:iterative_1-34"><a href="#list:number_islands:iterative_1-34" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>grid<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:number_islands:iterative_1-35"><a href="#list:number_islands:iterative_1-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:number_islands:iterative_1-36"><a href="#list:number_islands:iterative_1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:number_islands:iterative_1-37"><a href="#list:number_islands:iterative_1-37" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> n <span class="op">=</span> grid<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:number_islands:iterative_1-38"><a href="#list:number_islands:iterative_1-38" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> m <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">();</span></span>
<span id="list:number_islands:iterative_1-39"><a href="#list:number_islands:iterative_1-39" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans     <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:number_islands:iterative_1-40"><a href="#list:number_islands:iterative_1-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:number_islands:iterative_1-41"><a href="#list:number_islands:iterative_1-41" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:number_islands:iterative_1-42"><a href="#list:number_islands:iterative_1-42" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:number_islands:iterative_1-43"><a href="#list:number_islands:iterative_1-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> m<span class="op">;</span> j<span class="op">++)</span></span>
<span id="list:number_islands:iterative_1-44"><a href="#list:number_islands:iterative_1-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:number_islands:iterative_1-45"><a href="#list:number_islands:iterative_1-45" aria-hidden="true" tabindex="-1"></a>      <span class="co">// visited cells are turned into water during the visit</span></span>
<span id="list:number_islands:iterative_1-46"><a href="#list:number_islands:iterative_1-46" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(!</span>grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">])</span></span>
<span id="list:number_islands:iterative_1-47"><a href="#list:number_islands:iterative_1-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span><span class="op">;</span></span>
<span id="list:number_islands:iterative_1-48"><a href="#list:number_islands:iterative_1-48" aria-hidden="true" tabindex="-1"></a>      ans<span class="op">++;</span></span>
<span id="list:number_islands:iterative_1-49"><a href="#list:number_islands:iterative_1-49" aria-hidden="true" tabindex="-1"></a>      visit<span class="op">({</span>i<span class="op">,</span> j<span class="op">},</span> grid<span class="op">);</span></span>
<span id="list:number_islands:iterative_1-50"><a href="#list:number_islands:iterative_1-50" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:number_islands:iterative_1-51"><a href="#list:number_islands:iterative_1-51" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:number_islands:iterative_1-52"><a href="#list:number_islands:iterative_1-52" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:number_islands:iterative_1-53"><a href="#list:number_islands:iterative_1-53" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="sec:num_island:recursive">DFS recursive</h4>
<p>The same idea can also be implemented recursively. In our opinion doing it this way makes the overall implementation more expressive, shorter and easier to reason about as well as to explain. Our first choice is always use this approach if possible when dealing with problem similar to the one presented here. Listing <a href="#list:number_islands:recursive" data-reference-type="ref" data-reference="list:number_islands:recursive">[list:number_islands:recursive]</a> shows a possible implementation of a recursive DFS solution for this problem. Notice that the recursion only happens during the DFS itself and that the driver function is basically the same as the ones we showed in the previous two solutions <a href="#list:number_islands:iterative" data-reference-type="ref" data-reference="list:number_islands:iterative">[list:number_islands:iterative]</a> and <a href="#list:number_islands:iterative_1" data-reference-type="ref" data-reference="list:number_islands:iterative_1">[list:number_islands:iterative_1]</a>.</p>
<div class="sourceCode" id="list:number_islands:recursive" data-language="c++" data-caption="Recursive DFS solution, to the problem of counting the number of islands in a map." label="list:number_islands:recursive"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:number_islands:recursive-1"><a href="#list:number_islands:recursive-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> cell <span class="op">=</span> <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;;</span></span>
<span id="list:number_islands:recursive-2"><a href="#list:number_islands:recursive-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> visit_recursive<span class="op">(</span><span class="at">const</span> cell<span class="op">&amp;</span> c<span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;&gt;&amp;</span> grid<span class="op">)</span></span>
<span id="list:number_islands:recursive-3"><a href="#list:number_islands:recursive-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:number_islands:recursive-4"><a href="#list:number_islands:recursive-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> n <span class="op">=</span> grid<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:number_islands:recursive-5"><a href="#list:number_islands:recursive-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> m <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">();</span></span>
<span id="list:number_islands:recursive-6"><a href="#list:number_islands:recursive-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:number_islands:recursive-7"><a href="#list:number_islands:recursive-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> <span class="op">[</span>x<span class="op">,</span> y<span class="op">]</span> <span class="op">=</span> c<span class="op">;</span></span>
<span id="list:number_islands:recursive-8"><a href="#list:number_islands:recursive-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// base case: a cell is out of the map or already visited or water</span></span>
<span id="list:number_islands:recursive-9"><a href="#list:number_islands:recursive-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>x <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">||</span> y <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">||</span> x <span class="op">&gt;=</span> n <span class="op">||</span> y <span class="op">&gt;=</span> m <span class="op">||</span> <span class="op">!</span>grid<span class="op">[</span>x<span class="op">][</span>y<span class="op">])</span></span>
<span id="list:number_islands:recursive-10"><a href="#list:number_islands:recursive-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="list:number_islands:recursive-11"><a href="#list:number_islands:recursive-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:number_islands:recursive-12"><a href="#list:number_islands:recursive-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// mark as visited</span></span>
<span id="list:number_islands:recursive-13"><a href="#list:number_islands:recursive-13" aria-hidden="true" tabindex="-1"></a>  grid<span class="op">[</span>x<span class="op">][</span>y<span class="op">]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:number_islands:recursive-14"><a href="#list:number_islands:recursive-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:number_islands:recursive-15"><a href="#list:number_islands:recursive-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// visit all cells that can potentially extend this island</span></span>
<span id="list:number_islands:recursive-16"><a href="#list:number_islands:recursive-16" aria-hidden="true" tabindex="-1"></a>  visit_recursive<span class="op">({</span>x <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> y<span class="op">},</span> grid<span class="op">);</span></span>
<span id="list:number_islands:recursive-17"><a href="#list:number_islands:recursive-17" aria-hidden="true" tabindex="-1"></a>  visit_recursive<span class="op">({</span>x <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> y<span class="op">},</span> grid<span class="op">);</span></span>
<span id="list:number_islands:recursive-18"><a href="#list:number_islands:recursive-18" aria-hidden="true" tabindex="-1"></a>  visit_recursive<span class="op">({</span>x<span class="op">,</span> y <span class="op">+</span> <span class="dv">1</span><span class="op">},</span> grid<span class="op">);</span></span>
<span id="list:number_islands:recursive-19"><a href="#list:number_islands:recursive-19" aria-hidden="true" tabindex="-1"></a>  visit_recursive<span class="op">({</span>x<span class="op">,</span> y <span class="op">-</span> <span class="dv">1</span><span class="op">},</span> grid<span class="op">);</span></span>
<span id="list:number_islands:recursive-20"><a href="#list:number_islands:recursive-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:number_islands:recursive-21"><a href="#list:number_islands:recursive-21" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> count_island_recursive_DFS<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;&gt;&amp;</span> grid<span class="op">)</span></span>
<span id="list:number_islands:recursive-22"><a href="#list:number_islands:recursive-22" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:number_islands:recursive-23"><a href="#list:number_islands:recursive-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>grid<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:number_islands:recursive-24"><a href="#list:number_islands:recursive-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:number_islands:recursive-25"><a href="#list:number_islands:recursive-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:number_islands:recursive-26"><a href="#list:number_islands:recursive-26" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> n <span class="op">=</span> grid<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:number_islands:recursive-27"><a href="#list:number_islands:recursive-27" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> m <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">();</span></span>
<span id="list:number_islands:recursive-28"><a href="#list:number_islands:recursive-28" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans     <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:number_islands:recursive-29"><a href="#list:number_islands:recursive-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:number_islands:recursive-30"><a href="#list:number_islands:recursive-30" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:number_islands:recursive-31"><a href="#list:number_islands:recursive-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> m<span class="op">;</span> j<span class="op">++)</span></span>
<span id="list:number_islands:recursive-32"><a href="#list:number_islands:recursive-32" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">])</span></span>
<span id="list:number_islands:recursive-33"><a href="#list:number_islands:recursive-33" aria-hidden="true" tabindex="-1"></a>      <span class="op">{</span></span>
<span id="list:number_islands:recursive-34"><a href="#list:number_islands:recursive-34" aria-hidden="true" tabindex="-1"></a>        ans<span class="op">++;</span></span>
<span id="list:number_islands:recursive-35"><a href="#list:number_islands:recursive-35" aria-hidden="true" tabindex="-1"></a>        visit_recursive<span class="op">({</span>i<span class="op">,</span> j<span class="op">},</span> grid<span class="op">);</span></span>
<span id="list:number_islands:recursive-36"><a href="#list:number_islands:recursive-36" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="list:number_islands:recursive-37"><a href="#list:number_islands:recursive-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:number_islands:recursive-38"><a href="#list:number_islands:recursive-38" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:number_islands:recursive-39"><a href="#list:number_islands:recursive-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="ch:median_sorted_arrays">Median of two sorted arrays</h1>
<h2 class="unnumbered" id="introduction-35">Introduction</h2>
<p>The median is one of the most basic and important concept in statistics and probability theory and it finds applications in almost every field of science. It is defined as the value that split a certain data set into two equally sized halves: the higher and the lower half. For example the median of the dataset <span class="math inline">\(\{1,3,4,6,10,12,19\}\)</span> is <span class="math inline">\(6\)</span> because we have <span class="math inline">\(3\)</span> elements greater and <span class="math inline">\(3\)</span> elements smaller than <span class="math inline">\(6\)</span>. When the size of the dataset is even, such element does not exists and thus the median is defined as the mean of the two middle elements; For instance given the dataset <span class="math inline">\(\{1,3,4,6,8,10,12,19\}\)</span>, the median is <span class="math inline">\(\frac{6+8}{2}=7\)</span>.</p>
<p>The problem covered in this chapter is about finding the median from a dataset provided as two separate input list of values (you can imagine, for instance, that each of the input set comes from a separate thread as part of a multithreaded application to analyze a large dataset). Despite an obvious solution exists that pretty follows from the definition of median, this problem is considered to be hard to solve optimally in a coding interview context as it requires non-trivial insights and careful implementation. But, despite its daunting reputation has been asked often during coding interviews.</p>
<p>For the rest of the chapter we will go throught the problem statement, and then we dive deeper into the problem by discussing a number of possible approaches that will make us go from a naive and inefficient to a more sophisticated but optimal solution.</p>
<h2 id="problem-statement-38">Problem statement</h2>
<div class="exercise">
<p>You are given two <strong>sorted</strong> arrays <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> of size <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span>, respectively. Your task is to write a function that takes as input <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> and returns the median of the two sorted arrays. <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> con be considered to be proper subsets of a third dataset <span class="math inline">\(C = A \cup B\)</span>.</p>
<div class="example">
<p><br />
Given two sorted arrays:</p>
<ul>
<li><p><span class="math inline">\(A=[1,4,6,10,15]\)</span></p></li>
<li><p><span class="math inline">\(B=[2,3,5,6]\)</span></p></li>
</ul>
<p>The median is <span class="math inline">\(5\)</span> (see Figure <a href="#fig:median_sorted_arrays:example2" data-reference-type="ref" data-reference="fig:median_sorted_arrays:example2">38.1</a>).</p>
</div>
<div class="example">
<p><br />
Given two sorted arrays:</p>
<ul>
<li><p><span class="math inline">\(A=[1,4,6,10]\)</span></p></li>
<li><p><span class="math inline">\(B=[2,3,5,6]\)</span></p></li>
</ul>
<p>The median is <span class="math inline">\(\frac{5+4}{2} = 4.5\)</span> (see Figure <a href="#fig:median_sorted_arrays:example1" data-reference-type="ref" data-reference="fig:median_sorted_arrays:example1">38.2</a>).</p>
</div>
</div>
<p><span id="fig:median_sorted_arrays:example2" label="fig:median_sorted_arrays:example2">[fig:median_sorted_arrays:example2]</span> <img src="/home/dspataro/git/algorithm_articles/sources/median_sorted_arrays/images/example2.png" title="fig:" id="fig:median_sorted_arrays:example2" alt="Example of median of two sorted array where the total number of elements is odd." /></p>
<p><span id="fig:median_sorted_arrays:example1" label="fig:median_sorted_arrays:example1">[fig:median_sorted_arrays:example1]</span> <img src="/home/dspataro/git/algorithm_articles/sources/median_sorted_arrays/images/example1.png" title="fig:" id="fig:median_sorted_arrays:example1" alt="Example of median of two sorted array where the total number of element is even." /></p>
<h2 id="clarification-questions-30">Clarification Questions</h2>
<div class="QandA">
<p>Can <span class="math inline">\(A\)</span> or <span class="math inline">\(B\)</span> be empty?</p>
<div class="answered">
<p><em>Yes, but you can assume that <span class="math inline">\(|A \cup B| &gt; 0\)</span> i.e. at most one of the input array can be empty.</em></p>
</div>
</div>
<h2 id="median_sorted_arrays:sec:discussion">Discussion</h2>
<p>Let’s start our discussion by reviewing the concept of median. The median of a collection <span class="math inline">\(C\)</span> of <span class="math inline">\(n\)</span> elements is (<span class="math inline">\(C_i\)</span> represents the <span class="math inline">\(i^{th}\)</span> element of <span class="math inline">\(C\)</span>):</p>
<ul>
<li><p><span class="math inline">\(C_{\frac{n}{2}}\)</span> if <span class="math inline">\(n\)</span> is odd (see Figure <a href="#fig:median_sorted_arrays:example1" data-reference-type="ref" data-reference="fig:median_sorted_arrays:example1">38.2</a>)</p></li>
<li><p><span class="math inline">\(\frac{C_{\floor{\frac{n}{2}}}+C_{\ceil{\frac{n}{2}}}}{2}\)</span> if <span class="math inline">\(n\)</span> is even (see Figure <a href="#fig:median_sorted_arrays:example2" data-reference-type="ref" data-reference="fig:median_sorted_arrays:example2">38.1</a>)</p></li>
</ul>
<p>In simpler terms the median of a sorted collection is the element which divides the collections into two equally sized halves, left and right, each with the same number of elements. If <span class="math inline">\(n\)</span> is even, clearly such element does not exists and thus the median is the defined to be the mean of the two middle elements as shown in Figure <a href="#fig:median_sorted_arrays:example1" data-reference-type="ref" data-reference="fig:median_sorted_arrays:example1">38.2</a>. Additionally, notice that because the collection is sorted then all the elements in the left half are smaller or equal then the median and all the elements on the right half are larger.</p>
<h3 id="median_sorted_arrays:sec:bruteforce">Brute-force</h3>
<p>Armed with the definition of median, we can immediately devise a simple and effective approach to find it given the two input sorted arrays. The only difference between the problem statement and the definition of median is that we are given two sorted arrays and not just one. Therefore it is natural that the very first thing that should come to mind is to:</p>
<ol>
<li><p>create a third array <span class="math inline">\(C = A \cup B\)</span>, which is the concatenation of the two input arrays</p></li>
<li><p>proceed by sorting <span class="math inline">\(C\)</span>,</p></li>
<li><p>calculate the median (and not forgetting to take into consideration the parity of <span class="math inline">\(|C|\)</span>)</p></li>
</ol>
<p>This approach is clearly correct as it is basically a direct consequence and application of the definition of median given above, but it is far from being optimal, as we will see below. Listing <a href="#list:median_sorted_naive" data-reference-type="ref" data-reference="list:median_sorted_naive">[list:median_sorted_naive]</a> shows a C++ implementation of this idea. Time and space complexities of this approach are <span class="math inline">\(O((n+m)log(n+m))\)</span>(because of sorting) and <span class="math inline">\(O(s+m)\)</span>(space required by the third array), respectively. Despite being suboptimal this solution has the benefit of being very short (only a few lines) and easy to read, explain and understand.</p>
<div class="sourceCode" id="list:median_sorted_naive" data-language="c++" data-caption="Naive implementation of solution to the problem of finding the median of two sorted arrays." label="list:median_sorted_naive"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:median_sorted_naive-1"><a href="#list:median_sorted_naive-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> mediam_sorted_arrays_naive<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>A<span class="op">,</span></span>
<span id="list:median_sorted_naive-2"><a href="#list:median_sorted_naive-2" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>B<span class="op">)</span></span>
<span id="list:median_sorted_naive-3"><a href="#list:median_sorted_naive-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:median_sorted_naive-4"><a href="#list:median_sorted_naive-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> C<span class="op">(</span>A<span class="op">);</span></span>
<span id="list:median_sorted_naive-5"><a href="#list:median_sorted_naive-5" aria-hidden="true" tabindex="-1"></a>  C<span class="op">.</span>insert<span class="op">(</span><span class="bu">std::</span>end<span class="op">(</span>C<span class="op">),</span> <span class="bu">std::</span>begin<span class="op">(</span>B<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>B<span class="op">));</span></span>
<span id="list:median_sorted_naive-6"><a href="#list:median_sorted_naive-6" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>sort<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>C<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>C<span class="op">));</span></span>
<span id="list:median_sorted_naive-7"><a href="#list:median_sorted_naive-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:median_sorted_naive-8"><a href="#list:median_sorted_naive-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> mid <span class="op">=</span> C<span class="op">.</span>size<span class="op">()</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="list:median_sorted_naive-9"><a href="#list:median_sorted_naive-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">(</span>C<span class="op">.</span>size<span class="op">()</span> <span class="op">&amp;</span> <span class="dv">1</span><span class="op">)</span> <span class="op">?</span> C<span class="op">[</span>mid<span class="op">]</span> <span class="op">:</span> <span class="op">(</span>C<span class="op">[</span>mid<span class="op">]</span> <span class="op">+</span> C<span class="op">[</span>mid <span class="op">+</span> <span class="dv">1</span><span class="op">])</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="list:median_sorted_naive-10"><a href="#list:median_sorted_naive-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="median_sorted_arrays:sec:bruteforce_improved">Brute-force improved</h3>
<p>The brute-force approach can be improved a bit if we use the fact that the arrays are already sorted. In the approach described in Section <a href="#median_sorted_arrays:sec:bruteforce" data-reference-type="ref" data-reference="median_sorted_arrays:sec:bruteforce">38.3.1</a> we do not use this fact and therefore we are forced to sort the entire array <span class="math inline">\(C\)</span> that we created by blindly juxtaposing <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> one after the other. By taking advantage of the fact that the inputs are sorted we can create the array <span class="math inline">\(C\)</span> in a smarter way, so that it is already sorted. In order to do so we will use the fact that you can merge two sorted array into a third sorted array in linear time. You might be already familiar with this idea if you know how the famous merge-sort algorithm<span class="citation" data-cites="wiki:mergesort"></span> works as the same operation is one of its two basic building blocks. Listing <a href="#list:median_sorted_naive_2" data-reference-type="ref" data-reference="list:median_sorted_naive_2">[list:median_sorted_naive_2]</a> shows how this idea can be coded in C++. Notice how most of the code is now taken by the function that is responsible for taking two sorted arrays (pay attention to the ) as input and returning a third sorted one.</p>
<div class="sourceCode" id="list:median_sorted_naive_2" data-language="c++" data-caption="Naive implementation of solution to the problem of finding the median of two sorted arrays using the merge part of merge-sort algorithm." label="list:median_sorted_naive_2"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:median_sorted_naive_2-1"><a href="#list:median_sorted_naive_2-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cassert&gt;</span></span>
<span id="list:median_sorted_naive_2-2"><a href="#list:median_sorted_naive_2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:median_sorted_naive_2-3"><a href="#list:median_sorted_naive_2-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> mergeSortedArrays<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">&amp;</span>A<span class="op">,</span></span>
<span id="list:median_sorted_naive_2-4"><a href="#list:median_sorted_naive_2-4" aria-hidden="true" tabindex="-1"></a>                                 <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">&amp;</span>B<span class="op">)</span></span>
<span id="list:median_sorted_naive_2-5"><a href="#list:median_sorted_naive_2-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:median_sorted_naive_2-6"><a href="#list:median_sorted_naive_2-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span><span class="bu">std::</span>is_sorted<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>A<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>A<span class="op">)));</span></span>
<span id="list:median_sorted_naive_2-7"><a href="#list:median_sorted_naive_2-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span><span class="bu">std::</span>is_sorted<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>B<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>B<span class="op">)));</span></span>
<span id="list:median_sorted_naive_2-8"><a href="#list:median_sorted_naive_2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:median_sorted_naive_2-9"><a href="#list:median_sorted_naive_2-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> size <span class="op">=</span> A<span class="op">.</span>size<span class="op">()</span> <span class="op">+</span> B<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:median_sorted_naive_2-10"><a href="#list:median_sorted_naive_2-10" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> C<span class="op">;</span></span>
<span id="list:median_sorted_naive_2-11"><a href="#list:median_sorted_naive_2-11" aria-hidden="true" tabindex="-1"></a>  C<span class="op">.</span>reserve<span class="op">(</span>size<span class="op">);</span></span>
<span id="list:median_sorted_naive_2-12"><a href="#list:median_sorted_naive_2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:median_sorted_naive_2-13"><a href="#list:median_sorted_naive_2-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> itA <span class="op">=</span> <span class="bu">std::</span>begin<span class="op">(</span>A<span class="op">);</span></span>
<span id="list:median_sorted_naive_2-14"><a href="#list:median_sorted_naive_2-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> itB <span class="op">=</span> <span class="bu">std::</span>begin<span class="op">(</span>B<span class="op">);</span></span>
<span id="list:median_sorted_naive_2-15"><a href="#list:median_sorted_naive_2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:median_sorted_naive_2-16"><a href="#list:median_sorted_naive_2-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>itA <span class="op">!=</span> <span class="bu">std::</span>end<span class="op">(</span>A<span class="op">)</span> <span class="op">&amp;&amp;</span> itB <span class="op">!=</span> <span class="bu">std::</span>end<span class="op">(</span>B<span class="op">))</span></span>
<span id="list:median_sorted_naive_2-17"><a href="#list:median_sorted_naive_2-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:median_sorted_naive_2-18"><a href="#list:median_sorted_naive_2-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(*</span>itA <span class="op">&lt;</span> <span class="op">*</span>itB<span class="op">)</span></span>
<span id="list:median_sorted_naive_2-19"><a href="#list:median_sorted_naive_2-19" aria-hidden="true" tabindex="-1"></a>      C<span class="op">.</span>push_back<span class="op">(*</span>itA<span class="op">++);</span></span>
<span id="list:median_sorted_naive_2-20"><a href="#list:median_sorted_naive_2-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="list:median_sorted_naive_2-21"><a href="#list:median_sorted_naive_2-21" aria-hidden="true" tabindex="-1"></a>      C<span class="op">.</span>push_back<span class="op">(*</span>itB<span class="op">++);</span></span>
<span id="list:median_sorted_naive_2-22"><a href="#list:median_sorted_naive_2-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:median_sorted_naive_2-23"><a href="#list:median_sorted_naive_2-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:median_sorted_naive_2-24"><a href="#list:median_sorted_naive_2-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>itA <span class="op">!=</span> <span class="bu">std::</span>end<span class="op">(</span>A<span class="op">))</span></span>
<span id="list:median_sorted_naive_2-25"><a href="#list:median_sorted_naive_2-25" aria-hidden="true" tabindex="-1"></a>    C<span class="op">.</span>push_back<span class="op">(*</span>itA<span class="op">++);</span></span>
<span id="list:median_sorted_naive_2-26"><a href="#list:median_sorted_naive_2-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:median_sorted_naive_2-27"><a href="#list:median_sorted_naive_2-27" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>itB <span class="op">!=</span> <span class="bu">std::</span>end<span class="op">(</span>B<span class="op">))</span></span>
<span id="list:median_sorted_naive_2-28"><a href="#list:median_sorted_naive_2-28" aria-hidden="true" tabindex="-1"></a>    C<span class="op">.</span>push_back<span class="op">(*</span>itB<span class="op">++);</span></span>
<span id="list:median_sorted_naive_2-29"><a href="#list:median_sorted_naive_2-29" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> C<span class="op">;</span></span>
<span id="list:median_sorted_naive_2-30"><a href="#list:median_sorted_naive_2-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:median_sorted_naive_2-31"><a href="#list:median_sorted_naive_2-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:median_sorted_naive_2-32"><a href="#list:median_sorted_naive_2-32" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> mediam_sorted_arrays_merge<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>A<span class="op">,</span></span>
<span id="list:median_sorted_naive_2-33"><a href="#list:median_sorted_naive_2-33" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>B<span class="op">)</span></span>
<span id="list:median_sorted_naive_2-34"><a href="#list:median_sorted_naive_2-34" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:median_sorted_naive_2-35"><a href="#list:median_sorted_naive_2-35" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> C <span class="op">=</span> mergeSortedArrays<span class="op">(</span>A<span class="op">,</span> B<span class="op">);</span></span>
<span id="list:median_sorted_naive_2-36"><a href="#list:median_sorted_naive_2-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:median_sorted_naive_2-37"><a href="#list:median_sorted_naive_2-37" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> mid <span class="op">=</span> C<span class="op">.</span>size<span class="op">()</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="list:median_sorted_naive_2-38"><a href="#list:median_sorted_naive_2-38" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">(</span>C<span class="op">.</span>size<span class="op">()</span> <span class="op">&amp;</span> <span class="dv">1</span><span class="op">)</span> <span class="op">?</span> C<span class="op">[</span>mid<span class="op">]</span> <span class="op">:</span> <span class="op">(</span>C<span class="op">[</span>mid<span class="op">]</span> <span class="op">+</span> C<span class="op">[</span>mid <span class="op">+</span> <span class="dv">1</span><span class="op">])</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="list:median_sorted_naive_2-39"><a href="#list:median_sorted_naive_2-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The time and complexities of this version are both <span class="math inline">\(O(n+m)\)</span>, much better than the one from the solution presented in Section <a href="#median_sorted_arrays:sec:bruteforce" data-reference-type="ref" data-reference="median_sorted_arrays:sec:bruteforce">38.3.1</a> but, it is still suboptimal as this problem can be solved in logarithmic time. We are going to see how in Section <a href="#median_sorted_arrays:sec:log" data-reference-type="ref" data-reference="median_sorted_arrays:sec:log">38.3.3</a>.</p>
<h4 id="merge-sorted-arrays-in-linear-time">Merge sorted arrays in linear time</h4>
<p>How exactly can we merge two sorted arrays <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> into a third sorted array <span class="math inline">\(Z\)</span> in linear time? The idea behind is that we can build <span class="math inline">\(Z\)</span> incrementally starting from an empty array, and at each step of the process inserting one of the elements of <span class="math inline">\(X\)</span> or <span class="math inline">\(Y\)</span> depening on which one of the two containts the smallest element at that moment. In the implementation of this is achieved by using two iterators, and each pointing to the next element of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> to be inserted in <span class="math inline">\(Z\)</span>, respectively. The loop is responsible for comparing the two elements pointed by the iterators and always inserting the smallest one into <span class="math inline">\(Z\)</span>. Once an element is merged in the final array, the corrensponding iterator is incremented so the next value will be considered at the next iteration. When one of the two iterators its the end of its array, then all we are left are the remaining elements of the other collection that we can at this point blindly insert into <span class="math inline">\(Z\)</span> because they are sorted (see the last two loops in the code). Figure <a href="#fig:median_sorted_array:mergearray" data-reference-type="ref" data-reference="fig:median_sorted_array:mergearray">[fig:median_sorted_array:mergearray]</a> shows all the steps that are necessary to perform the merging for the arrays: <span class="math inline">\(X = \{1,3,5,8,15\}\)</span> and <span class="math inline">\(X = \{2,4,7\}\)</span>. At step <span class="math inline">\(1\)</span> (Figure <a href="#fig:median_sorted_array:mergearray0" data-reference-type="ref" data-reference="fig:median_sorted_array:mergearray0">38.3</a>) <span class="math inline">\(Z\)</span> is initially empty and and point to the beginning of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>, respectively. Because the element pointed by itA is smaller, it is selected for merging and thus itA is incremented. At step <span class="math inline">\(2\)</span> (Figure <a href="#fig:median_sorted_array:mergearray1" data-reference-type="ref" data-reference="fig:median_sorted_array:mergearray1">38.4</a>) the element pointed by itB is smaller, and as in the previous step, it is merged in <span class="math inline">\(Z\)</span> and itB is incremeneted. The same operations are performed for all the steps depicted in Figures <a href="#fig:median_sorted_array:mergearray2" data-reference-type="ref" data-reference="fig:median_sorted_array:mergearray2">38.5</a>, <a href="#fig:median_sorted_array:mergearray3" data-reference-type="ref" data-reference="fig:median_sorted_array:mergearray3">38.6</a>, <a href="#fig:median_sorted_array:mergearray4" data-reference-type="ref" data-reference="fig:median_sorted_array:mergearray4">38.7</a>, <a href="#fig:median_sorted_array:mergearray5" data-reference-type="ref" data-reference="fig:median_sorted_array:mergearray5">38.8</a> and <a href="#fig:median_sorted_array:mergearray6" data-reference-type="ref" data-reference="fig:median_sorted_array:mergearray6">38.9</a>. Eventually itB goes out of range signalling that all the element in <span class="math inline">\(Y\)</span> have been processed (see Figure <a href="#fig:median_sorted_array:mergearray6" data-reference-type="ref" data-reference="fig:median_sorted_array:mergearray6">38.9</a>). At this point then, as shown in Figure <a href="#fig:median_sorted_array:mergearray7" data-reference-type="ref" data-reference="fig:median_sorted_array:mergearray7">38.10</a> we can safely merge all the element in <span class="math inline">\(X\)</span> into <span class="math inline">\(Z\)</span> that is now ready to be returned (see Figure <a href="#fig:median_sorted_array:mergearray8" data-reference-type="ref" data-reference="fig:median_sorted_array:mergearray8">38.11</a>).</p>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/median_sorted_arrays/images/mergearrays0.png" id="fig:median_sorted_array:mergearray0" alt="Step 1: Z is initially empty. itX and itY points to the beginning of X and Y, respectively. The element pointed by itX is merged as it is smaller. itX is advanced by one position." /><figcaption aria-hidden="true">Step <span class="math inline">\(1\)</span>: <span class="math inline">\(Z\)</span> is initially empty. itX and itY points to the beginning of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>, respectively. The element pointed by itX is merged as it is smaller. itX is advanced by one position.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/median_sorted_arrays/images/mergearrays1.jpg" id="fig:median_sorted_array:mergearray1" alt="Step 2: itY is smaller than itX, thus it is the one being merged. itB is also advanced by one position. " /><figcaption aria-hidden="true">Step <span class="math inline">\(2\)</span>: itY is smaller than itX, thus it is the one being merged. itB is also advanced by one position. </figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/median_sorted_arrays/images/mergearrays2.jpg" id="fig:median_sorted_array:mergearray2" alt="Step 3: itX is smaller than itY, thus it is the one being merged. itX is also advanced by one position." /><figcaption aria-hidden="true">Step <span class="math inline">\(3\)</span>: itX is smaller than itY, thus it is the one being merged. itX is also advanced by one position.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/median_sorted_arrays/images/mergearrays3.jpg" id="fig:median_sorted_array:mergearray3" alt="Step 4: itY is smaller than itX, thus it is the one being merged. itB is also advanced by one position. " /><figcaption aria-hidden="true">Step <span class="math inline">\(4\)</span>: itY is smaller than itX, thus it is the one being merged. itB is also advanced by one position. </figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/median_sorted_arrays/images/mergearrays4.jpg" id="fig:median_sorted_array:mergearray4" alt="Step 5: itX is smaller than itY, thus it is the one being merged. itX is also advanced by one position." /><figcaption aria-hidden="true">Step <span class="math inline">\(5\)</span>: itX is smaller than itY, thus it is the one being merged. itX is also advanced by one position.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/median_sorted_arrays/images/mergearrays5.jpg" id="fig:median_sorted_array:mergearray5" alt="Step 6:itY is smaller than itX, thus it is the one being merged. itB is also advanced by one position." /><figcaption aria-hidden="true">Step <span class="math inline">\(6\)</span>:itY is smaller than itX, thus it is the one being merged. itB is also advanced by one position.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/median_sorted_arrays/images/mergearrays6.jpg" id="fig:median_sorted_array:mergearray6" alt=" itY now points to the past-the-end element of Y. There are no more element of Y to merge." /><figcaption aria-hidden="true"> itY now points to the past-the-end element of <span class="math inline">\(Y\)</span>. There are no more element of <span class="math inline">\(Y\)</span> to merge.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/median_sorted_arrays/images/mergearrays7.jpg" id="fig:median_sorted_array:mergearray7" alt="Step 7: All the remaning element from the current location of itX to the end of X are merged into Z. " /><figcaption aria-hidden="true">Step <span class="math inline">\(7\)</span>: All the remaning element from the current location of itX to the end of X are merged into <span class="math inline">\(Z\)</span>. </figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/median_sorted_arrays/images/mergearrays8.jpg" id="fig:median_sorted_array:mergearray8" alt="All the elements of X and Y have been merged. Z contains the element of X \cup Y and it is sorted." /><figcaption aria-hidden="true">All the elements of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> have been merged. <span class="math inline">\(Z\)</span> contains the element of <span class="math inline">\(X \cup Y\)</span> and it is sorted.</figcaption>
</figure>
<h3 id="median_sorted_arrays:sec:log">Logarithmic solution</h3>
<p>If we want to improve the <span class="math inline">\(O(n+m)\)</span> solution we have at hand at this point we need to abandon the idea of constructing a third array containing all the elements from the inputs. There is no way this can be done in less than linear time as one must at least access the input element once. Turns out, we do not actually need to have the array <span class="math inline">\(C\)</span> at all.</p>
<p>The key insights are:</p>
<ul>
<li><p>we know exactly what the size of the merged array <span class="math inline">\(C\)</span> would be: <span class="math inline">\(n+m\)</span>.</p></li>
<li><p>we also know that the part of <span class="math inline">\(C\)</span> to the left of the median, <span class="math inline">\(C_l\)</span> would be made up from elements among the smallest values of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>. These values also lie in the left portions of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>. For instance, w.r.t. the example in Figure <a href="#fig:median_sorted_arrays:example2" data-reference-type="ref" data-reference="fig:median_sorted_arrays:example2">38.1</a> we can see that the left half (the first <span class="math inline">\(5\)</span> elements) of <span class="math inline">\(A \cup B\)</span> is made from the first two elements of <span class="math inline">\(A\)</span> and the smallest <span class="math inline">\(3\)</span> elements of <span class="math inline">\(B\)</span>. Because <span class="math inline">\(C\)</span> will be sorted, only the smallest elements of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> will can be part of <span class="math inline">\(C_l\)</span>.</p></li>
</ul>
<p>The problem is that we do not know exactly how many elements of <span class="math inline">\(A\)</span> will be part <span class="math inline">\(C_l\)</span> but if we do, then, we also know immediately how many elements of <span class="math inline">\(B\)</span> go to <span class="math inline">\(C_l\)</span> and at that point we can calculate the median. We cannot find directly how many elements of <span class="math inline">\(A\)</span> contributes to <span class="math inline">\(C_l\)</span>, but we can test farily easily if the first <span class="math inline">\(i\)</span> elements do. Let’s suppose we try to make <span class="math inline">\(C_l\)</span> by using <span class="math inline">\(i\)</span> elements from the left portion of <span class="math inline">\(A\)</span>. Because <span class="math inline">\(|C|=n+m\)</span> then <span class="math inline">\(|C_l| = \frac{n+m}{2} = i+j\)</span> where <span class="math inline">\(j\)</span> is the number of elements from the left part of <span class="math inline">\(B\)</span> contributing to <span class="math inline">\(C_l\)</span>. Thus if we take <span class="math inline">\(i\)</span> elements from <span class="math inline">\(A\)</span> we need to take <span class="math inline">\(j = (n+m)-i\)</span> elements from <span class="math inline">\(B\)</span>. Once <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are decided, we also know that the last element of <span class="math inline">\(C_l\)</span>, will be the maximum element among the first <span class="math inline">\(i\)</span> elements of <span class="math inline">\(A\)</span> and the first <span class="math inline">\(j\)</span> elements of <span class="math inline">\(B\)</span>. From these arguments follows that the right half of <span class="math inline">\(C\)</span>, <span class="math inline">\(C_r\)</span>, contains all the remaining <span class="math inline">\(n-i\)</span> elements of <span class="math inline">\(A\)</span> and <span class="math inline">\(m-j\)</span> of <span class="math inline">\(B\)</span>, and also that the first element of <span class="math inline">\(C_r\)</span> will be the smallest element among them. Given:</p>
<ul>
<li><p><span class="math inline">\(M_l\)</span> is the largest elements among the <span class="math inline">\(A[i]\)</span> <span class="math inline">\(B[j]\)</span></p></li>
<li><p><span class="math inline">\(m_r\)</span> is the smallest element among the <span class="math inline">\(A[i+1]\)</span> <span class="math inline">\(B[j+1]\)</span></p></li>
</ul>
<p>then if <span class="math inline">\(i\)</span> is indeed the right amount of element from <span class="math inline">\(A\)</span> belonging to <span class="math inline">\(C_l\)</span> then, <span class="math inline">\(M_l \leq m_r\)</span>. If <span class="math inline">\(M_l &gt; m_r\)</span> then we need to understand whether we took too many or too few elements from <span class="math inline">\(A\)</span> to be part of <span class="math inline">\(C_l\)</span>. We can check this by checking whether <span class="math inline">\(M_l\)</span> belongs to <span class="math inline">\(B\)</span> or <span class="math inline">\(A\)</span>, respectively. Thus if <span class="math inline">\(A[i] &gt; B[j]\)</span> we reduce or increase <span class="math inline">\(i\)</span> by doing <span class="math inline">\(r = r-1\)</span>. Conversely if <span class="math inline">\(A[i] &lt; B[i]\)</span> then <span class="math inline">\(i\)</span> is increased by moving the left boundary of the binary search range: <span class="math inline">\(l = l+1\)</span>.</p>
<p>Listing <a href="#list:median_sorted_binary" data-reference-type="ref" data-reference="list:median_sorted_binary">[list:median_sorted_binary]</a> shows an implementation of the idea above.</p>
<div class="sourceCode" id="list:median_sorted_binary" data-language="c++" data-caption="Binary search solution to the \textit{median of two sorted arrays} problem." label="list:median_sorted_binary"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:median_sorted_binary-1"><a href="#list:median_sorted_binary-1" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> midpoint<span class="op">(</span><span class="at">const</span> <span class="dt">size_t</span> l<span class="op">,</span> <span class="at">const</span> <span class="dt">size_t</span> r<span class="op">)</span></span>
<span id="list:median_sorted_binary-2"><a href="#list:median_sorted_binary-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:median_sorted_binary-3"><a href="#list:median_sorted_binary-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>l <span class="op">&lt;=</span> r<span class="op">);</span></span>
<span id="list:median_sorted_binary-4"><a href="#list:median_sorted_binary-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> l <span class="op">+</span> <span class="op">(</span>r <span class="op">-</span> l<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="list:median_sorted_binary-5"><a href="#list:median_sorted_binary-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:median_sorted_binary-6"><a href="#list:median_sorted_binary-6" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> mediam_sorted_arrays_binary_search<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>A<span class="op">,</span></span>
<span id="list:median_sorted_binary-7"><a href="#list:median_sorted_binary-7" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>B<span class="op">)</span></span>
<span id="list:median_sorted_binary-8"><a href="#list:median_sorted_binary-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:median_sorted_binary-9"><a href="#list:median_sorted_binary-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> l <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> r <span class="op">=</span> A<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:median_sorted_binary-10"><a href="#list:median_sorted_binary-10" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">size_t</span> size_C      <span class="op">=</span> A<span class="op">.</span>size<span class="op">()</span> <span class="op">+</span> B<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:median_sorted_binary-11"><a href="#list:median_sorted_binary-11" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">size_t</span> half_size_C <span class="op">=</span> size_C <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="list:median_sorted_binary-12"><a href="#list:median_sorted_binary-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:median_sorted_binary-13"><a href="#list:median_sorted_binary-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> median <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="list:median_sorted_binary-14"><a href="#list:median_sorted_binary-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>l <span class="op">&lt;=</span> r<span class="op">)</span></span>
<span id="list:median_sorted_binary-15"><a href="#list:median_sorted_binary-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:median_sorted_binary-16"><a href="#list:median_sorted_binary-16" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">size_t</span> i <span class="op">=</span> midpoint<span class="op">(</span>l<span class="op">,</span> r<span class="op">);</span></span>
<span id="list:median_sorted_binary-17"><a href="#list:median_sorted_binary-17" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">size_t</span> j <span class="op">=</span> half_size_C <span class="op">-</span> i<span class="op">;</span></span>
<span id="list:median_sorted_binary-18"><a href="#list:median_sorted_binary-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*</span></span>
<span id="list:median_sorted_binary-19"><a href="#list:median_sorted_binary-19" aria-hidden="true" tabindex="-1"></a><span class="co">        const int idx_i = i - 1;</span></span>
<span id="list:median_sorted_binary-20"><a href="#list:median_sorted_binary-20" aria-hidden="true" tabindex="-1"></a><span class="co">        const int idx_j = j - 1;</span></span>
<span id="list:median_sorted_binary-21"><a href="#list:median_sorted_binary-21" aria-hidden="true" tabindex="-1"></a><span class="co">        if (A[i - 1] &lt;= B[j] &amp;&amp; B[j - 1] &lt;= A[i])</span></span>
<span id="list:median_sorted_binary-22"><a href="#list:median_sorted_binary-22" aria-hidden="true" tabindex="-1"></a><span class="co">          if (size % 2 == 0)</span></span>
<span id="list:median_sorted_binary-23"><a href="#list:median_sorted_binary-23" aria-hidden="true" tabindex="-1"></a><span class="co">            return (std::max(A[i - 1], B[j - 1]) + std::min(A[i], B[j])) / 2.0;</span></span>
<span id="list:median_sorted_binary-24"><a href="#list:median_sorted_binary-24" aria-hidden="true" tabindex="-1"></a><span class="co">          else</span></span>
<span id="list:median_sorted_binary-25"><a href="#list:median_sorted_binary-25" aria-hidden="true" tabindex="-1"></a><span class="co">            return std::max(A[i - 1], B[j - 1]);</span></span>
<span id="list:median_sorted_binary-26"><a href="#list:median_sorted_binary-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:median_sorted_binary-27"><a href="#list:median_sorted_binary-27" aria-hidden="true" tabindex="-1"></a><span class="co">        if (A[i - 1] &gt; B[j])</span></span>
<span id="list:median_sorted_binary-28"><a href="#list:median_sorted_binary-28" aria-hidden="true" tabindex="-1"></a><span class="co">          r = i - 1;</span></span>
<span id="list:median_sorted_binary-29"><a href="#list:median_sorted_binary-29" aria-hidden="true" tabindex="-1"></a><span class="co">        else</span></span>
<span id="list:median_sorted_binary-30"><a href="#list:median_sorted_binary-30" aria-hidden="true" tabindex="-1"></a><span class="co">          l = i - 1;*/</span></span>
<span id="list:median_sorted_binary-31"><a href="#list:median_sorted_binary-31" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:median_sorted_binary-32"><a href="#list:median_sorted_binary-32" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> median<span class="op">;</span></span>
<span id="list:median_sorted_binary-33"><a href="#list:median_sorted_binary-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>https://leetcode.com/problems/median-of-two-sorted-arrays/ complete this code first use binary search to find i l , r is the range of elements of A initially l = 0 r = min(n, (n+m)/2) i = l+r/2 j = n+m-i if max among A[i] and B[j] &lt;= min A[i+1],B[j+1] we have a median otherwise if A[i] &gt; B[j] then r = i-1 else l = i+1</p>
<h1 id="ch:lowest_common_ancestor">BST Lowest Common Ancestor</h1>
<h2 class="unnumbered" id="introduction-36">Introduction</h2>
<p>The lowest common ancestor is an important concept in graph theory and it is quite often a topic or a fundamental building block of coding interview questions. LCA have important application in graph theory for instance in:</p>
<ul>
<li><p>computation of <em>minimum spanning tree</em>,</p></li>
<li><p>finding a <em>dominator tree</em>, or</p></li>
<li><p>as a stepping stone for algorithm for <em>network routing</em>, or <em>range searching</em>.</p></li>
</ul>
<p>Given a tree and two nodes <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span>, the lowest common ancestor of <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span>, (<span class="math inline">\(LCA(p,q)\)</span>) is defined as the lowest or deepest node that has both <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> as descendant. In other words the LCA is the shared ancestor or <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> that is the farthest from the root of the tree.</p>
<p>There are several known algorithm for finding the LCA efficiently on a generic tree, one of the most fundamental being the one from Harel and Tarjan <span class="citation" data-cites="harel84 harel80"></span>. In this chapter however, we will focus on the (simpler) problem of finding the LCA for trees of a particular kind: binary search trees. This constraint greatly simplifies the general problem of finding LCA.</p>
<h2 id="problem-statement-39">Problem statement</h2>
<div class="exercise">
<p>Write a function that takes a binary search tree <span class="math inline">\(T\)</span>, and two nodes <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> and returns their lowest common ancestor.</p>
<div class="example">
<p><br />
Given the tree in Figure <a href="#fig:lowest_common_ancestor:example1" data-reference-type="ref" data-reference="fig:lowest_common_ancestor:example1">39.1</a> the lowest common ancestor for nodes:</p>
<ul>
<li><p><span class="math inline">\(p = 2\)</span>, <span class="math inline">\(q=12\)</span> is node <span class="math inline">\(3\)</span></p></li>
<li><p><span class="math inline">\(p = 12\)</span>, <span class="math inline">\(q=3\)</span> is node <span class="math inline">\(12\)</span></p></li>
<li><p><span class="math inline">\(p = 18\)</span>, <span class="math inline">\(q=1\)</span> is the root node <span class="math inline">\(13\)</span></p></li>
</ul>
<p><span id="ex:lower_common_ancestor:example1" label="ex:lower_common_ancestor:example1">[ex:lower_common_ancestor:example1]</span></p>
</div>
</div>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/lowest_common_ancestor/images/example1.jpg" id="fig:lowest_common_ancestor:example1" style="width:50.0%" alt="Binary Search tree of the Example [ex:lower_common_ancestor:example1]" /><figcaption aria-hidden="true">Binary Search tree of the Example <a href="#ex:lower_common_ancestor:example1" data-reference-type="ref" data-reference="ex:lower_common_ancestor:example1">[ex:lower_common_ancestor:example1]</a></figcaption>
</figure>
<p>. <span id="fig:lowest_common_ancestor:example1" label="fig:lowest_common_ancestor:example1">[fig:lowest_common_ancestor:example1]</span></p>
<h2 id="clarification-questions-31">Clarification Questions</h2>
<div class="QandA">
<p>What to return in case the input tree is empty?</p>
<div class="answered">
<p><em>You can return an empty tree.</em></p>
</div>
<p>Should I check for the validity of the binary search property for <span class="math inline">\(T\)</span>?</p>
<div class="answered">
<p><em>No, you can assume <span class="math inline">\(T\)</span> to always be a valid binary search tree.</em></p>
</div>
<p>Can I assume <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> to always be always present in <span class="math inline">\(T\)</span>?</p>
<div class="answered">
<p><em>Yes</em></p>
</div>
</div>
<h2 id="lowest_common_ancestor:sec:discussion">Discussion</h2>
<p>Based on the definition of LCA one of the simplest solution possible would be to compute the path from the root to <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> as store them as two separate lists of nodes: <span class="math inline">\(P_q\)</span> and <span class="math inline">\(P_p\)</span>. We can then compare these lists and notice that they will match up until a certain point, say up to the <span class="math inline">\(k^{th}\)</span> node of the path. After that the lists do not match anymore. Therefore the <span class="math inline">\(k^{th}\)</span> element of the list is the LCA for <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span>. For instance w.r.t the tree in Figure <a href="#fig:lowest_common_ancestor:example1" data-reference-type="ref" data-reference="fig:lowest_common_ancestor:example1">39.1</a> the paths from the root to the nodes <span class="math inline">\(5\)</span> and <span class="math inline">\(2\)</span> are the following, respectivey:</p>
<div class="flalign">
<p>&amp;P_5 = {,4,12,10,5}<br />
&amp;P_2 = {,1,2}</p>
</div>
<p>As you can see they match up to node <span class="math inline">\(3\)</span> that is indeed their LCA.</p>
<p>If we try the same approach for the nodes <span class="math inline">\(5\)</span> and <span class="math inline">\(11\)</span> we have that their respective paths from the root are:</p>
<div class="flalign">
<p>&amp;P_5 = {,5}<br />
&amp;P_1 = {,11}</p>
</div>
<p><span class="math inline">\(P_5\)</span> and <span class="math inline">\(P_{11}\)</span> match up to until the penultimate node (<span class="math inline">\(10\)</span>). Therefore, their LCA is node <span class="math inline">\(10\)</span>.</p>
<p>This approach is correct and it is easily implementable, and its time and space complexity is <span class="math inline">\(O(k)\)</span> where <span class="math inline">\(k\)</span> is the height of <span class="math inline">\(T\)</span> (which for unbalanced trees might be proportional to the number of nodes in <span class="math inline">\(T\)</span>). Listing <a href="#list:lowest_common_ancestor_paths" data-reference-type="ref" data-reference="list:lowest_common_ancestor_paths">[list:lowest_common_ancestor_paths]</a> show an implementation of the idea above.</p>
<div class="sourceCode" id="list:lowest_common_ancestor_paths" data-language="c++" data-caption="LCA solution based on the difference of paths from the root." label="list:lowest_common_ancestor_paths"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:lowest_common_ancestor_paths-1"><a href="#list:lowest_common_ancestor_paths-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:lowest_common_ancestor_paths-2"><a href="#list:lowest_common_ancestor_paths-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> find_path_helper<span class="op">(</span>Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> root<span class="op">,</span></span>
<span id="list:lowest_common_ancestor_paths-3"><a href="#list:lowest_common_ancestor_paths-3" aria-hidden="true" tabindex="-1"></a>                      <span class="at">const</span> T<span class="op">&amp;</span> target<span class="op">,</span></span>
<span id="list:lowest_common_ancestor_paths-4"><a href="#list:lowest_common_ancestor_paths-4" aria-hidden="true" tabindex="-1"></a>                      <span class="bu">std::</span>vector<span class="op">&lt;</span>Node<span class="op">&lt;</span>T<span class="op">&gt;*&gt;&amp;</span> path<span class="op">)</span></span>
<span id="list:lowest_common_ancestor_paths-5"><a href="#list:lowest_common_ancestor_paths-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:lowest_common_ancestor_paths-6"><a href="#list:lowest_common_ancestor_paths-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>root<span class="op">);</span>  <span class="co">// because target in guaranteed to be in the tree.</span></span>
<span id="list:lowest_common_ancestor_paths-7"><a href="#list:lowest_common_ancestor_paths-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:lowest_common_ancestor_paths-8"><a href="#list:lowest_common_ancestor_paths-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// visited a new node. remember it</span></span>
<span id="list:lowest_common_ancestor_paths-9"><a href="#list:lowest_common_ancestor_paths-9" aria-hidden="true" tabindex="-1"></a>  path<span class="op">.</span>push_back<span class="op">(</span>root<span class="op">);</span></span>
<span id="list:lowest_common_ancestor_paths-10"><a href="#list:lowest_common_ancestor_paths-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>root<span class="op">-&gt;</span>val <span class="op">==</span> target<span class="op">)</span></span>
<span id="list:lowest_common_ancestor_paths-11"><a href="#list:lowest_common_ancestor_paths-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:lowest_common_ancestor_paths-12"><a href="#list:lowest_common_ancestor_paths-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// found the target element. we can stop as the path is complete</span></span>
<span id="list:lowest_common_ancestor_paths-13"><a href="#list:lowest_common_ancestor_paths-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="list:lowest_common_ancestor_paths-14"><a href="#list:lowest_common_ancestor_paths-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:lowest_common_ancestor_paths-15"><a href="#list:lowest_common_ancestor_paths-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:lowest_common_ancestor_paths-16"><a href="#list:lowest_common_ancestor_paths-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">// classic BST search</span></span>
<span id="list:lowest_common_ancestor_paths-17"><a href="#list:lowest_common_ancestor_paths-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>target <span class="op">&lt;=</span> root<span class="op">-&gt;</span>val<span class="op">)</span></span>
<span id="list:lowest_common_ancestor_paths-18"><a href="#list:lowest_common_ancestor_paths-18" aria-hidden="true" tabindex="-1"></a>    find_path_helper<span class="op">(</span>root<span class="op">-&gt;</span>left<span class="op">,</span> target<span class="op">,</span> path<span class="op">);</span></span>
<span id="list:lowest_common_ancestor_paths-19"><a href="#list:lowest_common_ancestor_paths-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span></span>
<span id="list:lowest_common_ancestor_paths-20"><a href="#list:lowest_common_ancestor_paths-20" aria-hidden="true" tabindex="-1"></a>    find_path_helper<span class="op">(</span>root<span class="op">-&gt;</span>right<span class="op">,</span> target<span class="op">,</span> path<span class="op">);</span></span>
<span id="list:lowest_common_ancestor_paths-21"><a href="#list:lowest_common_ancestor_paths-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:lowest_common_ancestor_paths-22"><a href="#list:lowest_common_ancestor_paths-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:lowest_common_ancestor_paths-23"><a href="#list:lowest_common_ancestor_paths-23" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:lowest_common_ancestor_paths-24"><a href="#list:lowest_common_ancestor_paths-24" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>Node<span class="op">&lt;</span>T<span class="op">&gt;*&gt;</span> find_path<span class="op">(</span>Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> root<span class="op">,</span> <span class="at">const</span> T<span class="op">&amp;</span> node<span class="op">)</span></span>
<span id="list:lowest_common_ancestor_paths-25"><a href="#list:lowest_common_ancestor_paths-25" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:lowest_common_ancestor_paths-26"><a href="#list:lowest_common_ancestor_paths-26" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span>Node<span class="op">&lt;</span>T<span class="op">&gt;*&gt;</span> path <span class="op">=</span> <span class="op">{};</span></span>
<span id="list:lowest_common_ancestor_paths-27"><a href="#list:lowest_common_ancestor_paths-27" aria-hidden="true" tabindex="-1"></a>  find_path_helper<span class="op">(</span>root<span class="op">,</span> node<span class="op">,</span> path<span class="op">);</span></span>
<span id="list:lowest_common_ancestor_paths-28"><a href="#list:lowest_common_ancestor_paths-28" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> path<span class="op">;</span></span>
<span id="list:lowest_common_ancestor_paths-29"><a href="#list:lowest_common_ancestor_paths-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:lowest_common_ancestor_paths-30"><a href="#list:lowest_common_ancestor_paths-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:lowest_common_ancestor_paths-31"><a href="#list:lowest_common_ancestor_paths-31" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:lowest_common_ancestor_paths-32"><a href="#list:lowest_common_ancestor_paths-32" aria-hidden="true" tabindex="-1"></a>Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> findLeastCommonAncestor_paths<span class="op">(</span>Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> root<span class="op">,</span> <span class="at">const</span> T<span class="op">&amp;</span> p<span class="op">,</span> <span class="at">const</span> T<span class="op">&amp;</span> q<span class="op">)</span></span>
<span id="list:lowest_common_ancestor_paths-33"><a href="#list:lowest_common_ancestor_paths-33" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:lowest_common_ancestor_paths-34"><a href="#list:lowest_common_ancestor_paths-34" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span>Node<span class="op">&lt;</span>T<span class="op">&gt;*&gt;</span> P_p <span class="op">=</span> find_path<span class="op">(</span>root<span class="op">,</span> p<span class="op">);</span></span>
<span id="list:lowest_common_ancestor_paths-35"><a href="#list:lowest_common_ancestor_paths-35" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span>Node<span class="op">&lt;</span>T<span class="op">&gt;*&gt;</span> P_q <span class="op">=</span> find_path<span class="op">(</span>root<span class="op">,</span> q<span class="op">);</span></span>
<span id="list:lowest_common_ancestor_paths-36"><a href="#list:lowest_common_ancestor_paths-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:lowest_common_ancestor_paths-37"><a href="#list:lowest_common_ancestor_paths-37" aria-hidden="true" tabindex="-1"></a>  <span class="co">// find the point up to which P_q and P_q are the same</span></span>
<span id="list:lowest_common_ancestor_paths-38"><a href="#list:lowest_common_ancestor_paths-38" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> itp     <span class="op">=</span> begin<span class="op">(</span>P_p<span class="op">);</span></span>
<span id="list:lowest_common_ancestor_paths-39"><a href="#list:lowest_common_ancestor_paths-39" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> itq     <span class="op">=</span> begin<span class="op">(</span>P_q<span class="op">);</span></span>
<span id="list:lowest_common_ancestor_paths-40"><a href="#list:lowest_common_ancestor_paths-40" aria-hidden="true" tabindex="-1"></a>  Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> ans <span class="op">=</span> <span class="op">*</span>itp<span class="op">;</span></span>
<span id="list:lowest_common_ancestor_paths-41"><a href="#list:lowest_common_ancestor_paths-41" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">((</span>itp <span class="op">!=</span> end<span class="op">(</span>P_p<span class="op">)</span> <span class="op">&amp;&amp;</span> itq <span class="op">!=</span> end<span class="op">(</span>P_q<span class="op">))</span> <span class="op">&amp;&amp;</span> <span class="op">(*</span>itp <span class="op">==</span> <span class="op">*</span>itq<span class="op">))</span></span>
<span id="list:lowest_common_ancestor_paths-42"><a href="#list:lowest_common_ancestor_paths-42" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:lowest_common_ancestor_paths-43"><a href="#list:lowest_common_ancestor_paths-43" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">=</span> <span class="op">*</span>itp<span class="op">;</span></span>
<span id="list:lowest_common_ancestor_paths-44"><a href="#list:lowest_common_ancestor_paths-44" aria-hidden="true" tabindex="-1"></a>    itp<span class="op">++;</span></span>
<span id="list:lowest_common_ancestor_paths-45"><a href="#list:lowest_common_ancestor_paths-45" aria-hidden="true" tabindex="-1"></a>    itq<span class="op">++;</span></span>
<span id="list:lowest_common_ancestor_paths-46"><a href="#list:lowest_common_ancestor_paths-46" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:lowest_common_ancestor_paths-47"><a href="#list:lowest_common_ancestor_paths-47" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:lowest_common_ancestor_paths-48"><a href="#list:lowest_common_ancestor_paths-48" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This approach is however not optimal as we waste unnecessary space for storing entire paths. This is not really necessary as we only really care about the last node that is common. One way to avoid memorizing the entire paths is to find the path for both <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> simultaneously and only remember the last node we visited. It as some point of this visit we find that the the next node to visit for <span class="math inline">\(p\)</span> is different from the direction of the search for <span class="math inline">\(q\)</span> wants us to go, we can stop as this is the point where the paths for <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> diverge. We can therefore return the last element that was common. Despite the fact this approach does not improve the time complexity w.r.t to the other solution, we have in this case only a constant space usage which is a very good improvement compared to the linear space complexity for Listing <a href="#list:lowest_common_ancestor_paths" data-reference-type="ref" data-reference="list:lowest_common_ancestor_paths">[list:lowest_common_ancestor_paths]</a>. This optimized version is shown in Listing <a href="#list:lowest_common_ancestor_paths_optimized" data-reference-type="ref" data-reference="list:lowest_common_ancestor_paths_optimized">[list:lowest_common_ancestor_paths_optimized]</a>.</p>
<div class="sourceCode" id="list:lowest_common_ancestor_paths_optimized" data-language="c++" data-caption="Space optimized version of Listing \ref{list:lowest_common_ancestor_paths}" label="list:lowest_common_ancestor_paths_optimized"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:lowest_common_ancestor_paths_optimized-1"><a href="#list:lowest_common_ancestor_paths_optimized-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-2"><a href="#list:lowest_common_ancestor_paths_optimized-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> find_path_optimized_helper<span class="op">(</span>Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> root<span class="op">,</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-3"><a href="#list:lowest_common_ancestor_paths_optimized-3" aria-hidden="true" tabindex="-1"></a>                                <span class="at">const</span> T<span class="op">&amp;</span> p<span class="op">,</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-4"><a href="#list:lowest_common_ancestor_paths_optimized-4" aria-hidden="true" tabindex="-1"></a>                                <span class="at">const</span> T<span class="op">&amp;</span> q<span class="op">,</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-5"><a href="#list:lowest_common_ancestor_paths_optimized-5" aria-hidden="true" tabindex="-1"></a>                                Node<span class="op">&lt;</span>T<span class="op">&gt;*&amp;</span> last_common<span class="op">)</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-6"><a href="#list:lowest_common_ancestor_paths_optimized-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-7"><a href="#list:lowest_common_ancestor_paths_optimized-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>root<span class="op">);</span>  <span class="co">// because target in guaranteed to be in the tree.</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-8"><a href="#list:lowest_common_ancestor_paths_optimized-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:lowest_common_ancestor_paths_optimized-9"><a href="#list:lowest_common_ancestor_paths_optimized-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// LCA is the current node. Either p is descendant of q or the other way</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-10"><a href="#list:lowest_common_ancestor_paths_optimized-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// around</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-11"><a href="#list:lowest_common_ancestor_paths_optimized-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>root<span class="op">-&gt;</span>val <span class="op">==</span> p <span class="op">||</span> root<span class="op">-&gt;</span>val <span class="op">==</span> q<span class="op">)</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-12"><a href="#list:lowest_common_ancestor_paths_optimized-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-13"><a href="#list:lowest_common_ancestor_paths_optimized-13" aria-hidden="true" tabindex="-1"></a>    last_common <span class="op">=</span> root<span class="op">;</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-14"><a href="#list:lowest_common_ancestor_paths_optimized-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-15"><a href="#list:lowest_common_ancestor_paths_optimized-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-16"><a href="#list:lowest_common_ancestor_paths_optimized-16" aria-hidden="true" tabindex="-1"></a>  last_common <span class="op">=</span> root<span class="op">;</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-17"><a href="#list:lowest_common_ancestor_paths_optimized-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:lowest_common_ancestor_paths_optimized-18"><a href="#list:lowest_common_ancestor_paths_optimized-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">// paths for p and q takes different direction from here</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-19"><a href="#list:lowest_common_ancestor_paths_optimized-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">((</span>p <span class="op">&lt;=</span> root<span class="op">-&gt;</span>val <span class="op">&amp;&amp;</span> q <span class="op">&gt;</span> root<span class="op">-&gt;</span>val<span class="op">)</span> <span class="op">||</span> <span class="op">(</span>p <span class="op">&gt;</span> root<span class="op">-&gt;</span>val <span class="op">&amp;&amp;</span> q <span class="op">&lt;=</span> root<span class="op">-&gt;</span>val<span class="op">))</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-20"><a href="#list:lowest_common_ancestor_paths_optimized-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-21"><a href="#list:lowest_common_ancestor_paths_optimized-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:lowest_common_ancestor_paths_optimized-22"><a href="#list:lowest_common_ancestor_paths_optimized-22" aria-hidden="true" tabindex="-1"></a>  <span class="co">// they are both lower or equal than val or both higher</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-23"><a href="#list:lowest_common_ancestor_paths_optimized-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>p <span class="op">&lt;=</span> root<span class="op">-&gt;</span>val<span class="op">)</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-24"><a href="#list:lowest_common_ancestor_paths_optimized-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-25"><a href="#list:lowest_common_ancestor_paths_optimized-25" aria-hidden="true" tabindex="-1"></a>    find_path_optimized_helper<span class="op">(</span>root<span class="op">-&gt;</span>left<span class="op">,</span> p<span class="op">,</span> q<span class="op">,</span> last_common<span class="op">);</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-26"><a href="#list:lowest_common_ancestor_paths_optimized-26" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-27"><a href="#list:lowest_common_ancestor_paths_optimized-27" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-28"><a href="#list:lowest_common_ancestor_paths_optimized-28" aria-hidden="true" tabindex="-1"></a>    find_path_optimized_helper<span class="op">(</span>root<span class="op">-&gt;</span>right<span class="op">,</span> p<span class="op">,</span> q<span class="op">,</span> last_common<span class="op">);</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-29"><a href="#list:lowest_common_ancestor_paths_optimized-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-30"><a href="#list:lowest_common_ancestor_paths_optimized-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:lowest_common_ancestor_paths_optimized-31"><a href="#list:lowest_common_ancestor_paths_optimized-31" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-32"><a href="#list:lowest_common_ancestor_paths_optimized-32" aria-hidden="true" tabindex="-1"></a>Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> findLeastCommonAncestor_paths_optimized<span class="op">(</span>Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> root<span class="op">,</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-33"><a href="#list:lowest_common_ancestor_paths_optimized-33" aria-hidden="true" tabindex="-1"></a>                                                 <span class="at">const</span> T<span class="op">&amp;</span> p<span class="op">,</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-34"><a href="#list:lowest_common_ancestor_paths_optimized-34" aria-hidden="true" tabindex="-1"></a>                                                 <span class="at">const</span> T<span class="op">&amp;</span> q<span class="op">)</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-35"><a href="#list:lowest_common_ancestor_paths_optimized-35" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-36"><a href="#list:lowest_common_ancestor_paths_optimized-36" aria-hidden="true" tabindex="-1"></a>  Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> ans <span class="op">=</span> root<span class="op">;</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-37"><a href="#list:lowest_common_ancestor_paths_optimized-37" aria-hidden="true" tabindex="-1"></a>  find_path_optimized_helper<span class="op">(</span>root<span class="op">,</span> p<span class="op">,</span> q<span class="op">,</span> ans<span class="op">);</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-38"><a href="#list:lowest_common_ancestor_paths_optimized-38" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:lowest_common_ancestor_paths_optimized-39"><a href="#list:lowest_common_ancestor_paths_optimized-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We can however simplify the implementation shown in Listing <a href="#list:lowest_common_ancestor_paths_optimized" data-reference-type="ref" data-reference="list:lowest_common_ancestor_paths_optimized">[list:lowest_common_ancestor_paths_optimized]</a> by rewriting it such that it runs iteratively rather than recursively. Listing <a href="#list:lowest_common_ancestor_iterative" data-reference-type="ref" data-reference="list:lowest_common_ancestor_iterative">[list:lowest_common_ancestor_iterative]</a> shows this iterative version which starts at the root of <span class="math inline">\(T\)</span> and keep navigating the tree until by moving left or right until the direction of the search for both <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> is the same. When the path diverges we can stop and return the current node which is the lowest node shared node in the paths from the root to <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span></p>
<div class="sourceCode" id="list:lowest_common_ancestor_iterative" data-language="c++" data-caption="Iterative solution to the problem of finding the LCA in a binary search tree." label="list:lowest_common_ancestor_iterative"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:lowest_common_ancestor_iterative-1"><a href="#list:lowest_common_ancestor_iterative-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:lowest_common_ancestor_iterative-2"><a href="#list:lowest_common_ancestor_iterative-2" aria-hidden="true" tabindex="-1"></a>Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> findLeastCommonAncestor_reference<span class="op">(</span>Node<span class="op">&lt;</span>T<span class="op">&gt;*</span> root<span class="op">,</span></span>
<span id="list:lowest_common_ancestor_iterative-3"><a href="#list:lowest_common_ancestor_iterative-3" aria-hidden="true" tabindex="-1"></a>                                           <span class="at">const</span> T<span class="op">&amp;</span> p<span class="op">,</span></span>
<span id="list:lowest_common_ancestor_iterative-4"><a href="#list:lowest_common_ancestor_iterative-4" aria-hidden="true" tabindex="-1"></a>                                           <span class="at">const</span> T<span class="op">&amp;</span> q<span class="op">)</span></span>
<span id="list:lowest_common_ancestor_iterative-5"><a href="#list:lowest_common_ancestor_iterative-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:lowest_common_ancestor_iterative-6"><a href="#list:lowest_common_ancestor_iterative-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>root<span class="op">)</span></span>
<span id="list:lowest_common_ancestor_iterative-7"><a href="#list:lowest_common_ancestor_iterative-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:lowest_common_ancestor_iterative-8"><a href="#list:lowest_common_ancestor_iterative-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> payload <span class="op">=</span> root<span class="op">-&gt;</span>val<span class="op">;</span></span>
<span id="list:lowest_common_ancestor_iterative-9"><a href="#list:lowest_common_ancestor_iterative-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>payload <span class="op">&gt;</span> p <span class="op">&amp;&amp;</span> payload <span class="op">&gt;</span> q<span class="op">)</span></span>
<span id="list:lowest_common_ancestor_iterative-10"><a href="#list:lowest_common_ancestor_iterative-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:lowest_common_ancestor_iterative-11"><a href="#list:lowest_common_ancestor_iterative-11" aria-hidden="true" tabindex="-1"></a>      root <span class="op">=</span> root<span class="op">-&gt;</span>left<span class="op">;</span></span>
<span id="list:lowest_common_ancestor_iterative-12"><a href="#list:lowest_common_ancestor_iterative-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:lowest_common_ancestor_iterative-13"><a href="#list:lowest_common_ancestor_iterative-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>payload <span class="op">&lt;</span> p <span class="op">&amp;&amp;</span> payload <span class="op">&lt;</span> q<span class="op">)</span></span>
<span id="list:lowest_common_ancestor_iterative-14"><a href="#list:lowest_common_ancestor_iterative-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:lowest_common_ancestor_iterative-15"><a href="#list:lowest_common_ancestor_iterative-15" aria-hidden="true" tabindex="-1"></a>      root <span class="op">=</span> root<span class="op">-&gt;</span>right<span class="op">;</span></span>
<span id="list:lowest_common_ancestor_iterative-16"><a href="#list:lowest_common_ancestor_iterative-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:lowest_common_ancestor_iterative-17"><a href="#list:lowest_common_ancestor_iterative-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="list:lowest_common_ancestor_iterative-18"><a href="#list:lowest_common_ancestor_iterative-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:lowest_common_ancestor_iterative-19"><a href="#list:lowest_common_ancestor_iterative-19" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> root<span class="op">;</span></span>
<span id="list:lowest_common_ancestor_iterative-20"><a href="#list:lowest_common_ancestor_iterative-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:lowest_common_ancestor_iterative-21"><a href="#list:lowest_common_ancestor_iterative-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:lowest_common_ancestor_iterative-22"><a href="#list:lowest_common_ancestor_iterative-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> root<span class="op">;</span></span>
<span id="list:lowest_common_ancestor_iterative-23"><a href="#list:lowest_common_ancestor_iterative-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="ch:distance_between_nodes_in_tree">Distance between nodes in BST</h1>
<h2 class="unnumbered" id="introduction-37">Introduction</h2>
<p>In the problem described in this chapter we are going to investigate how we can find the the distance between two nodes in a binary search tree. As we will see this problem can be approached and solved very straightforwardly if we are able identify the key idea behind it. This insight can become apparent after we look at a few examples and our advice for approaching this problem (and to be honest all problems on graphs and trees) is to draw and discuss quite a few examples with your interviewer. This help you get a much better intuitive understanding of what the problem is really about, which will eventually lead to the eureka moment.</p>
<p>This is going to be a relatively short chapter because the solution is built on top of the solution of a problem discussed in another chapter. In Section <a href="#sec:distance_between_nodes_in_tree:problem" data-reference-type="ref" data-reference="sec:distance_between_nodes_in_tree:problem">40.1</a> we will have a look at the formal problem statement and in Section <a href="#distance_between_nodes_in_tree:sec:discussion" data-reference-type="ref" data-reference="distance_between_nodes_in_tree:sec:discussion">40.3</a> we discuss the solution approach and we will look into two possible different implementations: recursive and iterative.</p>
<h2 id="sec:distance_between_nodes_in_tree:problem">Problem statement</h2>
<div class="exercise">
<p>Write a function that takes as input a binary search tree <span class="math inline">\(T\)</span> and two nodes <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> and returns the distance between <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span>. The distance between two nodes <span class="math inline">\(D(p,q)\)</span> is defined as the number of edges you need to traverse to get from <span class="math inline">\(p\)</span> to <span class="math inline">\(q\)</span>.</p>
<div class="example">
<p><br />
Given the tree shown in Figure <a href="#fig:distance_between_nodes_in_tree:example1" data-reference-type="ref" data-reference="fig:distance_between_nodes_in_tree:example1">40.2</a>, <span class="math inline">\(p = 1\)</span> and <span class="math inline">\(q=3\)</span>, the function returns <span class="math inline">\(D(1,3)=2\)</span></p>
<p>If <span class="math inline">\(p=3\)</span> and <span class="math inline">\(q=2\)</span> the function returna <span class="math inline">\(1\)</span>. <span id="ex:distance_between_nodes_in_tree:example1" label="ex:distance_between_nodes_in_tree:example1">[ex:distance_between_nodes_in_tree:example1]</span></p>
</div>
<div class="example">
<p><br />
Given the tree shown in Figure <a href="#fig:distance_between_nodes_in_tree:example2" data-reference-type="ref" data-reference="fig:distance_between_nodes_in_tree:example2">40.1</a>, <span class="math inline">\(p = 5\)</span> and <span class="math inline">\(q=2\)</span>, the function returns <span class="math inline">\(D(5,2)=6\)</span> <span id="ex:distance_between_nodes_in_tree:example2" label="ex:distance_between_nodes_in_tree:example2">[ex:distance_between_nodes_in_tree:example2]</span></p>
</div>
</div>
<h2 id="clarification-questions-32">Clarification Questions</h2>
<div class="QandA">
<p>Can <span class="math inline">\(p\)</span> be equal to <span class="math inline">\(q\)</span>?</p>
<div class="answered">
<p><em>Yes, this is a valid case.</em></p>
</div>
<p>Is it guaranteed for <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> to be present in <span class="math inline">\(T\)</span>?</p>
<div class="answered">
<p><em>Yes, you can assume <span class="math inline">\(T\)</span> always contains both <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span>.</em></p>
</div>
</div>
<h2 id="distance_between_nodes_in_tree:sec:discussion">Discussion</h2>
<p>As already mentioned in the introduction this problem can become quite challenging if we are not able to steer our approach in the right direction. The intuitive idea on how this problem should be approached is going to be almost self-evident if we look at a couple of examples, solve them by hand and then try to look for similarities in their solution.</p>
<p>Let’s have a look at some instances of this problem and their solution. If we consider <span class="math inline">\(T\)</span> to the tree depicted in Figure <a href="#fig:distance_between_nodes_in_tree:example3" data-reference-type="ref" data-reference="fig:distance_between_nodes_in_tree:example3">40.3</a> then the distance between nodes <span class="math inline">\(p=3\)</span> and <span class="math inline">\(q=9\)</span> is <span class="math inline">\(4\)</span> and can be found by walking up the tree from node <span class="math inline">\(3\)</span> up to a node <span class="math inline">\(5\)</span> (follow the red arcs) from which we can descend and reach node <span class="math inline">\(9\)</span> (green arcs). Notice that node <span class="math inline">\(5\)</span> is the first node from which we can visit the tree down and reach both nodes <span class="math inline">\(3\)</span> and <span class="math inline">\(9\)</span>. You can also see that the same reasoning applies also to the trees shown in Figures <a href="#fig:distance_between_nodes_in_tree:example4" data-reference-type="ref" data-reference="fig:distance_between_nodes_in_tree:example4">40.4</a> and <a href="#fig:distance_between_nodes_in_tree:example5" data-reference-type="ref" data-reference="fig:distance_between_nodes_in_tree:example5">40.5</a> where you get the minimum distance by traveling up to the first node that allows you to reach the destination node. Notice that in Figure <a href="#fig:distance_between_nodes_in_tree:example5" data-reference-type="ref" data-reference="fig:distance_between_nodes_in_tree:example5">40.5</a> the path upwards has length zero as from <span class="math inline">\(p\)</span> you can already reach <span class="math inline">\(q\)</span> by visiting down the tree.</p>
<p>At this point should be clear that the minimum distance between two nodes can be calculated as the sum of distances from <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> their lowest common ancestor (LCA). The LCA is the lowest node from which it is possible to walk in a downward direction and reach both <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span>. In order to go from <span class="math inline">\(p\)</span> to <span class="math inline">\(q\)</span> one must pass through their LCA. If you need to refresh your memory on the topic of finding the LCA on binary search trees you can read Chapter <a href="#ch:lowest_common_ancestor" data-reference-type="ref" data-reference="ch:lowest_common_ancestor">39</a>. Listing <a href="#list:distance_between_nodes_in_tree" data-reference-type="ref" data-reference="list:distance_between_nodes_in_tree">[list:distance_between_nodes_in_tree]</a> shows a possible implementation of the idea described above.</p>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/distance_between_nodes_in_tree/images/example2.jpg" id="fig:distance_between_nodes_in_tree:example2" style="width:80.0%" alt="Binary Search tree of the Example [ex:distance_between_nodes_in_tree:example2]" /><figcaption aria-hidden="true">Binary Search tree of the Example <a href="#ex:distance_between_nodes_in_tree:example2" data-reference-type="ref" data-reference="ex:distance_between_nodes_in_tree:example2">[ex:distance_between_nodes_in_tree:example2]</a></figcaption>
</figure>
<p>. <span id="fig:distance_between_nodes_in_tree:example2" label="fig:distance_between_nodes_in_tree:example2">[fig:distance_between_nodes_in_tree:example2]</span></p>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/distance_between_nodes_in_tree/images/example1.jpg" id="fig:distance_between_nodes_in_tree:example1" alt="Binary Search tree of the Example [ex:distance_between_nodes_in_tree:example1]" /><figcaption aria-hidden="true">Binary Search tree of the Example <a href="#ex:distance_between_nodes_in_tree:example1" data-reference-type="ref" data-reference="ex:distance_between_nodes_in_tree:example1">[ex:distance_between_nodes_in_tree:example1]</a></figcaption>
</figure>
<p>. <span id="fig:distance_between_nodes_in_tree:example1" label="fig:distance_between_nodes_in_tree:example1">[fig:distance_between_nodes_in_tree:example1]</span></p>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/distance_between_nodes_in_tree/images/example3.jpg" id="fig:distance_between_nodes_in_tree:example3" />
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/distance_between_nodes_in_tree/images/example4.jpg" id="fig:distance_between_nodes_in_tree:example4" />
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/distance_between_nodes_in_tree/images/example5.jpg" id="fig:distance_between_nodes_in_tree:example5" />
</figure>
<div class="sourceCode" id="list:distance_between_nodes_in_tree" data-language="c++" data-caption="Solution to the problem of finding the distance between two nodes in a binary search tree." label="list:distance_between_nodes_in_tree"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:distance_between_nodes_in_tree-1"><a href="#list:distance_between_nodes_in_tree-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="list:distance_between_nodes_in_tree-2"><a href="#list:distance_between_nodes_in_tree-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * Calculates the distance between T and a node with payload `val`</span></span>
<span id="list:distance_between_nodes_in_tree-3"><a href="#list:distance_between_nodes_in_tree-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Perform a classic BST visit/search (downward) from T for val.</span></span>
<span id="list:distance_between_nodes_in_tree-4"><a href="#list:distance_between_nodes_in_tree-4" aria-hidden="true" tabindex="-1"></a><span class="co"> *</span></span>
<span id="list:distance_between_nodes_in_tree-5"><a href="#list:distance_between_nodes_in_tree-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@param</span><span class="co"> </span><span class="cv">T</span><span class="co"> is valid binary search tree</span></span>
<span id="list:distance_between_nodes_in_tree-6"><a href="#list:distance_between_nodes_in_tree-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@param</span><span class="co"> </span><span class="cv">val</span><span class="co"> is the value to be searched in T</span></span>
<span id="list:distance_between_nodes_in_tree-7"><a href="#list:distance_between_nodes_in_tree-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co"> the distance between T and val</span></span>
<span id="list:distance_between_nodes_in_tree-8"><a href="#list:distance_between_nodes_in_tree-8" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="list:distance_between_nodes_in_tree-9"><a href="#list:distance_between_nodes_in_tree-9" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="list:distance_between_nodes_in_tree-10"><a href="#list:distance_between_nodes_in_tree-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> find_distance_down<span class="op">(</span><span class="at">const</span> Node<span class="op">&lt;</span>U<span class="op">&gt;*</span> <span class="at">const</span> T<span class="op">,</span> <span class="at">const</span> U val<span class="op">)</span></span>
<span id="list:distance_between_nodes_in_tree-11"><a href="#list:distance_between_nodes_in_tree-11" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:distance_between_nodes_in_tree-12"><a href="#list:distance_between_nodes_in_tree-12" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>T <span class="op">&amp;&amp;</span> <span class="st">&quot;node val exists and is reachable from T&quot;</span><span class="op">);</span></span>
<span id="list:distance_between_nodes_in_tree-13"><a href="#list:distance_between_nodes_in_tree-13" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> payload <span class="op">=</span> T<span class="op">-&gt;</span>val<span class="op">;</span></span>
<span id="list:distance_between_nodes_in_tree-14"><a href="#list:distance_between_nodes_in_tree-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>payload <span class="op">==</span> val<span class="op">)</span></span>
<span id="list:distance_between_nodes_in_tree-15"><a href="#list:distance_between_nodes_in_tree-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:distance_between_nodes_in_tree-16"><a href="#list:distance_between_nodes_in_tree-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>val <span class="op">&lt;=</span> payload<span class="op">)</span></span>
<span id="list:distance_between_nodes_in_tree-17"><a href="#list:distance_between_nodes_in_tree-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="op">+</span> find_distance_down<span class="op">(</span>T<span class="op">-&gt;</span>left<span class="op">,</span> val<span class="op">);</span></span>
<span id="list:distance_between_nodes_in_tree-18"><a href="#list:distance_between_nodes_in_tree-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">1</span> <span class="op">+</span> find_distance_down<span class="op">(</span>T<span class="op">-&gt;</span>right<span class="op">,</span> val<span class="op">);</span></span>
<span id="list:distance_between_nodes_in_tree-19"><a href="#list:distance_between_nodes_in_tree-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:distance_between_nodes_in_tree-20"><a href="#list:distance_between_nodes_in_tree-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:distance_between_nodes_in_tree-21"><a href="#list:distance_between_nodes_in_tree-21" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="list:distance_between_nodes_in_tree-22"><a href="#list:distance_between_nodes_in_tree-22" aria-hidden="true" tabindex="-1"></a><span class="co"> * Find the distance between two nodes a tree</span></span>
<span id="list:distance_between_nodes_in_tree-23"><a href="#list:distance_between_nodes_in_tree-23" aria-hidden="true" tabindex="-1"></a><span class="co"> *</span></span>
<span id="list:distance_between_nodes_in_tree-24"><a href="#list:distance_between_nodes_in_tree-24" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@param</span><span class="co"> </span><span class="cv">T</span><span class="co"> is valid binary search tree</span></span>
<span id="list:distance_between_nodes_in_tree-25"><a href="#list:distance_between_nodes_in_tree-25" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@param</span><span class="co"> </span><span class="cv">p</span><span class="co"> is the payload of a node in T</span></span>
<span id="list:distance_between_nodes_in_tree-26"><a href="#list:distance_between_nodes_in_tree-26" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@param</span><span class="co"> </span><span class="cv">q</span><span class="co"> is the payload of a node in T</span></span>
<span id="list:distance_between_nodes_in_tree-27"><a href="#list:distance_between_nodes_in_tree-27" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co"> the minimum number of edges to traverse to get from p to q</span></span>
<span id="list:distance_between_nodes_in_tree-28"><a href="#list:distance_between_nodes_in_tree-28" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="list:distance_between_nodes_in_tree-29"><a href="#list:distance_between_nodes_in_tree-29" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="list:distance_between_nodes_in_tree-30"><a href="#list:distance_between_nodes_in_tree-30" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> min_distance_nodes_BST<span class="op">(</span>Node<span class="op">&lt;</span>U<span class="op">&gt;*</span> T<span class="op">,</span> <span class="at">const</span> U p<span class="op">,</span> <span class="at">const</span> U q<span class="op">)</span></span>
<span id="list:distance_between_nodes_in_tree-31"><a href="#list:distance_between_nodes_in_tree-31" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:distance_between_nodes_in_tree-32"><a href="#list:distance_between_nodes_in_tree-32" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> Node<span class="op">&lt;</span>U<span class="op">&gt;*</span> <span class="at">const</span> lca <span class="op">=</span> find_LCA<span class="op">(</span>T<span class="op">,</span> p<span class="op">,</span> q<span class="op">);</span></span>
<span id="list:distance_between_nodes_in_tree-33"><a href="#list:distance_between_nodes_in_tree-33" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> find_distance_down<span class="op">(</span>lca<span class="op">,</span> p<span class="op">)</span> <span class="op">+</span> find_distance_down<span class="op">(</span>lca<span class="op">,</span> q<span class="op">);</span></span>
<span id="list:distance_between_nodes_in_tree-34"><a href="#list:distance_between_nodes_in_tree-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="conclusion-4">Conclusion</h2>
<p>In this chapter we have seen how we can efficiently solve the problem of finding the distance between two nodes in a binary search tree by using the concept of LCA (discussed more in details in Chapter <a href="#ch:lowest_common_ancestor" data-reference-type="ref" data-reference="ch:lowest_common_ancestor">39</a>). The general strategy is that, we can calculate the distance between the LCA and both <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span>. The sum of these two distances is the final answer. The distance between two nodes in a binary search tree can be found by slightly modifying the standard search algorithm for BSTs so that we return the number of recursive calls made instead of a boolean value signaling whether the element to be searched was found or not.</p>
<h1 id="ch:items_in_containers_amazon">Counts the items in the containers</h1>
<h2 class="unnumbered" id="introduction-38">Introduction</h2>
<p>Imagine you are the owner of a successful online store. You would like to be able to query what is the number of items you still have in the warehouse. The problem is that you cannot just walk into the warehouse and count the items as they are stored in closed containers. Thankfully, the warehouse is equipped with sensors and it is able to produce a string representing the state of the warehouse and single containers. The problem described in this chapter investigates how we can write an algorithm that takes such a string (the state of all the containers in the warehouse) and is able to answer queries on the number of elements that are present in some portions of the warehouse itself.</p>
<p>This problem has been reported to be asked during Amazon interviews and it is considered a medium difficulty problem. We will investigate two solutions:</p>
<ul>
<li><p>brute-force, that is going to have a relatively straightforward logic (blindly count the items in the string) and be easy to code (in Section <a href="#items_in_containers_amazon:sec:bruteforce" data-reference-type="ref" data-reference="items_in_containers_amazon:sec:bruteforce">41.3.1</a>),</p></li>
<li><p>a more sophisticated one with optimal asymptotic complexity where the input string is preprocessed so that queries can be answered faster.</p></li>
</ul>
<h2 id="problem-statement-40">Problem statement</h2>
<div class="exercise">
<p>You are given a string <span class="math inline">\(s\)</span> representing the current state of a warehouse. The string contains only two kinds of characters:</p>
<dl>
<dt>(ASCII 42)</dt>
<dd><p>: representing an item</p>
</dd>
<dt>(ASCII 124)</dt>
<dd><p>: representing the boundaries of a container.</p>
</dd>
</dl>
<p>A container is a closed space within the warehouse and it is represented in <span class="math inline">\(s\)</span> by a pair of . Items within a container <span class="math inline">\(c\)</span> are represented as appearing withing the two defining <span class="math inline">\(c\)</span>. You are also given an array of pairs <span class="math inline">\(Q = \{(s_0,
	e_0),(s_1, e_2),\ldots,(s_{n-1}, e_{e-1}) : 0 \leq s_i \leq e_i \leq |s|\}\)</span>, where each pair in <span class="math inline">\(Q\)</span> identifies a substring in <span class="math inline">\(s\)</span>. Each element of <span class="math inline">\(Q\)</span> is a query you must answer to.</p>
<p>Your task is to write a function that returns an array <span class="math inline">\(A\)</span> of length <span class="math inline">\(n\)</span>, containing the answers to all of the queries in <span class="math inline">\(Q\)</span>, where each element <span class="math inline">\(A_i\)</span> is the number of items contained in all the <strong>closed</strong> compartments between <span class="math inline">\((s_i, e_i)\)</span>.</p>
<div class="example">
<p><br />
Given <code>s = </code> and <span class="math inline">\(Q = \{(0,4),(0,5)\}\)</span> the function returns <span class="math inline">\(A=\{2,3\}\)</span>. <span class="math inline">\(s\)</span> has a total of <span class="math inline">\(2\)</span> closed containers the first with <span class="math inline">\(2\)</span> and <span class="math inline">\(1\)</span> item inside respectively.</p>
<p>The first query asks you to find the number of elements in the substring <span class="math inline">\(s[0,4]=\)</span> <code></code> where three items are represented but only two are within a closed container (the first two).</p>
<p>The second query refers to the substring <span class="math inline">\(s[0,5]=\)</span> <code></code>. The items are the same as in the previous query but this time all of them are in closed containers.</p>
</div>
<div class="example">
<p><br />
Given <code>s = </code> and <span class="math inline">\(Q = \{(0,2),(1,3)\}\)</span> the function returns <span class="math inline">\(A=\{0,1\}\)</span>. <span class="math inline">\(s\)</span> has a total of two items and only <span class="math inline">\(1\)</span> closed container containing only a single item.</p>
<p>The first query refers to the substring <span class="math inline">\(s[0,2]=\)</span> <code></code>. No closed container are represented in such substring thus the answer in this case must be <span class="math inline">\(0\)</span>. However, the second question refers to <span class="math inline">\(s[1,3]=\)</span> <code></code> where we can see we have a valid container. We can therefore counts the elements in it.</p>
</div>
</div>
<h2 id="clarification-questions-33">Clarification Questions</h2>
<div class="QandA">
<p>Is it guaranteed for the input string <span class="math inline">\(s\)</span> to only contains valid character?</p>
<div class="answered">
<p><em>Yes, you do not need to worry about the sanity of the input.</em></p>
</div>
</div>
<h2 id="items_in_containers_amazon:sec:discussion">Discussion</h2>
<h3 id="items_in_containers_amazon:sec:bruteforce">Brute-force</h3>
<p>This problem has a straightforward solution that basically loops over all the elements specified in a query <span class="math inline">\((s,e) \in Q\)</span> and counts all the elements inside the containers. Because the <span class="math inline">\(|s-e|\)</span> is <span class="math inline">\(O(|s|)\)</span> the complexity of this approach is <span class="math inline">\(O(|s|*|Q|)\)</span>. Listing <a href="#list:items_in_containers_amazon_bruteforce" data-reference-type="ref" data-reference="list:items_in_containers_amazon_bruteforce">[list:items_in_containers_amazon_bruteforce]</a> shows an implementation of such idea. Notice that most of the code complexity of this solution is in the function that has to make sure only to count items that are within a closed container. It does so by first finding the first container wall appearing after the start of the query interval. We can safely skip all those items because there are not inside a container. Once we have found the beginning of the first container, we can proceed by counting the elements, one container at the time.</p>
<div class="sourceCode" id="list:items_in_containers_amazon_bruteforce" data-language="c++" data-caption="Na\&quot;ive solution to the \textit{items in the container} problem." label="list:items_in_containers_amazon_bruteforce"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:items_in_containers_amazon_bruteforce-1"><a href="#list:items_in_containers_amazon_bruteforce-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> Query                   <span class="op">=</span> <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;;</span></span>
<span id="list:items_in_containers_amazon_bruteforce-2"><a href="#list:items_in_containers_amazon_bruteforce-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">char</span> kContDelimiter <span class="op">=</span> <span class="ch">&#39;|&#39;</span><span class="op">;</span></span>
<span id="list:items_in_containers_amazon_bruteforce-3"><a href="#list:items_in_containers_amazon_bruteforce-3" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">char</span> kItem          <span class="op">=</span> <span class="ch">&#39;*&#39;</span><span class="op">;</span></span>
<span id="list:items_in_containers_amazon_bruteforce-4"><a href="#list:items_in_containers_amazon_bruteforce-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:items_in_containers_amazon_bruteforce-5"><a href="#list:items_in_containers_amazon_bruteforce-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> count_items_in_substring<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> s<span class="op">,</span> <span class="at">const</span> Query<span class="op">&amp;</span> query<span class="op">)</span></span>
<span id="list:items_in_containers_amazon_bruteforce-6"><a href="#list:items_in_containers_amazon_bruteforce-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:items_in_containers_amazon_bruteforce-7"><a href="#list:items_in_containers_amazon_bruteforce-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[</span>start<span class="op">,</span> end<span class="op">]</span> <span class="op">=</span> query<span class="op">;</span></span>
<span id="list:items_in_containers_amazon_bruteforce-8"><a href="#list:items_in_containers_amazon_bruteforce-8" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>start <span class="op">&lt;=</span> end<span class="op">);</span></span>
<span id="list:items_in_containers_amazon_bruteforce-9"><a href="#list:items_in_containers_amazon_bruteforce-9" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>end <span class="op">&lt;=</span> <span class="bu">std::</span>ssize<span class="op">(</span>s<span class="op">));</span></span>
<span id="list:items_in_containers_amazon_bruteforce-10"><a href="#list:items_in_containers_amazon_bruteforce-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:items_in_containers_amazon_bruteforce-11"><a href="#list:items_in_containers_amazon_bruteforce-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> curr_char <span class="op">=</span> start<span class="op">;</span></span>
<span id="list:items_in_containers_amazon_bruteforce-12"><a href="#list:items_in_containers_amazon_bruteforce-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// find the first container</span></span>
<span id="list:items_in_containers_amazon_bruteforce-13"><a href="#list:items_in_containers_amazon_bruteforce-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>curr_char <span class="op">&lt;=</span> end <span class="op">&amp;&amp;</span> s<span class="op">[</span>curr_char<span class="op">]</span> <span class="op">!=</span> kContDelimiter<span class="op">)</span></span>
<span id="list:items_in_containers_amazon_bruteforce-14"><a href="#list:items_in_containers_amazon_bruteforce-14" aria-hidden="true" tabindex="-1"></a>    curr_char<span class="op">++;</span></span>
<span id="list:items_in_containers_amazon_bruteforce-15"><a href="#list:items_in_containers_amazon_bruteforce-15" aria-hidden="true" tabindex="-1"></a>  curr_char<span class="op">++;</span></span>
<span id="list:items_in_containers_amazon_bruteforce-16"><a href="#list:items_in_containers_amazon_bruteforce-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:items_in_containers_amazon_bruteforce-17"><a href="#list:items_in_containers_amazon_bruteforce-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans          <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:items_in_containers_amazon_bruteforce-18"><a href="#list:items_in_containers_amazon_bruteforce-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> cont_counter <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:items_in_containers_amazon_bruteforce-19"><a href="#list:items_in_containers_amazon_bruteforce-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>curr_char <span class="op">&lt;=</span> end<span class="op">)</span></span>
<span id="list:items_in_containers_amazon_bruteforce-20"><a href="#list:items_in_containers_amazon_bruteforce-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:items_in_containers_amazon_bruteforce-21"><a href="#list:items_in_containers_amazon_bruteforce-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>s<span class="op">[</span>curr_char<span class="op">]</span> <span class="op">==</span> kItem<span class="op">)</span></span>
<span id="list:items_in_containers_amazon_bruteforce-22"><a href="#list:items_in_containers_amazon_bruteforce-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:items_in_containers_amazon_bruteforce-23"><a href="#list:items_in_containers_amazon_bruteforce-23" aria-hidden="true" tabindex="-1"></a>      cont_counter<span class="op">++;</span></span>
<span id="list:items_in_containers_amazon_bruteforce-24"><a href="#list:items_in_containers_amazon_bruteforce-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:items_in_containers_amazon_bruteforce-25"><a href="#list:items_in_containers_amazon_bruteforce-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>s<span class="op">[</span>curr_char<span class="op">]</span> <span class="op">==</span> kContDelimiter<span class="op">)</span></span>
<span id="list:items_in_containers_amazon_bruteforce-26"><a href="#list:items_in_containers_amazon_bruteforce-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:items_in_containers_amazon_bruteforce-27"><a href="#list:items_in_containers_amazon_bruteforce-27" aria-hidden="true" tabindex="-1"></a>      ans <span class="op">+=</span> cont_counter<span class="op">;</span></span>
<span id="list:items_in_containers_amazon_bruteforce-28"><a href="#list:items_in_containers_amazon_bruteforce-28" aria-hidden="true" tabindex="-1"></a>      cont_counter <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:items_in_containers_amazon_bruteforce-29"><a href="#list:items_in_containers_amazon_bruteforce-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:items_in_containers_amazon_bruteforce-30"><a href="#list:items_in_containers_amazon_bruteforce-30" aria-hidden="true" tabindex="-1"></a>    curr_char<span class="op">++;</span></span>
<span id="list:items_in_containers_amazon_bruteforce-31"><a href="#list:items_in_containers_amazon_bruteforce-31" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:items_in_containers_amazon_bruteforce-32"><a href="#list:items_in_containers_amazon_bruteforce-32" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:items_in_containers_amazon_bruteforce-33"><a href="#list:items_in_containers_amazon_bruteforce-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:items_in_containers_amazon_bruteforce-34"><a href="#list:items_in_containers_amazon_bruteforce-34" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> items_in_containers_naive<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> curr_char<span class="op">,</span></span>
<span id="list:items_in_containers_amazon_bruteforce-35"><a href="#list:items_in_containers_amazon_bruteforce-35" aria-hidden="true" tabindex="-1"></a>                                           <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>Query<span class="op">&gt;&amp;</span> Q<span class="op">)</span></span>
<span id="list:items_in_containers_amazon_bruteforce-36"><a href="#list:items_in_containers_amazon_bruteforce-36" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:items_in_containers_amazon_bruteforce-37"><a href="#list:items_in_containers_amazon_bruteforce-37" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> ans<span class="op">;</span></span>
<span id="list:items_in_containers_amazon_bruteforce-38"><a href="#list:items_in_containers_amazon_bruteforce-38" aria-hidden="true" tabindex="-1"></a>  ans<span class="op">.</span>reserve<span class="op">(</span>Q<span class="op">.</span>size<span class="op">());</span></span>
<span id="list:items_in_containers_amazon_bruteforce-39"><a href="#list:items_in_containers_amazon_bruteforce-39" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> q <span class="op">:</span> Q<span class="op">)</span></span>
<span id="list:items_in_containers_amazon_bruteforce-40"><a href="#list:items_in_containers_amazon_bruteforce-40" aria-hidden="true" tabindex="-1"></a>    ans<span class="op">.</span>push_back<span class="op">(</span>count_items_in_substring<span class="op">(</span>curr_char<span class="op">,</span> q<span class="op">));</span></span>
<span id="list:items_in_containers_amazon_bruteforce-41"><a href="#list:items_in_containers_amazon_bruteforce-41" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:items_in_containers_amazon_bruteforce-42"><a href="#list:items_in_containers_amazon_bruteforce-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="items_in_containers_amazon:sec:lineartime">Linear time solution</h3>
<p>There is however a much faster solution to this problem that can be easily implemented provided we have come precomputed values. Performing some pre-computation in order to speed-up an algorithm is a common idea that is useful for the solution of many coding interview questions. In this particular problem, we are going to calculate two values for each character of the input string:</p>
<dl>
<dt><span class="math inline">\(C_i\)</span>, <strong>the closest delimiter to the right</strong></dt>
<dd><p>: we want to have for each character <span class="math inline">\(s_i\)</span> of the input string <span class="math inline">\(s\)</span> the information about the index of the closest container delimiter appearing after it. In other words we are looking for the index <span class="math inline">\(j &gt; i\)</span> such that <span class="math inline">\(s[j]=&#39;|&#39;\)</span>. If such index does not exists then we assume it is the index of the last character of <span class="math inline">\(s\)</span>, i.e. <span class="math inline">\(|s|-1\)</span>.</p>
</dd>
<dt><span class="math inline">\(P_i\)</span>, <strong>the number of elements in all containers to the left</strong></dt>
<dd><p>: this value should answer the question: given a character at index <span class="math inline">\(i\)</span> of <span class="math inline">\(s\)</span>, how many items are placed into all the closed containers appearing to the left of <span class="math inline">\(i\)</span>?</p>
</dd>
</dl>
<p>When this information is available for each and every position of <span class="math inline">\(s\)</span> then we can answer each query in constant time. Given a query <span class="math inline">\((l,r)\)</span>, we can calculate the answer to it by using the information about the closest container delimiter to the right of <span class="math inline">\(l\)</span>, <span class="math inline">\(c\geq l\)</span>, to find the beginning of the first container in the range <span class="math inline">\((s,e)\)</span>. All the elements between <span class="math inline">\(l\)</span> and <span class="math inline">\(c\)</span> can be ignored. So now that we have basically transformed our query from <span class="math inline">\((l,r)\)</span> to <span class="math inline">\((c,r)\)</span> we are ready to use the prefix sum of the number of elements in the containers.</p>
<p>We can calculate the answer to <span class="math inline">\((c,r)\)</span> by simply returning <span class="math inline">\(P_r - P_l\)</span>: the number of elements in the all container up to index <span class="math inline">\(r\)</span> minus, the number of elements in all containers up to the index <span class="math inline">\(l\)</span>.</p>
<p>Figure <a href="#fig:items_in_containers_amazon:example_prefix" data-reference-type="ref" data-reference="fig:items_in_containers_amazon:example_prefix">[fig:items_in_containers_amazon:example_prefix]</a> shows the values of <span class="math inline">\(P\)</span> and <span class="math inline">\(C\)</span> for the input string is . Each value of the array <span class="math inline">\(P_i\)</span> contains the count of the items inside all the containers in the prefix of <span class="math inline">\(s\)</span> u to and including index <span class="math inline">\(i\)</span>. For instance <span class="math inline">\(P_4=2\)</span> because the substring of <span class="math inline">\(s\)</span> between indices <span class="math inline">\(0\)</span> and <span class="math inline">\(4\)</span> only contains one container with two elements in it while <span class="math inline">\(P_5=3\)</span> because between indices <span class="math inline">\(0\)</span> and <span class="math inline">\(5\)</span>we have two containers with <span class="math inline">\(2\)</span> and <span class="math inline">\(1\)</span> items inside, respectively. The values in <span class="math inline">\(C_i\)</span> contains the indices of the first character in the suffix of <span class="math inline">\(s\)</span> from index <span class="math inline">\(i\)</span>. For instance <span class="math inline">\(C_1=3\)</span> because the first after index <span class="math inline">\(1\)</span> appears at index <span class="math inline">\(3\)</span> in <span class="math inline">\(s\)</span> while <span class="math inline">\(C_3=3\)</span> because <span class="math inline">\(s[3]\)</span> contains itself. Notice that the last element of <span class="math inline">\(s\)</span> always contains <span class="math inline">\(|s|-1\)</span> regarless of the fact <span class="math inline">\(s_{|s|-1}\)</span> is or not. Listing <a href="#list:items_in_containers_amazon_lineartime" data-reference-type="ref" data-reference="list:items_in_containers_amazon_lineartime">[list:items_in_containers_amazon_lineartime]</a> shows an implementation of the idea above. The main driver function is which first calls other two functions:</p>
<div class="enumerate*">
<p>and,</p>
</div>
<p>that are responsible for the pre-computation of <span class="math inline">\(C\)</span> and <span class="math inline">\(P\)</span>, respectively. Notice that in Listing <a href="#list:items_in_containers_amazon_lineartime" data-reference-type="ref" data-reference="list:items_in_containers_amazon_lineartime">[list:items_in_containers_amazon_lineartime]</a>, for the sake of clarity, <span class="math inline">\(C\)</span> and <span class="math inline">\(P\)</span>, are named and , respectively.</p>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/items_in_containers_amazon/images/delimiter_on_right.jpg" id="fig:items_in_containers_amazon:delimiter_right" alt="Each element at location i of the array C contains an integer corresponding to the smallest index j of s larger than i such that s[j]=&#39;|&#39; is a delimiter of a container." /><figcaption aria-hidden="true">Each element at location <span class="math inline">\(i\)</span> of the array <span class="math inline">\(C\)</span> contains an integer corresponding to the smallest index <span class="math inline">\(j\)</span> of <span class="math inline">\(s\)</span> larger than <span class="math inline">\(i\)</span> such that <span class="math inline">\(s[j]=&#39;|&#39;\)</span> is a delimiter of a container.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/items_in_containers_amazon/images/prefix_sum.jpg" id="fig:items_in_containers_amazon:prefix_sum" alt="Each element at index i of the array P contains the number of elements in all the closed containers appearing before i in s. " /><figcaption aria-hidden="true">Each element at index <span class="math inline">\(i\)</span> of the array <span class="math inline">\(P\)</span> contains the number of elements in all the closed containers appearing before <span class="math inline">\(i\)</span> in <span class="math inline">\(s\)</span>. </figcaption>
</figure>
<p><span id="fig:items_in_containers_amazon:example_prefix" label="fig:items_in_containers_amazon:example_prefix">[fig:items_in_containers_amazon:example_prefix]</span></p>
<div class="sourceCode" id="list:items_in_containers_amazon_lineartime" data-language="c++" data-caption="Linear time and linear space solution to the \textit{items in the container} problem." label="list:items_in_containers_amazon_lineartime"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:items_in_containers_amazon_lineartime-1"><a href="#list:items_in_containers_amazon_lineartime-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:items_in_containers_amazon_lineartime-2"><a href="#list:items_in_containers_amazon_lineartime-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> prefix_sum_containers_items<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> s<span class="op">)</span></span>
<span id="list:items_in_containers_amazon_lineartime-3"><a href="#list:items_in_containers_amazon_lineartime-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:items_in_containers_amazon_lineartime-4"><a href="#list:items_in_containers_amazon_lineartime-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> cont_prefix_sum<span class="op">;</span></span>
<span id="list:items_in_containers_amazon_lineartime-5"><a href="#list:items_in_containers_amazon_lineartime-5" aria-hidden="true" tabindex="-1"></a>  cont_prefix_sum<span class="op">.</span>reserve<span class="op">(</span>s<span class="op">.</span>size<span class="op">());</span></span>
<span id="list:items_in_containers_amazon_lineartime-6"><a href="#list:items_in_containers_amazon_lineartime-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:items_in_containers_amazon_lineartime-7"><a href="#list:items_in_containers_amazon_lineartime-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> it <span class="op">=</span> <span class="bu">std::</span>begin<span class="op">(</span>s<span class="op">);</span></span>
<span id="list:items_in_containers_amazon_lineartime-8"><a href="#list:items_in_containers_amazon_lineartime-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>it <span class="op">!=</span> <span class="bu">std::</span>end<span class="op">(</span>s<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">*</span>it <span class="op">!=</span> <span class="ch">&#39;|&#39;</span><span class="op">)</span></span>
<span id="list:items_in_containers_amazon_lineartime-9"><a href="#list:items_in_containers_amazon_lineartime-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:items_in_containers_amazon_lineartime-10"><a href="#list:items_in_containers_amazon_lineartime-10" aria-hidden="true" tabindex="-1"></a>    cont_prefix_sum<span class="op">.</span>push_back<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="list:items_in_containers_amazon_lineartime-11"><a href="#list:items_in_containers_amazon_lineartime-11" aria-hidden="true" tabindex="-1"></a>    it <span class="op">=</span> <span class="bu">std::</span>next<span class="op">(</span>it<span class="op">);</span></span>
<span id="list:items_in_containers_amazon_lineartime-12"><a href="#list:items_in_containers_amazon_lineartime-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:items_in_containers_amazon_lineartime-13"><a href="#list:items_in_containers_amazon_lineartime-13" aria-hidden="true" tabindex="-1"></a>  cont_prefix_sum<span class="op">.</span>push_back<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="list:items_in_containers_amazon_lineartime-14"><a href="#list:items_in_containers_amazon_lineartime-14" aria-hidden="true" tabindex="-1"></a>  it <span class="op">=</span> <span class="bu">std::</span>next<span class="op">(</span>it<span class="op">);</span></span>
<span id="list:items_in_containers_amazon_lineartime-15"><a href="#list:items_in_containers_amazon_lineartime-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:items_in_containers_amazon_lineartime-16"><a href="#list:items_in_containers_amazon_lineartime-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> cont_curr_countainer <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:items_in_containers_amazon_lineartime-17"><a href="#list:items_in_containers_amazon_lineartime-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>it <span class="op">!=</span> <span class="bu">std::</span>end<span class="op">(</span>s<span class="op">))</span></span>
<span id="list:items_in_containers_amazon_lineartime-18"><a href="#list:items_in_containers_amazon_lineartime-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:items_in_containers_amazon_lineartime-19"><a href="#list:items_in_containers_amazon_lineartime-19" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> count_prev_containers <span class="op">=</span></span>
<span id="list:items_in_containers_amazon_lineartime-20"><a href="#list:items_in_containers_amazon_lineartime-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">(</span>cont_prefix_sum<span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">?</span> cont_prefix_sum<span class="op">.</span>back<span class="op">()</span> <span class="op">:</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="list:items_in_containers_amazon_lineartime-21"><a href="#list:items_in_containers_amazon_lineartime-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(*</span>it <span class="op">==</span> <span class="ch">&#39;|&#39;</span><span class="op">)</span></span>
<span id="list:items_in_containers_amazon_lineartime-22"><a href="#list:items_in_containers_amazon_lineartime-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:items_in_containers_amazon_lineartime-23"><a href="#list:items_in_containers_amazon_lineartime-23" aria-hidden="true" tabindex="-1"></a>      <span class="co">// sum of the previous and previous container items</span></span>
<span id="list:items_in_containers_amazon_lineartime-24"><a href="#list:items_in_containers_amazon_lineartime-24" aria-hidden="true" tabindex="-1"></a>      cont_prefix_sum<span class="op">.</span>push_back<span class="op">(</span>count_prev_containers <span class="op">+</span> cont_curr_countainer<span class="op">);</span></span>
<span id="list:items_in_containers_amazon_lineartime-25"><a href="#list:items_in_containers_amazon_lineartime-25" aria-hidden="true" tabindex="-1"></a>      cont_curr_countainer <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:items_in_containers_amazon_lineartime-26"><a href="#list:items_in_containers_amazon_lineartime-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:items_in_containers_amazon_lineartime-27"><a href="#list:items_in_containers_amazon_lineartime-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="list:items_in_containers_amazon_lineartime-28"><a href="#list:items_in_containers_amazon_lineartime-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:items_in_containers_amazon_lineartime-29"><a href="#list:items_in_containers_amazon_lineartime-29" aria-hidden="true" tabindex="-1"></a>      cont_prefix_sum<span class="op">.</span>push_back<span class="op">(</span>count_prev_containers<span class="op">);</span></span>
<span id="list:items_in_containers_amazon_lineartime-30"><a href="#list:items_in_containers_amazon_lineartime-30" aria-hidden="true" tabindex="-1"></a>      cont_curr_countainer<span class="op">++;</span></span>
<span id="list:items_in_containers_amazon_lineartime-31"><a href="#list:items_in_containers_amazon_lineartime-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:items_in_containers_amazon_lineartime-32"><a href="#list:items_in_containers_amazon_lineartime-32" aria-hidden="true" tabindex="-1"></a>    it <span class="op">=</span> <span class="bu">std::</span>next<span class="op">(</span>it<span class="op">);</span></span>
<span id="list:items_in_containers_amazon_lineartime-33"><a href="#list:items_in_containers_amazon_lineartime-33" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:items_in_containers_amazon_lineartime-34"><a href="#list:items_in_containers_amazon_lineartime-34" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> cont_prefix_sum<span class="op">;</span></span>
<span id="list:items_in_containers_amazon_lineartime-35"><a href="#list:items_in_containers_amazon_lineartime-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:items_in_containers_amazon_lineartime-36"><a href="#list:items_in_containers_amazon_lineartime-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:items_in_containers_amazon_lineartime-37"><a href="#list:items_in_containers_amazon_lineartime-37" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> find_closest_bars_right<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> s<span class="op">)</span></span>
<span id="list:items_in_containers_amazon_lineartime-38"><a href="#list:items_in_containers_amazon_lineartime-38" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:items_in_containers_amazon_lineartime-39"><a href="#list:items_in_containers_amazon_lineartime-39" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> ans<span class="op">(</span>s<span class="op">.</span>size<span class="op">());</span></span>
<span id="list:items_in_containers_amazon_lineartime-40"><a href="#list:items_in_containers_amazon_lineartime-40" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> idx_last_bar <span class="op">=</span> <span class="bu">std::</span>ssize<span class="op">(</span>s<span class="op">)</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:items_in_containers_amazon_lineartime-41"><a href="#list:items_in_containers_amazon_lineartime-41" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="bu">std::</span>ssize<span class="op">(</span>s<span class="op">)</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span></span>
<span id="list:items_in_containers_amazon_lineartime-42"><a href="#list:items_in_containers_amazon_lineartime-42" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:items_in_containers_amazon_lineartime-43"><a href="#list:items_in_containers_amazon_lineartime-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>s<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> <span class="ch">&#39;|&#39;</span><span class="op">)</span></span>
<span id="list:items_in_containers_amazon_lineartime-44"><a href="#list:items_in_containers_amazon_lineartime-44" aria-hidden="true" tabindex="-1"></a>      idx_last_bar <span class="op">=</span> i<span class="op">;</span></span>
<span id="list:items_in_containers_amazon_lineartime-45"><a href="#list:items_in_containers_amazon_lineartime-45" aria-hidden="true" tabindex="-1"></a>    ans<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> idx_last_bar<span class="op">;</span></span>
<span id="list:items_in_containers_amazon_lineartime-46"><a href="#list:items_in_containers_amazon_lineartime-46" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:items_in_containers_amazon_lineartime-47"><a href="#list:items_in_containers_amazon_lineartime-47" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:items_in_containers_amazon_lineartime-48"><a href="#list:items_in_containers_amazon_lineartime-48" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:items_in_containers_amazon_lineartime-49"><a href="#list:items_in_containers_amazon_lineartime-49" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> items_in_containers_lineartime<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> s<span class="op">,</span></span>
<span id="list:items_in_containers_amazon_lineartime-50"><a href="#list:items_in_containers_amazon_lineartime-50" aria-hidden="true" tabindex="-1"></a>                                                <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>Query<span class="op">&gt;&amp;</span> Q<span class="op">)</span></span>
<span id="list:items_in_containers_amazon_lineartime-51"><a href="#list:items_in_containers_amazon_lineartime-51" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:items_in_containers_amazon_lineartime-52"><a href="#list:items_in_containers_amazon_lineartime-52" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> prefix_sum_count_items <span class="op">=</span></span>
<span id="list:items_in_containers_amazon_lineartime-53"><a href="#list:items_in_containers_amazon_lineartime-53" aria-hidden="true" tabindex="-1"></a>      prefix_sum_containers_items<span class="op">(</span>s<span class="op">);</span></span>
<span id="list:items_in_containers_amazon_lineartime-54"><a href="#list:items_in_containers_amazon_lineartime-54" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> closest_bars_right <span class="op">=</span> find_closest_bars_right<span class="op">(</span>s<span class="op">);</span></span>
<span id="list:items_in_containers_amazon_lineartime-55"><a href="#list:items_in_containers_amazon_lineartime-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:items_in_containers_amazon_lineartime-56"><a href="#list:items_in_containers_amazon_lineartime-56" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> ans<span class="op">;</span></span>
<span id="list:items_in_containers_amazon_lineartime-57"><a href="#list:items_in_containers_amazon_lineartime-57" aria-hidden="true" tabindex="-1"></a>  ans<span class="op">.</span>reserve<span class="op">(</span>Q<span class="op">.</span>size<span class="op">());</span></span>
<span id="list:items_in_containers_amazon_lineartime-58"><a href="#list:items_in_containers_amazon_lineartime-58" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[</span>start<span class="op">,</span> end<span class="op">]</span> <span class="op">:</span> Q<span class="op">)</span></span>
<span id="list:items_in_containers_amazon_lineartime-59"><a href="#list:items_in_containers_amazon_lineartime-59" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:items_in_containers_amazon_lineartime-60"><a href="#list:items_in_containers_amazon_lineartime-60" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> new_start <span class="op">=</span> closest_bars_right<span class="op">[</span>start<span class="op">];</span></span>
<span id="list:items_in_containers_amazon_lineartime-61"><a href="#list:items_in_containers_amazon_lineartime-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>new_start <span class="op">&gt;=</span> end<span class="op">)</span></span>
<span id="list:items_in_containers_amazon_lineartime-62"><a href="#list:items_in_containers_amazon_lineartime-62" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:items_in_containers_amazon_lineartime-63"><a href="#list:items_in_containers_amazon_lineartime-63" aria-hidden="true" tabindex="-1"></a>      ans<span class="op">.</span>push_back<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="list:items_in_containers_amazon_lineartime-64"><a href="#list:items_in_containers_amazon_lineartime-64" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:items_in_containers_amazon_lineartime-65"><a href="#list:items_in_containers_amazon_lineartime-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="list:items_in_containers_amazon_lineartime-66"><a href="#list:items_in_containers_amazon_lineartime-66" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:items_in_containers_amazon_lineartime-67"><a href="#list:items_in_containers_amazon_lineartime-67" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> count_before_start <span class="op">=</span></span>
<span id="list:items_in_containers_amazon_lineartime-68"><a href="#list:items_in_containers_amazon_lineartime-68" aria-hidden="true" tabindex="-1"></a>          <span class="op">(</span>new_start <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">?</span> <span class="dv">0</span> <span class="op">:</span> prefix_sum_count_items<span class="op">[</span>new_start<span class="op">];</span></span>
<span id="list:items_in_containers_amazon_lineartime-69"><a href="#list:items_in_containers_amazon_lineartime-69" aria-hidden="true" tabindex="-1"></a>      ans<span class="op">.</span>push_back<span class="op">(</span>prefix_sum_count_items<span class="op">[</span>end<span class="op">]</span> <span class="op">-</span> count_before_start<span class="op">);</span></span>
<span id="list:items_in_containers_amazon_lineartime-70"><a href="#list:items_in_containers_amazon_lineartime-70" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:items_in_containers_amazon_lineartime-71"><a href="#list:items_in_containers_amazon_lineartime-71" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:items_in_containers_amazon_lineartime-72"><a href="#list:items_in_containers_amazon_lineartime-72" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:items_in_containers_amazon_lineartime-73"><a href="#list:items_in_containers_amazon_lineartime-73" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="ch:min_difficulty_job_scheduler">Minimum difficulty job schedule</h1>
<h2 class="unnumbered" id="introduction-39">Introduction</h2>
<p>Imagine you are part of a team currently busy doing beta testing on your new cool feature. The testing consists of executing several tasks. Each task has dependencies on other tasks and is assigned a certain amount of complexity points (a measure of how difficult a task is to be performed; it is not a measure of time). The dependencies between the tasks have been already worked out i.e. the order in which the tasks are going to be executed is decided. The problem in this chapter is about coming up with a schedule plan for the execution of these tasks spanning across a given number of days. Among all possible schedules, we need to make an effort to calculate the minimum possible complexity achievable for a schedule that will eventually make sure all tasks are executed and also that there is at least one task executed every day.</p>
<h2 id="problem-statement-41">Problem statement</h2>
<div class="exercise">
<p>Write a function that takes as an input a list of tasks <span class="math inline">\(I\)</span> and an integer <span class="math inline">\(d\)</span>. The elements in <span class="math inline">\(I\)</span> are dependent on each other and to schedule a certain task <span class="math inline">\(I_i\)</span> all the tasks <span class="math inline">\(I_j \: : j &lt;
    i\)</span> have to be completed. The function should return the minimum complexity among all possible schedules of length exactly <span class="math inline">\(d\)</span> days. The complexity of a job is calculated as the sum of the complexity of every single day of the schedule. The complexity of a day of the schedule is defined as the maximum complexity of the task planned for that day.</p>
<p>As an additional constraint, you have to make sure that there is at least a task scheduled for each day.</p>
<div class="example">
<p><br />
Given:</p>
<ul>
<li><p><span class="math inline">\(I = \{6,5,4,3,2,1\}\)</span></p></li>
<li><p><span class="math inline">\(d = 2\)</span></p></li>
</ul>
<p>the function returns <span class="math inline">\(7\)</span>. You can schedule tasks <span class="math inline">\(0\)</span> to <span class="math inline">\(4\)</span> during the first day and the last task during the second day. You cannot just schedule all tasks during the first day because then you would have a day in the schedule without planned tasks which is not allowed.</p>
</div>
<div class="example">
<p><br />
Given:</p>
<ul>
<li><p><span class="math inline">\(I = \{10,10,10\}\)</span></p></li>
<li><p><span class="math inline">\(d = 4\)</span></p></li>
</ul>
<p>the function returns <span class="math inline">\(-1\)</span>. There is no way to schedule tasks for <span class="math inline">\(4\)</span> days when there are only <span class="math inline">\(3\)</span> tasks available for scheduling.</p>
</div>
<div class="example">
<p><br />
Given:</p>
<ul>
<li><p><span class="math inline">\(I = \{7,1,7,1,7,1\}\)</span></p></li>
<li><p><span class="math inline">\(d = 3\)</span></p></li>
</ul>
<p>the function returns <span class="math inline">\(15\)</span>. You can schedule the first <span class="math inline">\(4\)</span> tasks the first day for a total complexity of <span class="math inline">\(7\)</span>. Task at index <span class="math inline">\(4\)</span> and <span class="math inline">\(5\)</span> can be scheduled for days <span class="math inline">\(2\)</span> and <span class="math inline">\(3\)</span> respectively.</p>
<p>Notice that in this case if <span class="math inline">\(d = 2\)</span> then the function would return <span class="math inline">\(8\)</span>.</p>
</div>
<div class="example">
<p><br />
Given:</p>
<ul>
<li><p><span class="math inline">\(I = \{11,111,22,222,33,333,44,444\}\)</span></p></li>
<li><p><span class="math inline">\(d = 6\)</span></p></li>
</ul>
<p>the function returns <span class="math inline">\(843\)</span>. You can schedule tasks <span class="math inline">\(0,1,2,3,4\)</span> in the first <span class="math inline">\(5\)</span> days and the rest during the .</p>
</div>
</div>
<h2 id="clarification-questions-34">Clarification Questions</h2>
<div class="QandA">
<p>What should the function return in the case where it is not possible to make a valid schedule? For instance when <span class="math inline">\(|I| &lt; d\)</span>?</p>
<div class="answered">
<p><em>You can return <span class="math inline">\(-1\)</span> in that case.</em></p>
</div>
<p>It is guaranteed for the complexity values to be positive (<span class="math inline">\(\geq 0\)</span>)?</p>
<div class="answered">
<p><em>Yes you can assume complexities are always positive.</em></p>
</div>
</div>
<h2 id="min_difficulty_job_scheduler:sec:discussion">Discussion</h2>
<p>This problem is a classic example of a problem that can be easily solvable via dynamic programming but can be super challenging if you try to approach it differently. Fortunately, the statement is full of hints about the fact this problem can be solved using DP. For instance:</p>
<div class="enumerate*">
<p>it is an optimization problem, and,</p>
<p>you are not asked to find an actual schedule, but only the value of the best possible one.</p>
</div>
<p>. Very often those are the two most common ingredients in a DP problem. We have, therefore, to be able to spot the hints in the statement so that we think about DP.</p>
<h3 id="min_difficulty_job_scheduler:sec:bruteforce">Brute-force</h3>
<p>If you do not think about DP right away one of the possible ways of approaching this problem would be to try out all possible schedules, and for each of them calculate its cost, and return the smallest. The problem explicitly mentions a case where a solution does not exist. This is an easy case as there is only one scenario where you cannot schedule jobs for <span class="math inline">\(d\)</span> days: when the number of jobs to be scheduled is strictly less than <span class="math inline">\(d\)</span>. The core of the problem is really about the case where <span class="math inline">\(|I| \geq d\)</span>. You can think about a schedule as a way of splitting <span class="math inline">\(I\)</span> into <span class="math inline">\(d\)</span> non-empty sub-arrays. You can split an array into <span class="math inline">\(d\)</span> parts by placing <span class="math inline">\(d-1\)</span> splitting-points in <span class="math inline">\(I\)</span> at different locations. A different placing of the splitting-points leads univocally to a different schedule. There is, therefore, a one-to-one correspondence between a subset of size <span class="math inline">\(d-1\)</span> of <span class="math inline">\(\{0,1,2, \ldots, |I|-2\}\)</span> (the splitting point locations) and schedules (see Equation <a href="#eq:min_difficulty_job_scheduler:cost_combination" data-reference-type="ref" data-reference="eq:min_difficulty_job_scheduler:cost_combination">[eq:min_difficulty_job_scheduler:cost_combination]</a>). We can therefore generate all possible schedules by generating all possible combinations of <span class="math inline">\(d-1\)</span> elements from <span class="math inline">\(\{0,1,2, \ldots, |I|-2\}\)</span> where each number of a combination <span class="math inline">\(\{e_0, \ldots, e_{d-1}\}\)</span> represent a splitting point in <span class="math inline">\(I\)</span> and <span class="math inline">\(e_i\)</span> identifies the following subarray of <span class="math inline">\(I\)</span>: <span class="math inline">\(\{A_{e_i-1+1}, A_{e_i-1+1}, \ldots ,
A_{e_i}\}\)</span>.</p>
<p>In order to solve this problem we can calculate the costs for each of the schedule represented by a combination of <span class="math inline">\(d-1\)</span> elements of <span class="math inline">\(\{0,1,2, \ldots, |I|-1\}\)</span>, and return the cost of the best (the one having minimum cost overall). The cost of a schedule, as stated in the problem statement, is the sum of the costs for each of the <span class="math inline">\(d\)</span> day where the cost of a single day is the cost of the most expensive job scheduled for that particular day. So given a schedule represented by the combination <span class="math inline">\(e = \{e_1, \ldots, \_{d-1}\}\)</span> we can easily calculate its cost, <span class="math inline">\(C(e)\)</span>, by using: <span class="math display">\[C(e) = \underbrace{\max(A_0, A_1, \ldots, A_{e_1})}_{\text{cost for the } 1^{st} \text{day}} + \underbrace{\max(A_{e_1+1}, A_{e_1+2}, \ldots, A_{e_2})}_{\text{cost for the } 2^{nd} \text{day}} + \ldots + \underbrace{\max(A_{e_{d-1}+1}, A_{e_{d-1}+2}, \ldots, A_{|I|-1})}_{\text{cost for the } d^{th} \text{day}}
    \label{eq:min_difficulty_job_scheduler:cost_combination}\]</span></p>
<h4 id="generate-all-combinations">Generate all combinations</h4>
<p>The real challenge at this point is really about the generation of combinations in groups of <span class="math inline">\(d-1\)</span> elements. We can generate all the combinations one at a time by using a backtracking algorithm where we try to construct one combination of elements at a time. A possible recursive implementation of such algorithm is shown in Listing <a href="#list:min_difficulty_job_scheduler:combinations" data-reference-type="ref" data-reference="list:min_difficulty_job_scheduler:combinations">[list:min_difficulty_job_scheduler:combinations]</a>. The function takes as a input two integer <span class="math inline">\(k\)</span> and <span class="math inline">\(l\)</span>. <span class="math inline">\(k\)</span> represents the size of the combination and <span class="math inline">\(l\)</span> identifies the elements of the combinations i.e. <span class="math inline">\(0,1,\ldots,
l-1\)</span>. If you had to write a generic function for generating combinations you would also most likely have a parameter containing the list of elements from which to generate the combinations. In this case, such list is implicit, as we need to generate combinations of splitting points and can be uniquely identified by a single integer. For instance generates all combinations of three elements from <span class="math inline">\(\{0,1,2,3,4,5,6,7,8,9\}\)</span> and generates all combinations of <span class="math inline">\(2\)</span> elements from <span class="math inline">\(\{0,1,2,3\}\)</span>. is a recursive function which enumerates all combinations. It takes the following parameters:</p>
<ul>
<li><p>: the output list of all generated combination,</p></li>
<li><p>: the work-in-progress combination,</p></li>
<li><p>: the size of the combinations</p></li>
<li><p>: the last number we can add to the work-in-progress combination</p></li>
<li><p>: the first number we can add to the combination</p></li>
</ul>
<p>Each call tries to place a number in the work-in-progress at location specified by <span class="math inline">\(curr_el\)</span>. Initially <span class="math inline">\(curr_el = 0\)</span> and each recursive call increases it by <span class="math inline">\(1\)</span>. Eventually <span class="math inline">\(curr_el = d\)</span> and we can stop the recursion and return. At that point the combination is ready and saved into . After each recursive call, the last inserted element is removed from the work-in-progress combination and another number is pushed. The process repeats until there is no more number to be pushed.</p>
<div class="sourceCode" id="list:min_difficulty_job_scheduler:combinations" data-language="c++" data-caption="Function that generates all the combinations of size $k$ from the elements $\{0,1,\ldots,l\}$" label="list:min_difficulty_job_scheduler:combinations"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:min_difficulty_job_scheduler:combinations-1"><a href="#list:min_difficulty_job_scheduler:combinations-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> Combination <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;;</span></span>
<span id="list:min_difficulty_job_scheduler:combinations-2"><a href="#list:min_difficulty_job_scheduler:combinations-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> CombinationList <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>Combination<span class="op">&gt;;</span></span>
<span id="list:min_difficulty_job_scheduler:combinations-3"><a href="#list:min_difficulty_job_scheduler:combinations-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_difficulty_job_scheduler:combinations-4"><a href="#list:min_difficulty_job_scheduler:combinations-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> all_combinations_helper<span class="op">(</span>CombinationList<span class="op">&amp;</span> all_combinations<span class="op">,</span> Combination<span class="op">&amp;</span> combination<span class="op">,</span> <span class="at">const</span> <span class="dt">unsigned</span> d<span class="op">,</span> <span class="at">const</span> <span class="dt">int</span> curr_idx<span class="op">,</span> <span class="at">const</span> <span class="dt">unsigned</span> limit<span class="op">)</span></span>
<span id="list:min_difficulty_job_scheduler:combinations-5"><a href="#list:min_difficulty_job_scheduler:combinations-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:min_difficulty_job_scheduler:combinations-6"><a href="#list:min_difficulty_job_scheduler:combinations-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>combination<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> d<span class="op">){</span></span>
<span id="list:min_difficulty_job_scheduler:combinations-7"><a href="#list:min_difficulty_job_scheduler:combinations-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">//combination is ready</span></span>
<span id="list:min_difficulty_job_scheduler:combinations-8"><a href="#list:min_difficulty_job_scheduler:combinations-8" aria-hidden="true" tabindex="-1"></a>        all_combinations<span class="op">.</span>push_back<span class="op">(</span>combination<span class="op">);</span></span>
<span id="list:min_difficulty_job_scheduler:combinations-9"><a href="#list:min_difficulty_job_scheduler:combinations-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span>   </span>
<span id="list:min_difficulty_job_scheduler:combinations-10"><a href="#list:min_difficulty_job_scheduler:combinations-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:min_difficulty_job_scheduler:combinations-11"><a href="#list:min_difficulty_job_scheduler:combinations-11" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="list:min_difficulty_job_scheduler:combinations-12"><a href="#list:min_difficulty_job_scheduler:combinations-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> curr_idx<span class="op">;</span> i <span class="op">&lt;</span> limit <span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:min_difficulty_job_scheduler:combinations-13"><a href="#list:min_difficulty_job_scheduler:combinations-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:min_difficulty_job_scheduler:combinations-14"><a href="#list:min_difficulty_job_scheduler:combinations-14" aria-hidden="true" tabindex="-1"></a>        combination<span class="op">.</span>push_back<span class="op">(</span>i<span class="op">);</span></span>
<span id="list:min_difficulty_job_scheduler:combinations-15"><a href="#list:min_difficulty_job_scheduler:combinations-15" aria-hidden="true" tabindex="-1"></a>        all_combinations_helper<span class="op">(</span>all_combinations<span class="op">,</span>combination<span class="op">,</span> d<span class="op">,</span> i<span class="op">+</span><span class="dv">1</span><span class="op">,</span> limit<span class="op">);</span></span>
<span id="list:min_difficulty_job_scheduler:combinations-16"><a href="#list:min_difficulty_job_scheduler:combinations-16" aria-hidden="true" tabindex="-1"></a>        combination<span class="op">.</span>pop_back<span class="op">();</span></span>
<span id="list:min_difficulty_job_scheduler:combinations-17"><a href="#list:min_difficulty_job_scheduler:combinations-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:min_difficulty_job_scheduler:combinations-18"><a href="#list:min_difficulty_job_scheduler:combinations-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="list:min_difficulty_job_scheduler:combinations-19"><a href="#list:min_difficulty_job_scheduler:combinations-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:min_difficulty_job_scheduler:combinations-20"><a href="#list:min_difficulty_job_scheduler:combinations-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_difficulty_job_scheduler:combinations-21"><a href="#list:min_difficulty_job_scheduler:combinations-21" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> all_combinations<span class="op">(</span><span class="at">const</span> <span class="dt">unsigned</span> d<span class="op">,</span> <span class="at">const</span> <span class="dt">unsigned</span> limit<span class="op">)</span></span>
<span id="list:min_difficulty_job_scheduler:combinations-22"><a href="#list:min_difficulty_job_scheduler:combinations-22" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:min_difficulty_job_scheduler:combinations-23"><a href="#list:min_difficulty_job_scheduler:combinations-23" aria-hidden="true" tabindex="-1"></a>    Combination work_in_progress<span class="op">;</span></span>
<span id="list:min_difficulty_job_scheduler:combinations-24"><a href="#list:min_difficulty_job_scheduler:combinations-24" aria-hidden="true" tabindex="-1"></a>    work_in_progress<span class="op">.</span>reserve<span class="op">(</span>d<span class="op">);</span></span>
<span id="list:min_difficulty_job_scheduler:combinations-25"><a href="#list:min_difficulty_job_scheduler:combinations-25" aria-hidden="true" tabindex="-1"></a>    CombinationList all_combinations<span class="op">;</span></span>
<span id="list:min_difficulty_job_scheduler:combinations-26"><a href="#list:min_difficulty_job_scheduler:combinations-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">//limit -1 because the last cut cannot be empty</span></span>
<span id="list:min_difficulty_job_scheduler:combinations-27"><a href="#list:min_difficulty_job_scheduler:combinations-27" aria-hidden="true" tabindex="-1"></a>    all_combinations_helper<span class="op">(</span>all_combinations<span class="op">,</span>work_in_progress<span class="op">,</span>d<span class="op">,</span><span class="dv">0</span><span class="op">,</span>limit<span class="op">-</span><span class="dv">1</span> <span class="op">);</span></span>
<span id="list:min_difficulty_job_scheduler:combinations-28"><a href="#list:min_difficulty_job_scheduler:combinations-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> all_combinations<span class="op">;</span></span>
<span id="list:min_difficulty_job_scheduler:combinations-29"><a href="#list:min_difficulty_job_scheduler:combinations-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="wrapping-up">Wrapping-up</h4>
<p>Once we are able to generate all the possible schedules we are going to evaluate the cost associated with each of them, and pick the one with the smallest difficulty overall. All is left to do at this point is to come up with a way to evaluate a given schedule <span class="math inline">\(c\)</span>. We have already seen in Equation <a href="#eq:min_difficulty_job_scheduler:cost_combination" data-reference-type="ref" data-reference="eq:min_difficulty_job_scheduler:cost_combination">[eq:min_difficulty_job_scheduler:cost_combination]</a> how a certain combination of <span class="math inline">\(d-1\)</span> splitting points maps directly to subarrays of <span class="math inline">\(I\)</span>. The function in Listing <a href="#list:min_difficulty_job_scheduler:combinations" data-reference-type="ref" data-reference="list:min_difficulty_job_scheduler:combinations">[list:min_difficulty_job_scheduler:combinations]</a> uses this idea to evaluate a schedule and calculate its difficulty by summing up the difficulties of each of the tasks scheduled each day. Notice that and identify the elements of <span class="math inline">\(I\)</span> in the following range: <span class="math inline">\([start, finish]\)</span> (the element pointed by is included). The function is the driver that is responsible for keeping track of the minimum difficulty among all the processed schedules.</p>
<div class="sourceCode" id="list:min_difficulty_job_scheduler:solution_combinations" data-language="c++" data-caption="Brute-force solution that works by evaluating all the possible schedules generated using Listing \ref{list:min_difficulty_job_scheduler:combinations}" label="list:min_difficulty_job_scheduler:solution_combinations"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:min_difficulty_job_scheduler:solution_combinations-1"><a href="#list:min_difficulty_job_scheduler:solution_combinations-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> calculate_cost_schedule<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> I<span class="op">,</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-2"><a href="#list:min_difficulty_job_scheduler:solution_combinations-2" aria-hidden="true" tabindex="-1"></a>                            <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> cutpoints_combo<span class="op">)</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-3"><a href="#list:min_difficulty_job_scheduler:solution_combinations-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-4"><a href="#list:min_difficulty_job_scheduler:solution_combinations-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans    <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-5"><a href="#list:min_difficulty_job_scheduler:solution_combinations-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> start <span class="op">=</span> <span class="bu">std::</span>begin<span class="op">(</span>I<span class="op">);</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-6"><a href="#list:min_difficulty_job_scheduler:solution_combinations-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> cutpoint <span class="op">:</span> cutpoints_combo<span class="op">)</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-7"><a href="#list:min_difficulty_job_scheduler:solution_combinations-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-8"><a href="#list:min_difficulty_job_scheduler:solution_combinations-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> finish <span class="op">=</span> <span class="bu">std::</span>begin<span class="op">(</span>I<span class="op">)</span> <span class="op">+</span> cutpoint <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-9"><a href="#list:min_difficulty_job_scheduler:solution_combinations-9" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">+=</span> <span class="op">*</span><span class="bu">std::</span>max_element<span class="op">(</span>start<span class="op">,</span> finish<span class="op">);</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-10"><a href="#list:min_difficulty_job_scheduler:solution_combinations-10" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> finish<span class="op">;</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-11"><a href="#list:min_difficulty_job_scheduler:solution_combinations-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-12"><a href="#list:min_difficulty_job_scheduler:solution_combinations-12" aria-hidden="true" tabindex="-1"></a>  ans <span class="op">+=</span> <span class="op">*</span><span class="bu">std::</span>max_element<span class="op">(</span>start<span class="op">,</span> <span class="bu">std::</span>end<span class="op">(</span>I<span class="op">));</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-13"><a href="#list:min_difficulty_job_scheduler:solution_combinations-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-14"><a href="#list:min_difficulty_job_scheduler:solution_combinations-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-15"><a href="#list:min_difficulty_job_scheduler:solution_combinations-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-16"><a href="#list:min_difficulty_job_scheduler:solution_combinations-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> min_difficulty_scheduler_combinations<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> I<span class="op">,</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-17"><a href="#list:min_difficulty_job_scheduler:solution_combinations-17" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">const</span> <span class="dt">unsigned</span> d<span class="op">)</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-18"><a href="#list:min_difficulty_job_scheduler:solution_combinations-18" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-19"><a href="#list:min_difficulty_job_scheduler:solution_combinations-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>I<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;</span> d<span class="op">)</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-20"><a href="#list:min_difficulty_job_scheduler:solution_combinations-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-21"><a href="#list:min_difficulty_job_scheduler:solution_combinations-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-22"><a href="#list:min_difficulty_job_scheduler:solution_combinations-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> all_combinations_cutpoints <span class="op">=</span> all_combinations<span class="op">(</span>d <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> I<span class="op">.</span>size<span class="op">());</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-23"><a href="#list:min_difficulty_job_scheduler:solution_combinations-23" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans                         <span class="op">=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>max<span class="op">();</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-24"><a href="#list:min_difficulty_job_scheduler:solution_combinations-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> cutpoints_combo <span class="op">:</span> all_combinations_cutpoints<span class="op">)</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-25"><a href="#list:min_difficulty_job_scheduler:solution_combinations-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-26"><a href="#list:min_difficulty_job_scheduler:solution_combinations-26" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>ans<span class="op">,</span> calculate_cost_schedule<span class="op">(</span>I<span class="op">,</span> cutpoints_combo<span class="op">));</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-27"><a href="#list:min_difficulty_job_scheduler:solution_combinations-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-28"><a href="#list:min_difficulty_job_scheduler:solution_combinations-28" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:min_difficulty_job_scheduler:solution_combinations-29"><a href="#list:min_difficulty_job_scheduler:solution_combinations-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="dynamic-programming-1">Dynamic Programming</h3>
<p>The key insight to solve this problem with DP is that given that you have decided on a set of tasks that are scheduled in the first day, say the first <span class="math inline">\(i\)</span> tasks, than the minimum difficulty of a schedule across <span class="math inline">\(d\)</span> days having the first <span class="math inline">\(i\)</span> elements scheduled the first day is the sum of</p>
<div class="enumerate*">
<p>the largest difficulty among the first <span class="math inline">\(i\)</span> tasks, and</p>
<p>the cost of the best possible schedule of the last <span class="math inline">\(|I|- i\)</span> tasks across <span class="math inline">\(d-1\)</span> days.</p>
</div>
<p>More formally, if <span class="math inline">\(C(I,d)\)</span> is a function returning the minimum cost of a schedule of the tasks in <span class="math inline">\(I\)</span> across <span class="math inline">\(d\)</span> days , and can be defined as follows: <span class="math display">\[\begin{cases}
        C(\emptyset, 0) = 0 \; :  \text{the cost of scheduling $0$ task in $0$ days is $0$}\\
        C(\emptyset, d &gt; 0) = +\infty \; : \text{it is impossible to schedule $0$ tasks in $1$ or more days}\\
        C(|I|, 0) = +\infty \: :\text{it is impossible to schedule $1$ or more tasks  in $0$ days}\\\\
        C(|I|, d) = \underbrace{\min_{\forall j \in \{0,1,\ldots,|I-1|\}}}_{\text{ $\forall$ schedule of the $d^{th}$ day}} \Bigg( \max I_j + \underbrace{C\Big(I - \{0,1,\ldots,j\}, d-1\Big)}_{\text{optimal solution to a subproblem}}\Bigg)\\
     \end{cases}
    \label{eq:min_difficulty_job_scheduler:dpformula}\]</span> <span class="math inline">\(C(I,d)\)</span> has a recursive definition and we can quickly see that the problem has both the properties a DP problem has:</p>
<dl>
<dt>optimal substructure:</dt>
<dd><p>can be solved by solving and combining together various <strong>optimal</strong> solutions to <strong>smaller</strong> subproblems.</p>
</dd>
<dt>overlapping subproblems:</dt>
<dd><p>the same problems are solved over and over again. (try to draw the recursion tree for <span class="math inline">\(C\)</span> if you are not entirely convinced)</p>
</dd>
</dl>
<h3 id="top-down">Top-down</h3>
<p>Without any optimization, the function that we obtain by translating the recursive definition of Equation <a href="#eq:min_difficulty_job_scheduler:dpformula" data-reference-type="ref" data-reference="eq:min_difficulty_job_scheduler:dpformula">[eq:min_difficulty_job_scheduler:dpformula]</a> is extremely inefficient due to the fact problems are recalculated over and over (See Appendix <a href="#sect:appendix:DP" data-reference-type="ref" data-reference="sect:appendix:DP">[sect:appendix:DP]</a>). In order to make good use of DP, we can therefore use memoization to avoid unnecessary recomputation. Listing <a href="#list:min_difficulty_job_scheduler:solutiondp" data-reference-type="ref" data-reference="list:min_difficulty_job_scheduler:solutiondp">[list:min_difficulty_job_scheduler:solutiondp]</a> shows a possible implementation of this idea where a is used to remember the calls to (the equivalent of the function <span class="math inline">\(C\)</span>). Notice that given <span class="math inline">\(I\)</span> and <span class="math inline">\(d\)</span> the function can "only" be invoked in <span class="math inline">\(|I| \times d\)</span> ways. Therefore, in the worst case, by using memoization we will never make more than <span class="math inline">\(|I| \times d\)</span> calls to . Because the cost of a single call to is linear in <span class="math inline">\(|I|\)</span> the complexity of the whole algorithm is <span class="math inline">\(O(|I|^2 d)\)</span></p>
<div class="sourceCode" id="list:min_difficulty_job_scheduler:solutiondp" data-language="c++" data-caption="Dynamic programming top-down solution." label="list:min_difficulty_job_scheduler:solutiondp"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:min_difficulty_job_scheduler:solutiondp-1"><a href="#list:min_difficulty_job_scheduler:solutiondp-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> KeyHash</span>
<span id="list:min_difficulty_job_scheduler:solutiondp-2"><a href="#list:min_difficulty_job_scheduler:solutiondp-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-3"><a href="#list:min_difficulty_job_scheduler:solutiondp-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>size_t<span class="op"> </span><span class="kw">operator</span><span class="op">()(</span><span class="at">const</span> <span class="bu">std::</span>tuple<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;&amp;</span> key<span class="op">)</span> <span class="at">const</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-4"><a href="#list:min_difficulty_job_scheduler:solutiondp-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-5"><a href="#list:min_difficulty_job_scheduler:solutiondp-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>key<span class="op">)</span> <span class="op">^</span> <span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;(</span>key<span class="op">);</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-6"><a href="#list:min_difficulty_job_scheduler:solutiondp-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-7"><a href="#list:min_difficulty_job_scheduler:solutiondp-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-8"><a href="#list:min_difficulty_job_scheduler:solutiondp-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-9"><a href="#list:min_difficulty_job_scheduler:solutiondp-9" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> Cache <span class="op">=</span> <span class="bu">std::</span>unordered_map<span class="op">&lt;</span><span class="bu">std::</span>tuple<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;,</span> <span class="dt">int</span><span class="op">,</span> KeyHash<span class="op">&gt;;</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-10"><a href="#list:min_difficulty_job_scheduler:solutiondp-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-11"><a href="#list:min_difficulty_job_scheduler:solutiondp-11" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> min_difficulty_scheduler_DP_topdown_helper<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> I<span class="op">,</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-12"><a href="#list:min_difficulty_job_scheduler:solutiondp-12" aria-hidden="true" tabindex="-1"></a>                                                <span class="at">const</span> <span class="dt">size_t</span> start<span class="op">,</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-13"><a href="#list:min_difficulty_job_scheduler:solutiondp-13" aria-hidden="true" tabindex="-1"></a>                                                <span class="at">const</span> <span class="dt">int</span> d<span class="op">,</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-14"><a href="#list:min_difficulty_job_scheduler:solutiondp-14" aria-hidden="true" tabindex="-1"></a>                                                Cache<span class="op">&amp;</span> cache<span class="op">)</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-15"><a href="#list:min_difficulty_job_scheduler:solutiondp-15" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-16"><a href="#list:min_difficulty_job_scheduler:solutiondp-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>start <span class="op">&gt;=</span> I<span class="op">.</span>size<span class="op">()</span> <span class="op">&amp;&amp;</span> d <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-17"><a href="#list:min_difficulty_job_scheduler:solutiondp-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-18"><a href="#list:min_difficulty_job_scheduler:solutiondp-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-19"><a href="#list:min_difficulty_job_scheduler:solutiondp-19" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">size_t</span> remaining <span class="op">=</span> I<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> start<span class="op">;</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-20"><a href="#list:min_difficulty_job_scheduler:solutiondp-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>remaining <span class="op">&lt;</span> d<span class="op">)</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-21"><a href="#list:min_difficulty_job_scheduler:solutiondp-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>max<span class="op">();</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-22"><a href="#list:min_difficulty_job_scheduler:solutiondp-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-23"><a href="#list:min_difficulty_job_scheduler:solutiondp-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> t <span class="op">=</span> <span class="bu">std::</span>make_tuple<span class="op">(</span>start<span class="op">,</span> d<span class="op">);</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-24"><a href="#list:min_difficulty_job_scheduler:solutiondp-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> it <span class="op">=</span> cache<span class="op">.</span>find<span class="op">(</span>t<span class="op">);</span> it <span class="op">!=</span> cache<span class="op">.</span>end<span class="op">())</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-25"><a href="#list:min_difficulty_job_scheduler:solutiondp-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> it<span class="op">-&gt;</span>second<span class="op">;</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-26"><a href="#list:min_difficulty_job_scheduler:solutiondp-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-27"><a href="#list:min_difficulty_job_scheduler:solutiondp-27" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> M    <span class="op">=</span> I<span class="op">[</span>start<span class="op">];</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-28"><a href="#list:min_difficulty_job_scheduler:solutiondp-28" aria-hidden="true" tabindex="-1"></a>  <span class="dt">long</span> ans <span class="op">=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>max<span class="op">();</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-29"><a href="#list:min_difficulty_job_scheduler:solutiondp-29" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> start<span class="op">;</span> i <span class="op">&lt;</span> I<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-30"><a href="#list:min_difficulty_job_scheduler:solutiondp-30" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-31"><a href="#list:min_difficulty_job_scheduler:solutiondp-31" aria-hidden="true" tabindex="-1"></a>    M   <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>M<span class="op">,</span> I<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-32"><a href="#list:min_difficulty_job_scheduler:solutiondp-32" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-33"><a href="#list:min_difficulty_job_scheduler:solutiondp-33" aria-hidden="true" tabindex="-1"></a>        ans<span class="op">,</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-34"><a href="#list:min_difficulty_job_scheduler:solutiondp-34" aria-hidden="true" tabindex="-1"></a>        M <span class="op">+</span> min_difficulty_scheduler_DP_topdown_helper<span class="op">(</span>I<span class="op">,</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> d <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> cache<span class="op">));</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-35"><a href="#list:min_difficulty_job_scheduler:solutiondp-35" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-36"><a href="#list:min_difficulty_job_scheduler:solutiondp-36" aria-hidden="true" tabindex="-1"></a>  cache<span class="op">[</span>t<span class="op">]</span> <span class="op">=</span> ans<span class="op">;</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-37"><a href="#list:min_difficulty_job_scheduler:solutiondp-37" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-38"><a href="#list:min_difficulty_job_scheduler:solutiondp-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-39"><a href="#list:min_difficulty_job_scheduler:solutiondp-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-40"><a href="#list:min_difficulty_job_scheduler:solutiondp-40" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> min_difficulty_scheduler_DP_topdown<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> I<span class="op">,</span> <span class="dt">int</span> d<span class="op">)</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-41"><a href="#list:min_difficulty_job_scheduler:solutiondp-41" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-42"><a href="#list:min_difficulty_job_scheduler:solutiondp-42" aria-hidden="true" tabindex="-1"></a>  Cache cache<span class="op">;</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-43"><a href="#list:min_difficulty_job_scheduler:solutiondp-43" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> ans <span class="op">=</span> min_difficulty_scheduler_DP_topdown_helper<span class="op">(</span>I<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> d<span class="op">,</span> cache<span class="op">);</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-44"><a href="#list:min_difficulty_job_scheduler:solutiondp-44" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>ans <span class="op">&gt;=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>max<span class="op">())</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-45"><a href="#list:min_difficulty_job_scheduler:solutiondp-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-46"><a href="#list:min_difficulty_job_scheduler:solutiondp-46" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondp-47"><a href="#list:min_difficulty_job_scheduler:solutiondp-47" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="bottom-up">Bottom-up</h3>
<p>In this section, we are going to have a look at how we can implement the DP idea in a bottom-up fashion. Like many bottom-up solutions, we have to come up with a way of filling out a table of values of some sort. For this problem we can use a table <span class="math inline">\(T\)</span> of size <span class="math inline">\(d \times |I|\)</span> where each element of the table <span class="math inline">\(T[i][j]\)</span> will eventually contain the solution to the problem of scheduling the elements of <span class="math inline">\(|I|\)</span> up to and including the task at index <span class="math inline">\(j\)</span> in exactly <span class="math inline">\(i\)</span> days. Clearly, filling some cells of <span class="math inline">\(T\)</span> is easier than others. For instance, all the values of the first column of <span class="math inline">\(T\)</span> are all filled with a value indicating that the problem has no solution because you cannot schedule any task in <span class="math inline">\(0\)</span> days. An exception should be made for <span class="math inline">\(T[0][0]\)</span> that is filled with <span class="math inline">\(0\)</span> as the cost of scheduling <span class="math inline">\(0\)</span> tasks in <span class="math inline">\(0\)</span> days is equivalent to the cost of doing nothing. To mark that a subproblem is impossible we can use a large value, or perhaps the largest value a cell of <span class="math inline">\(T\)</span> can hold.</p>
<p>Additionally, also the values of the first row are relatively easy to fill in. The values of the first row contain values that are symmetrically equal to the cells in the first column. Each value of the first row represents a solution to the problem of scheduling some task in <span class="math inline">\(0\)</span> days and there is clearly no way that can be done (except for the case when you have <span class="math inline">\(0\)</span> task to schedule). The elements of the first row are also relatively easy to fill. An element of the first row <span class="math inline">\(T[1][j]\)</span> correspond to the subproblem of scheduling the first <span class="math inline">\(j\)</span> of <span class="math inline">\(I\)</span> in exactly one day. Its cost is clearly the maximum difficulty among the elements of <span class="math inline">\(I\)</span> from <span class="math inline">\(0\)</span> to <span class="math inline">\(j\)</span> as there is only one way of scheduling all the <span class="math inline">\(j+1\)</span> tasks in a single day.</p>
<p>Things get a bit more interesting when looking at the second row. When we have two days at our disposal to schedule <span class="math inline">\(j\)</span> tasks we have more freedom on which task to schedule on the first day and which on the second. The values we just filled for the first two can however be helpful in making the best decision for the elements of the second row. We can in-fact fill <span class="math inline">\(T[2][j]\)</span> by scheduling one task on the first day, and <span class="math inline">\(j-1\)</span> on the second. Or <span class="math inline">\(2\)</span> tasks the first day and <span class="math inline">\(j-2\)</span> in the second and so on. But which of these divisions is the best? Easy! let’s try them all and see which one yields the smallest difficulty overall. Therefore we can calculate <span class="math inline">\(T[2][j]\)</span> as shown in Equation <a href="#eq:min_difficulty_schedule:secondRowbottomup" data-reference-type="ref" data-reference="eq:min_difficulty_schedule:secondRowbottomup">[eq:min_difficulty_schedule:secondRowbottomup]</a>: <span class="math display">\[T[2][j] = \min_{1 \leq k \leq j-1} \Big( T[1][k] + \big(\ max_{k+1 \leq l \leq j }I_l \big)  \Big)
\label{eq:min_difficulty_schedule:secondRowbottomup}\]</span> Equation <a href="#eq:min_difficulty_schedule:generic_bottom_up" data-reference-type="ref" data-reference="eq:min_difficulty_schedule:generic_bottom_up">[eq:min_difficulty_schedule:generic_bottom_up]</a> is really saying that we can calculate the minimum difficulty of scheduling the tasks in <span class="math inline">\(I\)</span> up to the one having index <span class="math inline">\(j\)</span> by calculating the minimum among the costs of scheduling the tasks up to the index <span class="math inline">\(k \leq j-1\)</span> on the first day and the rest on the second. The trick here is that we have already calculated all the possible costs of scheduling all possible number of tasks, and thus all we have to do at this step is to calculate the costs of scheduling the tasks from the one having index <span class="math inline">\(k+1\)</span> to task <span class="math inline">\(j\)</span>. This can be done by simply returning the maximum costs among those tasks.</p>
<p>This exact same reasoning can be applied to all the other rows and we can therefore come up with a general formula that can be used to fill the entire table of values as shown in Equation <a href="#eq:min_difficulty_schedule:generic_bottom_up" data-reference-type="ref" data-reference="eq:min_difficulty_schedule:generic_bottom_up">[eq:min_difficulty_schedule:generic_bottom_up]</a>. <span class="math display">\[T[i][j] = \min_{i-1 \leq k \leq j-1} \Big( T[i-1][k] + \big(\ max_{k+1 \leq l \leq j }I_l \big)  \Big)
    \label{eq:min_difficulty_schedule:generic_bottom_up}\]</span></p>
<p>Clearly the solution to the entire problem is in <span class="math inline">\(T[d][|I|-1]\)</span>: the cost of scheduling all the elements in <span class="math inline">\(I\)</span> in exactly <span class="math inline">\(d\)</span> days. Listing <a href="#list:min_difficulty_job_scheduler:solutiondpbottomup" data-reference-type="ref" data-reference="list:min_difficulty_job_scheduler:solutiondpbottomup">[list:min_difficulty_job_scheduler:solutiondpbottomup]</a> shows an implementation of this idea.</p>
<div class="sourceCode" id="list:min_difficulty_job_scheduler:solutiondpbottomup" data-language="c++" data-caption="Dynamic programming bottom-up solution." label="list:min_difficulty_job_scheduler:solutiondpbottomup"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:min_difficulty_job_scheduler:solutiondpbottomup-1"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-2"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> DPTable <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;;</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-3"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-4"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> min_difficulty_scheduler_DP_bottomup<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> I<span class="op">,</span> <span class="dt">int</span> d<span class="op">)</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-5"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-6"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> num_tasks <span class="op">=</span> I<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-7"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> INF       <span class="op">=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>max<span class="op">();</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-8"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-9"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>num_tasks <span class="op">&lt;</span> d<span class="op">)</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-10"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-11"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-12"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-12" aria-hidden="true" tabindex="-1"></a>  DPTable T<span class="op">(</span>d<span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>num_tasks<span class="op">,</span> INF<span class="op">));</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-13"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-14"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// initializing values for the first day</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-15"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> maxV <span class="op">=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>min<span class="op">();</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-16"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> num_tasks<span class="op">;</span> j<span class="op">++)</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-17"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-18"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-18" aria-hidden="true" tabindex="-1"></a>    maxV    <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>maxV<span class="op">,</span> I<span class="op">[</span>j<span class="op">]);</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-19"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-19" aria-hidden="true" tabindex="-1"></a>    T<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> maxV<span class="op">;</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-20"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-21"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-22"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> d<span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-23"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-24"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> num_tasks<span class="op">;</span> j<span class="op">++)</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-25"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-26"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-26" aria-hidden="true" tabindex="-1"></a>      <span class="co">// l is the number of tasks scheduled the previous days i-1 days</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-27"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-27" aria-hidden="true" tabindex="-1"></a>      <span class="co">// l must be at least i-1 (it is impossible to schedule them otherwise)</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-28"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-28" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> l <span class="op">=</span> i <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> l <span class="op">&lt;</span> j<span class="op">;</span> l<span class="op">++)</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-29"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-29" aria-hidden="true" tabindex="-1"></a>      <span class="op">{</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-30"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">// elements from [0,l] the scheduled the days before and [l+1,j] today</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-31"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-31" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="kw">auto</span> start_task_dth_day <span class="op">=</span> <span class="bu">std::</span>begin<span class="op">(</span>I<span class="op">)</span> <span class="op">+</span> l <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-32"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-32" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="kw">auto</span> end_task_dth_day   <span class="op">=</span> <span class="bu">std::</span>begin<span class="op">(</span>I<span class="op">)</span> <span class="op">+</span> j <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-33"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-33" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> max_tasks_second_day <span class="op">=</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-34"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-34" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span><span class="bu">std::</span>max_element<span class="op">(</span>start_task_dth_day<span class="op">,</span> end_task_dth_day<span class="op">);</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-35"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-36"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-36" aria-hidden="true" tabindex="-1"></a>        T<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>T<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> T<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>l<span class="op">]</span> <span class="op">+</span> max_tasks_second_day<span class="op">);</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-37"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-37" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-38"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-39"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-39" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-40"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-41"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-41" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> T<span class="op">[</span>d <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>num_tasks <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="list:min_difficulty_job_scheduler:solutiondpbottomup-42"><a href="#list:min_difficulty_job_scheduler:solutiondpbottomup-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This implementation has a space complexity of <span class="math inline">\(O(d*|I|)\)</span>, but a closer inspection to the code and to Equation <a href="#eq:min_difficulty_schedule:generic_bottom_up" data-reference-type="ref" data-reference="eq:min_difficulty_schedule:generic_bottom_up">[eq:min_difficulty_schedule:generic_bottom_up]</a> should make clear that we do not really need to keep all the values for <span class="math inline">\(T\)</span> in memory all the time. In-fact all we need is two rows with the values for days <span class="math inline">\(i\)</span> and <span class="math inline">\(i-1\)</span>. This way the complexity goes down to <span class="math inline">\(O(|I|)\)</span>. Listing can be easily modified so that it implements this memory saving strategy. We will leave this as an exercise to the reader.</p>
<h2 id="conclusion-5">Conclusion</h2>
<h1 id="ch:max_triplet">Max triplet sum</h1>
<h2 class="unnumbered" id="introduction-40">Introduction</h2>
<h2 id="problem-statement-42">Problem statement</h2>
<div class="exercise">
<p><span id="example:max_triplet:exercice1" label="example:max_triplet:exercice1">[example:max_triplet:exercice1]</span> Write a function that, given an array <span class="math inline">\(I\)</span> of length <span class="math inline">\(n\)</span>, returns the maximum value obtainable by summing <span class="math inline">\(3\)</span> distinct elements of <span class="math inline">\(I\)</span>: <span class="math inline">\(I_i\)</span>, <span class="math inline">\(I_j\)</span> and <span class="math inline">\(I_k\)</span> such that <span class="math inline">\(0 \leq i &lt; j &lt; k \leq n-1\)</span> and <span class="math inline">\(I_i &lt; I_j &lt; I_k\)</span>.</p>
<div class="example">
<p><span id="example:max_triplet:example1" label="example:max_triplet:example1">[example:max_triplet:example1]</span><br />
Given <span class="math inline">\(I = \{2, 5, 3, 1, 4, 9\}\)</span> the function returns <span class="math inline">\(16\)</span>. The max value of <span class="math inline">\(16\)</span> is obtainable by summing together the elements of <span class="math inline">\(I\)</span> at indices: <span class="math inline">\(0\)</span>,<span class="math inline">\(1\)</span> and <span class="math inline">\(5\)</span> : <span class="math inline">\(I_0 +
		I_1+I_5=2+5+9= 16\)</span>.</p>
<p>Notice that there is another way of obtains the max sum of <span class="math inline">\(16\)</span>, that is by using the elements at indices <span class="math inline">\(2\)</span>,<span class="math inline">\(4\)</span> and <span class="math inline">\(5\)</span>: <span class="math inline">\(I_2 + I_4+I_5=3+4+9= 16\)</span>.</p>
</div>
<div class="example">
<p><span id="example:max_triplet:example2" label="example:max_triplet:example2">[example:max_triplet:example2]</span><br />
Given <span class="math inline">\(I = \{3,2,1\}\)</span> the function returns <span class="math inline">\(-1\)</span> as there is no valid triplet in <span class="math inline">\(I\)</span>.</p>
</div>
<div class="example">
<p><br />
Given <span class="math inline">\(I = \{1,3,2\}\)</span> the function returns <span class="math inline">\(-1\)</span> as there is no valid triplet in <span class="math inline">\(I\)</span>. <span id="ex:max_triplet:example2" label="ex:max_triplet:example2">[ex:max_triplet:example2]</span></p>
</div>
<div class="example">
<p><br />
Given <span class="math inline">\(I = \{1,2,3\}\)</span> the function returns <span class="math inline">\(6\)</span>. There is only one valid triplet in <span class="math inline">\(I\)</span>. <span id="ex:max_triplet:example3" label="ex:max_triplet:example3">[ex:max_triplet:example3]</span></p>
</div>
</div>
<h2 id="clarification-questions-35">Clarification Questions</h2>
<div class="QandA">
<p>Is it guaranteed that <span class="math inline">\(I\)</span> contains at least three elements?</p>
<div class="answered">
<p><em>No. When <span class="math inline">\(n &lt; 3\)</span> the function should return <span class="math inline">\(-1\)</span>.</em></p>
</div>
<p>Is it guaranteed the answer to fit a standard ?</p>
<div class="answered">
<p><em>Yes you can assume the the answer always fits a standard <span class="math inline">\(4\)</span>-bytes</em></p>
</div>
</div>
<h2 id="max_triplet:sec:discussion">Discussion</h2>
<p>The problem is asking us to find the largest possible sum obtainable by summing up three distinct elements of <span class="math inline">\(I\)</span> with the additional constraint that when ordered according to their indices they form a sorted sequence. You can form such a triplet by selecting an element at index <span class="math inline">\(i\)</span>, then another element at index <span class="math inline">\(j\)</span> that it appears after and it is larger than the element at position <span class="math inline">\(i\)</span> and finally, a third element at index <span class="math inline">\(k\)</span> which appears after and it is larger than the element at index <span class="math inline">\(j\)</span>.</p>
<h2 id="max_triplet:sec:bruteforce">Brute-force</h2>
<p>We can solve this problem trivially in a brute-force manner by trying all possible triplets of ordered indices <span class="math inline">\(i &lt; j &lt;k\)</span> and keep track of the triplet yielding the maximum value. Three simple nested loops are enough to implement this idea, as shown in Listing <a href="#list:max_triplet_bruteforce" data-reference-type="ref" data-reference="list:max_triplet_bruteforce">[list:max_triplet_bruteforce]</a>. The time complexity of this approach is <span class="math inline">\((O(|I|^3)\)</span> which is far from being optimal. The space complexity is <span class="math inline">\(O(1)\)</span> as no additional space is used.</p>
<div class="sourceCode" id="list:max_triplet_bruteforce" data-language="c++" data-caption="Cubic time complexity bruteforce solution." label="list:max_triplet_bruteforce"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:max_triplet_bruteforce-1"><a href="#list:max_triplet_bruteforce-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> max_triplet_sum_bruteforce<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> I<span class="op">)</span></span>
<span id="list:max_triplet_bruteforce-2"><a href="#list:max_triplet_bruteforce-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:max_triplet_bruteforce-3"><a href="#list:max_triplet_bruteforce-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> n <span class="op">=</span> <span class="bu">std::</span>ssize<span class="op">(</span>I<span class="op">);</span></span>
<span id="list:max_triplet_bruteforce-4"><a href="#list:max_triplet_bruteforce-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ans <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:max_triplet_bruteforce-5"><a href="#list:max_triplet_bruteforce-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span> <span class="op">;</span> i <span class="op">&lt;</span> n <span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:max_triplet_bruteforce-6"><a href="#list:max_triplet_bruteforce-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:max_triplet_bruteforce-7"><a href="#list:max_triplet_bruteforce-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i<span class="op">+</span><span class="dv">1</span> <span class="op">;</span> j <span class="op">&lt;</span> n <span class="op">;</span> j<span class="op">++)</span></span>
<span id="list:max_triplet_bruteforce-8"><a href="#list:max_triplet_bruteforce-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="list:max_triplet_bruteforce-9"><a href="#list:max_triplet_bruteforce-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(!(</span>I<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> I<span class="op">[</span>j<span class="op">]))</span></span>
<span id="list:max_triplet_bruteforce-10"><a href="#list:max_triplet_bruteforce-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span><span class="op">;</span></span>
<span id="list:max_triplet_bruteforce-11"><a href="#list:max_triplet_bruteforce-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_triplet_bruteforce-12"><a href="#list:max_triplet_bruteforce-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> j<span class="op">+</span><span class="dv">1</span> <span class="op">;</span> k <span class="op">&lt;</span> n <span class="op">;</span> k<span class="op">++)</span></span>
<span id="list:max_triplet_bruteforce-13"><a href="#list:max_triplet_bruteforce-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="list:max_triplet_bruteforce-14"><a href="#list:max_triplet_bruteforce-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span><span class="op">(!(</span>I<span class="op">[</span>j<span class="op">]</span> <span class="op">&lt;</span> I<span class="op">[</span>k<span class="op">])</span> <span class="op">)</span></span>
<span id="list:max_triplet_bruteforce-15"><a href="#list:max_triplet_bruteforce-15" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">continue</span><span class="op">;</span></span>
<span id="list:max_triplet_bruteforce-16"><a href="#list:max_triplet_bruteforce-16" aria-hidden="true" tabindex="-1"></a>                <span class="co">//here: i &lt; j &lt; k and I[i] &lt; I[j] &lt; I[k]</span></span>
<span id="list:max_triplet_bruteforce-17"><a href="#list:max_triplet_bruteforce-17" aria-hidden="true" tabindex="-1"></a>                ans <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>ans<span class="op">,</span>I<span class="op">[</span>i<span class="op">]+</span>I<span class="op">[</span>j<span class="op">]+</span>I<span class="op">[</span>k<span class="op">]</span> <span class="op">);</span></span>
<span id="list:max_triplet_bruteforce-18"><a href="#list:max_triplet_bruteforce-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="list:max_triplet_bruteforce-19"><a href="#list:max_triplet_bruteforce-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="list:max_triplet_bruteforce-20"><a href="#list:max_triplet_bruteforce-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:max_triplet_bruteforce-21"><a href="#list:max_triplet_bruteforce-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:max_triplet_bruteforce-22"><a href="#list:max_triplet_bruteforce-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="precalculation-and-binary-search">Precalculation and Binary Search</h2>
<p>The cubic time complexity approach discussed in Section <a href="#max_triplet:sec:bruteforce" data-reference-type="ref" data-reference="max_triplet:sec:bruteforce">43.4</a> can be dramatically improved if we approach the problem a little differently. Imagine we would be able to efficiently calculate <span class="math inline">\(L_j\)</span> and <span class="math inline">\(G_j\)</span> for an element at index <span class="math inline">\(j\)</span> where:</p>
<ol>
<li><p><span class="math inline">\(L_j\)</span> is the <strong>largest</strong> value among any of the elements of <span class="math inline">\(I\)</span> appearing at any index <strong>smaller</strong> than <span class="math inline">\(j\)</span> and it is <strong>smaller</strong> than <span class="math inline">\(I_j\)</span>;</p></li>
<li><p><span class="math inline">\(G_j\)</span> is the <strong>largest</strong> value among any of the elements of <span class="math inline">\(I\)</span> appearing at any index <strong>higher</strong> than <span class="math inline">\(j\)</span> and it is <strong>larger</strong> than <span class="math inline">\(I_J\)</span>.</p></li>
</ol>
<p>When these values are available we can calculate the value of the largest sum obtainable by any triplet having <span class="math inline">\(I_j\)</span> as the middle element. The triplet <span class="math inline">\((L_j, I_j, G_j)\)</span> yield the largest sum as if that was not the case it would mean that either existed a larger element than <span class="math inline">\(L_j\)</span> that is smaller than <span class="math inline">\(I_j\)</span> in any of the positions before <span class="math inline">\(j\)</span> or that existed an element that is larger than <span class="math inline">\(G_j\)</span> in any of the positions after <span class="math inline">\(j\)</span>. Both of these two scenarios are impossible because <span class="math inline">\(L_j\)</span> is by definition the largest element that is smaller than <span class="math inline">\(I_j\)</span> and appears before index <span class="math inline">\(j\)</span> and similarly, <span class="math inline">\(G_j\)</span> is defined to be the largest element appearing after index <span class="math inline">\(j\)</span> and that is larger than <span class="math inline">\(I_j\)</span>.</p>
<p>We can use this fact to calculate the answer to this problem by looping over <span class="math inline">\(I\)</span> and for each element <span class="math inline">\(I_j\)</span> calculate <span class="math inline">\(L_j+ I_j+ G_j\)</span>. The largest of the sums calculated this way is the final answer. But how can we calculate <span class="math inline">\(L_j\)</span> and <span class="math inline">\(G_j\)</span> for <span class="math inline">\(I_j\)</span>?</p>
<p><span class="math inline">\(L_j\)</span> can be calculated efficiently by keeping a sorted list of all the values appearing before index <span class="math inline">\(j\)</span> and use binary search to find <span class="math inline">\(L_j\)</span> in the list while <span class="math inline">\(G_j\)</span> can be precalculated in a similar fashion to what we have done for the problem in Chapter <a href="#ch:greatest_right" data-reference-type="ref" data-reference="ch:greatest_right">6</a> where we loop from the right to the left of <span class="math inline">\(I\)</span> and we keep track of the largest element (<span class="math inline">\(M\)</span>) seen so far. If <span class="math inline">\(M\)</span> is larger then the element we are currently examining (<span class="math inline">\(I_x\)</span>) then <span class="math inline">\(M\)</span> is also the largest element larger than <span class="math inline">\(I_x\)</span> appearing after <span class="math inline">\(x\)</span>. If not, it means that <span class="math inline">\(I_x\)</span> is the largest element so far, and that <span class="math inline">\(I_x\)</span> does not have any larger element on its right: thus <span class="math inline">\(M = I_x\)</span> (see Section <a href="#sec:greatest_right:linear" data-reference-type="ref" data-reference="sec:greatest_right:linear">6.3.2</a> and Listing <a href="#list:greatest_right_final1" data-reference-type="ref" data-reference="list:greatest_right_final1">[list:greatest_right_final1]</a>).</p>
<div class="sourceCode" id="list:max_triplet" data-language="c++" data-caption="$O(nlog(n))$ solution to the max triplet sum problem." label="list:max_triplet"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:max_triplet-1"><a href="#list:max_triplet-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_triplet-2"><a href="#list:max_triplet-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> MIN_INT <span class="op">=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>min<span class="op">();</span></span>
<span id="list:max_triplet-3"><a href="#list:max_triplet-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> find_largest_smaller_than<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>set<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> N<span class="op">,</span> <span class="at">const</span> <span class="dt">int</span> n<span class="op">)</span></span>
<span id="list:max_triplet-4"><a href="#list:max_triplet-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:max_triplet-5"><a href="#list:max_triplet-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> it <span class="op">=</span>N<span class="op">.</span>lower_bound<span class="op">(</span> n<span class="op">);</span></span>
<span id="list:max_triplet-6"><a href="#list:max_triplet-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>N<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> it<span class="op">==</span><span class="bu">std::</span>begin<span class="op">(</span>N<span class="op">))</span></span>
<span id="list:max_triplet-7"><a href="#list:max_triplet-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>make_tuple<span class="op">(</span>MIN_INT<span class="op">,</span> <span class="kw">false</span><span class="op">);</span></span>
<span id="list:max_triplet-8"><a href="#list:max_triplet-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>make_tuple<span class="op">(*(--</span>it<span class="op">),</span> <span class="kw">true</span><span class="op">);</span></span>
<span id="list:max_triplet-9"><a href="#list:max_triplet-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:max_triplet-10"><a href="#list:max_triplet-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_triplet-11"><a href="#list:max_triplet-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> max_triplet_sum_prefix_binary_search<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>A<span class="op">)</span> <span class="op">{</span></span>
<span id="list:max_triplet-12"><a href="#list:max_triplet-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>set<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> N<span class="op">;</span>    </span>
<span id="list:max_triplet-13"><a href="#list:max_triplet-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> L<span class="op">;</span></span>
<span id="list:max_triplet-14"><a href="#list:max_triplet-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="list:max_triplet-15"><a href="#list:max_triplet-15" aria-hidden="true" tabindex="-1"></a>    L<span class="op">.</span>resize<span class="op">(</span>A<span class="op">.</span>size<span class="op">(),</span> MIN_INT<span class="op">);</span></span>
<span id="list:max_triplet-16"><a href="#list:max_triplet-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> M <span class="op">=</span> A<span class="op">[</span>A<span class="op">.</span>size<span class="op">()-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="list:max_triplet-17"><a href="#list:max_triplet-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="bu">std::</span>ssize<span class="op">(</span>A<span class="op">)-</span><span class="dv">2</span> <span class="op">;</span> i <span class="op">&gt;=</span><span class="dv">0</span> <span class="op">;</span> i<span class="op">--)</span></span>
<span id="list:max_triplet-18"><a href="#list:max_triplet-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:max_triplet-19"><a href="#list:max_triplet-19" aria-hidden="true" tabindex="-1"></a>        L<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> A<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> M <span class="op">?</span> M <span class="op">:</span> MIN_INT<span class="op">;</span></span>
<span id="list:max_triplet-20"><a href="#list:max_triplet-20" aria-hidden="true" tabindex="-1"></a>        M <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>A<span class="op">[</span>i<span class="op">],</span> M<span class="op">);</span></span>
<span id="list:max_triplet-21"><a href="#list:max_triplet-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:max_triplet-22"><a href="#list:max_triplet-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="list:max_triplet-23"><a href="#list:max_triplet-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ans <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:max_triplet-24"><a href="#list:max_triplet-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span> <span class="op">;</span> i <span class="op">&lt;</span> A<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span></span>
<span id="list:max_triplet-25"><a href="#list:max_triplet-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:max_triplet-26"><a href="#list:max_triplet-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> larger <span class="op">=</span> L<span class="op">[</span>i<span class="op">];</span></span>
<span id="list:max_triplet-27"><a href="#list:max_triplet-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> <span class="op">[</span>smaller<span class="op">,</span> exists<span class="op">]</span> <span class="op">=</span> find_largest_smaller_than<span class="op">(</span>N<span class="op">,</span>A<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:max_triplet-28"><a href="#list:max_triplet-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>larger <span class="op">!=</span> MIN_INT <span class="op">&amp;&amp;</span> exists<span class="op">)</span></span>
<span id="list:max_triplet-29"><a href="#list:max_triplet-29" aria-hidden="true" tabindex="-1"></a>            ans <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>ans<span class="op">,</span> A<span class="op">[</span>i<span class="op">]+</span>larger <span class="op">+</span>smaller<span class="op">);</span></span>
<span id="list:max_triplet-30"><a href="#list:max_triplet-30" aria-hidden="true" tabindex="-1"></a>        N<span class="op">.</span>insert<span class="op">(</span>A<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:max_triplet-31"><a href="#list:max_triplet-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:max_triplet-32"><a href="#list:max_triplet-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:max_triplet-33"><a href="#list:max_triplet-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="list:max_triplet-34"><a href="#list:max_triplet-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="ch:dice_rolls">Number of Dice Rolls With Target Sum</h1>
<h2 class="unnumbered" id="introduction-41">Introduction</h2>
<p>Dices have been around for quite a long time: the oldest dice known were discovered in Iran, as part of a staggering five-thousand-year-old Backgammon<a href="#fn28" class="footnote-ref" id="fnref28" role="doc-noteref"><sup>28</sup></a> set.</p>
<p>If we think about what a die is, the first thing that comes to mind is the fair <span class="math inline">\(6\)</span> faced-die (see Figure <a href="#fig:dice_rolls:6faces_dice" data-reference-type="ref" data-reference="fig:dice_rolls:6faces_dice">44.2</a>), but potentially any polyhedron can be a die: consider for instance a <span class="math inline">\(20\)</span>-faced icosahedron (see Figure <a href="#fig:dice_rolls:20faces_dice" data-reference-type="ref" data-reference="fig:dice_rolls:20faces_dice">44.3</a>), or a <span class="math inline">\(12\)</span>-faced dodecahedron (see Figure <a href="#fig:dice_rolls:12faces_dice" data-reference-type="ref" data-reference="fig:dice_rolls:12faces_dice">44.1</a>). In this chapter’s problem, we will use up to <span class="math inline">\(30\)</span> dice at the same time, each with up to <span class="math inline">\(30\)</span> faces, and we are going to calculate the number of ways we can obtain a certain target value when we throw them all at the same time.</p>
<h2 id="problem-statement-43">Problem statement</h2>
<div class="exercise">
<p>You have <span class="math inline">\(d\)</span> dice, and each die has <span class="math inline">\(f\)</span> faces numbered <span class="math inline">\(1, 2, \ldots..., f\)</span>. Write a function that returns the number of possible ways to roll the dice so the sum of the upper faces equals a given target number <span class="math inline">\(t\)</span>. Because this number can be very large, the answer should be returned modulo <span class="math inline">\(10^9 + 7\)</span>.</p>
<div class="example">
<p><br />
Given <span class="math inline">\(d=1\)</span>, <span class="math inline">\(f=6\)</span> and <span class="math inline">\(t=6\)</span> the function should return <span class="math inline">\(1\)</span>. Clearly, there is only one way to obtain <span class="math inline">\(6\)</span> when rolling a common <span class="math inline">\(6\)</span>-face cubic die.</p>
</div>
<div class="example">
<p><span id="ex:dice_rolls:example2" label="ex:dice_rolls:example2">[ex:dice_rolls:example2]</span><br />
Given <span class="math inline">\(d=2\)</span>, <span class="math inline">\(f=6\)</span> and <span class="math inline">\(t=7\)</span> the function should return <span class="math inline">\(6\)</span>. Table <a href="#tab:dice_rolls:arrangements_example2" data-reference-type="ref" data-reference="tab:dice_rolls:arrangements_example2">44.1</a> lists all the possible ways of obtaining <span class="math inline">\(7\)</span> from two common <span class="math inline">\(6\)</span>-face dice.</p>
</div>
<div class="example">
<p><br />
Given <span class="math inline">\(d=2\)</span>, <span class="math inline">\(f=3\)</span> and <span class="math inline">\(t=7\)</span> the function should return <span class="math inline">\(0\)</span> because the highest number obtainable by rolling two dices with three faces is <span class="math inline">\(6\)</span>.</p>
</div>
</div>
<div id="tab:dice_rolls:arrangements_example2">
<table>
<caption>Possible valide arrangements of two dice for the Example <a href="#ex:dice_rolls:example2" data-reference-type="ref" data-reference="ex:dice_rolls:example2">[ex:dice_rolls:example2]</a></caption>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>First die</strong></th>
<th style="text-align: center;"><strong>Second die</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">6</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">5</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
</div>
<h2 id="clarification-questions-36">Clarification Questions</h2>
<div class="QandA">
<p>What is the maximum number of dices, faces, and the highest target value possible?</p>
<div class="answered">
<p><span class="math inline">\(30\)</span>,<span class="math inline">\(30\)</span> and <span class="math inline">\(1000\)</span>, respectively.</p>
</div>
</div>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/dice_rolls/images/3d_dices.jpg" id="fig:dice_rolls:12faces_dice" alt="Example of dice with 12 faces." /><figcaption aria-hidden="true">Example of dice with <span class="math inline">\(12\)</span> faces.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/dice_rolls/images/cubic_dice.jpg" id="fig:dice_rolls:6faces_dice" alt="Example of common 6 faces dice." /><figcaption aria-hidden="true">Example of common <span class="math inline">\(6\)</span> faces dice.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/dice_rolls/images/icosahedron_dice.jpg" id="fig:dice_rolls:20faces_dice" alt="Example of dice with 20 faces." /><figcaption aria-hidden="true">Example of dice with <span class="math inline">\(20\)</span> faces.</figcaption>
</figure>
<h2 id="dice_rolls:sec:discussion">Discussion</h2>
<p>Let’s start by noticing that the answer can be astronomically high, but more importantly, the number of possible value combinations resulting from rolling <span class="math inline">\(d\)</span> dices is even larger: if each die has <span class="math inline">\(f\)</span> faces, then we are looking at <span class="math inline">\(f^d\)</span> possible distinct roll outcomes! During an interview, a brute-force approach, where we go over each and every possible roll outcome of the <span class="math inline">\(d\)</span> dice, is completely out of question (considering the constraints on the maximum number of dices and faces we might get for input) unless we are willing to wait around <span class="math inline">\(6 \times 10^{18}\)</span> years. Even if we implement this algorithm so that it can run on the fastest supercomputer available today (which is capable of a staggering <span class="math inline">\(\approx450\)</span> <a href="#fn29" class="footnote-ref" id="fnref29" role="doc-noteref"><sup>29</sup></a> operations per second), it would still require <span class="math inline">\(\frac{30^{30}}{10e15}\)</span>s to run to completion. By that time, humanity will be long gone, the universe will be a dark and cold place, but most importantly, the position you are dreaming about will have gone to somebody else.</p>
<p>This type of <em>"counting"</em> questions is usually (and crucially more efficiently) solved by using a dynamic programming approach. In fact, this question shares a lot of similarities with the classical dynamic programming <em>Coin change</em> problem, to the point that we could solve this one using the solution to the other. In fact we can stretch this reasoning so to consider the topic treated in this chapter to be a proper specialization of the *Coin change* problem, where the number of available coins is equal to <span class="math inline">\(d\)</span> and the denomination of the coins are <span class="math inline">\(1,2,\ldots,f\)</span>: we have coins of the same denomination as the dice faces.</p>
<h3 id="dice_rolls:sec:bruteforce">Brute-force</h3>
<p>For science’s sake, let’s see how a brute-force approach would apply here. As we all know, a brute-force approach evaluates all possible outcomes of rolling <span class="math inline">\(d\)</span> dice and keeps track of how many yield a total sum of <span class="math inline">\(t\)</span>. When dealing with this kind of task, where you have to enumerate/generate the elements of a given set, recursion is usually the way to go, especially if the elements (in this case a combination of face values) have a recursive definition. In this specific case, we can generate all possible combinations of <span class="math inline">\(d\)</span> faces we can obtain from rolling <span class="math inline">\(d\)</span> dices by:</p>
<ul>
<li><p>generate the combinations from rolling <span class="math inline">\(d-1\)</span> dice;</p></li>
<li><p>create <span class="math inline">\(f\)</span> copies of them;</p></li>
<li><p>prepend <span class="math inline">\(1\)</span> to the items of the first copy;</p></li>
<li><p>prepend <span class="math inline">\(2\)</span> to the items of the second copy;</p></li>
<li><p><span class="math inline">\(\ldots\)</span></p></li>
<li><p>prepend <span class="math inline">\(f\)</span> to the items of the last copy.</p></li>
</ul>
<p>For instance, we can generate all rolls outcome <span class="math inline">\(3\)</span> six-faced dice by:</p>
<ol>
<li><p>Generate all the outcomes for only <span class="math inline">\(2\)</span> of them <span class="math inline">\(C_2\)</span>:<br />
<span class="math inline">\(\!
	\begin{aligned}[t]
		C_2 =  \{
			&amp; (1,1),(1,2),(1,3),	(1,4),	(2,1),	(2,2),	(2,3),	(2,4),\\
			&amp;(3,1),	(3,2),	(3,3),	(3,4),	(4,1),	(4,2),	(4,3),	(4,4)\}
	\end{aligned}\)</span></p></li>
<li><p>Append <span class="math inline">\(1\)</span> to each of the elements of <span class="math inline">\(C_2\)</span>:<br />
<span class="math inline">\(\!
	\begin{aligned}[t]
		C_3^1 =  \{
			&amp;(1,1,1),(1,1,2),(1,1,3),(1,1,4),(1,2,1),(1,2,2),(1,2,3),(1,2,4),\\
			&amp;(1,3,1),(1,3,2),(1,3,3),(1,3,4),(1,4,1),(1,4,2),(1,4,3),(1,4,4)\}
	\end{aligned}\)</span></p></li>
<li><p>Append <span class="math inline">\(2\)</span> to each of the elements of <span class="math inline">\(C_2\)</span>:<br />
<span class="math inline">\(\!
	\begin{aligned}[t]
		C_3^2 =  \{
			&amp;(2,1,1),(2,1,2),(2,1,3),(2,1,4),(2,2,1),(2,2,2),(2,2,3),(2,2,4),\\
			&amp;(2,3,1),(2,3,2),(2,3,3),(2,3,4),(2,4,1),(2,4,2),(2,4,3),(2,4,4)\}
	\end{aligned}\)</span></p></li>
<li><p>Append <span class="math inline">\(3\)</span> to each of the elements of <span class="math inline">\(C_2\)</span>:<br />
<span class="math inline">\(\!
	\begin{aligned}[t]
		C_3^3 =  \{
			&amp;(3,1,1),(3,1,2),(3,1,3),(3,1,4),(3,2,1),(3,2,2),(3,2,3),(3,2,4),\\
			&amp;(3,3,1),(3,3,2),(3,3,3),(3,3,4),(3,4,1),(3,4,2),(3,4,3),(3,4,4)\}
	\end{aligned}\)</span></p></li>
<li><p>Prepend <span class="math inline">\(4\)</span> to each of the elements of <span class="math inline">\(C_2\)</span>:<br />
<span class="math inline">\(\!
	\begin{aligned}[t]
		C_3^4 =  \{
			&amp; (4,1,1),(4,1,2),(4,1,3),(4,1,4),(4,2,1),(4,2,2),(4,2,3),(4,2,4),\\
			&amp;(4,3,1),(4,3,2),(4,3,3),(4,3,4),(4,4,1),(4,4,2),(4,4,3),(4,4,4)\}
	\end{aligned}\)</span></p></li>
<li><p>Finally, return <span class="math inline">\(C_3 = \{C_2^1 \cup  C_2^2 \cup C_2^3 \cup C_2^4\}\)</span></p></li>
</ol>
<p>The definition above is correct, but not very useful in practice: it requires making many copies of a potentially very large (indeed exponential) set of items. We will therefore use a different approach that will still run in exponential time (this section is named brute-force after all), but it can be used as a basis for developing a more efficient DP solution.</p>
<p>We start by rolling the first die; clearly, we have <span class="math inline">\(f\)</span> possible values we can get, but once the value for this specific die is set, say we got the value <span class="math inline">\(x\)</span>, we are left with <span class="math inline">\(d-1\)</span> dices to roll and we still have to make up for <span class="math inline">\(t-x\)</span> with the remaining <span class="math inline">\(d-1\)</span> dice in order to reach our target value <span class="math inline">\(t\)</span>. Once a die is rolled, we are left with exactly the original problem on a smaller number of dice and target value. This is why recursion is handy as we can describe the solution to the entire problem in terms of solutions to sub-problems. We can continue this recursive process, rolling one die at a time, until we reach one of the following cases:</p>
<ol>
<li><p><span class="math inline">\(d&lt;0\)</span> or <span class="math inline">\(t&lt;0\)</span> the answer is <span class="math inline">\(0\)</span>. There is no solution to the problem when the number of dice to use is negative or the target number is negative.</p></li>
<li><p><span class="math inline">\(t=0\)</span>. We have reached the target value <span class="math inline">\(t\)</span>. If we have used <strong>all</strong> dice then we have a solution, otherwise we do not. In other words:</p>
<ul>
<li><p>if <span class="math inline">\(d=0\)</span>, we have used all <span class="math inline">\(d\)</span> dice and the sum is exactly equal to <span class="math inline">\(t\)</span>. This is a valid combination. We have rolled <span class="math inline">\(d\)</span> dice and the sum of their faces is exactly equal to <span class="math inline">\(t\)</span>.</p></li>
<li><p>if <span class="math inline">\(d&gt;0\)</span>, we have not rolled all the dice, yet we have already reached our target value. If we continue to roll, we will generate a combination with a total sum higher than <span class="math inline">\(t\)</span>. This is not a good combination.</p></li>
</ul></li>
</ol>
<p>The idea above can be better expressed using the recurrence relation shown in Equation <a href="#eq:dice_rolls:dpformula" data-reference-type="ref" data-reference="eq:dice_rolls:dpformula">[eq:dice_rolls:dpformula]</a> where <span class="math inline">\(S(d,t,f)\)</span> is the number of ways one can obtain a target value <span class="math inline">\(t\)</span> by throwing <span class="math inline">\(d\)</span> dice. Notice that the third parameter never changes, and thus it does not play a dynamic role in the recurrence.</p>
<p><span class="math display">\[S(d,t,f)=\begin{cases}
		 1 \: \: \text{ if } \: d=t=0 \\
		 0 \: \: \text{ if } \: d=0, \: t&gt;0 \\ \\
		\sum_{1}^{\min(f,t)} S(d-1,t-j,f)  \:\: \text{ otherwise}
	 \end{cases}
	\label{eq:dice_rolls:dpformula}\]</span></p>
<p>Listing <a href="#list:dice_rolls:bruteforce" data-reference-type="ref" data-reference="list:dice_rolls:bruteforce">[list:dice_rolls:bruteforce]</a> shows a possible implementation of such idea. Please note that this code is remarkably similar to the brute-force solution for the Coin Change problem in Chapter <a href="#ch:coin_change" data-reference-type="ref" data-reference="ch:coin_change">[ch:coin_change]</a>. Section <a href="#sec:min_difficulty_job_scheduler:generate_all_combination" data-reference-type="ref" data-reference="sec:min_difficulty_job_scheduler:generate_all_combination">[sec:min_difficulty_job_scheduler:generate_all_combination]</a> also discuss the problem of generating combinations, and the material discussed there can be adapted and applied here.</p>
<div class="sourceCode" id="list:dice_rolls:bruteforce" data-language="c++" data-caption="Brute-force (enumerating all possible combinations) solution for the problem of counting the number of dice rolls summing up to a target number $t$." label="list:dice_rolls:bruteforce"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:dice_rolls:bruteforce-1"><a href="#list:dice_rolls:bruteforce-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> num_rolls_to_target_bruteforce<span class="op">(</span><span class="at">const</span> <span class="dt">int</span> dices<span class="op">,</span></span>
<span id="list:dice_rolls:bruteforce-2"><a href="#list:dice_rolls:bruteforce-2" aria-hidden="true" tabindex="-1"></a>                                   <span class="at">const</span> <span class="dt">int</span> f<span class="op">,</span></span>
<span id="list:dice_rolls:bruteforce-3"><a href="#list:dice_rolls:bruteforce-3" aria-hidden="true" tabindex="-1"></a>                                   <span class="at">const</span> <span class="dt">int</span> target<span class="op">)</span></span>
<span id="list:dice_rolls:bruteforce-4"><a href="#list:dice_rolls:bruteforce-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:dice_rolls:bruteforce-5"><a href="#list:dice_rolls:bruteforce-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> <span class="dt">unsigned</span> <span class="dt">long</span> MOD <span class="op">=</span> <span class="fl">1e9</span> <span class="op">+</span> <span class="dv">7</span><span class="op">;</span></span>
<span id="list:dice_rolls:bruteforce-6"><a href="#list:dice_rolls:bruteforce-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ops. overreached</span></span>
<span id="list:dice_rolls:bruteforce-7"><a href="#list:dice_rolls:bruteforce-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>target <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">||</span> dices <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:dice_rolls:bruteforce-8"><a href="#list:dice_rolls:bruteforce-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:dice_rolls:bruteforce-9"><a href="#list:dice_rolls:bruteforce-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:dice_rolls:bruteforce-10"><a href="#list:dice_rolls:bruteforce-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// no more die to roll. Have we reached the target value?</span></span>
<span id="list:dice_rolls:bruteforce-11"><a href="#list:dice_rolls:bruteforce-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>dices <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:dice_rolls:bruteforce-12"><a href="#list:dice_rolls:bruteforce-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> target <span class="op">==</span> <span class="dv">0</span> <span class="op">?</span> <span class="dv">1</span> <span class="op">:</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:dice_rolls:bruteforce-13"><a href="#list:dice_rolls:bruteforce-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:dice_rolls:bruteforce-14"><a href="#list:dice_rolls:bruteforce-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// for each possible face</span></span>
<span id="list:dice_rolls:bruteforce-15"><a href="#list:dice_rolls:bruteforce-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:dice_rolls:bruteforce-16"><a href="#list:dice_rolls:bruteforce-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> f<span class="op">;</span> i<span class="op">++,</span> ans <span class="op">%=</span> MOD<span class="op">)</span></span>
<span id="list:dice_rolls:bruteforce-17"><a href="#list:dice_rolls:bruteforce-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:dice_rolls:bruteforce-18"><a href="#list:dice_rolls:bruteforce-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// we assume we rolled the face with value i and solve the associated</span></span>
<span id="list:dice_rolls:bruteforce-19"><a href="#list:dice_rolls:bruteforce-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// subproblem</span></span>
<span id="list:dice_rolls:bruteforce-20"><a href="#list:dice_rolls:bruteforce-20" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">+=</span> num_rolls_to_target_bruteforce<span class="op">(</span>dices <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> f<span class="op">,</span> target <span class="op">-</span> i<span class="op">);</span></span>
<span id="list:dice_rolls:bruteforce-21"><a href="#list:dice_rolls:bruteforce-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:dice_rolls:bruteforce-22"><a href="#list:dice_rolls:bruteforce-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:dice_rolls:bruteforce-23"><a href="#list:dice_rolls:bruteforce-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The time and space complexity of this approach are exponential and constant, respectively.</p>
<p>The proof of this can be derived from the solution of the recurrence relation shown in Equation <a href="#eq:dice_rolls:dpformula_complexity" data-reference-type="ref" data-reference="eq:dice_rolls:dpformula_complexity">[eq:dice_rolls:dpformula_complexity]</a>: <span class="math display">\[S(d,t) = S(d-1,t-1) + S(d-1,t-2)
\label{eq:dice_rolls:dpformula_complexity}\]</span></p>
<p>where <span class="math inline">\(S(d,t)\)</span>expresses the number of invocations of the function for a given number of dice <span class="math inline">\(d\)</span> and target value <span class="math inline">\(t\)</span> when <span class="math inline">\(f=2\)</span>. The resulting invocation tree is complete and has height <span class="math inline">\(h=t\)</span> (assuming <span class="math inline">\(d \leq t\)</span>, but the same reasoning can be applied in the other cases). The cost of each node of the tree is <span class="math inline">\(O(1)\)</span>. The number of nodes in such a tree is exponentially proportional to its height.</p>
<h3 id="dice_rolls:sec:DP">Dynamic Programming - Recursive top-down</h3>
<p>The brute-force solution we laid down in Section <a href="#dice_rolls:sec:bruteforce" data-reference-type="ref" data-reference="dice_rolls:sec:bruteforce">44.3.1</a> can be turned into a nice and efficient one with the help of DP, and in particular of memoization. As per many other problems solvable with DP out there, the brute-force solution above can be turned into a much more efficient one by simply realizing that the same sub-problems are solved over and over again. For istance, imagine the case where <span class="math inline">\(f=5\)</span>. We might end up solving the sub-problem where <span class="math inline">\(d=1\)</span> and <span class="math inline">\(t=3\)</span> from the sub-problem where <span class="math inline">\(d=2\)</span>, <span class="math inline">\(t=4\)</span> (by rolling the face with <span class="math inline">\(1\)</span>), or from the sub-problem <span class="math inline">\(d=2\)</span>, <span class="math inline">\(t=5\)</span> (by rolling the face with <span class="math inline">\(2\)</span>).</p>
<p>However, the maximum number of <em>distinct</em> invocations for the function is not larger than <span class="math inline">\(30\times 1000 = 30000\)</span>: the maximum number of dice multiplied by the largest target value as these are the only function parameters varying during the execution. If we can somehow guarantee that no duplicate work is done for a given <span class="math inline">\(d\)</span> and <span class="math inline">\(t\)</span>, then we can get away with only <span class="math inline">\(O(d\times t)\)</span> function calls.</p>
<p>Consider, for instance, what happens during the execution of the code in Listing <a href="#list:dice_rolls:bruteforce" data-reference-type="ref" data-reference="list:dice_rolls:bruteforce">[list:dice_rolls:bruteforce]</a> for the following input:</p>
<ul>
<li><p><span class="math inline">\(d = 3\)</span></p></li>
<li><p><span class="math inline">\(f = 6\)</span></p></li>
<li><p><span class="math inline">\(t = 12\)</span></p></li>
</ul>
<p>The function is called <span class="math inline">\(6\)</span> times and the sub-problem is solved <span class="math inline">\(5\)</span> times. You can verify this yourself if you draw the recursion tree for , or simply add a print statement at the beginning of the function. All these duplicate calls are superfluous and they represent work that can be saved if the result of each sub-problem is stored into a cache as shown in the following Listing.</p>
<p>The function subproblem solved <span class="math inline">\(6\)</span> times and the subproblem is solved <span class="math inline">\(5\)</span> times. If you are not convinced draw the recursion tree, or add a print statement at the beginning of the function. All these superfluous execution can be avoided if the result of each of the subproblem is stored into a cache as shown in Listing <a href="#list:dice_rolls:dp" data-reference-type="ref" data-reference="list:dice_rolls:dp">[list:dice_rolls:dp]</a>.</p>
<div class="sourceCode" id="list:dice_rolls:dp" data-language="c++" data-caption="Dynamic programming with memoization top-down recursive  solution for the problem of counting the number of dice rolls summing up to a target number $t$." label="list:dice_rolls:dp"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:dice_rolls:dp-1"><a href="#list:dice_rolls:dp-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> Cache <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">unsigned</span> <span class="dt">long</span><span class="op">&gt;&gt;;</span></span>
<span id="list:dice_rolls:dp-2"><a href="#list:dice_rolls:dp-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:dice_rolls:dp-3"><a href="#list:dice_rolls:dp-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> num_rolls_to_target_memoization_helper<span class="op">(</span><span class="at">const</span> <span class="dt">int</span> target<span class="op">,</span></span>
<span id="list:dice_rolls:dp-4"><a href="#list:dice_rolls:dp-4" aria-hidden="true" tabindex="-1"></a>                                           <span class="at">const</span> <span class="dt">int</span> dices<span class="op">,</span></span>
<span id="list:dice_rolls:dp-5"><a href="#list:dice_rolls:dp-5" aria-hidden="true" tabindex="-1"></a>                                           <span class="at">const</span> <span class="dt">int</span> f<span class="op">,</span></span>
<span id="list:dice_rolls:dp-6"><a href="#list:dice_rolls:dp-6" aria-hidden="true" tabindex="-1"></a>                                           Cache<span class="op">&amp;</span> cache<span class="op">)</span></span>
<span id="list:dice_rolls:dp-7"><a href="#list:dice_rolls:dp-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:dice_rolls:dp-8"><a href="#list:dice_rolls:dp-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> <span class="dt">unsigned</span> <span class="dt">long</span> MOD <span class="op">=</span> <span class="fl">1e9</span> <span class="op">+</span> <span class="dv">7</span><span class="op">;</span></span>
<span id="list:dice_rolls:dp-9"><a href="#list:dice_rolls:dp-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:dice_rolls:dp-10"><a href="#list:dice_rolls:dp-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>target <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">||</span> dices <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:dice_rolls:dp-11"><a href="#list:dice_rolls:dp-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:dice_rolls:dp-12"><a href="#list:dice_rolls:dp-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:dice_rolls:dp-13"><a href="#list:dice_rolls:dp-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>dices <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:dice_rolls:dp-14"><a href="#list:dice_rolls:dp-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> target <span class="op">==</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:dice_rolls:dp-15"><a href="#list:dice_rolls:dp-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:dice_rolls:dp-16"><a href="#list:dice_rolls:dp-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>cache<span class="op">[</span>dices<span class="op">][</span>target<span class="op">]</span> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span></span>
<span id="list:dice_rolls:dp-17"><a href="#list:dice_rolls:dp-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cache<span class="op">[</span>dices<span class="op">][</span>target<span class="op">];</span></span>
<span id="list:dice_rolls:dp-18"><a href="#list:dice_rolls:dp-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:dice_rolls:dp-19"><a href="#list:dice_rolls:dp-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">unsigned</span> <span class="dt">long</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:dice_rolls:dp-20"><a href="#list:dice_rolls:dp-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> f<span class="op">;</span> i<span class="op">++,</span> ans <span class="op">%=</span> MOD<span class="op">)</span></span>
<span id="list:dice_rolls:dp-21"><a href="#list:dice_rolls:dp-21" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">+=</span></span>
<span id="list:dice_rolls:dp-22"><a href="#list:dice_rolls:dp-22" aria-hidden="true" tabindex="-1"></a>        num_rolls_to_target_memoization_helper<span class="op">(</span>target <span class="op">-</span> i<span class="op">,</span> dices <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> f<span class="op">,</span> cache<span class="op">);</span></span>
<span id="list:dice_rolls:dp-23"><a href="#list:dice_rolls:dp-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:dice_rolls:dp-24"><a href="#list:dice_rolls:dp-24" aria-hidden="true" tabindex="-1"></a>  cache<span class="op">[</span>dices<span class="op">][</span>target<span class="op">]</span> <span class="op">=</span> ans<span class="op">;</span></span>
<span id="list:dice_rolls:dp-25"><a href="#list:dice_rolls:dp-25" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:dice_rolls:dp-26"><a href="#list:dice_rolls:dp-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:dice_rolls:dp-27"><a href="#list:dice_rolls:dp-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:dice_rolls:dp-28"><a href="#list:dice_rolls:dp-28" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> num_rolls_to_target_memoization<span class="op">(</span><span class="dt">int</span> d<span class="op">,</span> <span class="dt">int</span> f<span class="op">,</span> <span class="dt">int</span> target<span class="op">)</span></span>
<span id="list:dice_rolls:dp-29"><a href="#list:dice_rolls:dp-29" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:dice_rolls:dp-30"><a href="#list:dice_rolls:dp-30" aria-hidden="true" tabindex="-1"></a>  Cache DP<span class="op">(</span>d <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">unsigned</span> <span class="dt">long</span><span class="op">&gt;(</span>target <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">));</span></span>
<span id="list:dice_rolls:dp-31"><a href="#list:dice_rolls:dp-31" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> num_rolls_to_target_memoization_helper<span class="op">(</span>target<span class="op">,</span> d<span class="op">,</span> f<span class="op">,</span> DP<span class="op">);</span></span>
<span id="list:dice_rolls:dp-32"><a href="#list:dice_rolls:dp-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This implementation is an almost identical copy of the brute-force solution, except for the addition of a cache. Note how <strong>before</strong> actually trying to compute the answer, we first look into the cache (see highlighted lines) to see if it is already present in the cache. If not, we solve the problem and before returning the answer we <strong>save</strong> the result into the cache.</p>
<h2 id="dice_rolls:sec:bottom">Dynamic programming - Iterative bottom-up</h2>
<p>Turning the top-down-up solution shown in Section <a href="#dice_rolls:sec:DP" data-reference-type="ref" data-reference="dice_rolls:sec:DP">44.3.2</a> into a bottom-up one is relatively easy: the recursive definition of the solution (see Equation <a href="#eq:dice_rolls:dpformula" data-reference-type="ref" data-reference="eq:dice_rolls:dpformula">[eq:dice_rolls:dpformula]</a>) clearly shows that we can calculate the answer for a given number of dice <span class="math inline">\(d\)</span> and a target value <span class="math inline">\(t\)</span> if we have already calculated the values for targets <span class="math inline">\(t-1, t-2, \ldots, t-f\)</span> and <span class="math inline">\(d-1\)</span>. We also know how to easily calculate the answer for all possible target values when <span class="math inline">\(d=0\)</span> and <span class="math inline">\(d=1\)</span> and from there we can apply the reasoning above. This is exactly the strategy that Listing <a href="#list:dice_rolls:dpbottomup" data-reference-type="ref" data-reference="list:dice_rolls:dpbottomup">[list:dice_rolls:dpbottomup]</a> implements.</p>
<div class="sourceCode" id="list:dice_rolls:dpbottomup" data-language="c++" data-caption="Dynamic programming bottom-up solution for the problem of counting the number of dice rolls summing up to a target number $t$." label="list:dice_rolls:dpbottomup"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:dice_rolls:dpbottomup-1"><a href="#list:dice_rolls:dpbottomup-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> Cache <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">unsigned</span> <span class="dt">long</span><span class="op">&gt;&gt;;</span></span>
<span id="list:dice_rolls:dpbottomup-2"><a href="#list:dice_rolls:dpbottomup-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:dice_rolls:dpbottomup-3"><a href="#list:dice_rolls:dpbottomup-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> num_rolls_to_target_bottom_up<span class="op">(</span><span class="at">const</span> <span class="dt">int</span> d<span class="op">,</span> <span class="at">const</span> <span class="dt">int</span> f<span class="op">,</span> <span class="at">const</span> <span class="dt">int</span> target<span class="op">)</span></span>
<span id="list:dice_rolls:dpbottomup-4"><a href="#list:dice_rolls:dpbottomup-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:dice_rolls:dpbottomup-5"><a href="#list:dice_rolls:dpbottomup-5" aria-hidden="true" tabindex="-1"></a>  Cache DP<span class="op">(</span>d <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">unsigned</span> <span class="dt">long</span><span class="op">&gt;(</span>target <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="list:dice_rolls:dpbottomup-6"><a href="#list:dice_rolls:dpbottomup-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:dice_rolls:dpbottomup-7"><a href="#list:dice_rolls:dpbottomup-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> f <span class="op">&amp;&amp;</span> j <span class="op">&lt;=</span> target<span class="op">;</span> j<span class="op">++)</span></span>
<span id="list:dice_rolls:dpbottomup-8"><a href="#list:dice_rolls:dpbottomup-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:dice_rolls:dpbottomup-9"><a href="#list:dice_rolls:dpbottomup-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// only one way to make a given value with 1 dice</span></span>
<span id="list:dice_rolls:dpbottomup-10"><a href="#list:dice_rolls:dpbottomup-10" aria-hidden="true" tabindex="-1"></a>    DP<span class="op">[</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:dice_rolls:dpbottomup-11"><a href="#list:dice_rolls:dpbottomup-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:dice_rolls:dpbottomup-12"><a href="#list:dice_rolls:dpbottomup-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:dice_rolls:dpbottomup-13"><a href="#list:dice_rolls:dpbottomup-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// 1 way to make 0 with 0 dice</span></span>
<span id="list:dice_rolls:dpbottomup-14"><a href="#list:dice_rolls:dpbottomup-14" aria-hidden="true" tabindex="-1"></a>  DP<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:dice_rolls:dpbottomup-15"><a href="#list:dice_rolls:dpbottomup-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:dice_rolls:dpbottomup-16"><a href="#list:dice_rolls:dpbottomup-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">// num dices</span></span>
<span id="list:dice_rolls:dpbottomup-17"><a href="#list:dice_rolls:dpbottomup-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> d<span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:dice_rolls:dpbottomup-18"><a href="#list:dice_rolls:dpbottomup-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:dice_rolls:dpbottomup-19"><a href="#list:dice_rolls:dpbottomup-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// target value</span></span>
<span id="list:dice_rolls:dpbottomup-20"><a href="#list:dice_rolls:dpbottomup-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> t <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> t <span class="op">&lt;=</span> target<span class="op">;</span> t<span class="op">++)</span></span>
<span id="list:dice_rolls:dpbottomup-21"><a href="#list:dice_rolls:dpbottomup-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:dice_rolls:dpbottomup-22"><a href="#list:dice_rolls:dpbottomup-22" aria-hidden="true" tabindex="-1"></a>      <span class="co">// face value for the ith die</span></span>
<span id="list:dice_rolls:dpbottomup-23"><a href="#list:dice_rolls:dpbottomup-23" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> f <span class="op">&amp;&amp;</span> j <span class="op">&lt;=</span> t<span class="op">;</span> j<span class="op">++)</span></span>
<span id="list:dice_rolls:dpbottomup-24"><a href="#list:dice_rolls:dpbottomup-24" aria-hidden="true" tabindex="-1"></a>      <span class="op">{</span></span>
<span id="list:dice_rolls:dpbottomup-25"><a href="#list:dice_rolls:dpbottomup-25" aria-hidden="true" tabindex="-1"></a>        DP<span class="op">[</span>i<span class="op">][</span>t<span class="op">]</span> <span class="op">+=</span> DP<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>t <span class="op">-</span> j<span class="op">];</span></span>
<span id="list:dice_rolls:dpbottomup-26"><a href="#list:dice_rolls:dpbottomup-26" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="list:dice_rolls:dpbottomup-27"><a href="#list:dice_rolls:dpbottomup-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:dice_rolls:dpbottomup-28"><a href="#list:dice_rolls:dpbottomup-28" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:dice_rolls:dpbottomup-29"><a href="#list:dice_rolls:dpbottomup-29" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> DP<span class="op">[</span>d<span class="op">][</span>target<span class="op">];</span></span>
<span id="list:dice_rolls:dpbottomup-30"><a href="#list:dice_rolls:dpbottomup-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We use a 2D table (initialized with zeros) with <span class="math inline">\(d+1\)</span> rows and <span class="math inline">\(t+1\)</span> columns where each cell corresponds to the solution of a sub-problem where <span class="math inline">\(d=i\)</span> and <span class="math inline">\(t=j\)</span>. The first loop takes care of filling the table with <em>"known" values</em> for all sub-problems where <span class="math inline">\(d=1\)</span>. If we only have a die with <span class="math inline">\(f\)</span> faces, there is only one way we can achieve the target values <span class="math inline">\(1,2,\ldots, f\)</span> and no way to obtain any higher values. The rest of the code fills the table one row at a time (one dice at a time) by using the values of the previous row.</p>
<p>The time and space complexity of this algorithm are <span class="math inline">\(\Theta(dtf)\)</span> and <span class="math inline">\(\Theta(dt)\)</span>, respectively. However, the space complexity can be lowered easily down to <span class="math inline">\(\Theta(t)\)</span> because, as already mentioned, we only need space for two rows of the DP table: one for the values of the current <span class="math inline">\(d\)</span> and one for the values at <span class="math inline">\(d-1\)</span>.</p>
<h1 id="ch:remove_duplicated_sorted_array_inplace">Remove duplicates in sorted array</h1>
<h2 class="unnumbered" id="introduction-42">Introduction</h2>
<p>Sorting and duplicates are the bread and butter of coding interview questions. There are countless problems that ask you to perform some task, or calculate an answer, where you either are given some kind of sorted input or there are duplicates involved.</p>
<p>In the problem described in this chapter, we are going to investigate how we can remove duplicates from an already sorted collection of elements. This problem is trivially solvable when you can use linear space, but doing it <em>in-place</em>, and by only using constant space, is going to be slightly more challenging.</p>
<h2 id="problem-statement-44">Problem statement</h2>
<div class="exercise">
<p><span id="example:remove_duplicated_sorted_array_inplace:exercice1" label="example:remove_duplicated_sorted_array_inplace:exercice1">[example:remove_duplicated_sorted_array_inplace:exercice1]</span> Write a function that takes a sorted array <span class="math inline">\(I\)</span> as input and returns the number of unique elements <span class="math inline">\(u\)</span> in it. The function should also cause all the unique elements of <span class="math inline">\(I\)</span> to appear in the first <span class="math inline">\(u\)</span> positions.</p>
<div class="example">
<p><span id="example:remove_duplicated_sorted_array_inplace:example1" label="example:remove_duplicated_sorted_array_inplace:example1">[example:remove_duplicated_sorted_array_inplace:example1]</span><br />
Given <span class="math inline">\(I=\{1,1,2,2,3,3,4,5,6,6,6,6,7\}\)</span> the function returns <span class="math inline">\(7\)</span> and <span class="math inline">\(I\)</span> is rearranged such that itself first <span class="math inline">\(7\)</span> elements are <span class="math inline">\(\{1,2,3,4,5,6,7\}\)</span>.</p>
</div>
<div class="example">
<p><span id="example:remove_duplicated_sorted_array_inplace:example2" label="example:remove_duplicated_sorted_array_inplace:example2">[example:remove_duplicated_sorted_array_inplace:example2]</span><br />
Given <span class="math inline">\(I=\{1,2,3,4\}\)</span> the function returns <span class="math inline">\(4\)</span> and <span class="math inline">\(I\)</span> is rearranged such that its first <span class="math inline">\(4\)</span> elements are <span class="math inline">\(\{1,2,3,4\}\)</span>.</p>
</div>
</div>
<h2 id="clarification-questions-37">Clarification Questions</h2>
<div class="QandA">
<p>Is it guaranteed for the input array to contain integers?</p>
<div class="answered">
<p><em>Yes you can assume <span class="math inline">\(I\)</span> is an array of integers, but only if you are free to produce a generic solution that works for any type.</em></p>
</div>
</div>
<h2 id="remove_duplicated_sorted_array_inplace:sec:discussion">Discussion</h2>
<p>This problem behavior is remarkably similar to the function from the STL library: it does not really remove any element from the input collection, instead, it rearranges the elements to divide the initial collection. The official documentation for says that:</p>
<p>As we can see, does not really remove or erase any element from the input collection, but what it does instead is rearranging the elements such that the initial collection is divided into two parts:</p>
<ol>
<li><p>the first (from the left) containing only the unique elements;</p></li>
<li><p>the second where the duplicate elements are moved to (possibly empty).</p></li>
</ol>
<p>This function is often used in real-life applications in pair with <a href="https://en.cppreference.com/w/cpp/container/vector/erase2"></a> to delete the second part of the newly arranged collection when you actually want the duplicates removed.</p>
<p>Listing <a href="#list:remove_duplicated_sorted_array_inplace_stl" data-reference-type="ref" data-reference="list:remove_duplicated_sorted_array_inplace_stl">[list:remove_duplicated_sorted_array_inplace_stl]</a> shows how we can solve this problem with a one-liner solution using and from the STL.</p>
<div class="sourceCode" id="list:remove_duplicated_sorted_array_inplace_stl" data-language="c++" data-caption="One-liner solution using \inline{std::unique}." label="list:remove_duplicated_sorted_array_inplace_stl"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:remove_duplicated_sorted_array_inplace_stl-1"><a href="#list:remove_duplicated_sorted_array_inplace_stl-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_stl-2"><a href="#list:remove_duplicated_sorted_array_inplace_stl-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> remove_duplicates_STL<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> I<span class="op">)</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_stl-3"><a href="#list:remove_duplicated_sorted_array_inplace_stl-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_stl-4"><a href="#list:remove_duplicated_sorted_array_inplace_stl-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">std::</span>distance<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>I<span class="op">),</span> <span class="bu">std::</span>unique<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>I<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>I<span class="op">)));</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_stl-5"><a href="#list:remove_duplicated_sorted_array_inplace_stl-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The code works by first invoking and the entire array, which causes to be split into two parts as described above and returns an iterator to the the first element of the second part. is then used to calculate the number of elements in the first part which is the final answer.</p>
<p>Being able to show you can use the standard library to solve a relatively complex problem is a good thing that every interviewer is going to appreciate. However, as important as making a good first impression is, this is unlikely going to be enough to clear the round just yet: if you use this approach during an actual interview, the interviewer is probably going to ask you to implement and yourself.</p>
<h3 id="linear-space-solution">Linear space solution</h3>
<p>As already mentioned in the introduction, it is quite easy to implement this problem when you can use linear additional space. You can think of building a list <span class="math inline">\(U\)</span> of unique elements of <span class="math inline">\(I\)</span> by:</p>
<ol>
<li><p>insert the first element of <span class="math inline">\(I\)</span>;</p></li>
<li><p>insert at the back of <span class="math inline">\(U\)</span> every element of <span class="math inline">\(I\)</span> that is not equal to the last element of <span class="math inline">\(U\)</span>.</p></li>
</ol>
<p>It is important to note that <span class="math inline">\(U\)</span> does not at any moment contain duplicates. Eventually, at the end of this process, <span class="math inline">\(U\)</span> contains an ordered list of all the unique elements in <span class="math inline">\(I\)</span>. All we have to do is copy <span class="math inline">\(U\)</span> into the first <span class="math inline">\(|U|\)</span> positions of <span class="math inline">\(|I|\)</span> and return <span class="math inline">\(|U|\)</span>. The complexity of this approach is linear in time and space, as in the worst-case scenario (when <span class="math inline">\(I\)</span> does not contain duplicates) we move the entire array <span class="math inline">\(I\)</span> into <span class="math inline">\(U\)</span>, and we then immediately copy <span class="math inline">\(U\)</span> back into <span class="math inline">\(I\)</span>. An implementation of this approach is shown below in Listing <a href="#list:remove_duplicated_sorted_array_inplace_linearspace" data-reference-type="ref" data-reference="list:remove_duplicated_sorted_array_inplace_linearspace">[list:remove_duplicated_sorted_array_inplace_linearspace]</a>.</p>
<div class="sourceCode" id="list:remove_duplicated_sorted_array_inplace_linearspace" data-language="c++" data-caption="Linear time and space solution using \inline{std::std::unordered_set} to remember what elements have been already encountered." label="list:remove_duplicated_sorted_array_inplace_linearspace"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:remove_duplicated_sorted_array_inplace_linearspace-1"><a href="#list:remove_duplicated_sorted_array_inplace_linearspace-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_linearspace-2"><a href="#list:remove_duplicated_sorted_array_inplace_linearspace-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> remove_duplicates_linear_space<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> I<span class="op">)</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_linearspace-3"><a href="#list:remove_duplicated_sorted_array_inplace_linearspace-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_linearspace-4"><a href="#list:remove_duplicated_sorted_array_inplace_linearspace-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> num_elements <span class="op">=</span> I<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_linearspace-5"><a href="#list:remove_duplicated_sorted_array_inplace_linearspace-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>num_elements <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_linearspace-6"><a href="#list:remove_duplicated_sorted_array_inplace_linearspace-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> num_elements<span class="op">;</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_linearspace-7"><a href="#list:remove_duplicated_sorted_array_inplace_linearspace-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:remove_duplicated_sorted_array_inplace_linearspace-8"><a href="#list:remove_duplicated_sorted_array_inplace_linearspace-8" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>unordered_set<span class="op">&lt;</span>T<span class="op">&gt;</span> inserted<span class="op">;</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_linearspace-9"><a href="#list:remove_duplicated_sorted_array_inplace_linearspace-9" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> I_uniques<span class="op">;</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_linearspace-10"><a href="#list:remove_duplicated_sorted_array_inplace_linearspace-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> x <span class="op">:</span> I<span class="op">)</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_linearspace-11"><a href="#list:remove_duplicated_sorted_array_inplace_linearspace-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_linearspace-12"><a href="#list:remove_duplicated_sorted_array_inplace_linearspace-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>inserted<span class="op">.</span>contains<span class="op">(</span>x<span class="op">))</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_linearspace-13"><a href="#list:remove_duplicated_sorted_array_inplace_linearspace-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_linearspace-14"><a href="#list:remove_duplicated_sorted_array_inplace_linearspace-14" aria-hidden="true" tabindex="-1"></a>      inserted<span class="op">.</span>insert<span class="op">(</span>x<span class="op">);</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_linearspace-15"><a href="#list:remove_duplicated_sorted_array_inplace_linearspace-15" aria-hidden="true" tabindex="-1"></a>      I_uniques<span class="op">.</span>push_back<span class="op">(</span>x<span class="op">);</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_linearspace-16"><a href="#list:remove_duplicated_sorted_array_inplace_linearspace-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_linearspace-17"><a href="#list:remove_duplicated_sorted_array_inplace_linearspace-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_linearspace-18"><a href="#list:remove_duplicated_sorted_array_inplace_linearspace-18" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>copy<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>I_uniques<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>I_uniques<span class="op">),</span> <span class="bu">std::</span>begin<span class="op">(</span>I<span class="op">));</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_linearspace-19"><a href="#list:remove_duplicated_sorted_array_inplace_linearspace-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> I_uniques<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_linearspace-20"><a href="#list:remove_duplicated_sorted_array_inplace_linearspace-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="sec:remove_duplicated_sorted_array_inplace:constant_space">Constant Space</h3>
<p>Although we cannot do much better than spending linear time, we can improve on the space used side to the point that we only need a constant amount of it. The key idea is that, because the array is sorted, equal elements will be one next to the other, therefore forming clusters of the same value. Eventually, <span class="math inline">\(I\)</span> has to be logically divided into two subarrays where we only care about the content of the first-part containing unique elements (no duplicates), as there are no constraints on the content of the second half.</p>
<p>The algorithm proposed in this section uses a two pointer technique with which we build the first half of <span class="math inline">\(I\)</span>, one element at a time, by looping through the elements of <span class="math inline">\(I\)</span> and keeping track of two pointers:</p>
<ul>
<li><p><span class="math inline">\(x\)</span>: a pointer to the last element of the first part of <span class="math inline">\(I\)</span>;</p></li>
<li><p><span class="math inline">\(y\)</span>: a pointer to the next element to be processed.</p></li>
</ul>
<p>When the element pointed by <span class="math inline">\(y\)</span> is different from the element pointed by <span class="math inline">\(x\)</span>, we know that we can add <span class="math inline">\(y\)</span> to the first part of <span class="math inline">\(I\)</span>. We can do that by copying <span class="math inline">\(I_y\)</span> into <span class="math inline">\(I_{x+1}\)</span> and incrementing both <span class="math inline">\(y\)</span> and <span class="math inline">\(x\)</span> so that the next comparison would be among the last inserted element and a brand new unprocessed one. If they are equal, however, the first part of <span class="math inline">\(I\)</span> is not going to grow and we can safely ignore the element pointed by <span class="math inline">\(y\)</span> as we already have an instance of it (the value pointed by <span class="math inline">\(X\)</span>) in the first half of <span class="math inline">\(I\)</span> already.</p>
<p>When all the elements of <span class="math inline">\(I\)</span> are processed (<span class="math inline">\(y \geq |I|\)</span>), then the algorithm can be stopped. At this point we know that <span class="math inline">\(x\)</span> is marking the end of the part of <span class="math inline">\(I\)</span> containing only unique elements. All we have to do is calculate and return its length.</p>
<p>Listing <a href="#list:remove_duplicated_sorted_array_inplace" data-reference-type="ref" data-reference="list:remove_duplicated_sorted_array_inplace">[list:remove_duplicated_sorted_array_inplace]</a> shows an implementation of such idea.</p>
<div class="sourceCode" id="list:remove_duplicated_sorted_array_inplace" data-language="c++" data-caption="Linear time constant space solution." label="list:remove_duplicated_sorted_array_inplace"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:remove_duplicated_sorted_array_inplace-1"><a href="#list:remove_duplicated_sorted_array_inplace-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:remove_duplicated_sorted_array_inplace-2"><a href="#list:remove_duplicated_sorted_array_inplace-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> remove_duplicates_constant_space<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> I<span class="op">)</span></span>
<span id="list:remove_duplicated_sorted_array_inplace-3"><a href="#list:remove_duplicated_sorted_array_inplace-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:remove_duplicated_sorted_array_inplace-4"><a href="#list:remove_duplicated_sorted_array_inplace-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> num_elements <span class="op">=</span> I<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:remove_duplicated_sorted_array_inplace-5"><a href="#list:remove_duplicated_sorted_array_inplace-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>num_elements <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="list:remove_duplicated_sorted_array_inplace-6"><a href="#list:remove_duplicated_sorted_array_inplace-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> num_elements<span class="op">;</span></span>
<span id="list:remove_duplicated_sorted_array_inplace-7"><a href="#list:remove_duplicated_sorted_array_inplace-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:remove_duplicated_sorted_array_inplace-8"><a href="#list:remove_duplicated_sorted_array_inplace-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> y <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:remove_duplicated_sorted_array_inplace-9"><a href="#list:remove_duplicated_sorted_array_inplace-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>y <span class="op">&lt;</span> num_elements<span class="op">)</span></span>
<span id="list:remove_duplicated_sorted_array_inplace-10"><a href="#list:remove_duplicated_sorted_array_inplace-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:remove_duplicated_sorted_array_inplace-11"><a href="#list:remove_duplicated_sorted_array_inplace-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>I<span class="op">[</span>x<span class="op">]</span> <span class="op">!=</span> I<span class="op">[</span>y<span class="op">])</span></span>
<span id="list:remove_duplicated_sorted_array_inplace-12"><a href="#list:remove_duplicated_sorted_array_inplace-12" aria-hidden="true" tabindex="-1"></a>      I<span class="op">[++</span>x<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>I<span class="op">[</span>y<span class="op">]);</span></span>
<span id="list:remove_duplicated_sorted_array_inplace-13"><a href="#list:remove_duplicated_sorted_array_inplace-13" aria-hidden="true" tabindex="-1"></a>    y<span class="op">++;</span></span>
<span id="list:remove_duplicated_sorted_array_inplace-14"><a href="#list:remove_duplicated_sorted_array_inplace-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:remove_duplicated_sorted_array_inplace-15"><a href="#list:remove_duplicated_sorted_array_inplace-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> x <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:remove_duplicated_sorted_array_inplace-16"><a href="#list:remove_duplicated_sorted_array_inplace-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice that with <span class="math inline">\(x\)</span> we have two important invariants:</p>
<ol>
<li><p><span class="math inline">\(x\)</span> there are no duplicates among all the elements to the left of (including) <span class="math inline">\(x\)</span>;</p></li>
<li><p><span class="math inline">\(y\)</span> is always larger than <span class="math inline">\(x\)</span>.</p></li>
</ol>
<p>These invariants are true prior to entering the loop and they are true at the end of each and every iteration. It is also essential to notice that the cells strictly between <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> can be overwritten as they must contain duplicates.</p>
<p>As already stated at the beginning of this section, the time complexity is linear but we now, as opposed to the other solution discussed so far, use only constant space.</p>
<p>Moreover, because we do not have to care about the state of the elements of <span class="math inline">\(I\)</span> after <span class="math inline">\(x\)</span>, we can use <a href="https://en.cppreference.com/w/cpp/utility/move"></a><a href="#fn30" class="footnote-ref" id="fnref30" role="doc-noteref"><sup>30</sup></a> to (potentially) avoid expensive copies.</p>
<p>Figure <a href="#fig:remove_duplicated_sorted_array_inplace:example1_process" data-reference-type="ref" data-reference="fig:remove_duplicated_sorted_array_inplace:example1_process">[fig:remove_duplicated_sorted_array_inplace:example1_process]</a> depicts the execution of this algorithm on the input of Example <a href="#example:remove_duplicated_sorted_array_inplace:example1" data-reference-type="ref" data-reference="example:remove_duplicated_sorted_array_inplace:example1">[example:remove_duplicated_sorted_array_inplace:example1]</a>, where the shaded part (the left side) of the array contains all the unique elements found so far (among all the elements to the left of <span class="math inline">\(y\)</span>): <span class="math inline">\(x\)</span> is a pointer to the last element of this sequence and <span class="math inline">\(y\)</span> is a pointer to the element currently processed.</p>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/remove_duplicated_sorted_array_inplace/images/example1_1.jpg" id="fig:remove_duplicated_sorted_array_inplace:example1_1" alt="I_x = I_y. y moved forward." /><figcaption aria-hidden="true"><span class="math inline">\(I_x = I_y\)</span>. <span class="math inline">\(y\)</span> moved forward.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/remove_duplicated_sorted_array_inplace/images/example1_2.jpg" id="fig:remove_duplicated_sorted_array_inplace:example1_2" alt="1 = I_x \neq I_y = 2. I_y copied into I_{x+1}. y and x are moved forward." /><figcaption aria-hidden="true"><span class="math inline">\(1 = I_x \neq I_y = 2\)</span>. <span class="math inline">\(I_y\)</span> copied into <span class="math inline">\(I_{x+1}\)</span>. <span class="math inline">\(y\)</span> and <span class="math inline">\(x\)</span> are moved forward.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/remove_duplicated_sorted_array_inplace/images/example1_3.jpg" id="fig:remove_duplicated_sorted_array_inplace:example1_3" alt="I_x = I_y. y only moved forward." /><figcaption aria-hidden="true"><span class="math inline">\(I_x = I_y\)</span>. <span class="math inline">\(y\)</span> only moved forward.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/remove_duplicated_sorted_array_inplace/images/example1_4.jpg" id="fig:remove_duplicated_sorted_array_inplace:example1_4" alt="2 = I_x \neq I_y = 3. I_y copied into I_{x+1}. y and x are moved forward." /><figcaption aria-hidden="true"><span class="math inline">\(2 = I_x \neq I_y = 3\)</span>. <span class="math inline">\(I_y\)</span> copied into <span class="math inline">\(I_{x+1}\)</span>. <span class="math inline">\(y\)</span> and <span class="math inline">\(x\)</span> are moved forward.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/remove_duplicated_sorted_array_inplace/images/example1_5.jpg" id="fig:remove_duplicated_sorted_array_inplace:example1_5" alt="I_x = I_y. y moved forward." /><figcaption aria-hidden="true"><span class="math inline">\(I_x = I_y\)</span>. <span class="math inline">\(y\)</span> moved forward.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/remove_duplicated_sorted_array_inplace/images/example1_7.jpg" id="fig:remove_duplicated_sorted_array_inplace:example1_6" alt="3 = I_x \neq I_y = 4. I_y copied into I_{x+1}. y and x are moved forward." /><figcaption aria-hidden="true"><span class="math inline">\(3 = I_x \neq I_y = 4\)</span>. <span class="math inline">\(I_y\)</span> copied into <span class="math inline">\(I_{x+1}\)</span>. <span class="math inline">\(y\)</span> and <span class="math inline">\(x\)</span> are moved forward.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/remove_duplicated_sorted_array_inplace/images/example1_8.jpg" id="fig:remove_duplicated_sorted_array_inplace:example1_6" alt="4 = I_x \neq I_y = 5. I_y copied into I_{x+1}. y and x are moved forward." /><figcaption aria-hidden="true"><span class="math inline">\(4 = I_x \neq I_y = 5\)</span>. <span class="math inline">\(I_y\)</span> copied into <span class="math inline">\(I_{x+1}\)</span>. <span class="math inline">\(y\)</span> and <span class="math inline">\(x\)</span> are moved forward.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/remove_duplicated_sorted_array_inplace/images/example1_10.jpg" id="fig:remove_duplicated_sorted_array_inplace:example1_6" alt="5 = I_x \neq I_y = 6. I_y copied into I_{x+1}. y and x are moved forward." /><figcaption aria-hidden="true"><span class="math inline">\(5 = I_x \neq I_y = 6\)</span>. <span class="math inline">\(I_y\)</span> copied into <span class="math inline">\(I_{x+1}\)</span>. <span class="math inline">\(y\)</span> and <span class="math inline">\(x\)</span> are moved forward.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/remove_duplicated_sorted_array_inplace/images/example1_11.jpg" id="fig:remove_duplicated_sorted_array_inplace:example1_6" alt="I_x = I_y. y moved forward." /><figcaption aria-hidden="true"><span class="math inline">\(I_x = I_y\)</span>. <span class="math inline">\(y\)</span> moved forward.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/remove_duplicated_sorted_array_inplace/images/example1_12.jpg" id="fig:remove_duplicated_sorted_array_inplace:example1_6" alt="I_x = I_y. y moved forward." /><figcaption aria-hidden="true"><span class="math inline">\(I_x = I_y\)</span>. <span class="math inline">\(y\)</span> moved forward.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/remove_duplicated_sorted_array_inplace/images/example1_13.jpg" id="fig:remove_duplicated_sorted_array_inplace:example1_6" alt="I_x = I_y. y moved forward." /><figcaption aria-hidden="true"><span class="math inline">\(I_x = I_y\)</span>. <span class="math inline">\(y\)</span> moved forward.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/remove_duplicated_sorted_array_inplace/images/example1_14.jpg" id="fig:remove_duplicated_sorted_array_inplace:example1_6" alt="6 = I_x \neq I_y = 7. I_y copied into I_{x+1}. y and x are moved forward." /><figcaption aria-hidden="true"><span class="math inline">\(6 = I_x \neq I_y = 7\)</span>. <span class="math inline">\(I_y\)</span> copied into <span class="math inline">\(I_{x+1}\)</span>. <span class="math inline">\(y\)</span> and <span class="math inline">\(x\)</span> are moved forward.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/remove_duplicated_sorted_array_inplace/images/example1_15.jpg" id="fig:remove_duplicated_sorted_array_inplace:example1_6" alt="y is outside the range of valid elements of I. The algorithm stops." /><figcaption aria-hidden="true"><span class="math inline">\(y\)</span> is outside the range of valid elements of <span class="math inline">\(I\)</span>. The algorithm stops.</figcaption>
</figure>
<h2 id="common-variations-3">Common Variations</h2>
<h3 id="max-2-duplicates-allowed">Max <span class="math inline">\(2\)</span> duplicates allowed</h3>
<p>In this section, we will have a look at a common variation of the main problem of this lesson, which differs from it on the fact that each element can now appear at <strong>most twice</strong> in the final rearrangement of <span class="math inline">\(I\)</span>.</p>
<div class="exercise">
<p>Write a function that given a sorted array <span class="math inline">\(I\)</span> removes all the duplicates in such a way an element appears <strong>at most twice</strong> and with all the valid elements being located at the beginning of <span class="math inline">\(I\)</span> itself. The function returns the number of valid elements in <span class="math inline">\(I\)</span>.</p>
<p><span id="example:remove_duplicated_sorted_array_inplace:exercice2" label="example:remove_duplicated_sorted_array_inplace:exercice2">[example:remove_duplicated_sorted_array_inplace:exercice2]</span></p>
<div class="example">
<p><span id="example:remove_duplicated_sorted_array_inplace_variation1:example1" label="example:remove_duplicated_sorted_array_inplace_variation1:example1">[example:remove_duplicated_sorted_array_inplace_variation1:example1]</span><br />
Given <span class="math inline">\(I=\{1,1,2,2,3,3,4,5,6,6,6,6,7\}\)</span> the function returns <span class="math inline">\(11\)</span> and <span class="math inline">\(I\)</span> is rearranged such that itself first <span class="math inline">\(11\)</span> elements are <span class="math inline">\(\{1,1,2,2,3,3,4,5,6,6,7\}\)</span>.</p>
</div>
<div class="example">
<p><span id="example:remove_duplicated_sorted_array_inplace_variation1:example2" label="example:remove_duplicated_sorted_array_inplace_variation1:example2">[example:remove_duplicated_sorted_array_inplace_variation1:example2]</span><br />
Given <span class="math inline">\(I=\{1,2,3,4\}\)</span> the function returns <span class="math inline">\(4\)</span> and <span class="math inline">\(I\)</span> is rearranged such that its first <span class="math inline">\(4\)</span> elements are <span class="math inline">\(\{1,2,3,4\}\)</span>.</p>
</div>
</div>
<h3 id="discussion-6">Discussion</h3>
<p>This variant can be solved with minimal changes to the solution presented for the main problem. We can modify the code shown in the Section <a href="#sec:remove_duplicated_sorted_array_inplace:constant_space" data-reference-type="ref" data-reference="sec:remove_duplicated_sorted_array_inplace:constant_space">45.3.2</a> so that we keep track of the number of repetitions we have already inserted for a given element. This can be implemented as shown in Listing <a href="#list:remove_duplicated_sorted_array_inplace_max_two" data-reference-type="ref" data-reference="list:remove_duplicated_sorted_array_inplace_max_two">[list:remove_duplicated_sorted_array_inplace_max_two]</a>.</p>
<div class="sourceCode" id="list:remove_duplicated_sorted_array_inplace_max_two" data-language="c++" data-caption="Linear time constant space solution to the variation where at most two duplicates are allowed." label="list:remove_duplicated_sorted_array_inplace_max_two"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:remove_duplicated_sorted_array_inplace_max_two-1"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-2"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@input</span><span class="co"> A : Integer array</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-3"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@input</span><span class="co"> n1 : Integer array&#39;s ( A ) length</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-4"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-4" aria-hidden="true" tabindex="-1"></a><span class="co"> *</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-5"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Output</span><span class="co"> Integer</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-6"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-6" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-7"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> removeDuplicates<span class="op">(</span><span class="dt">int</span><span class="op">*</span> A<span class="op">,</span> <span class="dt">int</span> n1<span class="op">)</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-8"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-9"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>n1 <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-10"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> n1<span class="op">;</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-11"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-12"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> last_inserted      <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-13"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> currently_examined <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-14"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> consecutive        <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-15"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>currently_examined <span class="op">&lt;</span> n1<span class="op">)</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-16"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-17"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>A<span class="op">[</span>last_inserted<span class="op">]</span> <span class="op">==</span> A<span class="op">[</span>currently_examined<span class="op">]</span> <span class="op">&amp;&amp;</span> consecutive <span class="op">==</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-18"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-19"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-19" aria-hidden="true" tabindex="-1"></a>      A<span class="op">[++</span>last_inserted<span class="op">]</span> <span class="op">=</span> A<span class="op">[</span>currently_examined<span class="op">];</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-20"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-20" aria-hidden="true" tabindex="-1"></a>      consecutive        <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-21"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-22"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>A<span class="op">[</span>last_inserted<span class="op">]</span> <span class="op">!=</span> A<span class="op">[</span>currently_examined<span class="op">])</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-23"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-24"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-24" aria-hidden="true" tabindex="-1"></a>      A<span class="op">[++</span>last_inserted<span class="op">]</span> <span class="op">=</span> A<span class="op">[</span>currently_examined<span class="op">];</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-25"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-25" aria-hidden="true" tabindex="-1"></a>      consecutive        <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-26"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-27"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-27" aria-hidden="true" tabindex="-1"></a>    currently_examined<span class="op">++;</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-28"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-28" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-29"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-29" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> last_inserted <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:remove_duplicated_sorted_array_inplace_max_two-30"><a href="#list:remove_duplicated_sorted_array_inplace_max_two-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice that the meaning of the variables <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> did not change, and that here we use the variable to keep track of the number of times the element pointed by appears in the array . If the element pointed by is equal to the element pointed by (we have a duplicate), then we decide whether to insert it or not based on the value of the variable :</p>
<ul>
<li><p>If it appears already more than <span class="math inline">\(1\)</span> times we discard it;</p></li>
<li><p>otherwise, we copy it to the cell at index <span class="math inline">\(x+1\)</span> and increment .</p></li>
</ul>
<p>The time and space complexity of this approach is <span class="math inline">\(O(|I|)\)</span> and <span class="math inline">\(O(1)\)</span>, respectively.</p>
<h3 id="max-k-duplicates-allowed">Max <span class="math inline">\(k\)</span> duplicates allowed</h3>
<p>This variation is also a quite common, and it is basically a generalization of problems above where this time each element can appear <span class="math inline">\(k\)</span> times. Notice that, when <span class="math inline">\(k= 1\)</span> and <span class="math inline">\(k=2\)</span> this problem is equivalent to the Problems <a href="#example:remove_duplicated_sorted_array_inplace:exercice1" data-reference-type="ref" data-reference="example:remove_duplicated_sorted_array_inplace:exercice1">[example:remove_duplicated_sorted_array_inplace:exercice1]</a> and <a href="#example:remove_duplicated_sorted_array_inplace:exercice2" data-reference-type="ref" data-reference="example:remove_duplicated_sorted_array_inplace:exercice2">[example:remove_duplicated_sorted_array_inplace:exercice2]</a>, respectively. The solution for this variation is not discussed here as it can be trivially derived from the solution to the Problem <a href="#example:remove_duplicated_sorted_array_inplace:exercice1" data-reference-type="ref" data-reference="example:remove_duplicated_sorted_array_inplace:exercice1">[example:remove_duplicated_sorted_array_inplace:exercice1]</a>.</p>
<div class="exercise">
<p>Write a function that given a sorted array <span class="math inline">\(I\)</span> removes all the duplicates in such a way an element appears at most twice and with all the valid elements being located at the beginning of the <span class="math inline">\(I\)</span> itself. The function returns the number of valid elements in <span class="math inline">\(I\)</span>.</p>
<p><span id="example:remove_duplicated_sorted_array_inplace_variation:exercice3" label="example:remove_duplicated_sorted_array_inplace_variation:exercice3">[example:remove_duplicated_sorted_array_inplace_variation:exercice3]</span></p>
<div class="example">
<p><span id="example:remove_duplicated_sorted_array_inplace_variation2:example1" label="example:remove_duplicated_sorted_array_inplace_variation2:example1">[example:remove_duplicated_sorted_array_inplace_variation2:example1]</span><br />
Given <span class="math inline">\(I=\{1,1,2,2,3,3,4,5,6,6,6,6,7\}\)</span> and <span class="math inline">\(k=3\)</span> the function returns <span class="math inline">\(12\)</span> and <span class="math inline">\(I\)</span> is rearranged such that itself first <span class="math inline">\(1\)</span> elements are <span class="math inline">\(\{1,1,2,2,3,3,4,5,6,6,6,7\}\)</span>. Notice the extra <span class="math inline">\(6\)</span> w.r.t. the Example <a href="#example:remove_duplicated_sorted_array_inplace_variation1:example1" data-reference-type="ref" data-reference="example:remove_duplicated_sorted_array_inplace_variation1:example1">[example:remove_duplicated_sorted_array_inplace_variation1:example1]</a>.</p>
</div>
<div class="example">
<p><span id="example:remove_duplicated_sorted_array_inplace_variation2:example2" label="example:remove_duplicated_sorted_array_inplace_variation2:example2">[example:remove_duplicated_sorted_array_inplace_variation2:example2]</span><br />
Given <span class="math inline">\(I=\{1,1,1,1,1,1,1,2,2,3,3,3,4,4\}\)</span> and <span class="math inline">\(k=5\)</span> the function returns <span class="math inline">\(13\)</span> and <span class="math inline">\(I\)</span> is rearranged such that its first <span class="math inline">\(13\)</span> elements are <span class="math inline">\(\{1,1,1,1,1,2,2,3,3,3,3,4,4\}\)</span>.</p>
</div>
</div>
<h1 id="ch:remove_all_occurrences_unsorted_array_inplace">Remove all occurrences - unsorted array</h1>
<h2 class="unnumbered" id="introduction-43">Introduction</h2>
<p>The problem described in this chapter asks you to implement a common operations: removes all elements satisfying specific criterium from a collection. This problem has lot of similarities with the one described in Chapter <a href="#ch:remove_duplicated_sorted_array_inplace" data-reference-type="ref" data-reference="ch:remove_duplicated_sorted_array_inplace">45</a> and as a consequence they share the same general solution approach.</p>
<p>There are many versions and variations of this problem with the most common being the one where the collection is a simple array or a vector of integers and you are asked to remove all the elements equal to a given integer. However, here we will discuss a more general version of this problem where the collection is of a generic type and the criterium is given in the form of a unary function returning a boolean<a href="#fn31" class="footnote-ref" id="fnref31" role="doc-noteref"><sup>31</sup></a>.</p>
<p>If you are asked to solve this actual particular problem’s version during an interview, you should be able to easily specialise what is discussed here on the fly.</p>
<h2 id="problem-statement-45">Problem statement</h2>
<div class="exercise">
<p><span id="example:remove_all_occurrences_unsorted_array_inplace:exercice1" label="example:remove_all_occurrences_unsorted_array_inplace:exercice1">[example:remove_all_occurrences_unsorted_array_inplace:exercice1]</span> Write a function that given a collection <span class="math inline">\(I\)</span> of elements of type and a predicate function <span class="math inline">\(p\)</span> with signature , rearranges <span class="math inline">\(I\)</span> in such a way that all the <span class="math inline">\(0 \leq k
 \leq |I|\)</span> elements satisfying <span class="math inline">\(p\)</span> in <span class="math inline">\(I\)</span> are moved to its front. The function should returns <span class="math inline">\(k\)</span>.</p>
<p>Moreover, the relative order of the elements satisfying <span class="math inline">\(p\)</span> should be preserved: If both elements at indices <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> satisfy the predicate <span class="math inline">\(p\)</span> and <span class="math inline">\(I_n\)</span> comes before <span class="math inline">\(I_m\)</span> then when the function returns, their relative order is unchanged albeit they both might be moved to new locations.</p>
<div class="example">
<p><span id="example:remove_all_occurrences_unsorted_array_inplace:example1" label="example:remove_all_occurrences_unsorted_array_inplace:example1">[example:remove_all_occurrences_unsorted_array_inplace:example1]</span><br />
Given <span class="math inline">\(I = \{{4, 1, 1, 2, 1, 3\}}\)</span> and a function <span class="math inline">\(p\)</span> returning true if its input argument is an even number, false otherwise, the function returns <span class="math inline">\(4\)</span>. The first <span class="math inline">\(4\)</span> elements of <span class="math inline">\(I\)</span> are <span class="math inline">\(\{1,1,1,3\}\)</span>.</p>
</div>
<div class="example">
<p><span id="example:remove_all_occurrences_unsorted_array_inplace:example2" label="example:remove_all_occurrences_unsorted_array_inplace:example2">[example:remove_all_occurrences_unsorted_array_inplace:example2]</span><br />
Given <span class="math inline">\(I = \{4, 1, 1, 2, 1, 3\}\)</span> and a function <span class="math inline">\(p\)</span> returning true if its input argument is odd, the function returns <span class="math inline">\(2\)</span>. At this point, the first <span class="math inline">\(2\)</span> elements of <span class="math inline">\(I\)</span> are <span class="math inline">\(\{4,2\}\)</span>.</p>
</div>
</div>
<h2 id="clarification-questions-38">Clarification Questions</h2>
<div class="QandA">
<p>What should be the content of <span class="math inline">\(I\)</span> from index <span class="math inline">\(k+1\)</span> and after?</p>
<div class="answered">
<p><em>There are no constraints on the content of those cells of <span class="math inline">\(I\)</span>.</em></p>
</div>
</div>
<h2 id="remove_all_occurrences_unsorted_array_inplace:sec:discussion">Discussion</h2>
<p>This problem could be restated as: <em>Implement the <a href="#fn32" class="footnote-ref" id="fnref32" role="doc-noteref"><sup>32</sup></a></em> function from the C++ STL. So I would not be really surprised if during an interview someone would come-up with a one-liner as the one shown in Listing <a href="#list:remove_all_occurrences_unsorted_array_inplace:STL" data-reference-type="ref" data-reference="list:remove_all_occurrences_unsorted_array_inplace:STL">[list:remove_all_occurrences_unsorted_array_inplace:STL]</a> <a href="#fn33" class="footnote-ref" id="fnref33" role="doc-noteref"><sup>33</sup></a>.</p>
<div class="sourceCode" id="list:remove_all_occurrences_unsorted_array_inplace:STL" data-language="c++" data-caption="One-liner solution using the STL functions \inline{distance} and \inline{remove_if}" label="list:remove_all_occurrences_unsorted_array_inplace:STL"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:remove_all_occurrences_unsorted_array_inplace:STL-1"><a href="#list:remove_all_occurrences_unsorted_array_inplace:STL-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:STL-2"><a href="#list:remove_all_occurrences_unsorted_array_inplace:STL-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> remove_elements_unsorted_array_remove_STL<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> A<span class="op">,</span> <span class="kw">auto</span> predicate<span class="op">)</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:STL-3"><a href="#list:remove_all_occurrences_unsorted_array_inplace:STL-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:STL-4"><a href="#list:remove_all_occurrences_unsorted_array_inplace:STL-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">std::</span>distance<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>A<span class="op">),</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:STL-5"><a href="#list:remove_all_occurrences_unsorted_array_inplace:STL-5" aria-hidden="true" tabindex="-1"></a>                       <span class="bu">std::</span>remove_if<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>A<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>A<span class="op">),</span> predicate<span class="op">));</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:STL-6"><a href="#list:remove_all_occurrences_unsorted_array_inplace:STL-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This algorithm has a linear time and constant space complexity, which is pretty much as good as it gets. You cannot do much better than this considering you must at least read all the elements in the input array. Rest assured that, however, if you present this solution to the interviewer, you should expect him to ask you to implement the logic behind itself. This is pretty much what this problem is all about.</p>
<h3 id="remove_all_occurrences_unsorted_array_inplace:sec:bruteforce">Linear time and linear space solution</h3>
<p>There is a straightforward way of solving this problem that has also the added benefit of occupying only a couple of lines and of being super clear and simple. The idea is that we can use an additional linear amount of space to temporarily store the valid (dissatisfying the predicate ) elements, and in a subsequent phase move them into the front of . Listing <a href="#list:remove_all_occurrences_unsorted_array_inplace:copy" data-reference-type="ref" data-reference="list:remove_all_occurrences_unsorted_array_inplace:copy">[list:remove_all_occurrences_unsorted_array_inplace:copy]</a> shows a possible implementation of this idea.</p>
<div class="sourceCode" id="list:remove_all_occurrences_unsorted_array_inplace:copy" data-language="c++" data-caption="Linear space solution using the \inline{std::copy} family of functions from the STL." label="list:remove_all_occurrences_unsorted_array_inplace:copy"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:remove_all_occurrences_unsorted_array_inplace:copy-1"><a href="#list:remove_all_occurrences_unsorted_array_inplace:copy-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:copy-2"><a href="#list:remove_all_occurrences_unsorted_array_inplace:copy-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> remove_elements_unsorted_array_linear_space<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> A<span class="op">,</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:copy-3"><a href="#list:remove_all_occurrences_unsorted_array_inplace:copy-3" aria-hidden="true" tabindex="-1"></a>                                                <span class="kw">auto</span> predicate<span class="op">)</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:copy-4"><a href="#list:remove_all_occurrences_unsorted_array_inplace:copy-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:copy-5"><a href="#list:remove_all_occurrences_unsorted_array_inplace:copy-5" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> temp<span class="op">;</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:copy-6"><a href="#list:remove_all_occurrences_unsorted_array_inplace:copy-6" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>copy_if<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>A<span class="op">),</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:copy-7"><a href="#list:remove_all_occurrences_unsorted_array_inplace:copy-7" aria-hidden="true" tabindex="-1"></a>               <span class="bu">std::</span>end<span class="op">(</span>A<span class="op">),</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:copy-8"><a href="#list:remove_all_occurrences_unsorted_array_inplace:copy-8" aria-hidden="true" tabindex="-1"></a>               <span class="bu">std::</span>back_inserter<span class="op">(</span>temp<span class="op">),</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:copy-9"><a href="#list:remove_all_occurrences_unsorted_array_inplace:copy-9" aria-hidden="true" tabindex="-1"></a>               <span class="bu">std::</span>not_fn<span class="op">(</span>predicate<span class="op">));</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:copy-10"><a href="#list:remove_all_occurrences_unsorted_array_inplace:copy-10" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>copy<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>temp<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>temp<span class="op">),</span> <span class="bu">std::</span>begin<span class="op">(</span>A<span class="op">));</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:copy-11"><a href="#list:remove_all_occurrences_unsorted_array_inplace:copy-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> temp<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:copy-12"><a href="#list:remove_all_occurrences_unsorted_array_inplace:copy-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This solution however, only works correctly for types that can be copied. Beware that the interviewer could well ask you to fix this: in that case, you can loop over and and <a href="https://en.cppreference.com/w/cpp/utility/move"> </a><a href="#fn34" class="footnote-ref" id="fnref34" role="doc-noteref"><sup>34</sup></a> the elements around instead.</p>
<h3 id="remove_all_occurrences_unsorted_array_inplace:sec:constant_space">Linear time and constant space solution</h3>
<p>The idea discussed in Section <a href="#remove_all_occurrences_unsorted_array_inplace:sec:bruteforce" data-reference-type="ref" data-reference="remove_all_occurrences_unsorted_array_inplace:sec:bruteforce">46.3.1</a> can quite easily be modified so that we avoid using linear additional space. We could use the elements of <span class="math inline">\(I\)</span> into <span class="math inline">\(I\)</span> itself, pretty much in the same fashion we already did for the problem discussed in Chapter <a href="#ch:remove_duplicated_sorted_array_inplace" data-reference-type="ref" data-reference="ch:remove_duplicated_sorted_array_inplace">45</a> while discussing the solution <a href="#list:remove_duplicated_sorted_array_inplace" data-reference-type="ref" data-reference="list:remove_duplicated_sorted_array_inplace">[list:remove_duplicated_sorted_array_inplace]</a>.</p>
<p>Here we use exactly the same approach of two pointers <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>:</p>
<ol>
<li><p><span class="math inline">\(x\)</span> keeps track of the new front to <span class="math inline">\(I\)</span>. It points to the end of the portion of <span class="math inline">\(I\)</span> (starting at index <span class="math inline">\(0\)</span> and ending at <span class="math inline">\(x-1\)</span>) containing all the valid elements found so far;</p></li>
<li><p><span class="math inline">\(y\)</span> is a pointer to the next element not yet processed in <span class="math inline">\(I\)</span>.</p></li>
</ol>
<p>Listing <a href="#list:remove_all_occurrences_unsorted_array_inplace:constant_space" data-reference-type="ref" data-reference="list:remove_all_occurrences_unsorted_array_inplace:constant_space">[list:remove_all_occurrences_unsorted_array_inplace:constant_space]</a> implements this idea.</p>
<div class="sourceCode" id="list:remove_all_occurrences_unsorted_array_inplace:constant_space" data-language="c++" data-caption="Constant space solution using a two pointer approach." label="list:remove_all_occurrences_unsorted_array_inplace:constant_space"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:remove_all_occurrences_unsorted_array_inplace:constant_space-1"><a href="#list:remove_all_occurrences_unsorted_array_inplace:constant_space-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> remove_elements_unsorted_array<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> A<span class="op">,</span> <span class="kw">auto</span> predicate<span class="op">)</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:constant_space-2"><a href="#list:remove_all_occurrences_unsorted_array_inplace:constant_space-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:constant_space-3"><a href="#list:remove_all_occurrences_unsorted_array_inplace:constant_space-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> x        <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:constant_space-4"><a href="#list:remove_all_occurrences_unsorted_array_inplace:constant_space-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> size <span class="op">=</span> A<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:constant_space-5"><a href="#list:remove_all_occurrences_unsorted_array_inplace:constant_space-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(!</span>predicate<span class="op">(</span>A<span class="op">[</span>x<span class="op">])</span> <span class="op">&amp;&amp;</span> x <span class="op">&lt;</span> size<span class="op">)</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:constant_space-6"><a href="#list:remove_all_occurrences_unsorted_array_inplace:constant_space-6" aria-hidden="true" tabindex="-1"></a>    x<span class="op">++;</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:constant_space-7"><a href="#list:remove_all_occurrences_unsorted_array_inplace:constant_space-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> y <span class="op">=</span> x <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:constant_space-8"><a href="#list:remove_all_occurrences_unsorted_array_inplace:constant_space-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>y <span class="op">&lt;</span> size<span class="op">)</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:constant_space-9"><a href="#list:remove_all_occurrences_unsorted_array_inplace:constant_space-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:constant_space-10"><a href="#list:remove_all_occurrences_unsorted_array_inplace:constant_space-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>predicate<span class="op">(</span>A<span class="op">[</span>y<span class="op">]))</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:constant_space-11"><a href="#list:remove_all_occurrences_unsorted_array_inplace:constant_space-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:constant_space-12"><a href="#list:remove_all_occurrences_unsorted_array_inplace:constant_space-12" aria-hidden="true" tabindex="-1"></a>      A<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> A<span class="op">[</span>y<span class="op">];</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:constant_space-13"><a href="#list:remove_all_occurrences_unsorted_array_inplace:constant_space-13" aria-hidden="true" tabindex="-1"></a>      x<span class="op">++;</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:constant_space-14"><a href="#list:remove_all_occurrences_unsorted_array_inplace:constant_space-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:constant_space-15"><a href="#list:remove_all_occurrences_unsorted_array_inplace:constant_space-15" aria-hidden="true" tabindex="-1"></a>    y<span class="op">++;</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:constant_space-16"><a href="#list:remove_all_occurrences_unsorted_array_inplace:constant_space-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:constant_space-17"><a href="#list:remove_all_occurrences_unsorted_array_inplace:constant_space-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> x<span class="op">;</span></span>
<span id="list:remove_all_occurrences_unsorted_array_inplace:constant_space-18"><a href="#list:remove_all_occurrences_unsorted_array_inplace:constant_space-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>At the beginning of the execution, the algorithm moves <span class="math inline">\(x\)</span> forward: all the valid elements that are already at the front of <span class="math inline">\(I\)</span> stay untouched where they are, as they are already in the right locations. At this point, <span class="math inline">\(x\)</span> points either to the first invalid element in <span class="math inline">\(I\)</span> or to one element past <span class="math inline">\(I\)</span>. In the second scenario, there is no more work to do. All the elements are valid to begin with, and the second</p>
<p>will not even start. <span class="math inline">\(I\)</span> is left unchanged. In the first scenario, we will use <span class="math inline">\(y\)</span> to scan the remaining element of <span class="math inline">\(I\)</span> past <span class="math inline">\(x\)</span>, and we move each valid element we encounter into the location pointed by <span class="math inline">\(x\)</span>. When this happens <span class="math inline">\(x\)</span> is moved forward as the portion of valid elements grew by one element.</p>
<p>Notice that the invariant <span class="math inline">\(x \leq y\)</span> is always respected as:</p>
<ul>
<li><p>it holds before the beginning of the loop;</p></li>
<li><p><span class="math inline">\(x\)</span> is incremented at the same rate or less compared to <span class="math inline">\(y\)</span>.</p></li>
</ul>
<p>At the end of this process, we are left with <span class="math inline">\(y\)</span> pointing to the one element past <span class="math inline">\(I\)</span> and <span class="math inline">\(x\)</span> pointing to one cell after the last valid element of the newly rearranged <span class="math inline">\(I\)</span>.</p>
<h1 id="ch:max_num_chunks_sorted">Sort the chunks, sort the array.</h1>
<h2 class="unnumbered" id="introduction-44">Introduction</h2>
<p>Sorting is a popular topic in computer science and programming interviews. Its usefulness is beyond dispute and is it not surprising that there are literally countless research papers and algorithms on the topic.</p>
<p>In this problem however we are not going to devise a novel sorting algorithm, instead will investigate how we can sort an entire array by sorting a number of its sub-arrays. The idea is that we would like to know how we can split an array into pieces such that if each of the pieces is sorted individually then the final result would be equivalent to having sorted the entire array, to begin with.</p>
<p>It is necessary to develop a key insight to solve this problem efficiently, and asking the right questions and looking at a certain number of good examples is fundamental for doing so. In the next section we are going to explore how these insights can be gained and then turned into an efficient code.</p>
<h2 id="problem-statement-46">Problem statement</h2>
<div class="exercise">
<p><span id="example:max_num_chunks_sorted:exercice1" label="example:max_num_chunks_sorted:exercice1">[example:max_num_chunks_sorted:exercice1]</span> Write a function that given an array <span class="math inline">\(I\)</span> of integers returns the maximum number of sub-arrays (or chunks) of <span class="math inline">\(I\)</span> such that if each of the sub-array is sorted individually, then <span class="math inline">\(I\)</span> as a whole is sorted.</p>
<div class="example">
<p><span id="example:max_num_chunks_sorted:example1" label="example:max_num_chunks_sorted:example1">[example:max_num_chunks_sorted:example1]</span><br />
Given <span class="math inline">\(I=\{45,88,1,9,90\}\)</span> then the function return <span class="math inline">\(1\)</span>.</p>
</div>
<div class="example">
<p><span id="example:max_num_chunks_sorted:example2" label="example:max_num_chunks_sorted:example2">[example:max_num_chunks_sorted:example2]</span><br />
Given <span class="math inline">\(I=\{4,3,2,1,5,9,10\}\)</span> then the function return <span class="math inline">\(4\)</span>. We can sort the following sub-arrays:</p>
<div class="itemize*">
<p><span class="math inline">\([0,3]\)</span></p>
<p><span class="math inline">\([4,4]\)</span></p>
<p><span class="math inline">\([4,4]\)</span></p>
<p><span class="math inline">\([4,4]\)</span></p>
</div>
</div>
</div>
<h2 id="clarification-questions-39">Clarification Questions</h2>
<div class="QandA">
<p>Can the chunks overlap?</p>
<div class="answered">
<p><em>No. If you choose to sort two sub-arrays of <span class="math inline">\(I\)</span> <span class="math inline">\(s_1=[p,q], p\leq q\)</span> and <span class="math inline">\(s_2=[x,y], x\leq y\)</span> then either <span class="math inline">\(x &gt; q\)</span> or <span class="math inline">\(p&gt;y\)</span>.</em></p>
</div>
</div>
<h2 id="max_num_chunks_sorted:sec:discussion">Discussion</h2>
<h2 id="max_num_chunks_sorted:sec:bruteforce">Brute-force</h2>
<p>Let’s start our discussion by thinking about a brute-force solution to this problem. One possible way of doing it would be to try to divide the array into <span class="math inline">\(|I|\)</span> non-empty and non-overlapping parts (only one way of performing such division), sort them individually and then check if <span class="math inline">\(I\)</span> is sorted. If it is not, then we can try to divide <span class="math inline">\(I\)</span> into <span class="math inline">\(|I|-1\)</span> sub-arrays, and check whether by sorting the resulting individual pieces <span class="math inline">\(I\)</span> turns to be sorted. This line of reasoning can be generalized and a general brute-force approach that works by progressively trying to split <span class="math inline">\(I\)</span> into less and less number of sub-arrays <span class="math inline">\(k &lt;|I|\)</span>. For each of the possible valid divisions of <span class="math inline">\(I\)</span> into <span class="math inline">\(k\)</span> sub-arrays, we can then check whether we can obtain a complete sorting of <span class="math inline">\(I\)</span> by only sorting the individual <span class="math inline">\(k\)</span> sub-arrays. Eventually when <span class="math inline">\(k=1\)</span>, <span class="math inline">\(I\)</span> would be sorted fully as this is equivalent to sorting <span class="math inline">\(I\)</span> entirely.</p>
<p>Clearly this algorithm is complete and correct as all possible valid partitions of <span class="math inline">\(I\)</span> are checked. Its complexity is however exponential in time as given a certain <span class="math inline">\(k\)</span> there are <span class="math inline">\({n \choose k}\)</span> possible way we can divide <span class="math inline">\(I\)</span> into <span class="math inline">\(k\)</span> sub-arrays. Listing <a href="#list:max_num_chunks_sorted:bruteforce" data-reference-type="ref" data-reference="list:max_num_chunks_sorted:bruteforce">[list:max_num_chunks_sorted:bruteforce]</a> shows a C++ implementation of such idea.</p>
<div class="sourceCode" id="list:max_num_chunks_sorted:bruteforce" data-language="c++" data-caption="Bruteforce solution to the problem \textit{Sort the chunks, sort the array}." label="list:max_num_chunks_sorted:bruteforce"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:max_num_chunks_sorted:bruteforce-1"><a href="#list:max_num_chunks_sorted:bruteforce-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_num_chunks_sorted:bruteforce-2"><a href="#list:max_num_chunks_sorted:bruteforce-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sort_subarrays<span class="op">(</span><span class="kw">auto</span> begin<span class="op">,</span> <span class="kw">auto</span> end<span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> subarrays<span class="op">)</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-3"><a href="#list:max_num_chunks_sorted:bruteforce-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-4"><a href="#list:max_num_chunks_sorted:bruteforce-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> it <span class="op">=</span> begin<span class="op">;</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-5"><a href="#list:max_num_chunks_sorted:bruteforce-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span> n <span class="op">:</span> subarrays<span class="op">)</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-6"><a href="#list:max_num_chunks_sorted:bruteforce-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-7"><a href="#list:max_num_chunks_sorted:bruteforce-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> itn <span class="op">=</span> begin <span class="op">+</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-8"><a href="#list:max_num_chunks_sorted:bruteforce-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>sort<span class="op">(</span>it<span class="op">,</span> itn<span class="op">);</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-9"><a href="#list:max_num_chunks_sorted:bruteforce-9" aria-hidden="true" tabindex="-1"></a>    it <span class="op">=</span> itn<span class="op">;</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-10"><a href="#list:max_num_chunks_sorted:bruteforce-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-11"><a href="#list:max_num_chunks_sorted:bruteforce-11" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>sort<span class="op">(</span>it<span class="op">,</span> end<span class="op">);</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-12"><a href="#list:max_num_chunks_sorted:bruteforce-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-13"><a href="#list:max_num_chunks_sorted:bruteforce-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_num_chunks_sorted:bruteforce-14"><a href="#list:max_num_chunks_sorted:bruteforce-14" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> check_all_k_combinations<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> I<span class="op">,</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-15"><a href="#list:max_num_chunks_sorted:bruteforce-15" aria-hidden="true" tabindex="-1"></a>                              <span class="at">const</span> <span class="dt">int</span> offset<span class="op">,</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-16"><a href="#list:max_num_chunks_sorted:bruteforce-16" aria-hidden="true" tabindex="-1"></a>                              <span class="at">const</span> <span class="dt">int</span> k<span class="op">,</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-17"><a href="#list:max_num_chunks_sorted:bruteforce-17" aria-hidden="true" tabindex="-1"></a>                              <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> combination<span class="op">)</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-18"><a href="#list:max_num_chunks_sorted:bruteforce-18" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-19"><a href="#list:max_num_chunks_sorted:bruteforce-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>k <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-20"><a href="#list:max_num_chunks_sorted:bruteforce-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-21"><a href="#list:max_num_chunks_sorted:bruteforce-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> I_copy<span class="op">(</span>I<span class="op">);</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-22"><a href="#list:max_num_chunks_sorted:bruteforce-22" aria-hidden="true" tabindex="-1"></a>    sort_subarrays<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>I_copy<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>I_copy<span class="op">),</span> combination<span class="op">);</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-23"><a href="#list:max_num_chunks_sorted:bruteforce-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>ranges<span class="bu">::</span>is_sorted<span class="op">(</span>I_copy<span class="op">);</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-24"><a href="#list:max_num_chunks_sorted:bruteforce-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-25"><a href="#list:max_num_chunks_sorted:bruteforce-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_num_chunks_sorted:bruteforce-26"><a href="#list:max_num_chunks_sorted:bruteforce-26" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> offset<span class="op">;</span> i <span class="op">&lt;</span> I<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> k<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-27"><a href="#list:max_num_chunks_sorted:bruteforce-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-28"><a href="#list:max_num_chunks_sorted:bruteforce-28" aria-hidden="true" tabindex="-1"></a>    combination<span class="op">.</span>push_back<span class="op">(</span>i<span class="op">);</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-29"><a href="#list:max_num_chunks_sorted:bruteforce-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>check_all_k_combinations<span class="op">(</span>I<span class="op">,</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> k <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> combination<span class="op">))</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-30"><a href="#list:max_num_chunks_sorted:bruteforce-30" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-31"><a href="#list:max_num_chunks_sorted:bruteforce-31" aria-hidden="true" tabindex="-1"></a>    combination<span class="op">.</span>pop_back<span class="op">();</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-32"><a href="#list:max_num_chunks_sorted:bruteforce-32" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-33"><a href="#list:max_num_chunks_sorted:bruteforce-33" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-34"><a href="#list:max_num_chunks_sorted:bruteforce-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-35"><a href="#list:max_num_chunks_sorted:bruteforce-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_num_chunks_sorted:bruteforce-36"><a href="#list:max_num_chunks_sorted:bruteforce-36" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> max_chunks_to_sorted_bruteforce<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> I<span class="op">)</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-37"><a href="#list:max_num_chunks_sorted:bruteforce-37" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-38"><a href="#list:max_num_chunks_sorted:bruteforce-38" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="bu">std::</span>ssize<span class="op">(</span>I<span class="op">);</span> k <span class="op">&gt;=</span> <span class="dv">2</span><span class="op">;</span> k<span class="op">--)</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-39"><a href="#list:max_num_chunks_sorted:bruteforce-39" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-40"><a href="#list:max_num_chunks_sorted:bruteforce-40" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> splitting_points<span class="op">{};</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-41"><a href="#list:max_num_chunks_sorted:bruteforce-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>check_all_k_combinations<span class="op">(</span>I<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> k <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> splitting_points<span class="op">))</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-42"><a href="#list:max_num_chunks_sorted:bruteforce-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-43"><a href="#list:max_num_chunks_sorted:bruteforce-43" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> k<span class="op">;</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-44"><a href="#list:max_num_chunks_sorted:bruteforce-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-45"><a href="#list:max_num_chunks_sorted:bruteforce-45" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-46"><a href="#list:max_num_chunks_sorted:bruteforce-46" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="list:max_num_chunks_sorted:bruteforce-47"><a href="#list:max_num_chunks_sorted:bruteforce-47" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="max_num_chunks_sorted:sec:lineartime">Linear time</h2>
<p>This problem can be however sorted in linear time if we take into consideration that if we sort a sub-array of <span class="math inline">\(I\)</span> containing elements from index <span class="math inline">\(s\)</span> to <span class="math inline">\(r&lt; |I|-1\)</span> (there is at least an element after this sub-array) then <span class="math inline">\(I\)</span> cannot be fully sorted if the maximum element among the elements <span class="math inline">\(I_s, I_{s+1},\ldots, I_r\)</span> is smaller than any of the element of <span class="math inline">\(I\)</span> after <span class="math inline">\(r\)</span> (or smaller than the smallest among those elements after <span class="math inline">\(r\)</span>). For instance, imagine <span class="math inline">\(I\)</span> is the input array of the example <a href="#example:max_num_chunks_sorted:example2" data-reference-type="ref" data-reference="example:max_num_chunks_sorted:example2">[example:max_num_chunks_sorted:example2]</a>. If we choose <span class="math inline">\(s=0\)</span> and <span class="math inline">\(r=2\)</span> then <span class="math inline">\(I\)</span> can never be properly sorted, no matter how we divide the elements after the one at index <span class="math inline">\(r=2\)</span> into subarrays because the element at index <span class="math inline">\(3\)</span> will always appear after the value <span class="math inline">\(4\)</span> (see Figure <a href="#fig:max_num_chunks_sorted:example1" data-reference-type="ref" data-reference="fig:max_num_chunks_sorted:example1">47.1</a>).</p>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/max_num_chunks_sorted/images/example1.jpg" id="fig:max_num_chunks_sorted:example1" style="width:60.0%" alt="Input array from the Example [example:max_num_chunks_sorted:example1]. If the sub-array identified by s and r is sorted in isolation, I as a whole cannot be sorted (no matter how elements from r to |I|-1 are sorted) because M will always appear before m, despite the fact M&gt;m and it should appear after." /><figcaption aria-hidden="true">Input array from the Example <a href="#example:max_num_chunks_sorted:example1" data-reference-type="ref" data-reference="example:max_num_chunks_sorted:example1">[example:max_num_chunks_sorted:example1]</a>. If the sub-array identified by <span class="math inline">\(s\)</span> and <span class="math inline">\(r\)</span> is sorted in isolation, <span class="math inline">\(I\)</span> as a whole cannot be sorted (no matter how elements from <span class="math inline">\(r\)</span> to <span class="math inline">\(|I|-1\)</span> are sorted) because <span class="math inline">\(M\)</span> will always appear before <span class="math inline">\(m\)</span>, despite the fact <span class="math inline">\(M&gt;m\)</span> and it should appear after.</figcaption>
</figure>
<p>. <span id="fig:max_num_chunks_sorted:example1" label="fig:max_num_chunks_sorted:example1">[fig:max_num_chunks_sorted:example1]</span></p>
<p>This insight makes it possible to derive a greedy approach to this problem that is based on the idea that we are going to split <span class="math inline">\(I\)</span> into as many pieces as possible, such that the largest element of a sub-array is smaller than all the subsequent elements.</p>
<p>Listing <a href="#list:max_num_chunks_sorted:linear" data-reference-type="ref" data-reference="list:max_num_chunks_sorted:linear">[list:max_num_chunks_sorted:linear]</a> shows an implementation of this idea that works by keeping a sorted list <span class="math inline">\(N\)</span> of all the elements not yet processed in <span class="math inline">\(I\)</span>. <span class="math inline">\(N\)</span> initially contains all the values in <span class="math inline">\(I\)</span>. We start a new chunk at index <span class="math inline">\(0\)</span> and we keep including elements into this chunk until the largest of its element is still larger than the smallest element in <span class="math inline">\(N\)</span>. When an element is included in the chunk, then it is removed from <span class="math inline">\(N\)</span>. If the largest element in the current chunk is indeed smaller than the smallest in <span class="math inline">\(N\)</span>, then this signals the fact we can sort this chunk independently without causing <span class="math inline">\(I\)</span> as a whole not to be sorted (all the elements of this chunk appear before the rest of the elements when <span class="math inline">\(I\)</span> is sorted). At this point, we can start a new chunk and repeat the process until we are left with no element to process (or equivalently <span class="math inline">\(N\)</span> is empty). Listing <a href="#list:max_num_chunks_sorted:linear" data-reference-type="ref" data-reference="list:max_num_chunks_sorted:linear">[list:max_num_chunks_sorted:linear]</a> has a complexity of <span class="math inline">\(O(|I|)\)</span> for both space and time.</p>
<div class="sourceCode" id="list:max_num_chunks_sorted:linear" data-language="c++" data-caption="Linear time solution to the problem \textit{Sort the chunks, sort the array}." label="list:max_num_chunks_sorted:linear"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:max_num_chunks_sorted:linear-1"><a href="#list:max_num_chunks_sorted:linear-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> max_chunks_to_sorted_lineartime<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> arr<span class="op">)</span></span>
<span id="list:max_num_chunks_sorted:linear-2"><a href="#list:max_num_chunks_sorted:linear-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:max_num_chunks_sorted:linear-3"><a href="#list:max_num_chunks_sorted:linear-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> <span class="dt">int</span> INF <span class="op">=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>min<span class="op">();</span></span>
<span id="list:max_num_chunks_sorted:linear-4"><a href="#list:max_num_chunks_sorted:linear-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_num_chunks_sorted:linear-5"><a href="#list:max_num_chunks_sorted:linear-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>arr<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:max_num_chunks_sorted:linear-6"><a href="#list:max_num_chunks_sorted:linear-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:max_num_chunks_sorted:linear-7"><a href="#list:max_num_chunks_sorted:linear-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_num_chunks_sorted:linear-8"><a href="#list:max_num_chunks_sorted:linear-8" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>set<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> N<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>arr<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>arr<span class="op">));</span></span>
<span id="list:max_num_chunks_sorted:linear-9"><a href="#list:max_num_chunks_sorted:linear-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans      <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:max_num_chunks_sorted:linear-10"><a href="#list:max_num_chunks_sorted:linear-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> curr_max <span class="op">=</span> INF<span class="op">;</span></span>
<span id="list:max_num_chunks_sorted:linear-11"><a href="#list:max_num_chunks_sorted:linear-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="bu">std::</span>ssize<span class="op">(</span>arr<span class="op">);</span> i<span class="op">++)</span></span>
<span id="list:max_num_chunks_sorted:linear-12"><a href="#list:max_num_chunks_sorted:linear-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:max_num_chunks_sorted:linear-13"><a href="#list:max_num_chunks_sorted:linear-13" aria-hidden="true" tabindex="-1"></a>    N<span class="op">.</span>erase<span class="op">(</span>arr<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:max_num_chunks_sorted:linear-14"><a href="#list:max_num_chunks_sorted:linear-14" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> new_max               <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>curr_max<span class="op">,</span> arr<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:max_num_chunks_sorted:linear-15"><a href="#list:max_num_chunks_sorted:linear-15" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> smallest_among_rest <span class="op">=</span> <span class="op">*(</span>N<span class="op">.</span>begin<span class="op">());</span></span>
<span id="list:max_num_chunks_sorted:linear-16"><a href="#list:max_num_chunks_sorted:linear-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>N<span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> new_max <span class="op">&gt;=</span> smallest_among_rest<span class="op">)</span></span>
<span id="list:max_num_chunks_sorted:linear-17"><a href="#list:max_num_chunks_sorted:linear-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:max_num_chunks_sorted:linear-18"><a href="#list:max_num_chunks_sorted:linear-18" aria-hidden="true" tabindex="-1"></a>      curr_max <span class="op">=</span> new_max<span class="op">;</span></span>
<span id="list:max_num_chunks_sorted:linear-19"><a href="#list:max_num_chunks_sorted:linear-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:max_num_chunks_sorted:linear-20"><a href="#list:max_num_chunks_sorted:linear-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="list:max_num_chunks_sorted:linear-21"><a href="#list:max_num_chunks_sorted:linear-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:max_num_chunks_sorted:linear-22"><a href="#list:max_num_chunks_sorted:linear-22" aria-hidden="true" tabindex="-1"></a>      ans<span class="op">++;</span></span>
<span id="list:max_num_chunks_sorted:linear-23"><a href="#list:max_num_chunks_sorted:linear-23" aria-hidden="true" tabindex="-1"></a>      curr_max <span class="op">=</span> INF<span class="op">;</span></span>
<span id="list:max_num_chunks_sorted:linear-24"><a href="#list:max_num_chunks_sorted:linear-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:max_num_chunks_sorted:linear-25"><a href="#list:max_num_chunks_sorted:linear-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:max_num_chunks_sorted:linear-26"><a href="#list:max_num_chunks_sorted:linear-26" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:max_num_chunks_sorted:linear-27"><a href="#list:max_num_chunks_sorted:linear-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="ch:palindrome_partitioning2">Palindrome Partitioning </h1>
<h2 class="unnumbered" id="introduction-45">Introduction</h2>
<p>In this chapter we are going to investigate a problem on strings. It features a short yet non-trivial statement which requires some care to internalize and understand fully. This is going to be yet another problem on palindromes, where you are asked to calculate the cost of breaking down an input string into chunks such that each of the individual chunks is a palindrome.</p>
<h2 id="problem-statement-47">Problem statement</h2>
<div class="exercise">
<p>Write a function that given a string <span class="math inline">\(s\)</span>, partitions it in a way that every resulting substring is a palindrome. A partition for a string <span class="math inline">\(s\)</span> is a collection of cut-points <span class="math inline">\(1 \leq c_0 &lt; c_1 \ldots &lt;
c_k &lt; |s|\)</span> splitting the string <span class="math inline">\(s\)</span> into <span class="math inline">\(k+1\)</span> non empty substrings:</p>
<ul>
<li><p><span class="math inline">\(s(0 \ldots c_0)\)</span></p></li>
<li><p><span class="math inline">\(s(c_0+1 \ldots c_1)\)</span></p></li>
<li><p>…</p></li>
<li><p><span class="math inline">\(s(k-1 \ldots c_k)\)</span></p></li>
</ul>
<p>The function should return the minimum number of cuts needed so that the resulting partition consists only of palindrome substrings.</p>
<div class="example">
<p><br />
Given <em>s="aab"</em> the function returns <span class="math inline">\(1\)</span>. <span class="math inline">\(0\)</span> cut-points are not enough as <span class="math inline">\(s\)</span> itself is not a palindrome but with one cutpoint at index <span class="math inline">\(1\)</span> we can obtain a the following partitioning <span class="math inline">\([&quot;aa&quot;,&quot;b&quot;]\)</span> where both <span class="math inline">\(aa\)</span> and <span class="math inline">\(b\)</span> are palindrome.</p>
</div>
<div class="example">
<p><br />
Given <em>s="itopinonavevanonipoti"</em> the function returns <span class="math inline">\(0\)</span> because <span class="math inline">\(s\)</span> is itself a palindrome.</p>
</div>
<div class="example">
<p><br />
Given <em>s="ababbbabbababa"</em> the function returns <span class="math inline">\(3\)</span>. One possible partition could be produced with <span class="math inline">\(3\)</span> cuts is: <span class="math inline">\([&quot;a&quot;,&quot;babbbab&quot;,&quot;b&quot;,&quot;ababa&quot;]\)</span>.</p>
</div>
</div>
<h2 id="clarification-questions-40">Clarification Questions</h2>
<div class="QandA">
<div class="answered">
<p><em></em></p>
</div>
</div>
<h2 id="palindrome_partitioning2:sec:discussion">Discussion</h2>
<h3 id="palindrome_partitioning2:sec:bruteforce">Brute-force</h3>
<p>The obvious trivial solution would be to try to all possible partitions of the input string, from the ones splitting it into <span class="math inline">\(1\)</span> piece, then all the ones splitting it into <span class="math inline">\(2\)</span> pieces, and so on in a similar fashion until we eventually find a partition that splits <span class="math inline">\(s\)</span> into palindromes. Such partition exists as if we split <span class="math inline">\(s\)</span> into <span class="math inline">\(|s|\)</span> pieces, down to its individual characters, the resulting substrings of length one are all palindrome. This approach is basically the same adopted for the brute-force (see Section <a href="#min_difficulty_job_scheduler:sec:bruteforce" data-reference-type="ref" data-reference="min_difficulty_job_scheduler:sec:bruteforce">42.3.1</a>) solution of the problem discussed in Chapter <a href="#ch:min_difficulty_job_scheduler" data-reference-type="ref" data-reference="ch:min_difficulty_job_scheduler">42</a> where the bulk of the complexity is into the generation of the partitions of incremental size. In order to do that, we could use the algorithm for the generation of all combinations of size <span class="math inline">\(k\)</span> shown in Listing <a href="#list:min_difficulty_job_scheduler:combinations" data-reference-type="ref" data-reference="list:min_difficulty_job_scheduler:combinations">[list:min_difficulty_job_scheduler:combinations]</a> to generate all possible cut-points and from there get the associated sub-strings. For each partition size <span class="math inline">\(l = 1,2,\ldots,|s|\)</span> we can use Listing <a href="#list:min_difficulty_job_scheduler:combinations" data-reference-type="ref" data-reference="list:min_difficulty_job_scheduler:combinations">[list:min_difficulty_job_scheduler:combinations]</a> to generate the combination of <span class="math inline">\(\{1,2,\ldots,|s|-1\}\)</span> in groups of size <span class="math inline">\(l\)</span> and for each of them evaluate whether the resulting substrings are all palindrome. We can return <span class="math inline">\(l\)</span> as soon as we find a combination which does.</p>
<p>Listing <a href="#list:min_difficulty_job_scheduler:combinations" data-reference-type="ref" data-reference="list:min_difficulty_job_scheduler:combinations">[list:min_difficulty_job_scheduler:combinations]</a> shows an implementation of this idea which has a time and space complexity of <span class="math inline">\(O(2^{|s|}\)</span>. The work done is the sum of all the work necessary to generate the combinations of sizes <span class="math inline">\(1,2,\ldots,|s-1|\)</span> i.e. <span class="math inline">\(\sum_{k=1}^{|s|-1} {|s|
\choose k} = 2^n\)</span>. The union of all combinations of size <span class="math inline">\(k=1,2,\ldots,|s|\)</span> is equivalent to the power-set (see Section <a href="#ch:power_set" data-reference-type="ref" data-reference="ch:power_set">1</a> at page ) which has size <span class="math inline">\(2^n\)</span>.</p>
<div class="sourceCode" id="list:palindrome_partitioning2" data-language="c++" data-caption="Exponential time solution to the palindrome partition problem using Listing \ref{list:min_difficulty_job_scheduler:combinations} at page as a sub-routine for the generation of the combinations of size $k$." label="list:palindrome_partitioning2"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:palindrome_partitioning2-1"><a href="#list:palindrome_partitioning2-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;generate_combinations.h&quot;</span></span>
<span id="list:palindrome_partitioning2-2"><a href="#list:palindrome_partitioning2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2-3"><a href="#list:palindrome_partitioning2-3" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="list:palindrome_partitioning2-4"><a href="#list:palindrome_partitioning2-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Returns</span></span>
<span id="list:palindrome_partitioning2-5"><a href="#list:palindrome_partitioning2-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * 	 true iff the substring of s starting at start and ending at end is palindrome</span></span>
<span id="list:palindrome_partitioning2-6"><a href="#list:palindrome_partitioning2-6" aria-hidden="true" tabindex="-1"></a><span class="co"> *   false otherwise.</span></span>
<span id="list:palindrome_partitioning2-7"><a href="#list:palindrome_partitioning2-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * */</span></span>
<span id="list:palindrome_partitioning2-8"><a href="#list:palindrome_partitioning2-8" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> is_palindrome<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span>s<span class="op">,</span> <span class="at">const</span> <span class="dt">size_t</span> start<span class="op">,</span> <span class="at">const</span> <span class="dt">size_t</span> end<span class="op">)</span></span>
<span id="list:palindrome_partitioning2-9"><a href="#list:palindrome_partitioning2-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:palindrome_partitioning2-10"><a href="#list:palindrome_partitioning2-10" aria-hidden="true" tabindex="-1"></a>	<span class="ot">assert</span><span class="op">(</span>start <span class="op">&lt;=</span> end<span class="op">);</span></span>
<span id="list:palindrome_partitioning2-11"><a href="#list:palindrome_partitioning2-11" aria-hidden="true" tabindex="-1"></a>	<span class="ot">assert</span><span class="op">(</span>end <span class="op">&lt;</span> s<span class="op">.</span>length<span class="op">());</span></span>
<span id="list:palindrome_partitioning2-12"><a href="#list:palindrome_partitioning2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2-13"><a href="#list:palindrome_partitioning2-13" aria-hidden="true" tabindex="-1"></a>	<span class="kw">auto</span> l <span class="op">=</span> start<span class="op">,</span> r <span class="op">=</span> end<span class="op">;</span></span>
<span id="list:palindrome_partitioning2-14"><a href="#list:palindrome_partitioning2-14" aria-hidden="true" tabindex="-1"></a>	<span class="cf">while</span><span class="op">(</span>l <span class="op">&lt;</span> r<span class="op">)</span></span>
<span id="list:palindrome_partitioning2-15"><a href="#list:palindrome_partitioning2-15" aria-hidden="true" tabindex="-1"></a>		<span class="cf">if</span><span class="op">(</span>s<span class="op">[</span>l<span class="op">++]!=</span>s<span class="op">[</span>r<span class="op">--])</span></span>
<span id="list:palindrome_partitioning2-16"><a href="#list:palindrome_partitioning2-16" aria-hidden="true" tabindex="-1"></a>			<span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:palindrome_partitioning2-17"><a href="#list:palindrome_partitioning2-17" aria-hidden="true" tabindex="-1"></a>	<span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:palindrome_partitioning2-18"><a href="#list:palindrome_partitioning2-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:palindrome_partitioning2-19"><a href="#list:palindrome_partitioning2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2-20"><a href="#list:palindrome_partitioning2-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> palindrome_partitioning2_bruteforce<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> </span>s<span class="op">)</span></span>
<span id="list:palindrome_partitioning2-21"><a href="#list:palindrome_partitioning2-21" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:palindrome_partitioning2-22"><a href="#list:palindrome_partitioning2-22" aria-hidden="true" tabindex="-1"></a>	<span class="cf">if</span><span class="op">(</span>is_palindrome<span class="op">(</span>s<span class="op">,</span><span class="dv">0</span><span class="op">,</span>s<span class="op">.</span>size<span class="op">()-</span><span class="dv">1</span><span class="op">))</span></span>
<span id="list:palindrome_partitioning2-23"><a href="#list:palindrome_partitioning2-23" aria-hidden="true" tabindex="-1"></a>		<span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:palindrome_partitioning2-24"><a href="#list:palindrome_partitioning2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2-25"><a href="#list:palindrome_partitioning2-25" aria-hidden="true" tabindex="-1"></a>	<span class="cf">for</span><span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">1</span> <span class="op">;</span> k <span class="op">&lt;=</span> <span class="bu">std::</span>ssize<span class="op">(</span>s<span class="op">)-</span><span class="dv">1</span><span class="op">;</span> k<span class="op">++)</span></span>
<span id="list:palindrome_partitioning2-26"><a href="#list:palindrome_partitioning2-26" aria-hidden="true" tabindex="-1"></a>	<span class="op">{</span></span>
<span id="list:palindrome_partitioning2-27"><a href="#list:palindrome_partitioning2-27" aria-hidden="true" tabindex="-1"></a>		<span class="co">//generate combinations in groups of k from [0...s.size()-2]</span></span>
<span id="list:palindrome_partitioning2-28"><a href="#list:palindrome_partitioning2-28" aria-hidden="true" tabindex="-1"></a>		<span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> cutpoints <span class="op">=</span> all_combinations<span class="op">(</span>k<span class="op">,</span>s<span class="op">.</span>size<span class="op">());</span></span>
<span id="list:palindrome_partitioning2-29"><a href="#list:palindrome_partitioning2-29" aria-hidden="true" tabindex="-1"></a>		<span class="co">//is there a partition of size k such that all the associated substrings in s are palindrome?</span></span>
<span id="list:palindrome_partitioning2-30"><a href="#list:palindrome_partitioning2-30" aria-hidden="true" tabindex="-1"></a>		<span class="at">const</span> <span class="kw">auto</span> found <span class="op">=</span> <span class="bu">std::</span>any_of<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>cutpoints<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>cutpoints<span class="op">),</span> <span class="op">[&amp;](</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> combo<span class="op">)</span></span>
<span id="list:palindrome_partitioning2-31"><a href="#list:palindrome_partitioning2-31" aria-hidden="true" tabindex="-1"></a>		<span class="op">{</span></span>
<span id="list:palindrome_partitioning2-32"><a href="#list:palindrome_partitioning2-32" aria-hidden="true" tabindex="-1"></a>			<span class="kw">auto</span> substring_start <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:palindrome_partitioning2-33"><a href="#list:palindrome_partitioning2-33" aria-hidden="true" tabindex="-1"></a>			<span class="cf">for</span><span class="op">(</span><span class="at">const</span> <span class="kw">auto</span> substring_end <span class="op">:</span> combo<span class="op">)</span></span>
<span id="list:palindrome_partitioning2-34"><a href="#list:palindrome_partitioning2-34" aria-hidden="true" tabindex="-1"></a>			<span class="op">{</span></span>
<span id="list:palindrome_partitioning2-35"><a href="#list:palindrome_partitioning2-35" aria-hidden="true" tabindex="-1"></a>				<span class="cf">if</span><span class="op">(!</span>is_palindrome<span class="op">(</span>s<span class="op">,</span>substring_start<span class="op">,</span> substring_end<span class="op">))</span></span>
<span id="list:palindrome_partitioning2-36"><a href="#list:palindrome_partitioning2-36" aria-hidden="true" tabindex="-1"></a>					<span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:palindrome_partitioning2-37"><a href="#list:palindrome_partitioning2-37" aria-hidden="true" tabindex="-1"></a>				substring_start<span class="op">=</span>substring_end<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:palindrome_partitioning2-38"><a href="#list:palindrome_partitioning2-38" aria-hidden="true" tabindex="-1"></a>			<span class="op">}</span></span>
<span id="list:palindrome_partitioning2-39"><a href="#list:palindrome_partitioning2-39" aria-hidden="true" tabindex="-1"></a>			<span class="cf">return</span> is_palindrome<span class="op">(</span>s<span class="op">,</span>substring_start<span class="op">,</span> s<span class="op">.</span>size<span class="op">()-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="list:palindrome_partitioning2-40"><a href="#list:palindrome_partitioning2-40" aria-hidden="true" tabindex="-1"></a>		<span class="op">});</span></span>
<span id="list:palindrome_partitioning2-41"><a href="#list:palindrome_partitioning2-41" aria-hidden="true" tabindex="-1"></a>		<span class="cf">if</span><span class="op">(</span>found<span class="op">)</span></span>
<span id="list:palindrome_partitioning2-42"><a href="#list:palindrome_partitioning2-42" aria-hidden="true" tabindex="-1"></a>			<span class="cf">return</span> k<span class="op">;</span></span>
<span id="list:palindrome_partitioning2-43"><a href="#list:palindrome_partitioning2-43" aria-hidden="true" tabindex="-1"></a>	<span class="op">}</span></span>
<span id="list:palindrome_partitioning2-44"><a href="#list:palindrome_partitioning2-44" aria-hidden="true" tabindex="-1"></a>	<span class="cf">return</span> s<span class="op">.</span>size<span class="op">()-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:palindrome_partitioning2-45"><a href="#list:palindrome_partitioning2-45" aria-hidden="true" tabindex="-1"></a>	</span>
<span id="list:palindrome_partitioning2-46"><a href="#list:palindrome_partitioning2-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="sec:palindrome_partitioning2:DP">Dynamic Programming</h2>
<p>This problem has however a solution that is much better than exponential time. As the title of this section suggests, we can use DP to effectively tackle it. The key insight that allows us to develop an effective DP solution is to think about how we can break down the problem into subproblem on a suffix of <span class="math inline">\(s\)</span>. What I mean is that we can think about a function <span class="math inline">\(P(s, i)\)</span> which returns the answer to the problem for the substring of <span class="math inline">\(s\)</span> from the character at index <span class="math inline">\(i\)</span> to its end. Clearly <span class="math inline">\(P(s,0)\)</span> is the answer to the general question. However given this formulation we can express the solution of a subproblem for a starting index <span class="math inline">\(i\)</span> in terms of optimal solution for the smaller sub-problems at indices <span class="math inline">\(j&gt;i\)</span>. Equation <a href="#eq:palindrome_partitioning2:dpformula" data-reference-type="ref" data-reference="eq:palindrome_partitioning2:dpformula">[eq:palindrome_partitioning2:dpformula]</a> captures this idea into a recurrence relation. It states that the answer to a subproblem for an empty substring of <span class="math inline">\(s\)</span> is zero: no cuts are necessary as an empty string is already palindrome. If the whole string from index <span class="math inline">\(i\)</span> to the end is a palindrome, then no cuts are necessary. For any other sub-problems <span class="math inline">\(P(s,i)\)</span> what we can do is to make a cut at an index <span class="math inline">\(k\geq i\)</span> provided that the substring of <span class="math inline">\(s\)</span> from index <span class="math inline">\(i\)</span> to <span class="math inline">\(k\)</span>,resulting from the cut, is a palindrome and then add to it the answer to the subproblem <span class="math inline">\(P(s,k+1)\)</span> which gives the optimal solution for the unprocessed part of <span class="math inline">\(s\)</span>: from index <span class="math inline">\(k+1\)</span> to the end.</p>
<p><span class="math display">\[P(s, i) = \begin{cases}
		0 \; \; \text{ if } i \geq |s|  \\
		0 \; \; \text{ if } s[i\ldots |s|-1]  \:\: \text{is palindrome}  \\
		\min_{k\geq |s|} \big( 1 + P(s,k+1) \big) \: \: \text{if} \: \: s[i\ldots k]  \:\: \text{is palindrome}
	 \end{cases}
	\label{eq:palindrome_partitioning2:dpformula}\]</span></p>
<h3 id="top-down-1">Top-down</h3>
<p>The solution outlined in Section <a href="#sec:palindrome_partitioning2:DP" data-reference-type="ref" data-reference="sec:palindrome_partitioning2:DP">48.4</a> and formalized in Equation <a href="#eq:palindrome_partitioning2:dpformula" data-reference-type="ref" data-reference="eq:palindrome_partitioning2:dpformula">[eq:palindrome_partitioning2:dpformula]</a> can be easily translated into a recursive solution as shown in Listing <a href="#list:palindrome_partitioning2:topdown" data-reference-type="ref" data-reference="list:palindrome_partitioning2:topdown">[list:palindrome_partitioning2:topdown]</a>. The recursive function has an almost 1-to-1 mapping to the Equation <a href="#eq:palindrome_partitioning2:dpformula" data-reference-type="ref" data-reference="eq:palindrome_partitioning2:dpformula">[eq:palindrome_partitioning2:dpformula]</a> except for the code responsible for the memoization optimization which allows the answer for a given subproblem that has been already solved previously, to be returned immediately. We have used this optimization already other problems like:</p>
<div class="enumerate*">
<p><em></em> in Section <a href="#ch:dice_rolls" data-reference-type="ref" data-reference="ch:dice_rolls">44</a> at page or</p>
<p><em></em> in Section <a href="#ch:min_difficulty_job_scheduler" data-reference-type="ref" data-reference="ch:min_difficulty_job_scheduler">42</a> at page</p>
</div>
<p>.</p>
<div class="sourceCode" id="list:palindrome_partitioning2:topdown" data-language="c++" data-caption="Quadratic time dynamic programming top-down solution to the palindrome partition problem." label="list:palindrome_partitioning2:topdown"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:palindrome_partitioning2:topdown-1"><a href="#list:palindrome_partitioning2:topdown-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> Cache <span class="op">=</span> <span class="bu">std::</span>unordered_map<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span><span class="dt">int</span><span class="op">&gt;;</span></span>
<span id="list:palindrome_partitioning2:topdown-2"><a href="#list:palindrome_partitioning2:topdown-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2:topdown-3"><a href="#list:palindrome_partitioning2:topdown-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> palindrome_partitioning2_DP_topdown_helper<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> </span>s<span class="op">,</span> <span class="at">const</span> <span class="dt">int</span> start_idx<span class="op">,</span> Cache<span class="op">&amp;</span> memoization_cache<span class="op">)</span></span>
<span id="list:palindrome_partitioning2:topdown-4"><a href="#list:palindrome_partitioning2:topdown-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:palindrome_partitioning2:topdown-5"><a href="#list:palindrome_partitioning2:topdown-5" aria-hidden="true" tabindex="-1"></a>	<span class="cf">if</span><span class="op">(</span>start_idx <span class="op">&gt;=</span> <span class="bu">std::</span>ssize<span class="op">(</span>s<span class="op">)</span> <span class="op">||</span> is_palindrome<span class="op">(</span>s<span class="op">,</span>start_idx<span class="op">,</span> <span class="bu">std::</span>ssize<span class="op">(</span>s<span class="op">)-</span><span class="dv">1</span><span class="op">)</span> <span class="op">)</span></span>
<span id="list:palindrome_partitioning2:topdown-6"><a href="#list:palindrome_partitioning2:topdown-6" aria-hidden="true" tabindex="-1"></a>		<span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:palindrome_partitioning2:topdown-7"><a href="#list:palindrome_partitioning2:topdown-7" aria-hidden="true" tabindex="-1"></a>	</span>
<span id="list:palindrome_partitioning2:topdown-8"><a href="#list:palindrome_partitioning2:topdown-8" aria-hidden="true" tabindex="-1"></a>	<span class="cf">if</span><span class="op">(</span>memoization_cache<span class="op">.</span>contains<span class="op">(</span>start_idx<span class="op">))</span></span>
<span id="list:palindrome_partitioning2:topdown-9"><a href="#list:palindrome_partitioning2:topdown-9" aria-hidden="true" tabindex="-1"></a>		<span class="cf">return</span> memoization_cache<span class="op">[</span>start_idx<span class="op">];</span></span>
<span id="list:palindrome_partitioning2:topdown-10"><a href="#list:palindrome_partitioning2:topdown-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2:topdown-11"><a href="#list:palindrome_partitioning2:topdown-11" aria-hidden="true" tabindex="-1"></a>	<span class="dt">int</span> ans <span class="op">=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>max<span class="op">();</span></span>
<span id="list:palindrome_partitioning2:topdown-12"><a href="#list:palindrome_partitioning2:topdown-12" aria-hidden="true" tabindex="-1"></a>	<span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> start_idx <span class="op">;</span> i <span class="op">&lt;</span> <span class="bu">std::</span>ssize<span class="op">(</span>s<span class="op">)</span> <span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:palindrome_partitioning2:topdown-13"><a href="#list:palindrome_partitioning2:topdown-13" aria-hidden="true" tabindex="-1"></a>	<span class="op">{</span></span>
<span id="list:palindrome_partitioning2:topdown-14"><a href="#list:palindrome_partitioning2:topdown-14" aria-hidden="true" tabindex="-1"></a>		<span class="cf">if</span><span class="op">(</span>is_palindrome<span class="op">(</span>s<span class="op">,</span>start_idx<span class="op">,</span> i<span class="op">))</span></span>
<span id="list:palindrome_partitioning2:topdown-15"><a href="#list:palindrome_partitioning2:topdown-15" aria-hidden="true" tabindex="-1"></a>			ans <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>ans<span class="op">,</span> <span class="dv">1</span> <span class="op">+</span> palindrome_partitioning2_DP_topdown_helper<span class="op">(</span>s<span class="op">,</span>i<span class="op">+</span><span class="dv">1</span><span class="op">,</span>memoization_cache<span class="op">));</span></span>
<span id="list:palindrome_partitioning2:topdown-16"><a href="#list:palindrome_partitioning2:topdown-16" aria-hidden="true" tabindex="-1"></a>	<span class="op">}</span></span>
<span id="list:palindrome_partitioning2:topdown-17"><a href="#list:palindrome_partitioning2:topdown-17" aria-hidden="true" tabindex="-1"></a>	</span>
<span id="list:palindrome_partitioning2:topdown-18"><a href="#list:palindrome_partitioning2:topdown-18" aria-hidden="true" tabindex="-1"></a>	<span class="ot">assert</span><span class="op">(</span>ans <span class="op">&lt;=</span> <span class="bu">std::</span>ssize<span class="op">(</span>s<span class="op">)-</span>start_idx<span class="op">);</span></span>
<span id="list:palindrome_partitioning2:topdown-19"><a href="#list:palindrome_partitioning2:topdown-19" aria-hidden="true" tabindex="-1"></a>	memoization_cache<span class="op">[</span>start_idx<span class="op">]</span> <span class="op">=</span> ans<span class="op">;</span></span>
<span id="list:palindrome_partitioning2:topdown-20"><a href="#list:palindrome_partitioning2:topdown-20" aria-hidden="true" tabindex="-1"></a>	<span class="cf">return</span> ans<span class="op">;</span>	</span>
<span id="list:palindrome_partitioning2:topdown-21"><a href="#list:palindrome_partitioning2:topdown-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:palindrome_partitioning2:topdown-22"><a href="#list:palindrome_partitioning2:topdown-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2:topdown-23"><a href="#list:palindrome_partitioning2:topdown-23" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> palindrome_partitioning2_DP_topdown<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> </span>s<span class="op">)</span></span>
<span id="list:palindrome_partitioning2:topdown-24"><a href="#list:palindrome_partitioning2:topdown-24" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:palindrome_partitioning2:topdown-25"><a href="#list:palindrome_partitioning2:topdown-25" aria-hidden="true" tabindex="-1"></a>	Cache memoization_cache<span class="op">;</span></span>
<span id="list:palindrome_partitioning2:topdown-26"><a href="#list:palindrome_partitioning2:topdown-26" aria-hidden="true" tabindex="-1"></a>	<span class="cf">return</span> palindrome_partitioning2_DP_topdown_helper<span class="op">(</span>s<span class="op">,</span><span class="dv">0</span><span class="op">,</span> memoization_cache<span class="op">);</span></span>
<span id="list:palindrome_partitioning2:topdown-27"><a href="#list:palindrome_partitioning2:topdown-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The complexity of this solution is <span class="math inline">\(O(|s|^3)\)</span> because each of the <span class="math inline">\(O(|s|)\)</span> distinct (for which we might have to execute the whole function code) calls to and each performs <span class="math inline">\(O(|s|^2)\)</span> work: the for loops runs <span class="math inline">\(O(|s|)\)</span> times, and the function has a complexity of <span class="math inline">\(O(|s|)\)</span></p>
<h4 id="top-down-improved">Top-down improved</h4>
<p>The complexity of code in Listing <a href="#list:palindrome_partitioning2:topdown" data-reference-type="ref" data-reference="list:palindrome_partitioning2:topdown">[list:palindrome_partitioning2:topdown]</a> can be lowered to <span class="math inline">\(O(|s|^2)\)</span> if only we were able to answer the question about whether a given substring of <span class="math inline">\(s\)</span> from index <span class="math inline">\(i\)</span> to <span class="math inline">\(j&gt;i\)</span> is a palindrome or not. The current implementation blindly process the whole substring to find-out that information. What we can do instead is to use DP (again) in order to build a table <span class="math inline">\(B\)</span> where each its elements <span class="math inline">\(B[i][j]\)</span> contains the information about whether the substring of <span class="math inline">\(s\)</span> from index <span class="math inline">\(i\)</span> to <span class="math inline">\(j&gt;i\)</span> is a palindrome. The key idea is that we can build such a table in <span class="math inline">\(O(|s|^2)\)</span> time, and store it using <span class="math inline">\(O(|s|^2)\)</span> space.</p>
<p>A palindrome is a word having the same first and last character, for which the substring obtained by removing the first and the last character is itself a palindrome. We are going to use this property to build <span class="math inline">\(B\)</span> which is reflected by the fact that an entry of <span class="math inline">\(B\)</span>, <span class="math inline">\(B[i][j]\)</span> contains true if and only if <span class="math inline">\(s[i]=s[j]\)</span> and <span class="math inline">\(B[i+1][j-1]\)</span> is true. There are certain cells of <span class="math inline">\(B\)</span> that we can fill immediately: for instance all the cells where <span class="math inline">\(i=j\)</span> can be set to true as those maps to sub-string of <span class="math inline">\(s\)</span> of length <span class="math inline">\(1\)</span> which are palindrome by definition. We can fill the table by using a recursive function and memoization. as shown in Listing <a href="#list:palindrome_partitioning2:recursivecache" data-reference-type="ref" data-reference="list:palindrome_partitioning2:recursivecache">[list:palindrome_partitioning2:recursivecache]</a> shows an implementation of a class which will provide the same information in the table <span class="math inline">\(B\)</span> but wrapped in a class with a simple API: a constructor taking a as input and a function for answering queries on sub-strings of <span class="math inline">\(s\)</span>. Notice that the constructor will immediately call the function which will fill the table <span class="math inline">\(B\)</span> fully before any call to . With minimal change we can also make the class , by removing the function completely by implementing in terms of . The file<code>"hash_pair.h"</code><a href="#fn35" class="footnote-ref" id="fnref35" role="doc-noteref"><sup>35</sup></a> contains some code which only purpose is to allows us to use as keys in the . can however also be implemented in a iterative way, The same functionality can be also implemented iteratively by using a bottom-up DP strategy. Listing <a href="#list:palindrome_partitioning2:iterativecache" data-reference-type="ref" data-reference="list:palindrome_partitioning2:iterativecache">[list:palindrome_partitioning2:iterativecache]</a> how it can be done.</p>
<div class="sourceCode" id="list:palindrome_partitioning2:recursivecache" data-language="c++" data-caption="Recursive implementation of a class which allows to answer queries about whether a given substring of a given string is palindrome or not in constant time." label="list:palindrome_partitioning2:recursivecache"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:palindrome_partitioning2:recursivecache-1"><a href="#list:palindrome_partitioning2:recursivecache-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;hash_pair.h&quot;</span></span>
<span id="list:palindrome_partitioning2:recursivecache-2"><a href="#list:palindrome_partitioning2:recursivecache-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2:recursivecache-3"><a href="#list:palindrome_partitioning2:recursivecache-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PalindromeSubstringCacheRecursive</span>
<span id="list:palindrome_partitioning2:recursivecache-4"><a href="#list:palindrome_partitioning2:recursivecache-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:palindrome_partitioning2:recursivecache-5"><a href="#list:palindrome_partitioning2:recursivecache-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="list:palindrome_partitioning2:recursivecache-6"><a href="#list:palindrome_partitioning2:recursivecache-6" aria-hidden="true" tabindex="-1"></a>    PalindromeSubstringCacheRecursive<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> s<span class="op">)</span> <span class="op">:</span>mStr_size<span class="op">(</span>s<span class="op">.</span>size<span class="op">())</span> <span class="op">{</span></span>
<span id="list:palindrome_partitioning2:recursivecache-7"><a href="#list:palindrome_partitioning2:recursivecache-7" aria-hidden="true" tabindex="-1"></a>      buildMap<span class="op">(</span>s<span class="op">);</span></span>
<span id="list:palindrome_partitioning2:recursivecache-8"><a href="#list:palindrome_partitioning2:recursivecache-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:palindrome_partitioning2:recursivecache-9"><a href="#list:palindrome_partitioning2:recursivecache-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2:recursivecache-10"><a href="#list:palindrome_partitioning2:recursivecache-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="dt">bool</span> is_palindrome<span class="op">(</span><span class="at">const</span> <span class="dt">size_t</span> start<span class="op">,</span> <span class="at">const</span> <span class="dt">size_t</span> end<span class="op">)</span> <span class="at">const</span></span>
<span id="list:palindrome_partitioning2:recursivecache-11"><a href="#list:palindrome_partitioning2:recursivecache-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:palindrome_partitioning2:recursivecache-12"><a href="#list:palindrome_partitioning2:recursivecache-12" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">size_t</span><span class="op">,</span><span class="dt">size_t</span><span class="op">&gt;</span> p<span class="op">(</span>start<span class="op">,</span> end<span class="op">);</span></span>
<span id="list:palindrome_partitioning2:recursivecache-13"><a href="#list:palindrome_partitioning2:recursivecache-13" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> mB<span class="op">.</span>contains<span class="op">(</span>p<span class="op">)</span> <span class="op">&amp;&amp;</span>  mB<span class="op">.</span>at<span class="op">(</span>p<span class="op">);</span></span>
<span id="list:palindrome_partitioning2:recursivecache-14"><a href="#list:palindrome_partitioning2:recursivecache-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:palindrome_partitioning2:recursivecache-15"><a href="#list:palindrome_partitioning2:recursivecache-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2:recursivecache-16"><a href="#list:palindrome_partitioning2:recursivecache-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="dt">size_t</span> size<span class="op">()</span><span class="at">const</span> <span class="op">{</span></span>
<span id="list:palindrome_partitioning2:recursivecache-17"><a href="#list:palindrome_partitioning2:recursivecache-17" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> mStr_size<span class="op">;</span></span>
<span id="list:palindrome_partitioning2:recursivecache-18"><a href="#list:palindrome_partitioning2:recursivecache-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:palindrome_partitioning2:recursivecache-19"><a href="#list:palindrome_partitioning2:recursivecache-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2:recursivecache-20"><a href="#list:palindrome_partitioning2:recursivecache-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">private</span><span class="op">:</span></span>
<span id="list:palindrome_partitioning2:recursivecache-21"><a href="#list:palindrome_partitioning2:recursivecache-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_palindrome_substring_helper<span class="op">(</span><span class="at">const</span> string<span class="op">&amp;</span>s<span class="op">,</span> <span class="at">const</span> <span class="dt">size_t</span> start<span class="op">,</span> <span class="at">const</span> <span class="dt">size_t</span> end<span class="op">)</span></span>
<span id="list:palindrome_partitioning2:recursivecache-22"><a href="#list:palindrome_partitioning2:recursivecache-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:palindrome_partitioning2:recursivecache-23"><a href="#list:palindrome_partitioning2:recursivecache-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>start <span class="op">&gt;</span> end <span class="op">||</span> start <span class="op">&gt;=</span> s<span class="op">.</span>size<span class="op">()</span> <span class="op">||</span> end <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="list:palindrome_partitioning2:recursivecache-24"><a href="#list:palindrome_partitioning2:recursivecache-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:palindrome_partitioning2:recursivecache-25"><a href="#list:palindrome_partitioning2:recursivecache-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2:recursivecache-26"><a href="#list:palindrome_partitioning2:recursivecache-26" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span><span class="dt">int</span><span class="op">&gt;</span> p<span class="op">(</span>start<span class="op">,</span> end<span class="op">);</span></span>
<span id="list:palindrome_partitioning2:recursivecache-27"><a href="#list:palindrome_partitioning2:recursivecache-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>mB<span class="op">.</span>contains<span class="op">(</span>p<span class="op">))</span></span>
<span id="list:palindrome_partitioning2:recursivecache-28"><a href="#list:palindrome_partitioning2:recursivecache-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> mB<span class="op">.</span>at<span class="op">(</span>p<span class="op">);</span></span>
<span id="list:palindrome_partitioning2:recursivecache-29"><a href="#list:palindrome_partitioning2:recursivecache-29" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="list:palindrome_partitioning2:recursivecache-30"><a href="#list:palindrome_partitioning2:recursivecache-30" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="dt">bool</span> ans <span class="op">=</span> <span class="op">(</span>start <span class="op">==</span> end<span class="op">)</span> <span class="op">||</span> <span class="op">(</span></span>
<span id="list:palindrome_partitioning2:recursivecache-31"><a href="#list:palindrome_partitioning2:recursivecache-31" aria-hidden="true" tabindex="-1"></a>            <span class="op">(</span>s<span class="op">[</span>start<span class="op">]==</span>s<span class="op">[</span>end<span class="op">])</span> <span class="op">&amp;&amp;</span> </span>
<span id="list:palindrome_partitioning2:recursivecache-32"><a href="#list:palindrome_partitioning2:recursivecache-32" aria-hidden="true" tabindex="-1"></a>                is_palindrome_substring_helper<span class="op">(</span>s<span class="op">,</span>start<span class="op">+</span><span class="dv">1</span><span class="op">,</span> end<span class="op">-</span><span class="dv">1</span><span class="op">)</span></span>
<span id="list:palindrome_partitioning2:recursivecache-33"><a href="#list:palindrome_partitioning2:recursivecache-33" aria-hidden="true" tabindex="-1"></a>                <span class="op">);</span></span>
<span id="list:palindrome_partitioning2:recursivecache-34"><a href="#list:palindrome_partitioning2:recursivecache-34" aria-hidden="true" tabindex="-1"></a>        mB<span class="op">.</span>insert<span class="op">({</span>p<span class="op">,</span> ans<span class="op">});</span></span>
<span id="list:palindrome_partitioning2:recursivecache-35"><a href="#list:palindrome_partitioning2:recursivecache-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:palindrome_partitioning2:recursivecache-36"><a href="#list:palindrome_partitioning2:recursivecache-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:palindrome_partitioning2:recursivecache-37"><a href="#list:palindrome_partitioning2:recursivecache-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2:recursivecache-38"><a href="#list:palindrome_partitioning2:recursivecache-38" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> buildMap<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span>s<span class="op">)</span></span>
<span id="list:palindrome_partitioning2:recursivecache-39"><a href="#list:palindrome_partitioning2:recursivecache-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:palindrome_partitioning2:recursivecache-40"><a href="#list:palindrome_partitioning2:recursivecache-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span> <span class="op">;</span> i <span class="op">&lt;</span> <span class="bu">std::</span>size<span class="op">(</span>s<span class="op">)</span> <span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:palindrome_partitioning2:recursivecache-41"><a href="#list:palindrome_partitioning2:recursivecache-41" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="list:palindrome_partitioning2:recursivecache-42"><a href="#list:palindrome_partitioning2:recursivecache-42" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> j <span class="op">=</span> i<span class="op">;</span> j <span class="op">&lt;</span> <span class="bu">std::</span>size<span class="op">(</span>s<span class="op">);</span> j<span class="op">++)</span></span>
<span id="list:palindrome_partitioning2:recursivecache-43"><a href="#list:palindrome_partitioning2:recursivecache-43" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="list:palindrome_partitioning2:recursivecache-44"><a href="#list:palindrome_partitioning2:recursivecache-44" aria-hidden="true" tabindex="-1"></a>                mB<span class="op">[{</span>i<span class="op">,</span>j<span class="op">}]</span> <span class="op">=</span> is_palindrome_substring_helper<span class="op">(</span>s<span class="op">,</span>i<span class="op">,</span>j<span class="op">);</span></span>
<span id="list:palindrome_partitioning2:recursivecache-45"><a href="#list:palindrome_partitioning2:recursivecache-45" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="list:palindrome_partitioning2:recursivecache-46"><a href="#list:palindrome_partitioning2:recursivecache-46" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="list:palindrome_partitioning2:recursivecache-47"><a href="#list:palindrome_partitioning2:recursivecache-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:palindrome_partitioning2:recursivecache-48"><a href="#list:palindrome_partitioning2:recursivecache-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2:recursivecache-49"><a href="#list:palindrome_partitioning2:recursivecache-49" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>unordered_map<span class="op">&lt;</span><span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span><span class="dt">int</span><span class="op">&gt;,</span> <span class="dt">bool</span><span class="op">,</span> PairHasher<span class="op">&gt;</span> mB<span class="op">;</span></span>
<span id="list:palindrome_partitioning2:recursivecache-50"><a href="#list:palindrome_partitioning2:recursivecache-50" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">size_t</span> mStr_size<span class="op">;</span></span>
<span id="list:palindrome_partitioning2:recursivecache-51"><a href="#list:palindrome_partitioning2:recursivecache-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2:recursivecache-52"><a href="#list:palindrome_partitioning2:recursivecache-52" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="list:palindrome_partitioning2:iterativecache" data-language="c++" data-caption="Iterative implementation of a class which allows to answer queries about whether a given substring of a given string is palindrome or not in constant time." label="list:palindrome_partitioning2:iterativecache"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:palindrome_partitioning2:iterativecache-1"><a href="#list:palindrome_partitioning2:iterativecache-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PalindromeSubstringCacheIterative</span>
<span id="list:palindrome_partitioning2:iterativecache-2"><a href="#list:palindrome_partitioning2:iterativecache-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:palindrome_partitioning2:iterativecache-3"><a href="#list:palindrome_partitioning2:iterativecache-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="list:palindrome_partitioning2:iterativecache-4"><a href="#list:palindrome_partitioning2:iterativecache-4" aria-hidden="true" tabindex="-1"></a>    PalindromeSubstringCacheIterative<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> s<span class="op">)</span> <span class="op">:</span>mStr_size<span class="op">(</span>s<span class="op">.</span>size<span class="op">())</span> <span class="op">{</span></span>
<span id="list:palindrome_partitioning2:iterativecache-5"><a href="#list:palindrome_partitioning2:iterativecache-5" aria-hidden="true" tabindex="-1"></a>      buildMap<span class="op">(</span>s<span class="op">);</span></span>
<span id="list:palindrome_partitioning2:iterativecache-6"><a href="#list:palindrome_partitioning2:iterativecache-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:palindrome_partitioning2:iterativecache-7"><a href="#list:palindrome_partitioning2:iterativecache-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2:iterativecache-8"><a href="#list:palindrome_partitioning2:iterativecache-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="dt">bool</span> is_palindrome<span class="op">(</span><span class="at">const</span> <span class="dt">size_t</span> start<span class="op">,</span> <span class="at">const</span> <span class="dt">size_t</span> end<span class="op">)</span> <span class="at">const</span></span>
<span id="list:palindrome_partitioning2:iterativecache-9"><a href="#list:palindrome_partitioning2:iterativecache-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:palindrome_partitioning2:iterativecache-10"><a href="#list:palindrome_partitioning2:iterativecache-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2:iterativecache-11"><a href="#list:palindrome_partitioning2:iterativecache-11" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> start <span class="op">&lt;</span> mStr_size <span class="op">&amp;&amp;</span> end<span class="op">&gt;=</span><span class="dv">0</span> <span class="op">&amp;&amp;</span> </span>
<span id="list:palindrome_partitioning2:iterativecache-12"><a href="#list:palindrome_partitioning2:iterativecache-12" aria-hidden="true" tabindex="-1"></a>          mB<span class="op">[</span>start<span class="op">][</span>end<span class="op">]!=-</span><span class="dv">1</span> <span class="op">&amp;&amp;</span>  mB<span class="op">[</span>start<span class="op">][</span>end<span class="op">];</span></span>
<span id="list:palindrome_partitioning2:iterativecache-13"><a href="#list:palindrome_partitioning2:iterativecache-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:palindrome_partitioning2:iterativecache-14"><a href="#list:palindrome_partitioning2:iterativecache-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2:iterativecache-15"><a href="#list:palindrome_partitioning2:iterativecache-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="dt">size_t</span> size<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="list:palindrome_partitioning2:iterativecache-16"><a href="#list:palindrome_partitioning2:iterativecache-16" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> mStr_size<span class="op">;</span></span>
<span id="list:palindrome_partitioning2:iterativecache-17"><a href="#list:palindrome_partitioning2:iterativecache-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:palindrome_partitioning2:iterativecache-18"><a href="#list:palindrome_partitioning2:iterativecache-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2:iterativecache-19"><a href="#list:palindrome_partitioning2:iterativecache-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">private</span><span class="op">:</span></span>
<span id="list:palindrome_partitioning2:iterativecache-20"><a href="#list:palindrome_partitioning2:iterativecache-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2:iterativecache-21"><a href="#list:palindrome_partitioning2:iterativecache-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> buildMap<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span>s<span class="op">)</span></span>
<span id="list:palindrome_partitioning2:iterativecache-22"><a href="#list:palindrome_partitioning2:iterativecache-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:palindrome_partitioning2:iterativecache-23"><a href="#list:palindrome_partitioning2:iterativecache-23" aria-hidden="true" tabindex="-1"></a>        mB<span class="op">.</span>resize<span class="op">(</span>mStr_size<span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>mStr_size<span class="op">,-</span><span class="dv">1</span><span class="op">));</span></span>
<span id="list:palindrome_partitioning2:iterativecache-24"><a href="#list:palindrome_partitioning2:iterativecache-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> mStr_size<span class="op">-</span><span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span><span class="dv">0</span> <span class="op">;</span> i<span class="op">--)</span></span>
<span id="list:palindrome_partitioning2:iterativecache-25"><a href="#list:palindrome_partitioning2:iterativecache-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="list:palindrome_partitioning2:iterativecache-26"><a href="#list:palindrome_partitioning2:iterativecache-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i <span class="op">;</span> j <span class="op">&lt;</span> mStr_size <span class="op">;</span> j<span class="op">++</span> <span class="op">)</span></span>
<span id="list:palindrome_partitioning2:iterativecache-27"><a href="#list:palindrome_partitioning2:iterativecache-27" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="list:palindrome_partitioning2:iterativecache-28"><a href="#list:palindrome_partitioning2:iterativecache-28" aria-hidden="true" tabindex="-1"></a>                mB<span class="op">[</span>i<span class="op">][</span>j<span class="op">]=(</span>s<span class="op">[</span>i<span class="op">]==</span>s<span class="op">[</span>j<span class="op">])</span> <span class="op">&amp;&amp;</span> <span class="op">((</span>j<span class="op">-</span>i<span class="op">&lt;=</span><span class="dv">2</span><span class="op">)</span> <span class="op">||</span> mB<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="list:palindrome_partitioning2:iterativecache-29"><a href="#list:palindrome_partitioning2:iterativecache-29" aria-hidden="true" tabindex="-1"></a>                <span class="co">//mB[{i,j}]=s[i]==s[j] &amp;&amp; ((j-i&lt;=2) || mB[{i+1,j-1}]);</span></span>
<span id="list:palindrome_partitioning2:iterativecache-30"><a href="#list:palindrome_partitioning2:iterativecache-30" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="list:palindrome_partitioning2:iterativecache-31"><a href="#list:palindrome_partitioning2:iterativecache-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="list:palindrome_partitioning2:iterativecache-32"><a href="#list:palindrome_partitioning2:iterativecache-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:palindrome_partitioning2:iterativecache-33"><a href="#list:palindrome_partitioning2:iterativecache-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2:iterativecache-34"><a href="#list:palindrome_partitioning2:iterativecache-34" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> mB<span class="op">;</span></span>
<span id="list:palindrome_partitioning2:iterativecache-35"><a href="#list:palindrome_partitioning2:iterativecache-35" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">size_t</span> mStr_size<span class="op">;</span></span>
<span id="list:palindrome_partitioning2:iterativecache-36"><a href="#list:palindrome_partitioning2:iterativecache-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2:iterativecache-37"><a href="#list:palindrome_partitioning2:iterativecache-37" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Finally in Listing <a href="#list:palindrome_partitioning2;topdownquadratic" data-reference-type="ref" data-reference="list:palindrome_partitioning2;topdownquadratic">[list:palindrome_partitioning2;topdownquadratic]</a> we can see how such a <em>Substring Palindrome Cache</em> can be used in order to implement a quadratic solution for the problem treated by this chapter. Notice that the code for is almost identical to the one of in Listing <a href="#list:palindrome_partitioning2:topdown" data-reference-type="ref" data-reference="list:palindrome_partitioning2:topdown">[list:palindrome_partitioning2:topdown]</a> with the difference that the former takes <span class="math inline">\(B\)</span>, the substring palindrome cache, as an additional parameter and that, the call to is substituted with a query into <span class="math inline">\(B\)</span> which runs in constant time. The complexity of this solution is now <span class="math inline">\(O(|s|^2)\)</span> which is a big improvement from <span class="math inline">\(O(|s|^3)\)</span>. The space complexity is also <span class="math inline">\(O(|s|^2)\)</span>, because of the space used by <span class="math inline">\(B\)</span>.</p>
<div class="sourceCode" id="list:palindrome_partitioning2;topdownquadratic" data-language="c++" data-caption="Quadratic time dynamic programming bottom-up solution to the palindrome partition problem." label="list:palindrome_partitioning2;topdownquadratic"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:palindrome_partitioning2;topdownquadratic-1"><a href="#list:palindrome_partitioning2;topdownquadratic-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;PalindromeSubstringCacheRecursive.h&quot;</span></span>
<span id="list:palindrome_partitioning2;topdownquadratic-2"><a href="#list:palindrome_partitioning2;topdownquadratic-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2;topdownquadratic-3"><a href="#list:palindrome_partitioning2;topdownquadratic-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2;topdownquadratic-4"><a href="#list:palindrome_partitioning2;topdownquadratic-4" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> palindrome_partitioning2_DP_topdown_optimized_helper<span class="op">(</span><span class="at">const</span> PalindromeSubstringCacheRecursive<span class="op">&amp;</span> B<span class="op">,</span></span>
<span id="list:palindrome_partitioning2;topdownquadratic-5"><a href="#list:palindrome_partitioning2;topdownquadratic-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">size_t</span> start_idx<span class="op">,</span> Cache<span class="op">&amp;</span> memoization_cache<span class="op">)</span></span>
<span id="list:palindrome_partitioning2;topdownquadratic-6"><a href="#list:palindrome_partitioning2;topdownquadratic-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:palindrome_partitioning2;topdownquadratic-7"><a href="#list:palindrome_partitioning2;topdownquadratic-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> size <span class="op">=</span>  B<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:palindrome_partitioning2;topdownquadratic-8"><a href="#list:palindrome_partitioning2;topdownquadratic-8" aria-hidden="true" tabindex="-1"></a>	<span class="cf">if</span><span class="op">(</span>start_idx <span class="op">&gt;=</span> size <span class="op">||</span> B<span class="op">.</span>is_palindrome<span class="op">(</span>start_idx<span class="op">,</span> size<span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">)</span></span>
<span id="list:palindrome_partitioning2;topdownquadratic-9"><a href="#list:palindrome_partitioning2;topdownquadratic-9" aria-hidden="true" tabindex="-1"></a>		<span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:palindrome_partitioning2;topdownquadratic-10"><a href="#list:palindrome_partitioning2;topdownquadratic-10" aria-hidden="true" tabindex="-1"></a>	</span>
<span id="list:palindrome_partitioning2;topdownquadratic-11"><a href="#list:palindrome_partitioning2;topdownquadratic-11" aria-hidden="true" tabindex="-1"></a>	<span class="cf">if</span><span class="op">(</span>memoization_cache<span class="op">.</span>contains<span class="op">(</span>start_idx<span class="op">))</span></span>
<span id="list:palindrome_partitioning2;topdownquadratic-12"><a href="#list:palindrome_partitioning2;topdownquadratic-12" aria-hidden="true" tabindex="-1"></a>		<span class="cf">return</span> memoization_cache<span class="op">[</span>start_idx<span class="op">];</span></span>
<span id="list:palindrome_partitioning2;topdownquadratic-13"><a href="#list:palindrome_partitioning2;topdownquadratic-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2;topdownquadratic-14"><a href="#list:palindrome_partitioning2;topdownquadratic-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">//cout&lt;&lt;start_idx&lt;&lt;std::endl;</span></span>
<span id="list:palindrome_partitioning2;topdownquadratic-15"><a href="#list:palindrome_partitioning2;topdownquadratic-15" aria-hidden="true" tabindex="-1"></a>	<span class="dt">size_t</span> ans <span class="op">=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>max<span class="op">();</span></span>
<span id="list:palindrome_partitioning2;topdownquadratic-16"><a href="#list:palindrome_partitioning2;topdownquadratic-16" aria-hidden="true" tabindex="-1"></a>	<span class="cf">for</span><span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> start_idx <span class="op">;</span> i <span class="op">&lt;</span> size <span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:palindrome_partitioning2;topdownquadratic-17"><a href="#list:palindrome_partitioning2;topdownquadratic-17" aria-hidden="true" tabindex="-1"></a>	<span class="op">{</span></span>
<span id="list:palindrome_partitioning2;topdownquadratic-18"><a href="#list:palindrome_partitioning2;topdownquadratic-18" aria-hidden="true" tabindex="-1"></a>		<span class="cf">if</span><span class="op">(</span>B<span class="op">.</span>is_palindrome<span class="op">(</span>start_idx<span class="op">,</span> i<span class="op">))</span> <span class="co">//O(1)</span></span>
<span id="list:palindrome_partitioning2;topdownquadratic-19"><a href="#list:palindrome_partitioning2;topdownquadratic-19" aria-hidden="true" tabindex="-1"></a>			ans <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>ans<span class="op">,</span> <span class="dv">1</span> <span class="op">+</span> palindrome_partitioning2_DP_topdown_optimized_helper<span class="op">(</span>B<span class="op">,</span>i<span class="op">+</span><span class="dv">1</span><span class="op">,</span>memoization_cache<span class="op">));</span></span>
<span id="list:palindrome_partitioning2;topdownquadratic-20"><a href="#list:palindrome_partitioning2;topdownquadratic-20" aria-hidden="true" tabindex="-1"></a>	<span class="op">}</span></span>
<span id="list:palindrome_partitioning2;topdownquadratic-21"><a href="#list:palindrome_partitioning2;topdownquadratic-21" aria-hidden="true" tabindex="-1"></a>	</span>
<span id="list:palindrome_partitioning2;topdownquadratic-22"><a href="#list:palindrome_partitioning2;topdownquadratic-22" aria-hidden="true" tabindex="-1"></a>	<span class="ot">assert</span><span class="op">(</span>ans <span class="op">&lt;=</span> size <span class="op">-</span> start_idx<span class="op">);</span></span>
<span id="list:palindrome_partitioning2;topdownquadratic-23"><a href="#list:palindrome_partitioning2;topdownquadratic-23" aria-hidden="true" tabindex="-1"></a>	memoization_cache<span class="op">[</span>start_idx<span class="op">]</span> <span class="op">=</span> ans<span class="op">;</span></span>
<span id="list:palindrome_partitioning2;topdownquadratic-24"><a href="#list:palindrome_partitioning2;topdownquadratic-24" aria-hidden="true" tabindex="-1"></a>	<span class="cf">return</span> ans<span class="op">;</span>	</span>
<span id="list:palindrome_partitioning2;topdownquadratic-25"><a href="#list:palindrome_partitioning2;topdownquadratic-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:palindrome_partitioning2;topdownquadratic-26"><a href="#list:palindrome_partitioning2;topdownquadratic-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2;topdownquadratic-27"><a href="#list:palindrome_partitioning2;topdownquadratic-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2;topdownquadratic-28"><a href="#list:palindrome_partitioning2;topdownquadratic-28" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> palindrome_partitioning2_DP_topdown_optimized<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> </span>s<span class="op">)</span></span>
<span id="list:palindrome_partitioning2;topdownquadratic-29"><a href="#list:palindrome_partitioning2;topdownquadratic-29" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:palindrome_partitioning2;topdownquadratic-30"><a href="#list:palindrome_partitioning2;topdownquadratic-30" aria-hidden="true" tabindex="-1"></a>    PalindromeSubstringCacheRecursive B<span class="op">(</span>s<span class="op">);</span></span>
<span id="list:palindrome_partitioning2;topdownquadratic-31"><a href="#list:palindrome_partitioning2;topdownquadratic-31" aria-hidden="true" tabindex="-1"></a>	  Cache memoization_cache<span class="op">;</span></span>
<span id="list:palindrome_partitioning2;topdownquadratic-32"><a href="#list:palindrome_partitioning2;topdownquadratic-32" aria-hidden="true" tabindex="-1"></a>	  <span class="cf">return</span> palindrome_partitioning2_DP_topdown_optimized_helper<span class="op">(</span>B<span class="op">,</span><span class="dv">0</span><span class="bu">u</span><span class="op">,</span> memoization_cache<span class="op">);</span></span>
<span id="list:palindrome_partitioning2;topdownquadratic-33"><a href="#list:palindrome_partitioning2;topdownquadratic-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="bottom-up-1">Bottom-up</h3>
<p>In this section we are going to discuss how we can implement the DP approach shown in Section <a href="#sec:palindrome_partitioning2:DP" data-reference-type="ref" data-reference="sec:palindrome_partitioning2:DP">48.4</a> in a bottom-up fashion.</p>
<p>The idea is that we can start processing progressively longer portions of <span class="math inline">\(s\)</span> starting from the last character at index <span class="math inline">\(|s|-1\)</span>. Each of such portions, starting at index <span class="math inline">\(i\)</span> to the end of <span class="math inline">\(s\)</span> correspond to a sub-problem that can be uniquely identified by its starting index <span class="math inline">\(i\)</span>. For instance subproblem where <span class="math inline">\(i=3\)</span> correspond to a substring of <span class="math inline">\(s\)</span> from index <span class="math inline">\(3\)</span> to its end. When solving a given sub-problem <span class="math inline">\(i\)</span>, we will use the information about sub-problems related to smaller portions of <span class="math inline">\(s\)</span> starting at higher indices <span class="math inline">\(j &gt; i\)</span> to determine the minimum number of cuts necessary to split the substring <span class="math inline">\(s[i \ldots |s|-1]\)</span> it into several palindromes.</p>
<p>The substring of <span class="math inline">\(s\)</span> starting at index <span class="math inline">\(|s|-1\)</span> has size <span class="math inline">\(1\)</span> and therefore is already palindrome and does not need any cuts. For any other substring starting at index <span class="math inline">\(i = |s|-1-k\)</span> where <span class="math inline">\(k \geq 0\)</span>, we have two options:</p>
<ol>
<li><p>if <span class="math inline">\(s[i \ldots |s|-1]\)</span> is already a palindrome, then we know this subproblem has solution equal to <span class="math inline">\(0\)</span>. No cuts are necessary.</p></li>
<li><p>otherwise, we can try to split <span class="math inline">\(s[i \ldots |s|-1]\)</span> at index <span class="math inline">\(i+1 \leq j \leq |s|-1\)</span>. If <span class="math inline">\(s[i \ldots j]\)</span> is a palindrome, then we know we can turn <span class="math inline">\(s[i \ldots |s|-1]\)</span> into a partition of palindromes by using one cut (the one we just performed at index <span class="math inline">\(j\)</span>) plus all the cuts necessary to turn the substring <span class="math inline">\(s[j \ldots |s|-1]\)</span> into a partition of palindrome. The crucial point is that we have already solved the sub-problem <span class="math inline">\(j &gt; i\)</span> and therefore we can reuse its solution. The final answer for this sub-problem starting at index <span class="math inline">\(i\)</span> is the smallest value we can obtain among all the cuts (at index <span class="math inline">\(j &gt; i\)</span>) we can make.</p></li>
</ol>
<p>The sub-problem at index <span class="math inline">\(0\)</span> contains the answer for the entire problem i.e. the smallest size of a palindrome partition of <span class="math inline">\(s\)</span> starting at index <span class="math inline">\(0\)</span>. Listing <a href="#list:palindrome_partitioning2:bottomup" data-reference-type="ref" data-reference="list:palindrome_partitioning2:bottomup">[list:palindrome_partitioning2:bottomup]</a> implements this idea where we use an array having size <span class="math inline">\(|s|+1\)</span> to store the answers to all sub-problems.</p>
<div class="sourceCode" id="list:palindrome_partitioning2:bottomup" data-language="c++" data-caption="Quadratic time dynamic programming bottom-up solution to the palindrome partition problem." label="list:palindrome_partitioning2:bottomup"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:palindrome_partitioning2:bottomup-1"><a href="#list:palindrome_partitioning2:bottomup-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2:bottomup-2"><a href="#list:palindrome_partitioning2:bottomup-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:palindrome_partitioning2:bottomup-3"><a href="#list:palindrome_partitioning2:bottomup-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> palindrome_partitioning2_DP_bottomup<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> </span>s<span class="op">)</span></span>
<span id="list:palindrome_partitioning2:bottomup-4"><a href="#list:palindrome_partitioning2:bottomup-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:palindrome_partitioning2:bottomup-5"><a href="#list:palindrome_partitioning2:bottomup-5" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> DP<span class="op">(</span>s<span class="op">.</span>size<span class="op">()+</span><span class="dv">1</span><span class="op">,</span> s<span class="op">.</span>size<span class="op">()-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="list:palindrome_partitioning2:bottomup-6"><a href="#list:palindrome_partitioning2:bottomup-6" aria-hidden="true" tabindex="-1"></a>  DP<span class="op">[</span>s<span class="op">.</span>size<span class="op">()-</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span>  DP<span class="op">[</span>s<span class="op">.</span>size<span class="op">()]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:palindrome_partitioning2:bottomup-7"><a href="#list:palindrome_partitioning2:bottomup-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="bu">std::</span>ssize<span class="op">(</span>s<span class="op">)-</span><span class="dv">2</span> <span class="op">;</span> i <span class="op">&gt;=</span><span class="dv">0</span> <span class="op">;</span> i<span class="op">--)</span></span>
<span id="list:palindrome_partitioning2:bottomup-8"><a href="#list:palindrome_partitioning2:bottomup-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:palindrome_partitioning2:bottomup-9"><a href="#list:palindrome_partitioning2:bottomup-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span><span class="op">(</span>is_palindrome<span class="op">(</span>s<span class="op">,</span> i<span class="op">,</span> s<span class="op">.</span>size<span class="op">()-</span><span class="dv">1</span><span class="op">)</span> <span class="op">){</span></span>
<span id="list:palindrome_partitioning2:bottomup-10"><a href="#list:palindrome_partitioning2:bottomup-10" aria-hidden="true" tabindex="-1"></a>        DP<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:palindrome_partitioning2:bottomup-11"><a href="#list:palindrome_partitioning2:bottomup-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span><span class="op">;</span></span>
<span id="list:palindrome_partitioning2:bottomup-12"><a href="#list:palindrome_partitioning2:bottomup-12" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="list:palindrome_partitioning2:bottomup-13"><a href="#list:palindrome_partitioning2:bottomup-13" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i <span class="op">;</span> j <span class="op">&lt;</span> <span class="bu">std::</span>ssize<span class="op">(</span>s<span class="op">)</span> <span class="op">;</span> j<span class="op">++){</span></span>
<span id="list:palindrome_partitioning2:bottomup-14"><a href="#list:palindrome_partitioning2:bottomup-14" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span><span class="op">(</span>is_palindrome<span class="op">(</span>s<span class="op">,</span> i<span class="op">,</span> j<span class="op">)){</span></span>
<span id="list:palindrome_partitioning2:bottomup-15"><a href="#list:palindrome_partitioning2:bottomup-15" aria-hidden="true" tabindex="-1"></a>              <span class="at">const</span> <span class="kw">auto</span> cost_partition_rest <span class="op">=</span> j <span class="op">&lt;</span> <span class="bu">std::</span>ssize<span class="op">(</span>s<span class="op">)-</span><span class="dv">1</span> <span class="op">?</span> DP<span class="op">[</span>j<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">:</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:palindrome_partitioning2:bottomup-16"><a href="#list:palindrome_partitioning2:bottomup-16" aria-hidden="true" tabindex="-1"></a>              DP<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>DP<span class="op">[</span>i<span class="op">],</span> <span class="dv">1</span> <span class="op">+</span> cost_partition_rest<span class="op">);</span></span>
<span id="list:palindrome_partitioning2:bottomup-17"><a href="#list:palindrome_partitioning2:bottomup-17" aria-hidden="true" tabindex="-1"></a>          <span class="op">}</span></span>
<span id="list:palindrome_partitioning2:bottomup-18"><a href="#list:palindrome_partitioning2:bottomup-18" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="list:palindrome_partitioning2:bottomup-19"><a href="#list:palindrome_partitioning2:bottomup-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:palindrome_partitioning2:bottomup-20"><a href="#list:palindrome_partitioning2:bottomup-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> DP<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="list:palindrome_partitioning2:bottomup-21"><a href="#list:palindrome_partitioning2:bottomup-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="ch:max_gap">Find the largest gap</h1>
<h2 class="unnumbered" id="introduction-46">Introduction</h2>
<p>The problem discussed in the chapter is another one about sorting. Its statement is quite simple and the only input given is an unsorted array from which we are asked to calculate a value would be trivial to find if the input was sorted. Therefore, the real challenge of this problem is to come-up with a solution that does not require explicit sorting.</p>
<p>Particular attention should be paid to the examples as well as to the problem statement because it is quite easy to misinterpret the real requirements of the function you asked to write if you dive right away into coding. The problem asks you to return the largest distance between any element in the input array provided they appear one next to the other when <span class="math inline">\(I\)</span> is sorted. You might misinterpret the problem by thinking that you need to return the largest distance between any two elements of the original input array. This interpretation is wrong, and your intuition should make you aware of it right away considering that the solution to this problem involves only finding the minimum and the maximum values of the input array. You can expect any coding interview question to be harder than that. An imagination effort (or some pen and paper work) is thus necessary to understand each of the examples provided.</p>
<h2 id="problem-statement-48">Problem statement</h2>
<div class="exercise">
<p><span id="example:max_gap:exercice1" label="example:max_gap:exercice1">[example:max_gap:exercice1]</span> Write a function that given a unsorted array of non-negative integers <span class="math inline">\(I\)</span> of length <span class="math inline">\(n\)</span> returns the largest gap between two elements that would appear one next to the other if <span class="math inline">\(I\)</span> was sorted. A gap between <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> is defined as the absolute value of the difference between <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>: <span class="math inline">\(|x-y|\)</span>.</p>
<div class="example">
<p><span id="example:max_gap:example1" label="example:max_gap:example1">[example:max_gap:example1]</span><br />
Given <span class="math inline">\(I = \{5,3,1,8,9,2,4\}\)</span> the function returns <span class="math inline">\(3\)</span>. Sorting <span class="math inline">\(I\)</span> changes it into: <span class="math inline">\(sort(I)= \{1,2,3,4,5,8,9\}\)</span>, and the largest gap between any two consecutive elements is <span class="math inline">\(3\)</span>. In this case between <span class="math inline">\(5\)</span> and <span class="math inline">\(8\)</span>.</p>
</div>
<div class="example">
<p><span id="example:max_gap:example2" label="example:max_gap:example2">[example:max_gap:example2]</span><br />
Given <span class="math inline">\(I = \{7, 1, 8, 9,15\}\)</span> the function returns <span class="math inline">\(6\)</span>. <span class="math inline">\(sort(I)= \{1,7,8,9,15\}\)</span>, and the largest gap between any two of its consecutive elements is <span class="math inline">\(6\)</span> e.g. between <span class="math inline">\(1\)</span> and <span class="math inline">\(7\)</span> or between <span class="math inline">\(15\)</span> and <span class="math inline">\(9\)</span>.</p>
</div>
</div>
<h2 id="clarification-questions-41">Clarification Questions</h2>
<div class="QandA">
<p>Is the input <span class="math inline">\(I\)</span> modifiable?</p>
<div class="answered">
<p><em>Yes you can modify <span class="math inline">\(I\)</span>.</em></p>
</div>
<p>Is any guarantee or constraint on the value of each element of <span class="math inline">\(I\)</span>?</p>
<div class="answered">
<p><em>You can assume each element of <span class="math inline">\(I\)</span> to fit in a 4 bytes unsigned integer.</em></p>
</div>
</div>
<h2 id="max_gap:sec:trivial">Trivial Solution</h2>
<p>As already mentioned in the introduction this problem has an extremely simple solution when we can afford to get our hands on a sorted version of the input array. In this specific version of the problem <span class="math inline">\(I\)</span> is not read-only and we are allowed to modify it,therefore, we can sort it directly. If that is not possible all you have to do is to create a copy of <span class="math inline">\(I\)</span> and sort that instead.</p>
<p>Given a sorted collection, the largest gap between any two numbers can be find in linear time by just scanning each pair <span class="math inline">\(p=(I_k, I_{k+1)}\)</span> of subsequent elements and for each of them calculate their distance <span class="math inline">\(d_k=I_{k-1}-I_k\)</span>. Among all calculated distances we just return the largest. Listing <a href="#list:max_gap:bruteforce" data-reference-type="ref" data-reference="list:max_gap:bruteforce">[list:max_gap:bruteforce]</a> shows an implementation of this idea. Notice that:</p>
<ul>
<li><p>we do not need to use the absolute value operation as we are operating on a sorted collection and therefore, we are guaranteed that <span class="math inline">\(I_{k+1}\)</span> is larger or equal than <span class="math inline">\(I_k\)</span>.</p></li>
<li><p>the loop stops when <span class="math inline">\(i=|I|-1\)</span> in order to avoid accessing an invalid element while executing . When <span class="math inline">\(i=|I|-1\)</span> this would lead to accessing the element at index <span class="math inline">\(|I|\)</span>, which does not exists. In C++ this would cause undefined behaviour, and the most likely outcome would be a segmentation fault error.</p></li>
</ul>
<div class="sourceCode" id="list:max_gap:bruteforce" data-language="c++" data-caption="Trivial solution to the max gap problem using sorting and linear space." label="list:max_gap:bruteforce"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:max_gap:bruteforce-1"><a href="#list:max_gap:bruteforce-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> max_gap_bruteforce<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> I<span class="op">)</span></span>
<span id="list:max_gap:bruteforce-2"><a href="#list:max_gap:bruteforce-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:max_gap:bruteforce-3"><a href="#list:max_gap:bruteforce-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> I_copy<span class="op">(</span>I<span class="op">);</span></span>
<span id="list:max_gap:bruteforce-4"><a href="#list:max_gap:bruteforce-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ranges<span class="bu">::</span>sort<span class="op">(</span>I_copy<span class="op">);</span></span>
<span id="list:max_gap:bruteforce-5"><a href="#list:max_gap:bruteforce-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="list:max_gap:bruteforce-6"><a href="#list:max_gap:bruteforce-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ans <span class="op">=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>min<span class="op">();</span></span>
<span id="list:max_gap:bruteforce-7"><a href="#list:max_gap:bruteforce-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span> <span class="op">;</span> i <span class="op">&lt;</span> <span class="bu">std::</span>ssize<span class="op">(</span>I<span class="op">)-</span><span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:max_gap:bruteforce-8"><a href="#list:max_gap:bruteforce-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:max_gap:bruteforce-9"><a href="#list:max_gap:bruteforce-9" aria-hidden="true" tabindex="-1"></a>        ans <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>ans<span class="op">,</span> I_copy<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">]-</span>I_copy<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:max_gap:bruteforce-10"><a href="#list:max_gap:bruteforce-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:max_gap:bruteforce-11"><a href="#list:max_gap:bruteforce-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:max_gap:bruteforce-12"><a href="#list:max_gap:bruteforce-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="max_gap:sec:radix_sort">Radix Sort</h2>
<p>The idea we developed in Section <a href="#max_gap:sec:trivial" data-reference-type="ref" data-reference="max_gap:sec:trivial">49.3</a> can be improved if instead of using a normal comparison-based sorting algorithm we use radix-sort<span class="citation" data-cites="cit::wiki::radix_sort"></span>instead. Radix sort will perform better than a standard <span class="math inline">\(O(nlogn)\)</span> algorithm when there is an upper bound for the values of the input array. If we assume that such bound is the largest value a standard 4 bytes can hold then radix sort will have a complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Radix sort works by sorting the input array <span class="math inline">\(d\)</span> times, where <span class="math inline">\(d = \floor{log_{10}k+1}\)</span> and <span class="math inline">\(k\)</span> is the largest number in <span class="math inline">\(I\)</span>. <span class="math inline">\(d\)</span> is just the number of digits of the largest number in the list. For a standard <span class="math inline">\(d=\floor{log_{10}(2147483647) + 1}=10\)</span>. The sorting is obtained by repeatedly sorting the input list from the least to the most significant digit where each of the intermediate sorting steps is performed using counting-sort. For instance given <span class="math inline">\(I =
\{329,457,657,839,436,720,355\}\)</span> the first pass of radix sort will sort <span class="math inline">\(I\)</span> based on the value of the least significant digits. After this first pass we have <span class="math inline">\(I=\{720,355,436,457,657,329,839\}\)</span>. Notice how the first digits are sorted. At this point the algorithm proceed by sorting <span class="math inline">\(I\)</span> further but this time according to their second digit. The resulting list becomes <span class="math inline">\(I=\{720,329,436,839,355,457,657\}\)</span>. Finally the third pass will sort all the elements according the the most significant digit, resulting in a well sorted list: <span class="math inline">\(I=\{329,355,436,457,657,720,839\}\)</span>. Notice that this approach needs to be tweaked in case you want to apply radix sort to negative numbers<a href="#fn36" class="footnote-ref" id="fnref36" role="doc-noteref"><sup>36</sup></a>.</p>
<p>Listing <a href="#list:max_gap:radixsort" data-reference-type="ref" data-reference="list:max_gap:radixsort">[list:max_gap:radixsort]</a> shows an implementation of radix-sort and its application to the solution of this chapter’s problem.</p>
<div class="sourceCode" id="list:max_gap:radixsort" data-language="c++" data-caption="Linear time solution to the max gap problem using radix-sort." label="list:max_gap:radixsort"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:max_gap:radixsort-1"><a href="#list:max_gap:radixsort-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> count_sort<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> I<span class="op">,</span> <span class="at">const</span> <span class="dt">unsigned</span> base <span class="op">,</span> <span class="at">const</span> <span class="dt">unsigned</span> digit_idx<span class="op">)</span></span>
<span id="list:max_gap:radixsort-2"><a href="#list:max_gap:radixsort-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:max_gap:radixsort-3"><a href="#list:max_gap:radixsort-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> counters<span class="op">(</span>base<span class="op">);</span></span>
<span id="list:max_gap:radixsort-4"><a href="#list:max_gap:radixsort-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> el <span class="op">:</span> I<span class="op">)</span></span>
<span id="list:max_gap:radixsort-5"><a href="#list:max_gap:radixsort-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:max_gap:radixsort-6"><a href="#list:max_gap:radixsort-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">//get the digit_idx th digit</span></span>
<span id="list:max_gap:radixsort-7"><a href="#list:max_gap:radixsort-7" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="kw">auto</span> digit_value <span class="op">=</span> el<span class="op">/(</span><span class="bu">std::</span>pow<span class="op">(</span>base<span class="op">,</span> digit_idx<span class="op">))%</span>base<span class="op">;</span></span>
<span id="list:max_gap:radixsort-8"><a href="#list:max_gap:radixsort-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">//add this number to the corrensponding bucket</span></span>
<span id="list:max_gap:radixsort-9"><a href="#list:max_gap:radixsort-9" aria-hidden="true" tabindex="-1"></a>        counters<span class="op">[</span>digit_value<span class="op">].</span>push_back<span class="op">(</span>el<span class="op">);</span></span>
<span id="list:max_gap:radixsort-10"><a href="#list:max_gap:radixsort-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:max_gap:radixsort-11"><a href="#list:max_gap:radixsort-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_gap:radixsort-12"><a href="#list:max_gap:radixsort-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> pos <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:max_gap:radixsort-13"><a href="#list:max_gap:radixsort-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> list <span class="op">:</span> counters<span class="op">)</span></span>
<span id="list:max_gap:radixsort-14"><a href="#list:max_gap:radixsort-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:max_gap:radixsort-15"><a href="#list:max_gap:radixsort-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> num <span class="op">:</span> list<span class="op">)</span></span>
<span id="list:max_gap:radixsort-16"><a href="#list:max_gap:radixsort-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="list:max_gap:radixsort-17"><a href="#list:max_gap:radixsort-17" aria-hidden="true" tabindex="-1"></a>            I<span class="op">[</span>pos<span class="op">++]</span> <span class="op">=</span>  num<span class="op">;</span></span>
<span id="list:max_gap:radixsort-18"><a href="#list:max_gap:radixsort-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="list:max_gap:radixsort-19"><a href="#list:max_gap:radixsort-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:max_gap:radixsort-20"><a href="#list:max_gap:radixsort-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:max_gap:radixsort-21"><a href="#list:max_gap:radixsort-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_gap:radixsort-22"><a href="#list:max_gap:radixsort-22" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> radix_sort<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> I<span class="op">,</span> <span class="at">const</span> <span class="dt">unsigned</span> base <span class="op">=</span> <span class="dv">10</span><span class="op">)</span></span>
<span id="list:max_gap:radixsort-23"><a href="#list:max_gap:radixsort-23" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:max_gap:radixsort-24"><a href="#list:max_gap:radixsort-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">unsigned</span> digit <span class="op">=</span> <span class="dv">0</span> <span class="op">;</span> digit <span class="op">&lt;</span> base <span class="op">;</span> digit<span class="op">++)</span></span>
<span id="list:max_gap:radixsort-25"><a href="#list:max_gap:radixsort-25" aria-hidden="true" tabindex="-1"></a>        count_sort<span class="op">(</span>I<span class="op">,</span> base<span class="op">,</span> digit<span class="op">);</span></span>
<span id="list:max_gap:radixsort-26"><a href="#list:max_gap:radixsort-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:max_gap:radixsort-27"><a href="#list:max_gap:radixsort-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_gap:radixsort-28"><a href="#list:max_gap:radixsort-28" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> max_gap_radix_sort<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> I<span class="op">)</span></span>
<span id="list:max_gap:radixsort-29"><a href="#list:max_gap:radixsort-29" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:max_gap:radixsort-30"><a href="#list:max_gap:radixsort-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> I_copy<span class="op">(</span>I<span class="op">);</span></span>
<span id="list:max_gap:radixsort-31"><a href="#list:max_gap:radixsort-31" aria-hidden="true" tabindex="-1"></a>    radix_sort<span class="op">(</span>I_copy<span class="op">);</span></span>
<span id="list:max_gap:radixsort-32"><a href="#list:max_gap:radixsort-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="list:max_gap:radixsort-33"><a href="#list:max_gap:radixsort-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ans <span class="op">=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>min<span class="op">();</span></span>
<span id="list:max_gap:radixsort-34"><a href="#list:max_gap:radixsort-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span> <span class="op">;</span> i <span class="op">&lt;</span> <span class="bu">std::</span>ssize<span class="op">(</span>I<span class="op">)-</span><span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:max_gap:radixsort-35"><a href="#list:max_gap:radixsort-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:max_gap:radixsort-36"><a href="#list:max_gap:radixsort-36" aria-hidden="true" tabindex="-1"></a>        ans <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>ans<span class="op">,</span> I_copy<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">]-</span>I_copy<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:max_gap:radixsort-37"><a href="#list:max_gap:radixsort-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:max_gap:radixsort-38"><a href="#list:max_gap:radixsort-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:max_gap:radixsort-39"><a href="#list:max_gap:radixsort-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice how the main driver function is basically the same as from Listing <a href="#list:max_gap:bruteforce" data-reference-type="ref" data-reference="list:max_gap:bruteforce">[list:max_gap:bruteforce]</a> except for the sorting procedure used.</p>
<h2 id="max_gap:sec:buckets">Buckets and the pigeonhole principle</h2>
<p>All the solutions we have presented so far rely on sorting. In this section we are going to discuss an approach that relies on the pigeonhole principle<a href="#fn37" class="footnote-ref" id="fnref37" role="doc-noteref"><sup>37</sup></a> and bucketing. The general idea is that we could split the entire array into several buckets and then find the largest gap by only comparing one element of a given bucket to one element of the subsequent bucket.</p>
<p>You can think of <span class="math inline">\(I\)</span> as an array of buckets each containing a single element. <span class="math inline">\(|I|\)</span> is made of <span class="math inline">\(b\)</span> buckets and the total amount of element in <span class="math inline">\(I\)</span> is <span class="math inline">\(n=b\)</span>. Imagine for a moment that you would reduce the number of buckets from <span class="math inline">\(b\)</span> to some integer <span class="math inline">\(k &lt; b\)</span>. For the pigeonhole principle then, one or more of the buckets in <span class="math inline">\(I\)</span> have to contain strictly more than one element.</p>
<p>Let’s now focus for a moment of the gaps of an ideal collection where each its of the elements has a the same distance <span class="math inline">\(t\)</span> from its successor in the list. If such a collection is composed of <span class="math inline">\(n\)</span> elements, then there is a total of <span class="math inline">\(n-1\)</span> gaps, each of size <span class="math inline">\(t\)</span>. <span class="math inline">\(t\)</span> can be easily calculate if the maximum and minimum values are known: in-fact <span class="math inline">\(t=\frac{max-min}{n-1}\)</span>. For instance for the collection of five elements <span class="math inline">\(\{4,8,12,16,20\}\)</span> we have <span class="math inline">\(t=\frac{20-4}{4}\)</span> and for the <span class="math inline">\(\{-2,5,12,19\}\)</span> we have <span class="math inline">\(t=\frac{19- (-2)}{3} = 7\)</span>. If <span class="math inline">\(I\)</span> was like this ideal collection then the problem would be easily solved by using the formula above.</p>
<p><span class="math inline">\(I\)</span> is different to this ideal collection because elements do not have uniform gaps between each other. In this situation then we can argue that the maximum gap between any pair of subsequent elements of <span class="math inline">\(I\)</span> is always larger than <span class="math inline">\(t=\frac{max-min}{n-1}\)</span>. We can show this by taking an ideal collection <span class="math inline">\(C\)</span> and try to reduce the gap between any two subsequent elements <span class="math inline">\(C_{i}\)</span> and <span class="math inline">\(C_{i+1}\)</span>. We can do that by moving <span class="math inline">\(I_{i+1}\)</span> closer to <span class="math inline">\(I_{i}\)</span>. When this happens the gap <span class="math inline">\((I_{i+1}-I_{i})\)</span> becomes smaller than <span class="math inline">\(t\)</span>. So far all is looking promising. But what happens to the gap between <span class="math inline">\(I_{i+1}\)</span> and <span class="math inline">\(I_{i+2}\)</span>? It actually becomes larger than <span class="math inline">\(t\)</span>! In our effort to make the largest gap among two subsequent elements smaller, we obtained the opposite result: we made it larger. Figure <a href="#fig:max_gap:move_t" data-reference-type="ref" data-reference="fig:max_gap:move_t">49.1</a> shows an example of such scenario where we have a collection of uniformly separated elements where <span class="math inline">\(t  = 2\)</span>. When the third element is moved by one toward the second, you see that the gap between them is reduced from <span class="math inline">\(2\)</span> to <span class="math inline">\(1\)</span> but the gap between the third and the fourth element increases from <span class="math inline">\(2\)</span> to <span class="math inline">\(3\)</span>, and now the largest gap between any two pair of subsequent element is no more <span class="math inline">\(2\)</span> but <span class="math inline">\(3\)</span> which is larger than what we had to begin with. This shows that the maximum attainable gap can in a collection with uniform gaps can only increase.</p>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/max_gap/images/move_t.jpg" id="fig:max_gap:move_t" alt="Example of how trying to reduce the gap between pairs of subsequent element of a uniformly separated collections makes the largest gap larger." /><figcaption aria-hidden="true">Example of how trying to reduce the gap between pairs of subsequent element of a uniformly separated collections makes the largest gap larger.</figcaption>
</figure>
<p>. <span id="fig:max_gap:move_t" label="fig:max_gap:move_t">[fig:max_gap:move_t]</span></p>
<p>We are going to apply the two ideas above to solve this problem in the following way. We will distribute all the elements of <span class="math inline">\(I\)</span> into <span class="math inline">\(n-1\)</span> buckets. The first bucket would contains all the elements of <span class="math inline">\(I\)</span> in the following range: <span class="math inline">\([min, min + t)\)</span>. Similarly the second buckets will contain all the elements in the following range: <span class="math inline">\([min + t, min + 2t)\)</span>. In general the <span class="math inline">\(i^{th}\)</span> bucket would contain all the elements of <span class="math inline">\(I\)</span> in the following range: <span class="math inline">\([min + (i-1)t, min+it)\)</span> (where <span class="math inline">\(1
\leq i\)</span>). You can refer to Figure <a href="#fig:max_gap:bucketing_example2" data-reference-type="ref" data-reference="fig:max_gap:bucketing_example2">49.2</a> for an example of how such a division into buckets would work for the input array in Example <a href="#example:max_gap:example2" data-reference-type="ref" data-reference="example:max_gap:example2">[example:max_gap:example2]</a>. This allows us to skip comparing all the element within a bucket because we know for sure they will have a distance that is lower of equal than <span class="math inline">\(t\)</span> and we can therefore only concentrate on comparing elements of subsequent buckets. In particular we should compare the maximum value of the <span class="math inline">\(i^{th}\)</span> bucket with the minimum value of the <span class="math inline">\((i+1)^{th}\)</span> bucket. Why? Because they would appear one next to the other if <span class="math inline">\(I\)</span> was sorted. Because the number of buckets is always lower of equal than the number of elements in the collection, this approach has a linear time complexity as it does require to compare at most twice the number of input elements in <span class="math inline">\(I\)</span>. The space complexity is also linear as the number of buckets can be proportional to <span class="math inline">\(|I|\)</span>.</p>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/max_gap/images/bucketing_example1.jpg" id="fig:max_gap:bucketing_example2" alt="Division of the elements of the Example [example:max_gap:example2] into buckets." /><figcaption aria-hidden="true">Division of the elements of the Example <a href="#example:max_gap:example2" data-reference-type="ref" data-reference="example:max_gap:example2">[example:max_gap:example2]</a> into buckets.</figcaption>
</figure>
<p>. <span id="fig:max_gap:bucketing_example2" label="fig:max_gap:bucketing_example2">[fig:max_gap:bucketing_example2]</span></p>
<p>Listing <a href="#list:max_gap:buckets" data-reference-type="ref" data-reference="list:max_gap:buckets">[list:max_gap:buckets]</a> shows an implementation of this idea where we use the to model a bucket for which we only need to store three pieces of information:</p>
<div class="enumerate*">
<p>if the buckets contains at least one elements,</p>
<p>its minimum</p>
<p>and the maximum value</p>
</div>
<p>. If <span class="math inline">\(|I| &lt; 2\)</span> we can immediately return <span class="math inline">\(0\)</span> as there are no possible pairs to calculate the gap for. Otherwise we proceed in calculating <span class="math inline">\(t\)</span> and the number of buckets we need. The first loop takes care of filling each of the buckets an element belongs to. Notice that we can calculate such index for an element <span class="math inline">\(el\)</span> by using the following expression: <span class="math inline">\(\frac{el- \min(I)}{t}\)</span>. Once all the buckets are initialized, then we can proceed by calculating the largest gap between them by paying attention not to consider empty buckets which are ignored during the second loop. We proceed by considering the max element of the first bucket with the minimum element of the next non-empty bucket <span class="math inline">\(j &gt; 0\)</span>. Once the gap between them is calculated, we can move onto calculating the gap between the next pair of subsequent buckets which will be made of the bucket at index <span class="math inline">\(j\)</span> and the first non-empty bucket having index larger than <span class="math inline">\(j\)</span>. This process is repeated until all pairs of buckets are processed.</p>
<div class="sourceCode" id="list:max_gap:buckets" data-language="c++" data-caption="Linear time solution to the max gap problem using bucketing." label="list:max_gap:buckets"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:max_gap:buckets-1"><a href="#list:max_gap:buckets-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Bucket <span class="op">{</span></span>
<span id="list:max_gap:buckets-2"><a href="#list:max_gap:buckets-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> used <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="list:max_gap:buckets-3"><a href="#list:max_gap:buckets-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> minval <span class="op">=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>max<span class="op">();</span> </span>
<span id="list:max_gap:buckets-4"><a href="#list:max_gap:buckets-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxval <span class="op">=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>min<span class="op">();</span></span>
<span id="list:max_gap:buckets-5"><a href="#list:max_gap:buckets-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="list:max_gap:buckets-6"><a href="#list:max_gap:buckets-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_gap:buckets-7"><a href="#list:max_gap:buckets-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> max_gap_buckets<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> I<span class="op">)</span></span>
<span id="list:max_gap:buckets-8"><a href="#list:max_gap:buckets-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:max_gap:buckets-9"><a href="#list:max_gap:buckets-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>I<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="list:max_gap:buckets-10"><a href="#list:max_gap:buckets-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:max_gap:buckets-11"><a href="#list:max_gap:buckets-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_gap:buckets-12"><a href="#list:max_gap:buckets-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> <span class="op">[</span>minEl<span class="op">,</span>maxEl<span class="op">]</span> <span class="op">=</span> <span class="op">[&amp;</span>I<span class="op">]()</span> <span class="op">{</span></span>
<span id="list:max_gap:buckets-13"><a href="#list:max_gap:buckets-13" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="kw">auto</span> p <span class="op">=</span> <span class="bu">std::</span>minmax_element<span class="op">(</span>I<span class="op">.</span>begin<span class="op">(),</span> I<span class="op">.</span>end<span class="op">());</span></span>
<span id="list:max_gap:buckets-14"><a href="#list:max_gap:buckets-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>make_tuple<span class="op">(*</span>p<span class="op">.</span>first<span class="op">,</span> <span class="op">*</span>p<span class="op">.</span>second<span class="op">);</span></span>
<span id="list:max_gap:buckets-15"><a href="#list:max_gap:buckets-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}();</span></span>
<span id="list:max_gap:buckets-16"><a href="#list:max_gap:buckets-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="list:max_gap:buckets-17"><a href="#list:max_gap:buckets-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_gap:buckets-18"><a href="#list:max_gap:buckets-18" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> t <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span><span class="dv">1</span><span class="bu">l</span><span class="op">,(</span>maxEl <span class="op">-</span> minEl<span class="op">)</span> <span class="op">/</span> <span class="op">(</span><span class="bu">std::</span>ssize<span class="op">(</span>I<span class="op">)</span> <span class="op">-</span> <span class="dv">1</span><span class="op">));</span> <span class="co">// bucket size or capacity</span></span>
<span id="list:max_gap:buckets-19"><a href="#list:max_gap:buckets-19" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">size_t</span> num_buckets <span class="op">=</span> <span class="op">((</span>maxEl <span class="op">-</span> minEl<span class="op">)</span> <span class="op">/</span> t<span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span>      <span class="co">// number of buckets</span></span>
<span id="list:max_gap:buckets-20"><a href="#list:max_gap:buckets-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>Bucket<span class="op">&gt;</span> buckets<span class="op">(</span>num_buckets<span class="op">);</span></span>
<span id="list:max_gap:buckets-21"><a href="#list:max_gap:buckets-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_gap:buckets-22"><a href="#list:max_gap:buckets-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> el <span class="op">:</span> I<span class="op">)</span> <span class="op">{</span></span>
<span id="list:max_gap:buckets-23"><a href="#list:max_gap:buckets-23" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="dt">size_t</span> bucketIdx <span class="op">=</span> <span class="op">(</span>el <span class="op">-</span> minEl<span class="op">)</span> <span class="op">/</span> t<span class="op">;</span>   <span class="co">// bucket idx for this element</span></span>
<span id="list:max_gap:buckets-24"><a href="#list:max_gap:buckets-24" aria-hidden="true" tabindex="-1"></a>        buckets<span class="op">[</span>bucketIdx<span class="op">].</span>used <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="list:max_gap:buckets-25"><a href="#list:max_gap:buckets-25" aria-hidden="true" tabindex="-1"></a>        buckets<span class="op">[</span>bucketIdx<span class="op">].</span>minval <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>el<span class="op">,</span> buckets<span class="op">[</span>bucketIdx<span class="op">].</span>minval<span class="op">);</span></span>
<span id="list:max_gap:buckets-26"><a href="#list:max_gap:buckets-26" aria-hidden="true" tabindex="-1"></a>        buckets<span class="op">[</span>bucketIdx<span class="op">].</span>maxval <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>el<span class="op">,</span> buckets<span class="op">[</span>bucketIdx<span class="op">].</span>maxval<span class="op">);</span></span>
<span id="list:max_gap:buckets-27"><a href="#list:max_gap:buckets-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:max_gap:buckets-28"><a href="#list:max_gap:buckets-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_gap:buckets-29"><a href="#list:max_gap:buckets-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> prevBucketMax <span class="op">=</span> minEl<span class="op">,</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:max_gap:buckets-30"><a href="#list:max_gap:buckets-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span><span class="op">&amp;&amp;</span> bucket <span class="op">:</span> buckets<span class="op">)</span> <span class="op">{</span></span>
<span id="list:max_gap:buckets-31"><a href="#list:max_gap:buckets-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>bucket<span class="op">.</span>used<span class="op">)</span> <span class="co">//skip empty buckets</span></span>
<span id="list:max_gap:buckets-32"><a href="#list:max_gap:buckets-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span><span class="op">;</span></span>
<span id="list:max_gap:buckets-33"><a href="#list:max_gap:buckets-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_gap:buckets-34"><a href="#list:max_gap:buckets-34" aria-hidden="true" tabindex="-1"></a>        ans <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>ans<span class="op">,</span> bucket<span class="op">.</span>minval <span class="op">-</span> prevBucketMax<span class="op">);</span></span>
<span id="list:max_gap:buckets-35"><a href="#list:max_gap:buckets-35" aria-hidden="true" tabindex="-1"></a>        prevBucketMax <span class="op">=</span> bucket<span class="op">.</span>maxval<span class="op">;</span></span>
<span id="list:max_gap:buckets-36"><a href="#list:max_gap:buckets-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:max_gap:buckets-37"><a href="#list:max_gap:buckets-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:max_gap:buckets-38"><a href="#list:max_gap:buckets-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:max_gap:buckets-39"><a href="#list:max_gap:buckets-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="ch:smallest_range">Smallest Range I and II</h1>
<h2 class="unnumbered" id="introduction-47">Introduction</h2>
<p>This chapter discusses a problem and one of its variations on arrays. Both are very common interview questions, with the former having a really easy solution, and the latter being slightly more complex. Both variants however, can be solved by starting from the same idea and in just a handful of lines of code.</p>
<h2 id="problem-statement-49">Problem statement</h2>
<div class="exercise">
<p><span id="example:smallest_range:exercice1" label="example:smallest_range:exercice1">[example:smallest_range:exercice1]</span> Write a function that given given an array of integers <span class="math inline">\(I\)</span> and an integer <span class="math inline">\(K \geq 0\)</span> returns the smallest possible difference between the smallest and largest value in <span class="math inline">\(I\)</span> after you have added to each of the elements <span class="math inline">\(-K \leq p \leq K\)</span>.</p>
<div class="example">
<p><span id="example:smallest_range:example1" label="example:smallest_range:example1">[example:smallest_range:example1]</span><br />
Given <span class="math inline">\(I = \{3,5,1,7,8\}\)</span> and <span class="math inline">\(K=4\)</span> the function returns <span class="math inline">\(0\)</span>. You can add to <span class="math inline">\(I\)</span> the followings values: <span class="math inline">\(\{1,-1,3,-3,-4\}\)</span>. The modified array becomes: <span class="math inline">\(B=\{4,4,4,4,4\}\)</span>.</p>
</div>
<div class="example">
<p><span id="example:smallest_range:example2" label="example:smallest_range:example2">[example:smallest_range:example2]</span><br />
Given <span class="math inline">\(I = \{1,9,4\}\)</span> and <span class="math inline">\(K=2\)</span> the function returns <span class="math inline">\(4\)</span>.</p>
</div>
</div>
<h2 id="clarification-questions-42">Clarification Questions</h2>
<div class="QandA">
<p>Can you add <span class="math inline">\(p\)</span> multiple times to an element of <span class="math inline">\(I\)</span>?</p>
<div class="answered">
<p><em>No, you can only add <span class="math inline">\(p\)</span> once to each element of <span class="math inline">\(I\)</span>.</em></p>
</div>
</div>
<h2 id="smallest_range:sec:discussion">Discussion</h2>
<p>For this problem we are going to skip even discussing a brute-force solution<a href="#fn38" class="footnote-ref" id="fnref38" role="doc-noteref"><sup>38</sup></a> because it is impractical to actually code it during an interview. Moreover, such a solution is conceptually very different and time complexity-wise far off from the one that allows us to solve this problem efficiently. So let’s jump directly into the core of a good solution.</p>
<p>The problem is asking us to minimize the difference between the largest value (<span class="math inline">\(M\)</span>) and the smallest value (<span class="math inline">\(m\)</span>) of <span class="math inline">\(I\)</span> after we have processed it by adding to each and every of its element a value in the range <span class="math inline">\([-K,+K]\)</span>. Let’s call <span class="math inline">\(B\)</span> this post-processed version of <span class="math inline">\(I\)</span>. We know that if <span class="math inline">\(K\)</span> is large enough<a href="#fn39" class="footnote-ref" id="fnref39" role="doc-noteref"><sup>39</sup></a> so that we can modify <span class="math inline">\(M\)</span> and <span class="math inline">\(m\)</span> to be the same value by subtracting from <span class="math inline">\(M\)</span> and adding to <span class="math inline">\(m\)</span>, then we make all the elements of <span class="math inline">\(I\)</span> equal, thus reducing the difference between <span class="math inline">\(I\)</span>’s smallest and the largest element to zero (see Figure <a href="#fig:smallest_range:explanation2" data-reference-type="ref" data-reference="fig:smallest_range:explanation2">50.2</a>). This is possible because <span class="math inline">\(M-m\)</span> is the largest difference in <span class="math inline">\(I\)</span> and if we can effectively close their gap to <span class="math inline">\(0\)</span> then we can do the same with any other difference between any pair of elements of <span class="math inline">\(I\)</span>. On the other hand, if <span class="math inline">\(K\)</span> is not large enough<a href="#fn40" class="footnote-ref" id="fnref40" role="doc-noteref"><sup>40</sup></a> , then all we know is that we can reduce the difference between <span class="math inline">\(m\)</span> and <span class="math inline">\(M\)</span> to <span class="math inline">\(d=(M-K)-(m+K)\)</span>. Notice that in this case <span class="math inline">\(d &gt; 0\)</span> (see Figure <a href="#fig:smallest_range:explanation1" data-reference-type="ref" data-reference="fig:smallest_range:explanation1">50.1</a>). Moreover, similarly to what we have discussed above, because the difference between any other pair of elements of <span class="math inline">\(I\)</span> is smaller or equal than (<span class="math inline">\(M-m\)</span>), we also know that their differences can be made at least equal or smaller than <span class="math inline">\(d\)</span>.</p>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/smallest_range/images/explanation1.jpg" id="fig:smallest_range:explanation1" alt="m and M are the smallest and largest element of I, respectively. You can bring them closer together by adding K to m and subtracting K to M. d is the difference between these two new values. d will always be larger than any other difference you can obtain the same way. You can see that any other pair (I[i], I[j]) will have smaller difference because they are closer together to begin with." /><figcaption aria-hidden="true"><span class="math inline">\(m\)</span> and <span class="math inline">\(M\)</span> are the smallest and largest element of <span class="math inline">\(I\)</span>, respectively. You can bring them closer together by adding <span class="math inline">\(K\)</span> to <span class="math inline">\(m\)</span> and subtracting <span class="math inline">\(K\)</span> to <span class="math inline">\(M\)</span>. <span class="math inline">\(d\)</span> is the difference between these two new values. <span class="math inline">\(d\)</span> will always be larger than any other difference you can obtain the same way. You can see that any other pair <span class="math inline">\((I[i], I[j])\)</span> will have smaller difference because they are closer together to begin with.</figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/smallest_range/images/explanation2.jpg" id="fig:smallest_range:explanation2" alt="m and M are the smallest and largest element of I, respectively. If we add K to m and subtract K to M then in this case (m+K) will be larger than (M-K). This means that we can add to m and subtract to M a number p \leq K such that m+p =
		M-p. Because any other number in I is larger than m and smaller than M we can do the same with them, so that we bring all the elements to the same value." /><figcaption aria-hidden="true"><span class="math inline">\(m\)</span> and <span class="math inline">\(M\)</span> are the smallest and largest element of <span class="math inline">\(I\)</span>, respectively. If we add <span class="math inline">\(K\)</span> to <span class="math inline">\(m\)</span> and subtract <span class="math inline">\(K\)</span> to <span class="math inline">\(M\)</span> then in this case <span class="math inline">\((m+K)\)</span> will be larger than <span class="math inline">\((M-K)\)</span>. This means that we can add to <span class="math inline">\(m\)</span> and subtract to <span class="math inline">\(M\)</span> a number <span class="math inline">\(p \leq K\)</span> such that <span class="math inline">\(m+p =
		M-p\)</span>. Because any other number in <span class="math inline">\(I\)</span> is larger than <span class="math inline">\(m\)</span> and smaller than <span class="math inline">\(M\)</span> we can do the same with them, so that we bring all the elements to the same value.</figcaption>
</figure>
<p><span label="">[]</span></p>
<p>Therefore in order to solve this problem we only have to look at <span class="math inline">\(M\)</span> and <span class="math inline">\(m\)</span> and calculate <span class="math inline">\(d=(M-K)-(m+K)\)</span>. If <span class="math inline">\(d \leq 0\)</span> then it means that we can make all the elements of <span class="math inline">\(I\)</span> equal and the function should return <span class="math inline">\(0\)</span>, otherwise we can safely return <span class="math inline">\(d\)</span> as an answer.</p>
<p>You can find an implementation of this idea in Listing <a href="#list:smallest_range:solution1" data-reference-type="ref" data-reference="list:smallest_range:solution1">[list:smallest_range:solution1]</a> which has <span class="math inline">\(O(|I|)\)</span> time and <span class="math inline">\(O(1)\)</span> space complexity. The <a href="#fn41" class="footnote-ref" id="fnref41" role="doc-noteref"><sup>41</sup></a> function returns a pair of iterators pointing to the minimum and maximum element of the input range, respectively.</p>
<div class="sourceCode" id="list:smallest_range:solution1" data-language="c++" data-caption="Solution to the \textit{smallest range} problem." label="list:smallest_range:solution1"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:smallest_range:solution1-1"><a href="#list:smallest_range:solution1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> smallest_range_I<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> I<span class="op">,</span> <span class="at">const</span> <span class="dt">int</span> K<span class="op">)</span> <span class="op">{</span></span>
<span id="list:smallest_range:solution1-2"><a href="#list:smallest_range:solution1-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[</span>m<span class="op">,</span>M<span class="op">]</span>   <span class="op">=</span> <span class="bu">std::</span>minmax_element<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>I<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>I<span class="op">));</span></span>
<span id="list:smallest_range:solution1-3"><a href="#list:smallest_range:solution1-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> d <span class="op">=</span> <span class="op">(*</span>M<span class="op">-</span>K<span class="op">)</span> <span class="op">-</span> <span class="op">(*</span>m<span class="op">+</span>K<span class="op">);</span></span>
<span id="list:smallest_range:solution1-4"><a href="#list:smallest_range:solution1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>max<span class="op">(</span><span class="dv">0</span><span class="op">,</span> d<span class="op">);</span></span>
<span id="list:smallest_range:solution1-5"><a href="#list:smallest_range:solution1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="common-variations-4">Common Variations</h2>
<h3 id="smallest-range-ii">Smallest range II </h3>
<p>This variant is almost identical to the main problem of this chapter (see Exercise <a href="#example:smallest_range:exercice1" data-reference-type="ref" data-reference="example:smallest_range:exercice1">[example:smallest_range:exercice1]</a>) except that this time we are only allowed to add either <span class="math inline">\(-K\)</span> or <span class="math inline">\(+K\)</span> (and not any number in the range <span class="math inline">\([-K,K\)</span>) to each and every element of the input array <span class="math inline">\(I\)</span>. As we shall see, this complicates things quite a bit, but, nevertheless, the core solution strategy remains the same.</p>
<div class="exercise">
<p><span id="example:smallest_range:variation1:exercice1" label="example:smallest_range:variation1:exercice1">[example:smallest_range:variation1:exercice1]</span> Write a function that given given an array of integers <span class="math inline">\(I\)</span> and an integer <span class="math inline">\(K\)</span> returns the smallest possible difference between the smallest and largest value in <span class="math inline">\(I\)</span> after you have added to each of the elements either <span class="math inline">\(-K\)</span> or <span class="math inline">\(K\)</span>.</p>
<div class="example">
<p><span id="example:smallest_range:variation1:example1" label="example:smallest_range:variation1:example1">[example:smallest_range:variation1:example1]</span><br />
Given <span class="math inline">\(I = \{3,5,1,7,8\}\)</span> and <span class="math inline">\(K=2\)</span> the function returns <span class="math inline">\(3\)</span>. You can modify add to <span class="math inline">\(I\)</span> the followings values <span class="math inline">\(\{2,-2,2,-2,-2\}\)</span>. The modified array finally becomes: <span class="math inline">\(I&#39;=\{5,3,3,5,6\}\)</span>.</p>
</div>
<div class="example">
<p><span id="example:smallest_range:variation1:example2" label="example:smallest_range:variation1:example2">[example:smallest_range:variation1:example2]</span><br />
Given <span class="math inline">\(I = \{1,9,4\}\)</span> and <span class="math inline">\(K=3\)</span> the function returns <span class="math inline">\(3\)</span>.</p>
</div>
</div>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/smallest_range/images/bars.jpg" id="fig:smallest_range:bars_full" alt="This figure is visual representation of the Example [example:smallest_range:variation1:example1] where the highlighted boxes represent the input values, the white boxes on the higher part of the picture represent the values we can get by adding K to the corresponding element and the white boxes in the bottom part of the picture shows the values we can get by subtracting K to them." /><figcaption aria-hidden="true">This figure is visual representation of the Example <a href="#example:smallest_range:variation1:example1" data-reference-type="ref" data-reference="example:smallest_range:variation1:example1">[example:smallest_range:variation1:example1]</a> where the highlighted boxes represent the input values, the white boxes on the higher part of the picture represent the values we can get by adding <span class="math inline">\(K\)</span> to the corresponding element and the white boxes in the bottom part of the picture shows the values we can get by subtracting <span class="math inline">\(K\)</span> to them.</figcaption>
</figure>
<h2 id="smallest_range:sec:discussion">Discussion</h2>
<p>Let’s start by noticing that the solution to this problem is always smaller or equal than the difference between the largest (<span class="math inline">\(M)\)</span> and smaller <span class="math inline">\((m)\)</span> elements of <span class="math inline">\(I\)</span>. This is the case because in the worst case we can either add or subtract <span class="math inline">\(K\)</span> to all of the elements of <span class="math inline">\(I\)</span> and therefore preserve the relative difference between all the elements of <span class="math inline">\(I\)</span> (including <span class="math inline">\(M\)</span> and <span class="math inline">\(m\)</span>). We have this case when <span class="math inline">\((M-m) \leq K\)</span> because subtracting and adding <span class="math inline">\(K\)</span> to <span class="math inline">\(M\)</span> and <span class="math inline">\(m\)</span>, respectively, would eventually lead to a larger or equal difference<a href="#fn42" class="footnote-ref" id="fnref42" role="doc-noteref"><sup>42</sup></a>.</p>
<p>When <span class="math inline">\((M-m) &gt; K\)</span> then what we can do is to choose one element at index <span class="math inline">\(j\)</span> as a sort of pivot point and add <span class="math inline">\(K\)</span> to all the elements smaller or equal than <span class="math inline">\(I_j\)</span> and subtract <span class="math inline">\(K\)</span> to all of the elements of <span class="math inline">\(I\)</span> greater than <span class="math inline">\(I_j\)</span>. The new gap depends on the new smallest (<span class="math inline">\(m&#39;\)</span>) and largest elements (<span class="math inline">\(M&#39;\)</span>). Given <span class="math inline">\(p\)</span> is the smallest element larger than <span class="math inline">\(I_j\)</span> then, <span class="math inline">\(M&#39;\)</span> is the largest among <span class="math inline">\(I_j+K\)</span> and <span class="math inline">\(M-K\)</span> while <span class="math inline">\(m&#39;\)</span> is the smallest among <span class="math inline">\(p - K\)</span> and <span class="math inline">\(m+K\)</span>. Therefore for a given <span class="math inline">\(j\)</span> we calculate the maximum gap as <span class="math inline">\(d_j = M&#39;-m&#39;\)</span>. The final answer is the smallest of these gaps calculated for each of index of <span class="math inline">\(I\)</span>.</p>
<p>This approach relies on being able to quickly identify elements that are smaller or greater than a given value. If the array is sorted this can be achieved quite efficiently. In-fact is <span class="math inline">\(I\)</span> is sorted then for a given <span class="math inline">\(j\)</span> all the elements that are smaller than <span class="math inline">\(I_j\)</span> appear at indices smaller than <span class="math inline">\(j\)</span> and, similarly, all the elements that are larger appear at indices larger than <span class="math inline">\(j\)</span>. Therefore, if <span class="math inline">\(I\)</span> is sorted then <span class="math inline">\(m&#39;\)</span> is the smallest among <span class="math inline">\(I_{j+1}-K\)</span> and <span class="math inline">\(I_0 +K\)</span> and <span class="math inline">\(M&#39;\)</span> is the largest among <span class="math inline">\(I_j+K\)</span> and <span class="math inline">\(I_{|I|-1}-K\)</span>.</p>
<p>We can use these observation to derive the following algorithm:</p>
<ol>
<li><p>sort the input array <span class="math inline">\(I\)</span>,</p></li>
<li><p>for each <span class="math inline">\(j = 0 \ldots |I|-1\)</span> calculate <span class="math inline">\(d_j = \max{(I_j+K,I_{|I|-1}-K)} -
	\min{(I_{j+1}-K, I_0 +K)}\)</span>,</p></li>
<li><p>return the smallest <span class="math inline">\(d_j\)</span>.</p></li>
</ol>
<p>An execution of this algorithm for the Example <a href="#example:smallest_range:variation1:example1" data-reference-type="ref" data-reference="example:smallest_range:variation1:example1">[example:smallest_range:variation1:example1]</a> is shown in the Figure <a href="#fig:smallest_range:bars_execution" data-reference-type="ref" data-reference="fig:smallest_range:bars_execution">[fig:smallest_range:bars_execution]</a>. The initial input is shown in Figure <a href="#fig:smallest_range:bars_full" data-reference-type="ref" data-reference="fig:smallest_range:bars_full">50.3</a> where the smallest and greatest value are <span class="math inline">\(m=1\)</span> and <span class="math inline">\(M=8\)</span>, respectively. The only way for their gap to become smaller is for <span class="math inline">\(M\)</span> to be decreased and <span class="math inline">\(m\)</span> to be increased by <span class="math inline">\(K\)</span>. Figure <a href="#fig:smallest_range:bars2" data-reference-type="ref" data-reference="fig:smallest_range:bars2">50.4</a> shows how <span class="math inline">\(I\)</span> would look like if we would add <span class="math inline">\(K\)</span> to all the elements smaller or equal than <span class="math inline">\(j=0\)</span> and subtract <span class="math inline">\(K\)</span> to the others. The highlighted boxes show the new array values while the white boxes show the original values. Notice that the gap between the new minimum (<span class="math inline">\(1\)</span>, obtained by subtracting <span class="math inline">\(2\)</span> from the original element with value <span class="math inline">\(3\)</span>) and the new maximum element (<span class="math inline">\(6\)</span>, obtained by subtracting <span class="math inline">\(2\)</span> from <span class="math inline">\(8\)</span>) is now <span class="math inline">\(6-3=3\)</span>. Similarly Figure <a href="#fig:smallest_range:bars3" data-reference-type="ref" data-reference="fig:smallest_range:bars3">50.5</a> shows the resulting array for <span class="math inline">\(j=3\)</span>. The new array minimum and maximum values are now <span class="math inline">\(3\)</span> and <span class="math inline">\(6\)</span>, respectively. When <span class="math inline">\(j=2\)</span> or <span class="math inline">\(j=3\)</span>, as we can see in Figures <a href="#fig:smallest_range:bars4" data-reference-type="ref" data-reference="fig:smallest_range:bars4">50.6</a> and <a href="#fig:smallest_range:bars5" data-reference-type="ref" data-reference="fig:smallest_range:bars5">50.8</a> the gap increases w.r.t. to the case where <span class="math inline">\(j=1\)</span>. Finally Figure <a href="#fig:smallest_range:bars6" data-reference-type="ref" data-reference="fig:smallest_range:bars6">50.9</a> shows the case where all the new elements are obtained by adding <span class="math inline">\(K\)</span>. This scenario leaves the relative distance between the elements unchanged w.r.t. to the original values and therefore not surprisingly the gap between the smallest and largest element is <span class="math inline">\(7\)</span> (like in Figure <a href="#fig:smallest_range:bars_full" data-reference-type="ref" data-reference="fig:smallest_range:bars_full">50.3</a>).</p>
<p>Listing <a href="#list:smallest_range:solution2" data-reference-type="ref" data-reference="list:smallest_range:solution2">[list:smallest_range:solution2]</a> shows an implementation of this idea. Notice that, in the code, <span class="math inline">\(m&#39;\)</span> is and <span class="math inline">\(M&#39;\)</span> is .</p>
<div class="sourceCode" id="list:smallest_range:solution2" data-language="c++" data-caption="Solution to the \textit{smallest range} problem using sorting." label="list:smallest_range:solution2"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:smallest_range:solution2-1"><a href="#list:smallest_range:solution2-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:smallest_range:solution2-2"><a href="#list:smallest_range:solution2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> smallest_range_II<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> A<span class="op">,</span> <span class="at">const</span> <span class="dt">int</span> K<span class="op">)</span></span>
<span id="list:smallest_range:solution2-3"><a href="#list:smallest_range:solution2-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:smallest_range:solution2-4"><a href="#list:smallest_range:solution2-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>sort<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>A<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>A<span class="op">));</span></span>
<span id="list:smallest_range:solution2-5"><a href="#list:smallest_range:solution2-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> A<span class="op">.</span>back<span class="op">()</span> <span class="op">-</span> A<span class="op">.</span>front<span class="op">();</span></span>
<span id="list:smallest_range:solution2-6"><a href="#list:smallest_range:solution2-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> A<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span></span>
<span id="list:smallest_range:solution2-7"><a href="#list:smallest_range:solution2-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:smallest_range:solution2-8"><a href="#list:smallest_range:solution2-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> <span class="va">m_new</span> <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>A<span class="op">.</span>front<span class="op">()</span> <span class="op">+</span> K<span class="op">,</span> A<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> K<span class="op">);</span></span>
<span id="list:smallest_range:solution2-9"><a href="#list:smallest_range:solution2-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> M_new <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>A<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> K<span class="op">,</span> A<span class="op">.</span>back<span class="op">()</span> <span class="op">-</span> K<span class="op">);</span></span>
<span id="list:smallest_range:solution2-10"><a href="#list:smallest_range:solution2-10" aria-hidden="true" tabindex="-1"></a>    ans          <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>ans<span class="op">,</span> M_new <span class="op">-</span> <span class="va">m_new</span><span class="op">);</span></span>
<span id="list:smallest_range:solution2-11"><a href="#list:smallest_range:solution2-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:smallest_range:solution2-12"><a href="#list:smallest_range:solution2-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:smallest_range:solution2-13"><a href="#list:smallest_range:solution2-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/smallest_range/images/bars2.jpg" id="fig:smallest_range:bars2" alt="j=0" /><figcaption aria-hidden="true"><span class="math inline">\(j=0\)</span></figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/smallest_range/images/bars3.jpg" id="fig:smallest_range:bars3" alt="j=1" /><figcaption aria-hidden="true"><span class="math inline">\(j=1\)</span></figcaption>
</figure>
<p><img src="/home/dspataro/git/algorithm_articles/sources/smallest_range/images/bars4.jpg" title="fig:" id="fig:smallest_range:bars5" alt="j=1" /> <span id="fig:smallest_range:bars4" label="fig:smallest_range:bars4">[fig:smallest_range:bars4]</span></p>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/smallest_range/images/bars5.jpg" id="fig:smallest_range:bars5" alt="j=1" /><figcaption aria-hidden="true"><span class="math inline">\(j=1\)</span></figcaption>
</figure>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/smallest_range/images/bars6.jpg" id="fig:smallest_range:bars6" alt="j=1" /><figcaption aria-hidden="true"><span class="math inline">\(j=1\)</span></figcaption>
</figure>
<h1 id="ch:next_greater_element">Next Greater Element I</h1>
<h2 class="unnumbered" id="introduction-48">Introduction</h2>
<h2 id="problem-statement-50">Problem statement</h2>
<div class="exercise">
<p><span id="example:next_greater_element:exercice1" label="example:next_greater_element:exercice1">[example:next_greater_element:exercice1]</span> Write a function that given two arrays with no duplicates <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> where <span class="math inline">\(A \subset B\)</span> returns an array <span class="math inline">\(C\)</span> of size <span class="math inline">\(|A|\)</span> where <span class="math inline">\(C_i\)</span> contains the next greater element of <span class="math inline">\(A_i\)</span> among the elements of <span class="math inline">\(B\)</span>. The next greater element of a number <span class="math inline">\(A_i\)</span> is defined as the smallest element greater than <span class="math inline">\(A_i\)</span> among the elements of <span class="math inline">\(B\)</span> from index <span class="math inline">\(j\)</span> to <span class="math inline">\(|B|-1\)</span> where <span class="math inline">\(B_j = A_i\)</span></p>
<p>In other words, for each <span class="math inline">\(A_i\)</span> the function finds the smallest element in <span class="math inline">\(B\)</span> that is greater than <span class="math inline">\(A_i\)</span> among the cells that are to the right of the cell in <span class="math inline">\(B\)</span> having the value <span class="math inline">\(A_i\)</span> and places it into <span class="math inline">\(C\)</span> at index <span class="math inline">\(i\)</span>.</p>
<div class="example">
<p><span id="example:next_greater_element:example1" label="example:next_greater_element:example1">[example:next_greater_element:example1]</span><br />
Given <span class="math inline">\(A=\{4,1,2\}\)</span> and <span class="math inline">\(B=\{1,3,4,2\}\)</span> the function returns <span class="math inline">\(C=\{-1,2,-1\}\)</span>. <span class="math inline">\(C_0 = -1\)</span> because there <span class="math inline">\(A_0 = 4\)</span> appears in <span class="math inline">\(B\)</span> at index <span class="math inline">\(2\)</span> and there is no cells to the right of <span class="math inline">\(B_2\)</span> that is strictly greater than <span class="math inline">\(4\)</span>. <span class="math inline">\(C_1 = 2\)</span> because <span class="math inline">\(1\)</span> appears in <span class="math inline">\(B\)</span> at index <span class="math inline">\(0\)</span> and the smallest element larger than <span class="math inline">\(1\)</span> after index <span class="math inline">\(0\)</span> in <span class="math inline">\(B\)</span> is the element <span class="math inline">\(2\)</span> in the last position. <span class="math inline">\(C_2 = -1\)</span> because <span class="math inline">\(A_2 = 2\)</span> appears in <span class="math inline">\(B\)</span> at index <span class="math inline">\(3\)</span> and there is no element ot the right of it. Note that there exists a value in <span class="math inline">\(B\)</span> that is larger than <span class="math inline">\(2\)</span> but we are not considering it because it appears to the left of the cell in <span class="math inline">\(B\)</span> holding value <span class="math inline">\(A_2=2\)</span>.</p>
</div>
<div class="example">
<p><span id="example:next_greater_element:example2" label="example:next_greater_element:example2">[example:next_greater_element:example2]</span><br />
Given <span class="math inline">\(A=\{2,4\}\)</span> and <span class="math inline">\(B=\{9,2,1,4,12,8\}\)</span> the function returns <span class="math inline">\(C=\{4,8\}\)</span>. <span class="math inline">\(C_0 = 4\)</span> because there <span class="math inline">\(A_0 = 2\)</span> appears in <span class="math inline">\(B\)</span> at index <span class="math inline">\(1\)</span> and the smallest element larger than <span class="math inline">\(2\)</span> in <span class="math inline">\(B\)</span> from the cell to the right of the one at index <span class="math inline">\(1\)</span> is <span class="math inline">\(4\)</span>.</p>
<p><span class="math inline">\(C_1 = 8\)</span> because there <span class="math inline">\(A_0 = 4\)</span> appears in <span class="math inline">\(B\)</span> at index <span class="math inline">\(3\)</span> and the smallest element larger than <span class="math inline">\(2\)</span> in <span class="math inline">\(B\)</span> from the cell to the right of the one at index <span class="math inline">\(3\)</span> is <span class="math inline">\(8\)</span>, appearing at the very end of <span class="math inline">\(B\)</span>. Notice that <span class="math inline">\(12\)</span> is also larger than <span class="math inline">\(4\)</span> and appearing to the right of the index <span class="math inline">\(3\)</span> but is not the right answer because it is not the smallest.</p>
</div>
</div>
<h2 id="clarification-questions-43">Clarification Questions</h2>
<div class="QandA">
<p>How should the function behave when an element of <span class="math inline">\(A\)</span> does not have a next greater in <span class="math inline">\(B\)</span>?</p>
<div class="answered">
<p><em>The function can insert <span class="math inline">\(-1\)</span> in the corresponding cell of <span class="math inline">\(C\)</span>.</em></p>
</div>
</div>
<h3 id="next_greater_element:sec:bruteforce">Brute-force</h3>
<p>This problem has a very intuitive brute-force solution that boils down into the following steps:</p>
<ol>
<li><p>looping through each element at index <span class="math inline">\(i\)</span> of <span class="math inline">\(A\)</span></p></li>
<li><p>finding the position <span class="math inline">\(j\)</span> in <span class="math inline">\(B\)</span> where the value <span class="math inline">\(A_i\)</span> appear i.e. <span class="math inline">\(B_j = A_i\)</span> (which exists because <span class="math inline">\(A \subset B\)</span>)</p></li>
<li><p>find the smallest element larger than <span class="math inline">\(A_i\)</span> in <span class="math inline">\(B\)</span> only considering the positions strictly after <span class="math inline">\(j\)</span>.</p></li>
</ol>
<p>An implementation of this approach is shown in Listing <a href="#list:next_greater_element:bruteforce" data-reference-type="ref" data-reference="list:next_greater_element:bruteforce">[list:next_greater_element:bruteforce]</a> where we use to the location in <span class="math inline">\(B\)</span> (the iterator ) where <span class="math inline">\(A_j\)</span> exists. The subsequent is used to scan the remaining of the array and to keep track of the smallest element that is larger than <span class="math inline">\(A_i\)</span>. The complexity of this approach is <span class="math inline">\(O(|A| \times
|B|)\)</span> as we could potentially do linear work (proportional to <span class="math inline">\(|B|\)</span>) for each and every element of <span class="math inline">\(A\)</span>. One of such case is when the elements of <span class="math inline">\(A\)</span> appears in the first positions of <span class="math inline">\(B\)</span>.</p>
<div class="sourceCode" id="list:next_greater_element:bruteforce" data-language="c++" data-caption="Brute-force solution to the \textit{next smaller element}." label="list:next_greater_element:bruteforce"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:next_greater_element:bruteforce-1"><a href="#list:next_greater_element:bruteforce-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> </span>
<span id="list:next_greater_element:bruteforce-2"><a href="#list:next_greater_element:bruteforce-2" aria-hidden="true" tabindex="-1"></a>next_greater_element_I_bruteforce<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> A<span class="op">,</span></span>
<span id="list:next_greater_element:bruteforce-3"><a href="#list:next_greater_element:bruteforce-3" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> B<span class="op">)</span></span>
<span id="list:next_greater_element:bruteforce-4"><a href="#list:next_greater_element:bruteforce-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:next_greater_element:bruteforce-5"><a href="#list:next_greater_element:bruteforce-5" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> C<span class="op">(</span>A<span class="op">.</span>size<span class="op">());</span></span>
<span id="list:next_greater_element:bruteforce-6"><a href="#list:next_greater_element:bruteforce-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="bu">std::</span>ssize<span class="op">(</span>A<span class="op">);</span> i<span class="op">++)</span></span>
<span id="list:next_greater_element:bruteforce-7"><a href="#list:next_greater_element:bruteforce-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:next_greater_element:bruteforce-8"><a href="#list:next_greater_element:bruteforce-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> it   <span class="op">=</span> <span class="bu">std::</span>find<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>B<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>B<span class="op">),</span> A<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:next_greater_element:bruteforce-9"><a href="#list:next_greater_element:bruteforce-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ans_i <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:next_greater_element:bruteforce-10"><a href="#list:next_greater_element:bruteforce-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>it <span class="op">!=</span> B<span class="op">.</span>end<span class="op">())</span></span>
<span id="list:next_greater_element:bruteforce-11"><a href="#list:next_greater_element:bruteforce-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:next_greater_element:bruteforce-12"><a href="#list:next_greater_element:bruteforce-12" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(*</span>it <span class="op">&gt;</span> A<span class="op">[</span>i<span class="op">])</span></span>
<span id="list:next_greater_element:bruteforce-13"><a href="#list:next_greater_element:bruteforce-13" aria-hidden="true" tabindex="-1"></a>        ans_i <span class="op">=</span> <span class="op">(</span>ans_i <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">?</span> <span class="op">*</span>it <span class="op">:</span> <span class="bu">std::</span>min<span class="op">(</span>ans_i<span class="op">,</span> <span class="op">*</span>it<span class="op">);</span></span>
<span id="list:next_greater_element:bruteforce-14"><a href="#list:next_greater_element:bruteforce-14" aria-hidden="true" tabindex="-1"></a>      it<span class="op">++;</span></span>
<span id="list:next_greater_element:bruteforce-15"><a href="#list:next_greater_element:bruteforce-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:next_greater_element:bruteforce-16"><a href="#list:next_greater_element:bruteforce-16" aria-hidden="true" tabindex="-1"></a>    C<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> ans_i<span class="op">;</span></span>
<span id="list:next_greater_element:bruteforce-17"><a href="#list:next_greater_element:bruteforce-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:next_greater_element:bruteforce-18"><a href="#list:next_greater_element:bruteforce-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> C<span class="op">;</span></span>
<span id="list:next_greater_element:bruteforce-19"><a href="#list:next_greater_element:bruteforce-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="next_greater_element:sec:nlogntime"><span class="math inline">\(O(|B|log(|B|))\)</span> time, <span class="math inline">\(O(|B|)\)</span> space solution</h2>
<p>We can solve this problem much faster than quadratic time if we are willing to use some additional space (as it is often the case). In particular the problem would be easily solvable if we would have a map containing the information about the next greater element for each of the elements of <span class="math inline">\(B\)</span>. We could simply loop over all the elements of <span class="math inline">\(A\)</span> and query such a map to get the required answer. However we have just shifted the problem which now is, how can we generate such a map?</p>
<p>The idea is that we can fill the map for each element of <span class="math inline">\(B\)</span> starting from the back and at the same time keep a sorted list of all the elements of <span class="math inline">\(B\)</span> that we have already processed. This list can be used to quickly (by doing a binary search on it) find the upper bound for a given value. The upper bound for an integer <span class="math inline">\(x\)</span> is the first (or smallest) element in a collection that is strictly larger than <span class="math inline">\(x\)</span>. The upper bound operation can be easily implemented on a sorted collection using binary search. We have already implemented a similar operation (the lower bound) in Chapter <a href="#ch:find_k_closest_in_array" data-reference-type="ref" data-reference="ch:find_k_closest_in_array">35</a> and you can check Listing <a href="#list:find_k_closest_in_array:binary_lower_bound" data-reference-type="ref" data-reference="list:find_k_closest_in_array:binary_lower_bound">[list:find_k_closest_in_array:binary_lower_bound]</a> (at page ) to have an idea of how you can go about brewing your own version of .</p>
<p>The idea described above is implemented in Listing <a href="#list:next_greater_element:set" data-reference-type="ref" data-reference="list:next_greater_element:set">[list:next_greater_element:set]</a>. The contains the sorted list of elements of <span class="math inline">\(B\)</span> that we have already processed while the contains the information about the upper bounds for each of the processed elements of <span class="math inline">\(B\)</span>. The first goes through each element <span class="math inline">\(j\)</span> of <span class="math inline">\(B\)</span> (from the back to the front) and calculates the answer for <span class="math inline">\(B_j\)</span> by looking into the sorted <span class="math inline">\(N\)</span><a href="#fn43" class="footnote-ref" id="fnref43" role="doc-noteref"><sup>43</sup></a>. The second loop only takes care of copying the relevant information from the map to the return array. The time and space complexity of this code are <span class="math inline">\(O(|B|log(|B|))\)</span> (each of the <span class="math inline">\(|B|\)</span> insertions in <span class="math inline">\(N\)</span> costs <span class="math inline">\(O(log(|B|)\)</span>) and <span class="math inline">\(O(|B|)\)</span>, respectively.</p>
<div class="sourceCode" id="list:next_greater_element:set" data-language="c++" data-caption="$O(nlog(n))$ time and linear space solution." label="list:next_greater_element:set"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:next_greater_element:set-1"><a href="#list:next_greater_element:set-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> </span>
<span id="list:next_greater_element:set-2"><a href="#list:next_greater_element:set-2" aria-hidden="true" tabindex="-1"></a>next_greater_element_I_set<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> A<span class="op">,</span></span>
<span id="list:next_greater_element:set-3"><a href="#list:next_greater_element:set-3" aria-hidden="true" tabindex="-1"></a>                           <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> B<span class="op">)</span></span>
<span id="list:next_greater_element:set-4"><a href="#list:next_greater_element:set-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:next_greater_element:set-5"><a href="#list:next_greater_element:set-5" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> C<span class="op">(</span>A<span class="op">.</span>size<span class="op">());</span></span>
<span id="list:next_greater_element:set-6"><a href="#list:next_greater_element:set-6" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>set<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> N<span class="op">;</span></span>
<span id="list:next_greater_element:set-7"><a href="#list:next_greater_element:set-7" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>unordered_map<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> C_val<span class="op">;</span></span>
<span id="list:next_greater_element:set-8"><a href="#list:next_greater_element:set-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:next_greater_element:set-9"><a href="#list:next_greater_element:set-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> idx_B <span class="op">=</span> B<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> idx_B <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> idx_B<span class="op">--)</span></span>
<span id="list:next_greater_element:set-10"><a href="#list:next_greater_element:set-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:next_greater_element:set-11"><a href="#list:next_greater_element:set-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:next_greater_element:set-12"><a href="#list:next_greater_element:set-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> it         <span class="op">=</span> N<span class="op">.</span>upper_bound<span class="op">(</span>B<span class="op">[</span>idx_B<span class="op">]);</span></span>
<span id="list:next_greater_element:set-13"><a href="#list:next_greater_element:set-13" aria-hidden="true" tabindex="-1"></a>    C_val<span class="op">[</span>B<span class="op">[</span>idx_B<span class="op">]]</span> <span class="op">=</span> it <span class="op">!=</span> N<span class="op">.</span>end<span class="op">()</span> <span class="op">?</span> <span class="op">*</span>it <span class="op">:</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:next_greater_element:set-14"><a href="#list:next_greater_element:set-14" aria-hidden="true" tabindex="-1"></a>    N<span class="op">.</span>insert<span class="op">(</span>B<span class="op">[</span>idx_B<span class="op">]);</span></span>
<span id="list:next_greater_element:set-15"><a href="#list:next_greater_element:set-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:next_greater_element:set-16"><a href="#list:next_greater_element:set-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="bu">std::</span>ssize<span class="op">(</span>A<span class="op">);</span> i<span class="op">++)</span></span>
<span id="list:next_greater_element:set-17"><a href="#list:next_greater_element:set-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:next_greater_element:set-18"><a href="#list:next_greater_element:set-18" aria-hidden="true" tabindex="-1"></a>    C<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> C_val<span class="op">[</span>A<span class="op">[</span>i<span class="op">]];</span></span>
<span id="list:next_greater_element:set-19"><a href="#list:next_greater_element:set-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:next_greater_element:set-20"><a href="#list:next_greater_element:set-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> C<span class="op">;</span></span>
<span id="list:next_greater_element:set-21"><a href="#list:next_greater_element:set-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="common-variation-3">Common Variation</h2>
<h3 id="next_greater_element:sec:first">First next greater element</h3>
<p>There is a common variation of this problem featuring an almost identical statement to the one shown in Section <a href="#" data-reference-type="ref" data-reference="">54</a> with the only difference being that for an element of <span class="math inline">\(A_i\)</span> we should return the first (and not the necessarily the smallest like in the original variant) element in <span class="math inline">\(B\)</span> that is greater than <span class="math inline">\(A_i\)</span>.</p>
<div class="exercise">
<p><span id="example:next_greater_element:exercice2" label="example:next_greater_element:exercice2">[example:next_greater_element:exercice2]</span> Write a function that given two arrays with no duplicates <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> where <span class="math inline">\(A \subset B\)</span> returns an array <span class="math inline">\(C\)</span> of size <span class="math inline">\(|A|\)</span> where <span class="math inline">\(C_i\)</span> contains the first element greater than <span class="math inline">\(A_i\)</span> among the elements of <span class="math inline">\(B\)</span> strictly after the cell at index <span class="math inline">\(j\)</span>, where <span class="math inline">\(B_j = A_i\)</span>.</p>
<p>In other words, for each <span class="math inline">\(A_i\)</span> the function finds the first element in <span class="math inline">\(B\)</span> that is greater than <span class="math inline">\(A_i\)</span> among the cells that are to the right of the cell in <span class="math inline">\(B\)</span> having the value <span class="math inline">\(A_i\)</span> and places it into <span class="math inline">\(C\)</span> at index <span class="math inline">\(i\)</span>.</p>
</div>
<h2 id="next_greater_element:sec:variation1:discussion">Discussion</h2>
<p>The difference with the original variation is minimal but is big enough so that we have a linear-time solution for this problem. While to solve the original problem we were forced to keep a sorted list of all the already processed elements of <span class="math inline">\(B\)</span>, this time we can simply keep a stack storing only those processed elements of <span class="math inline">\(B\)</span> so that they form an increasing sequence.</p>
<p>Suppose we have a decreasing sequence followed by a greater number: For example, consider the following list: <span class="math inline">\(\{7,8,5, 4, 3, 2, 1, 6\}\)</span> (see Figure <a href="#fig:next_greater:stack" data-reference-type="ref" data-reference="fig:next_greater:stack">[fig:next_greater:stack]</a>); initially the stack is empty and when we process the first number (<span class="math inline">\(6\)</span>), there clearly no greater element at its right. Because the stack is empty, adding <span class="math inline">\(6\)</span> to it would still preserve the fact that the numbers contained in it form an increasing sequence (see Figure <a href="#fig:next_greater:variation1:stack1" data-reference-type="ref" data-reference="fig:next_greater:variation1:stack1">51.7</a>). When the <span class="math inline">\(1\)</span> is processed, then the stack is not empty and <span class="math inline">\(6\)</span> is at the top which is larger than <span class="math inline">\(1\)</span>. Therefore we can use <span class="math inline">\(6\)</span> as an answer for <span class="math inline">\(1\)</span> and add <span class="math inline">\(1\)</span> to the stack because the sequence <span class="math inline">\(1,6\)</span> is still increasing (see Figure <a href="#fig:next_greater:variation1:stack2" data-reference-type="ref" data-reference="fig:next_greater:variation1:stack2">51.2</a>). Things however, are a bit different when <span class="math inline">\(2\)</span> is processed. This time at the top of the stack we find a <span class="math inline">\(1\)</span> which is smaller than <span class="math inline">\(2\)</span>. Therefore the top of the stack cannot be the answer for the element <span class="math inline">\(2\)</span>. Moreover the sequence <span class="math inline">\(2,1,6\)</span> would not be increasing and therefore the two cannot be placed on top of the stack as-is. What we do is removing the elements from the current stack until adding the placing the <span class="math inline">\(2\)</span> at the top would make the elements in the stack an increasing sequence. So we remove <span class="math inline">\(1\)</span> from the stack and the new stack becomes <span class="math inline">\(2,6\)</span> (see Figure <a href="#fig:next_greater:variation1:stack3" data-reference-type="ref" data-reference="fig:next_greater:variation1:stack3">51.3</a>). The rest of the execution is described more in detail in Figure <a href="#fig:next_greater:stack" data-reference-type="ref" data-reference="fig:next_greater:stack">[fig:next_greater:stack]</a>.</p>
<p>From this example we can draw a general approach about how we can solve this problem using a stack. When we process an element we try to insert it into the stack paying attention to how this element compares to the top of the stack. If it is larger than we remove the top of the stack and compare it again with the subsequent element. We keep repeating and removing elements from the stack until either the element we are trying to place is smaller than the top of the stack or there are no more elements left in it. In the former case then the new top of the stack(after all the necessary removals) is going to be the answer associated with the element we are processing. In the latter, the answer does not exists and the element we are trying to place on the stack is therefore the largest processed so far. Listing <a href="#list:next_greater_element:stack" data-reference-type="ref" data-reference="list:next_greater_element:stack">[list:next_greater_element:stack]</a> shows an implementation of this idea.</p>
<div class="sourceCode" id="list:next_greater_element:stack" data-language="c++" data-caption="linear time solution to the Problem \ref{example:next_greater_element:exercice2} solved using a stack." label="list:next_greater_element:stack"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:next_greater_element:stack-1"><a href="#list:next_greater_element:stack-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> </span>
<span id="list:next_greater_element:stack-2"><a href="#list:next_greater_element:stack-2" aria-hidden="true" tabindex="-1"></a>next_greater_element_I_stack<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> A<span class="op">,</span></span>
<span id="list:next_greater_element:stack-3"><a href="#list:next_greater_element:stack-3" aria-hidden="true" tabindex="-1"></a>                           <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> B<span class="op">)</span></span>
<span id="list:next_greater_element:stack-4"><a href="#list:next_greater_element:stack-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:next_greater_element:stack-5"><a href="#list:next_greater_element:stack-5" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> C<span class="op">(</span>A<span class="op">.</span>size<span class="op">());</span></span>
<span id="list:next_greater_element:stack-6"><a href="#list:next_greater_element:stack-6" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>stack<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> N<span class="op">;</span></span>
<span id="list:next_greater_element:stack-7"><a href="#list:next_greater_element:stack-7" aria-hidden="true" tabindex="-1"></a>   <span class="bu">std::</span>unordered_map<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> C_val<span class="op">;</span></span>
<span id="list:next_greater_element:stack-8"><a href="#list:next_greater_element:stack-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:next_greater_element:stack-9"><a href="#list:next_greater_element:stack-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="bu">std::</span>ssize<span class="op">(</span>B<span class="op">)-</span><span class="dv">1</span> <span class="op">;</span> i <span class="op">&gt;=</span><span class="dv">0</span> <span class="op">;</span> i<span class="op">--)</span></span>
<span id="list:next_greater_element:stack-10"><a href="#list:next_greater_element:stack-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:next_greater_element:stack-11"><a href="#list:next_greater_element:stack-11" aria-hidden="true" tabindex="-1"></a>      <span class="cf">while</span><span class="op">(!</span>N<span class="op">.</span>empty<span class="op">()</span> <span class="op">&amp;&amp;</span> B<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> N<span class="op">.</span>top<span class="op">())</span></span>
<span id="list:next_greater_element:stack-12"><a href="#list:next_greater_element:stack-12" aria-hidden="true" tabindex="-1"></a>      <span class="op">{</span></span>
<span id="list:next_greater_element:stack-13"><a href="#list:next_greater_element:stack-13" aria-hidden="true" tabindex="-1"></a>          N<span class="op">.</span>pop<span class="op">();</span> <span class="co">//remove smaller elements than *it</span></span>
<span id="list:next_greater_element:stack-14"><a href="#list:next_greater_element:stack-14" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="list:next_greater_element:stack-15"><a href="#list:next_greater_element:stack-15" aria-hidden="true" tabindex="-1"></a>      <span class="co">//now the stack is either empty or contains an increasing sequence</span></span>
<span id="list:next_greater_element:stack-16"><a href="#list:next_greater_element:stack-16" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span><span class="op">(!</span>N<span class="op">.</span>empty<span class="op">())</span></span>
<span id="list:next_greater_element:stack-17"><a href="#list:next_greater_element:stack-17" aria-hidden="true" tabindex="-1"></a>        C_val<span class="op">[</span>B<span class="op">[</span>i<span class="op">]]</span> <span class="op">=</span> N<span class="op">.</span>top<span class="op">();</span></span>
<span id="list:next_greater_element:stack-18"><a href="#list:next_greater_element:stack-18" aria-hidden="true" tabindex="-1"></a>      N<span class="op">.</span>push<span class="op">(</span>B<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:next_greater_element:stack-19"><a href="#list:next_greater_element:stack-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:next_greater_element:stack-20"><a href="#list:next_greater_element:stack-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="bu">std::</span>ssize<span class="op">(</span>A<span class="op">);</span> i<span class="op">++)</span></span>
<span id="list:next_greater_element:stack-21"><a href="#list:next_greater_element:stack-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:next_greater_element:stack-22"><a href="#list:next_greater_element:stack-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>C_val<span class="op">.</span>contains<span class="op">(</span>A<span class="op">[</span>i<span class="op">]))</span></span>
<span id="list:next_greater_element:stack-23"><a href="#list:next_greater_element:stack-23" aria-hidden="true" tabindex="-1"></a>        C<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> C_val<span class="op">[</span>A<span class="op">[</span>i<span class="op">]];</span></span>
<span id="list:next_greater_element:stack-24"><a href="#list:next_greater_element:stack-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="list:next_greater_element:stack-25"><a href="#list:next_greater_element:stack-25" aria-hidden="true" tabindex="-1"></a>        C<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:next_greater_element:stack-26"><a href="#list:next_greater_element:stack-26" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:next_greater_element:stack-27"><a href="#list:next_greater_element:stack-27" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> C<span class="op">;</span></span>
<span id="list:next_greater_element:stack-28"><a href="#list:next_greater_element:stack-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="framed">
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/next_greater_element/images/stack1.jpg" id="fig:next_greater:variation1:stack1" alt="The stack is empty. We place 6 at the top." /><figcaption aria-hidden="true">The stack is empty. We place <span class="math inline">\(6\)</span> at the top.</figcaption>
</figure>
</div>
<div class="framed">
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/next_greater_element/images/stack2.jpg" id="fig:next_greater:variation1:stack2" alt="1 is smaller than the top of the stack therefore 1 is placed at the top. 6 is the answer for 1." /><figcaption aria-hidden="true"><span class="math inline">\(1\)</span> is smaller than the top of the stack therefore <span class="math inline">\(1\)</span> is placed at the top. <span class="math inline">\(6\)</span> is the answer for <span class="math inline">\(1\)</span>.</figcaption>
</figure>
</div>
<div class="framed">
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/next_greater_element/images/stack3.jpg" id="fig:next_greater:variation1:stack3" alt="The top of the stack 1 is smaller than 2. We therefore remove 1 and place to at the top. 6, also this time is the answer for 2" /><figcaption aria-hidden="true">The top of the stack <span class="math inline">\(1\)</span> is smaller than <span class="math inline">\(2\)</span>. We therefore remove <span class="math inline">\(1\)</span> and place to at the top. <span class="math inline">\(6\)</span>, also this time is the answer for <span class="math inline">\(2\)</span></figcaption>
</figure>
</div>
<div class="framed">
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/next_greater_element/images/stack4.jpg" id="fig:next_greater:variation1:stack1" alt="Similarly to what we did in Figure 51.3 we remove all the elements at the top until adding the 3 would preserve the increasing ordering of the stack elements. 2 is removed and 3 is the new top. 6 is the answer for 3." /><figcaption aria-hidden="true">Similarly to what we did in Figure <a href="#fig:next_greater:variation1:stack3" data-reference-type="ref" data-reference="fig:next_greater:variation1:stack3">51.3</a> we remove all the elements at the top until adding the <span class="math inline">\(3\)</span> would preserve the increasing ordering of the stack elements. <span class="math inline">\(2\)</span> is removed and <span class="math inline">\(3\)</span> is the new top. <span class="math inline">\(6\)</span> is the answer for <span class="math inline">\(3\)</span>.</figcaption>
</figure>
</div>
<div class="framed">
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/next_greater_element/images/stack5.jpg" id="fig:next_greater:variation1:stack1" alt="We add the 2 to the stack and return 3 (the current top of the stack) as the answer for 2." /><figcaption aria-hidden="true">We add the <span class="math inline">\(2\)</span> to the stack and return <span class="math inline">\(3\)</span> (the current top of the stack) as the answer for <span class="math inline">\(2\)</span>.</figcaption>
</figure>
</div>
<div class="framed">
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/next_greater_element/images/stack6.jpg" id="fig:next_greater:variation1:stack1" alt="5 is larger than the first two elements of the stack which are therefore removed.5 is the new top and 6 is the answer for 5. " /><figcaption aria-hidden="true"><span class="math inline">\(5\)</span> is larger than the first two elements of the stack which are therefore removed.<span class="math inline">\(5\)</span> is the new top and <span class="math inline">\(6\)</span> is the answer for <span class="math inline">\(5\)</span>. </figcaption>
</figure>
</div>
<div class="framed">
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/next_greater_element/images/stack7.jpg" id="fig:next_greater:variation1:stack1" alt="7 is larger than all the elements currently in the stack. Therefore all the elements are removed and the stack remains empty signalling that 7 has not greater elements at its right. The process ends here as there are no more elements to process." /><figcaption aria-hidden="true"><span class="math inline">\(7\)</span> is larger than all the elements currently in the stack. Therefore all the elements are removed and the stack remains empty signalling that <span class="math inline">\(7\)</span> has not greater elements at its right. The process ends here as there are no more elements to process.</figcaption>
</figure>
</div>
<h1 id="ch:count_bits">Count the bits</h1>
<h2 id="problem-statement-51">Problem statement</h2>
<div class="exercise">
<p><span id="example:count_bits:exercice1" label="example:count_bits:exercice1">[example:count_bits:exercice1]</span> Given a non negative integer number <span class="math inline">\(n\)</span> return an array <span class="math inline">\(B\)</span> of size <span class="math inline">\(n+1\)</span> where <span class="math inline">\(B_i\)</span> contains the number of bits set in the number <span class="math inline">\(i\)</span>.</p>
<div class="example">
<p><span id="example:count_bits:example1" label="example:count_bits:example1">[example:count_bits:example1]</span><br />
Given <span class="math inline">\(n = 5\)</span> the function returns <span class="math inline">\(B = \{0,1,1,2,1,2,2\}\)</span></p>
</div>
</div>
<h2 id="clarification-questions-44">Clarification Questions</h2>
<div class="QandA">
<p>Can we assume <span class="math inline">\(n\)</span> is always positive?</p>
<div class="answered">
<p><em>Yes, you do not have to perform any input validation.</em></p>
</div>
</div>
<h2 id="count_bits:sec:discussion">Discussion</h2>
<h3 id="count_bits:sec:bruteforce">Naïve approach solution</h3>
<p>Let’s be honest, this is an easy problem. All we have to do is to brute-force our way by counting the numbers of bits set for each and every number from <span class="math inline">\(0\)</span> to <span class="math inline">\(n+1\)</span>. Each number has a fixed size which on most the common modern C++ implementation is <span class="math inline">\(32\)</span>-bit () and therefore we can come up with a <span class="math inline">\(\Theta(32n)\)</span> solution. Counting the bits of a given integer can be even done with <a href="https://gcc.gnu.org/onlinedocs/gcc-4.9.2/gcc/X86-Built-in-Functions.html">compiler intrinsics</a> as which can map directly, when supported by the hardware, to fast machine instructions, or by using some simple bit manipulation trickery. From C++20 we also can use the function, together with a bunch of lot more bit related functions (in the header ). Listing <a href="#list:count_bits:bruteforce" data-reference-type="ref" data-reference="list:count_bits:bruteforce">[list:count_bits:bruteforce]</a> shows an implementation of this idea where we use our own version of the bit counting function for the sake of showing how this can be implemented. Function works by repeatedly inspecting the least significant bit of of the input number to check if it is set or not, and after that it shifts it to the right by one position so that the next time another bit is inspected.</p>
<div class="sourceCode" id="list:count_bits:bruteforce" data-language="c++" data-caption="Bruteforce solution where we manually count the number of bits for each number." label="list:count_bits:bruteforce"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:count_bits:bruteforce-1"><a href="#list:count_bits:bruteforce-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> my_pop_count<span class="op">(</span><span class="dt">unsigned</span> num<span class="op">)</span></span>
<span id="list:count_bits:bruteforce-2"><a href="#list:count_bits:bruteforce-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:count_bits:bruteforce-3"><a href="#list:count_bits:bruteforce-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:count_bits:bruteforce-4"><a href="#list:count_bits:bruteforce-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>num<span class="op">)</span></span>
<span id="list:count_bits:bruteforce-5"><a href="#list:count_bits:bruteforce-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:count_bits:bruteforce-6"><a href="#list:count_bits:bruteforce-6" aria-hidden="true" tabindex="-1"></a>        ans<span class="op">+=</span>num<span class="op">&amp;</span><span class="dv">1</span><span class="op">;</span> <span class="co">//is the last bit set</span></span>
<span id="list:count_bits:bruteforce-7"><a href="#list:count_bits:bruteforce-7" aria-hidden="true" tabindex="-1"></a>        num<span class="op">&gt;&gt;=</span><span class="dv">1</span><span class="op">;</span> <span class="co">//shift num one bit to the right</span></span>
<span id="list:count_bits:bruteforce-8"><a href="#list:count_bits:bruteforce-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:count_bits:bruteforce-9"><a href="#list:count_bits:bruteforce-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:count_bits:bruteforce-10"><a href="#list:count_bits:bruteforce-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:count_bits:bruteforce-11"><a href="#list:count_bits:bruteforce-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:count_bits:bruteforce-12"><a href="#list:count_bits:bruteforce-12" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> count_bits_bruteforce<span class="op">(</span><span class="at">const</span> <span class="dt">unsigned</span> n<span class="op">)</span></span>
<span id="list:count_bits:bruteforce-13"><a href="#list:count_bits:bruteforce-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:count_bits:bruteforce-14"><a href="#list:count_bits:bruteforce-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> ans<span class="op">;</span></span>
<span id="list:count_bits:bruteforce-15"><a href="#list:count_bits:bruteforce-15" aria-hidden="true" tabindex="-1"></a>    ans<span class="op">.</span>reserve<span class="op">(</span>n<span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="list:count_bits:bruteforce-16"><a href="#list:count_bits:bruteforce-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">unsigned</span> num <span class="op">=</span> <span class="dv">0</span> <span class="op">;</span> num <span class="op">&lt;=</span> n <span class="op">;</span>num<span class="op">++)</span></span>
<span id="list:count_bits:bruteforce-17"><a href="#list:count_bits:bruteforce-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:count_bits:bruteforce-18"><a href="#list:count_bits:bruteforce-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">//alternatively std::popcount or __builtin_popcount (only on gcc)</span></span>
<span id="list:count_bits:bruteforce-19"><a href="#list:count_bits:bruteforce-19" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="dt">int</span> num_bit_set <span class="op">=</span> my_pop_count<span class="op">(</span>num<span class="op">);</span> </span>
<span id="list:count_bits:bruteforce-20"><a href="#list:count_bits:bruteforce-20" aria-hidden="true" tabindex="-1"></a>        <span class="ot">assert</span><span class="op">(</span><span class="bu">std::</span>popcount<span class="op">(</span>num<span class="op">)</span> <span class="op">==</span> num_bit_set<span class="op">);</span> </span>
<span id="list:count_bits:bruteforce-21"><a href="#list:count_bits:bruteforce-21" aria-hidden="true" tabindex="-1"></a>              </span>
<span id="list:count_bits:bruteforce-22"><a href="#list:count_bits:bruteforce-22" aria-hidden="true" tabindex="-1"></a>        ans<span class="op">.</span>push_back<span class="op">(</span>num_bit_set<span class="op">);</span></span>
<span id="list:count_bits:bruteforce-23"><a href="#list:count_bits:bruteforce-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:count_bits:bruteforce-24"><a href="#list:count_bits:bruteforce-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:count_bits:bruteforce-25"><a href="#list:count_bits:bruteforce-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="count_bits:sec:dp">DP solution</h3>
<p>This problem can be solved in a more elegant way using dynamic programming. This approach will also not incur in a factor <span class="math inline">\(32\)</span> penalty for the count of the bits of a number.</p>
<p>The idea is that the number of bits set for a given number is equal to the number of bit set in the same number shifted one position to the right (removing the last bit), which is always smaller than the number we started with, plus one if the removed bit was <span class="math inline">\(1\)</span>.</p>
<p>For instance consider <span class="math inline">\(x=2730_{10} = 101010101010_2\)</span>. The least significant bit of <span class="math inline">\(x\)</span> is <span class="math inline">\(0\)</span> therefore its number of bits set is equal to the number of bits set of <span class="math inline">\(y=1365_{10} = 10101010101_2\)</span> (last bit removed). For the same reasons the number of bits set in <span class="math inline">\(y\)</span> is one (because the last bit is <span class="math inline">\(1\)</span>) plus the number of bits set in <span class="math inline">\(y=682_{10} = 1010101010_2\)</span>(last bit removed). We can follow this line of reasoning until we reach <span class="math inline">\(0\)</span>, which clearly has zero bits set.</p>
<p>Because every time we remove a bit we are solving a problem for a smaller number, and because the solution for a number <span class="math inline">\(x\)</span> can be required counting the bits of many numbers <span class="math inline">\(n&gt;x\)</span>, we can adopt DP(see Appendix <a href="#sect:appendix:DP" data-reference-type="ref" data-reference="sect:appendix:DP">[sect:appendix:DP]</a>) (it exposes optimal substructures as well as overlapping subproblems). In a DP solution we will use a DP table <span class="math inline">\(B\)</span>, which we initially fill only for the number <span class="math inline">\(0\)</span>. We will then follow a bottom-up approach where we start solving problems for <span class="math inline">\(x=1,2,\ldots,n\)</span>. When we reach a given number <span class="math inline">\(y\)</span> we have already solved and stored into <span class="math inline">\(B\)</span> the answers for every number less than <span class="math inline">\(y\)</span>, therefore we can count the number of bits in <span class="math inline">\(y\)</span>. Moreover because the answers for all of these numbers smaller than <span class="math inline">\(y\)</span> are stored in <span class="math inline">\(B\)</span> we do not need to recompute them.</p>
<p>Listing <a href="#list:count_bits:DP" data-reference-type="ref" data-reference="list:count_bits:DP">[list:count_bits:DP]</a> shows an implementation of this approach. You can find a shorter (three lines) and more compact (and possibly unreadable) but yet equivalent version of the same idea in Listing <a href="#list:count_bits:DP_short" data-reference-type="ref" data-reference="list:count_bits:DP_short">[list:count_bits:DP_short]</a>.</p>
<div class="sourceCode" id="list:count_bits:DP" data-language="c++" data-caption="DP solution where we calculate the bits for a given number from the its last bit and the answer of the number resulting from removing that last bit." label="list:count_bits:DP"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:count_bits:DP-1"><a href="#list:count_bits:DP-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> count_bits_DP<span class="op">(</span><span class="at">const</span> <span class="dt">unsigned</span> n<span class="op">)</span></span>
<span id="list:count_bits:DP-2"><a href="#list:count_bits:DP-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:count_bits:DP-3"><a href="#list:count_bits:DP-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> B<span class="op">;</span></span>
<span id="list:count_bits:DP-4"><a href="#list:count_bits:DP-4" aria-hidden="true" tabindex="-1"></a>    B<span class="op">.</span>reserve<span class="op">(</span>n<span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="list:count_bits:DP-5"><a href="#list:count_bits:DP-5" aria-hidden="true" tabindex="-1"></a>    B<span class="op">.</span>push_back<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="list:count_bits:DP-6"><a href="#list:count_bits:DP-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">unsigned</span> num <span class="op">=</span> <span class="dv">1</span> <span class="op">;</span> num <span class="op">&lt;=</span> n <span class="op">;</span>num<span class="op">++)</span></span>
<span id="list:count_bits:DP-7"><a href="#list:count_bits:DP-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:count_bits:DP-8"><a href="#list:count_bits:DP-8" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="dt">unsigned</span> last_bit <span class="op">=</span> num<span class="op">&amp;</span><span class="dv">1</span><span class="op">;</span></span>
<span id="list:count_bits:DP-9"><a href="#list:count_bits:DP-9" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="dt">unsigned</span> pop_count_rest <span class="op">=</span> B<span class="op">[</span>num<span class="op">&gt;&gt;</span><span class="dv">1</span><span class="op">];</span></span>
<span id="list:count_bits:DP-10"><a href="#list:count_bits:DP-10" aria-hidden="true" tabindex="-1"></a>        B<span class="op">.</span>push_back<span class="op">(</span>last_bit <span class="op">+</span> pop_count_rest<span class="op">);</span></span>
<span id="list:count_bits:DP-11"><a href="#list:count_bits:DP-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:count_bits:DP-12"><a href="#list:count_bits:DP-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> B<span class="op">;</span></span>
<span id="list:count_bits:DP-13"><a href="#list:count_bits:DP-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> </span>
<span id="list:count_bits:DP-14"><a href="#list:count_bits:DP-14" aria-hidden="true" tabindex="-1"></a> </span></code></pre></div>
<div class="sourceCode" id="list:count_bits:DP_short" data-language="c++" data-caption="Shorter version of Listing \ref{list:count_bits:DP}." label="list:count_bits:DP_short"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:count_bits:DP_short-1"><a href="#list:count_bits:DP_short-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> count_bits_DP_short<span class="op">(</span><span class="at">const</span> <span class="dt">unsigned</span> n<span class="op">)</span></span>
<span id="list:count_bits:DP_short-2"><a href="#list:count_bits:DP_short-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:count_bits:DP_short-3"><a href="#list:count_bits:DP_short-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> B<span class="op">(</span>n<span class="op">+</span><span class="dv">1</span><span class="op">,</span><span class="dv">0</span><span class="op">);</span></span>
<span id="list:count_bits:DP_short-4"><a href="#list:count_bits:DP_short-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">unsigned</span> num <span class="op">=</span> <span class="dv">1</span> <span class="op">;</span> num <span class="op">&lt;=</span> n <span class="op">;</span>num<span class="op">++)</span></span>
<span id="list:count_bits:DP_short-5"><a href="#list:count_bits:DP_short-5" aria-hidden="true" tabindex="-1"></a>        B<span class="op">[</span>num<span class="op">]</span> <span class="op">=</span> B<span class="op">[</span>num<span class="op">&gt;&gt;</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="op">(</span>num<span class="op">&amp;</span><span class="dv">1</span><span class="op">);</span></span>
<span id="list:count_bits:DP_short-6"><a href="#list:count_bits:DP_short-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> B<span class="op">;</span></span>
<span id="list:count_bits:DP_short-7"><a href="#list:count_bits:DP_short-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> </span>
<span id="list:count_bits:DP_short-8"><a href="#list:count_bits:DP_short-8" aria-hidden="true" tabindex="-1"></a> </span></code></pre></div>
<h3 id="count_bits:sec:pattern">Another efficient approach</h3>
<p>There is another way of solving this problem which is quite different than the DP approach we discussed above. Let’s start by noticing that any power of <span class="math inline">\(2\)</span> always have one and only one bit set. For instance <span class="math inline">\(2^2\)</span> has the bit at index <span class="math inline">\(2\)</span> set and the rest of the bit not set. The same applies for any other power of two <span class="math inline">\(2^k\)</span> where only the bit at index <span class="math inline">\(k\)</span> is set. All the numbers from <span class="math inline">\(2^k\)</span> to <span class="math inline">\(2^{k+1}-1\)</span> can be obtained by concatenating a <span class="math inline">\(1\)</span> (the bit at index <span class="math inline">\(k\)</span>) with all the binary representations of the numbers from <span class="math inline">\(0\)</span> to <span class="math inline">\(2^k-1\)</span> (all the numbers smaller than <span class="math inline">\(2^k\)</span>).</p>
<p>For instance let’s take <span class="math inline">\(k=4\)</span> as an example. All the numbers from <span class="math inline">\(2^4 = 16\)</span> to <span class="math inline">\(2^5-1 = 31\)</span> can be obtained as shown below:</p>
<ul>
<li><p><span class="math inline">\(16 = 16+0 = 10000_2+ 0_2\)</span></p></li>
<li><p><span class="math inline">\(17 = 16+1 = 10000_2+ 1_2\)</span></p></li>
<li><p><span class="math inline">\(18 = 16+2 = 10000_2+ 10_2\)</span></p></li>
<li><p><span class="math inline">\(19 = 16+3 = 10000_2+ 11_2\)</span></p></li>
<li><p><span class="math inline">\(20 = 16+4 = 10000_2+ 100_2\)</span></p></li>
<li><p><span class="math inline">\(21 = 16+5 = 10000_2+ 101_2\)</span></p></li>
<li><p><span class="math inline">\(22 = 16+6 = 10000_2+ 110_2\)</span></p></li>
<li><p><span class="math inline">\(23 = 16+7 = 10000_2+ 111_2\)</span></p></li>
<li><p><span class="math inline">\(24 = 16+8 = 10000_2+ 1000_2\)</span></p></li>
<li><p><span class="math inline">\(25 = 16+9 = 10000_2+ 1001_2\)</span></p></li>
<li><p><span class="math inline">\(\ldots\)</span></p></li>
<li><p><span class="math inline">\(31 = 16+15 = 10000_2+ 1111_2\)</span></p></li>
</ul>
<p>As you can see the answer for all the numbers from <span class="math inline">\(16\)</span> to <span class="math inline">\(31\)</span> can be calculated by adding one to the answer of all the rest of the numbers we have already calculated (the numbers from <span class="math inline">\(0\)</span> to <span class="math inline">\(15\)</span>). The same applies for smaller <span class="math inline">\(k\)</span>. For <span class="math inline">\(k=2\)</span> we have:</p>
<ul>
<li><p><span class="math inline">\(4 = 4+0 = 100_2+ 0_2\)</span></p></li>
<li><p><span class="math inline">\(5 = 4+1 = 100_2+ 1_2\)</span></p></li>
<li><p><span class="math inline">\(6 = 4+2 = 100_2+ 10_2\)</span></p></li>
<li><p><span class="math inline">\(7 = 4+3 = 100_2+ 11_2\)</span></p></li>
</ul>
<p>We can use this idea to build a fast and efficient solution which is shown in Listing <a href="#list:count_bits:powers" data-reference-type="ref" data-reference="list:count_bits:powers">[list:count_bits:powers]</a>. The answers are calculated incrementally by starting with the integers <span class="math inline">\(0\)</span>, <span class="math inline">\(1\)</span> and <span class="math inline">\(2\)</span> which have <span class="math inline">\(0\)</span>,<span class="math inline">\(1\)</span> and <span class="math inline">\(1\)</span> bits set, respectively. Then we can calculate the answer for <span class="math inline">\(2\)</span> and <span class="math inline">\(3\)</span> (from <span class="math inline">\(2^2\)</span> to <span class="math inline">\(2^3-1\)</span>) by adding <span class="math inline">\(1\)</span> to the answers for <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span>. For the numbers from <span class="math inline">\(4\)</span> to <span class="math inline">\(7\)</span> (<span class="math inline">\(2^2\)</span> to <span class="math inline">\(2^3-1\)</span>) we add <span class="math inline">\(1\)</span> to the answers to <span class="math inline">\(0\)</span>, <span class="math inline">\(1\)</span> and <span class="math inline">\(2\)</span> and <span class="math inline">\(3\)</span>, respectively. For the numbers from <span class="math inline">\(8\)</span> to <span class="math inline">\(15\)</span> (<span class="math inline">\(2^3\)</span> to <span class="math inline">\(2^4-1\)</span>) we add <span class="math inline">\(1\)</span> to the answers for <span class="math inline">\(0, 1, \ldots,7\)</span>. We keep doing that, adding <span class="math inline">\(1\)</span> to all the numbers from <span class="math inline">\(0\)</span> to <span class="math inline">\(2^k-1\)</span> in order to calculate the answer for all the numbers from <span class="math inline">\(2^k\)</span> to <span class="math inline">\(2^{k+1}-1\)</span>, until we reach <span class="math inline">\(n+1\)</span>. The complexity of this approach is <span class="math inline">\(\Theta(n)\)</span> and also in this case we do not pay the constant factor associated with a brute-force count of the bits in an integer.</p>
<div class="sourceCode" id="list:count_bits:powers" data-language="c++" data-caption="Alternative efficient solution where the number of bits set in a integer $k$ is found by using the number of bits set for a smaller integer: $k-(2^{\floor{log_2{k}}})$ (see Equation \ref{eq:count_bits:dpformula_powers})." label="list:count_bits:powers"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:count_bits:powers-1"><a href="#list:count_bits:powers-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> count_bits_DP_powers<span class="op">(</span><span class="at">const</span> <span class="dt">unsigned</span> n<span class="op">)</span></span>
<span id="list:count_bits:powers-2"><a href="#list:count_bits:powers-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:count_bits:powers-3"><a href="#list:count_bits:powers-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> B<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="list:count_bits:powers-4"><a href="#list:count_bits:powers-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> next_pow <span class="op">=</span> <span class="dv">2</span><span class="op">,</span> back_idx <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:count_bits:powers-5"><a href="#list:count_bits:powers-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:count_bits:powers-6"><a href="#list:count_bits:powers-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> next_pow<span class="op">)</span></span>
<span id="list:count_bits:powers-7"><a href="#list:count_bits:powers-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:count_bits:powers-8"><a href="#list:count_bits:powers-8" aria-hidden="true" tabindex="-1"></a>      <span class="co">//next power of two. </span></span>
<span id="list:count_bits:powers-9"><a href="#list:count_bits:powers-9" aria-hidden="true" tabindex="-1"></a>      next_pow <span class="op">*=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="list:count_bits:powers-10"><a href="#list:count_bits:powers-10" aria-hidden="true" tabindex="-1"></a>      <span class="co">//we use all the solutions from the start to build the next ones</span></span>
<span id="list:count_bits:powers-11"><a href="#list:count_bits:powers-11" aria-hidden="true" tabindex="-1"></a>      back_idx <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:count_bits:powers-12"><a href="#list:count_bits:powers-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:count_bits:powers-13"><a href="#list:count_bits:powers-13" aria-hidden="true" tabindex="-1"></a>    B<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> B<span class="op">[</span>back_idx<span class="op">++];</span></span>
<span id="list:count_bits:powers-14"><a href="#list:count_bits:powers-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:count_bits:powers-15"><a href="#list:count_bits:powers-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> B<span class="op">;</span></span>
<span id="list:count_bits:powers-16"><a href="#list:count_bits:powers-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice that the same approach can be easily adopted to obtain a top-down implementation where we memoize and reuse the answer to how many bits a given integer has set. We leave this an exercise to the reader <a href="#fn44" class="footnote-ref" id="fnref44" role="doc-noteref"><sup>44</sup></a>.</p>
<h1 id="ch:decode_string">Decode the message</h1>
<h2 class="unnumbered" id="introduction-49">Introduction</h2>
<p>This problem resemble the problem of decoding a string encoded with the famous <em>run-length encoding method</em>(RLE)<a href="#fn45" class="footnote-ref" id="fnref45" role="doc-noteref"><sup>45</sup></a> The problem discussed in this chapter is going to deal with a similar algorithm and you are asked to write a decode function for a string encoded with a run-length-encoding-like algorithm.</p>
<h2 id="problem-statement-52">Problem statement</h2>
<div class="exercise">
<p><span id="example:decode_string:exercice1" label="example:decode_string:exercice1">[example:decode_string:exercice1]</span> Write a function that given an encoded string <span class="math inline">\(s\)</span> decodes it. <span class="math inline">\(s\)</span> is of the form: <span class="math inline">\({k_1[d_1]k_2[d_2[ \ldots]}\)</span> where <span class="math inline">\(k\)</span> is a positive integer and <span class="math inline">\(s\)</span> is another encoded string. The decoded version of <span class="math inline">\(s\)</span> is obtained by appending <span class="math inline">\(d_1\)</span> <span class="math inline">\(k_1\)</span> followed by repeating <span class="math inline">\(d_2\)</span> <span class="math inline">\(k_2\)</span> times.</p>
<div class="example">
<p><span id="example:decode_string:example1" label="example:decode_string:example1">[example:decode_string:example1]</span><br />
Given the function returns .</p>
</div>
<div class="example">
<p><span id="example:decode_string:example2" label="example:decode_string:example2">[example:decode_string:example2]</span><br />
Given the function returns .</p>
</div>
<div class="example">
<p><br />
Given the function returns .</p>
<p><span id="ex:decode_string:example3" label="ex:decode_string:example3">[ex:decode_string:example3]</span></p>
</div>
</div>
<h2 id="clarification-questions-45">Clarification Questions</h2>
<div class="QandA">
<p>Is it guaranteed that <span class="math inline">\(s\)</span> is always valid?</p>
<div class="answered">
<p><em>Yes, <span class="math inline">\(s\)</span> contains only lower-case letters from the English alphabet, numbers and square brackets and it is valid encoded string. .</em></p>
</div>
</div>
<h2 id="decode_string:sec:discussion">Discussion</h2>
<h3 id="decode_string:sec:recursive">Recursive solution</h3>
<p>The first thing we notice about this problem is that the encoded string has a recursive definition. Whenever we encounter a number <span class="math inline">\(x\)</span> followed by the closed square bracket character we know that we have to decode whatever is inside the brackets and replicate it <span class="math inline">\(x\)</span> times. We can use this fact to simply create a recursive algorithm which follows this definition. The real challenge of this problem lies in the implementation more than in the algorithm itself.</p>
<p>The idea is to construct the final answer by looking at one character of <span class="math inline">\(s\)</span> at a time. We can start from char at index <span class="math inline">\(0\)</span> and depending on what it is:</p>
<ol>
<li><p>append it to the answer (when we have a letter)</p></li>
<li><p>parse it as a part of a number (when we encounter a digit) or,</p></li>
<li><p>recursively decode the rest of the string (when the current character is an open square bracket ).</p></li>
</ol>
<p>. For instance image we have to decode . We start by reading <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> which are letters and therefore are just appended to the final answer. We then see a digit, which signal us that a number started. We parse all of its digits into the integer <span class="math inline">\(242\)</span>. The end of the number is signaled by the presence of the char which also signals that a new encoded substring is starting. So when we see an open square bracket character we recursively call the decode function so that it returns the expansion of whatever is within the brackets. When the recursive call ends (when we find a closed square bracket character ) we are left with the expanded string which we can then replicate <span class="math inline">\(242\)</span> times and append to the final answer. When a recursive call ends, the caller must continue processing the elements of <span class="math inline">\(s\)</span> from the last unprocessed character. We keep track of the next element to be processed via a integer variable which is passed along to each of the recursive calls This is necessary because after the recursive call returns we might need to continue processing more characters. W.r.t. the example above, when the recursive call associated with the substring returns we still have to process for the encoded substring substring .</p>
<p>Listing <a href="#list:decode_string:recursive" data-reference-type="ref" data-reference="list:decode_string:recursive">[list:decode_string:recursive]</a> shows a possible implementation of this idea. Notice that the function takes as the second parameter as a reference to an integer. As mentioned already above, we use a reference because we want this number to be updated by each of the recursive calls. We use <span class="math inline">\(i\)</span> to keep track of the current character we are examining in <span class="math inline">\(s\)</span>. Figure <a href="#fig:decode_string:recursion" data-reference-type="ref" data-reference="fig:decode_string:recursion">53.1</a> graphically depicts and describe the execution of this algorithm on the input string . The time and complexity of the code in Listing <a href="#list:decode_string:recursive" data-reference-type="ref" data-reference="list:decode_string:recursive">[list:decode_string:recursive]</a> is <span class="math inline">\(O(K|S|)\)</span> where <span class="math inline">\(K\)</span> is the largest replication factor we can have.</p>
<div class="sourceCode" id="list:decode_string:recursive" data-language="c++" data-caption="Recursive implementation of the algorithm described in Section \ref{decode_string:sec:recursive}" label="list:decode_string:recursive"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:decode_string:recursive-1"><a href="#list:decode_string:recursive-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string<span class="op"> </span>decode_string_recursive_helper<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> s<span class="op">,</span> <span class="bu">std::</span>size_t<span class="op">&amp;</span> i<span class="op">)</span></span>
<span id="list:decode_string:recursive-2"><a href="#list:decode_string:recursive-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:decode_string:recursive-3"><a href="#list:decode_string:recursive-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> size <span class="op">=</span> s<span class="op">.</span>size<span class="op">();</span></span>
<span id="list:decode_string:recursive-4"><a href="#list:decode_string:recursive-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>ans<span class="op">;</span></span>
<span id="list:decode_string:recursive-5"><a href="#list:decode_string:recursive-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> multiplier <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:decode_string:recursive-6"><a href="#list:decode_string:recursive-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>i <span class="op">&lt;</span> size<span class="op">)</span></span>
<span id="list:decode_string:recursive-7"><a href="#list:decode_string:recursive-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:decode_string:recursive-8"><a href="#list:decode_string:recursive-8" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="kw">auto</span> curr_char <span class="op">=</span> s<span class="op">[</span>i<span class="op">];</span></span>
<span id="list:decode_string:recursive-9"><a href="#list:decode_string:recursive-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span><span class="bu">std::</span>isdigit<span class="op">(</span>s<span class="op">[</span>i<span class="op">]))</span></span>
<span id="list:decode_string:recursive-10"><a href="#list:decode_string:recursive-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="list:decode_string:recursive-11"><a href="#list:decode_string:recursive-11" aria-hidden="true" tabindex="-1"></a>            <span class="co">//parse the whole number</span></span>
<span id="list:decode_string:recursive-12"><a href="#list:decode_string:recursive-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span><span class="op">(</span>i <span class="op">&lt;</span> size <span class="op">&amp;&amp;</span> <span class="bu">std::</span>isdigit<span class="op">(</span>s<span class="op">[</span>i<span class="op">]))</span></span>
<span id="list:decode_string:recursive-13"><a href="#list:decode_string:recursive-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="list:decode_string:recursive-14"><a href="#list:decode_string:recursive-14" aria-hidden="true" tabindex="-1"></a>                multiplier<span class="op">*=</span><span class="dv">10</span><span class="op">;</span></span>
<span id="list:decode_string:recursive-15"><a href="#list:decode_string:recursive-15" aria-hidden="true" tabindex="-1"></a>                multiplier<span class="op">+=</span>s<span class="op">[</span>i<span class="op">]-</span><span class="ch">&#39;0&#39;</span><span class="op">;</span></span>
<span id="list:decode_string:recursive-16"><a href="#list:decode_string:recursive-16" aria-hidden="true" tabindex="-1"></a>                i<span class="op">++;</span></span>
<span id="list:decode_string:recursive-17"><a href="#list:decode_string:recursive-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span>   </span>
<span id="list:decode_string:recursive-18"><a href="#list:decode_string:recursive-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span><span class="cf">else</span> <span class="cf">if</span><span class="op">(</span>s<span class="op">[</span>i<span class="op">]==</span><span class="ch">&#39;[&#39;</span><span class="op">)</span></span>
<span id="list:decode_string:recursive-19"><a href="#list:decode_string:recursive-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="list:decode_string:recursive-20"><a href="#list:decode_string:recursive-20" aria-hidden="true" tabindex="-1"></a>            <span class="at">const</span> <span class="bu">std::</span>string<span class="op"> </span>nested <span class="op">=</span> decode_string_recursive_helper<span class="op">(</span>s<span class="op">,</span> <span class="op">++</span>i<span class="op">);</span></span>
<span id="list:decode_string:recursive-21"><a href="#list:decode_string:recursive-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span> <span class="op">;</span> k <span class="op">&lt;</span> multiplier <span class="op">;</span>k<span class="op">++)</span></span>
<span id="list:decode_string:recursive-22"><a href="#list:decode_string:recursive-22" aria-hidden="true" tabindex="-1"></a>                ans<span class="op">+=</span>nested<span class="op">;</span></span>
<span id="list:decode_string:recursive-23"><a href="#list:decode_string:recursive-23" aria-hidden="true" tabindex="-1"></a>            <span class="co">//no increment of i here.</span></span>
<span id="list:decode_string:recursive-24"><a href="#list:decode_string:recursive-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span><span class="cf">else</span> <span class="cf">if</span><span class="op">(</span>s<span class="op">[</span>i<span class="op">]==</span><span class="ch">&#39;]&#39;</span><span class="op">)</span></span>
<span id="list:decode_string:recursive-25"><a href="#list:decode_string:recursive-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="list:decode_string:recursive-26"><a href="#list:decode_string:recursive-26" aria-hidden="true" tabindex="-1"></a>            i<span class="op">++;</span></span>
<span id="list:decode_string:recursive-27"><a href="#list:decode_string:recursive-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="list:decode_string:recursive-28"><a href="#list:decode_string:recursive-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span><span class="cf">else</span><span class="op">{</span></span>
<span id="list:decode_string:recursive-29"><a href="#list:decode_string:recursive-29" aria-hidden="true" tabindex="-1"></a>            ans<span class="op">+=</span>s<span class="op">[</span>i<span class="op">];</span></span>
<span id="list:decode_string:recursive-30"><a href="#list:decode_string:recursive-30" aria-hidden="true" tabindex="-1"></a>            i<span class="op">++;</span></span>
<span id="list:decode_string:recursive-31"><a href="#list:decode_string:recursive-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="list:decode_string:recursive-32"><a href="#list:decode_string:recursive-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:decode_string:recursive-33"><a href="#list:decode_string:recursive-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="list:decode_string:recursive-34"><a href="#list:decode_string:recursive-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:decode_string:recursive-35"><a href="#list:decode_string:recursive-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="list:decode_string:recursive-36"><a href="#list:decode_string:recursive-36" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string<span class="op"> </span>decode_string_recursive<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> s<span class="op">)</span></span>
<span id="list:decode_string:recursive-37"><a href="#list:decode_string:recursive-37" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:decode_string:recursive-38"><a href="#list:decode_string:recursive-38" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>size_t<span class="op"> </span>pos <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:decode_string:recursive-39"><a href="#list:decode_string:recursive-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> decode_string_recursive_helper<span class="op">(</span>s<span class="op">,</span>pos<span class="op">);</span></span>
<span id="list:decode_string:recursive-40"><a href="#list:decode_string:recursive-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<figure>
<img src="/home/dspataro/git/algorithm_articles/sources/decode_string/images/recursion.jpg" id="fig:decode_string:recursion" style="width:125.0%" alt="Execution of the algorithm in Listing [list:decode_string:recursive] for the input string . The execution starts (Figure (a)) with a first call to with . The first two characters are letters and therefore they are appended to the instance of bounded to this recursive call (Figures (a) and (b)). Characters at indices 2 and 3 are numbers and they are parsed and saved into the integer (Figure (c)). The next character is going to be the open square bracket at index 4 and this will cause a new recursive call to happen with i=5 (Figure (d)). The process repeats now and we see at index 5 a letter that we append to the instance of bound to this call (Figures (e)). We then parse the number 12 at characters 6 and 7 (Figure (f)) and subsequently at index 8 we find an open square bracket leads to a new recursive call this time starting from index i=9 (Figure (g)). Index 9 holds a letter which is appended to the (empty) instance of bound to this call (Figure (h)). The next character is a closed square bracket which mean we can terminate the recursive call and return to the caller (which now holds ). We are not back (Figure (k)) to the second recursive call where, as you remember m is twelve. Therefore we replicate 12 times the string we received from the recursive call number three and append the result to the current instance of . We also set m to zero. Because the next character is again a closed bracket we return the the caller and repeat the process (Figure (i)).m=23 and therefore we replicate from the second recursive call 23 times. The rest of the characters left are the ones at indices 11 and 12 which are simple letters and are just appended to ." /><figcaption aria-hidden="true">Execution of the algorithm in Listing <a href="#list:decode_string:recursive" data-reference-type="ref" data-reference="list:decode_string:recursive">[list:decode_string:recursive]</a> for the input string . The execution starts (Figure (a)) with a first call to with . The first two characters are letters and therefore they are appended to the instance of bounded to this recursive call (Figures (a) and (b)). Characters at indices <span class="math inline">\(2\)</span> and <span class="math inline">\(3\)</span> are numbers and they are parsed and saved into the integer (Figure (c)). The next character is going to be the open square bracket at index <span class="math inline">\(4\)</span> and this will cause a new recursive call to happen with <span class="math inline">\(i=5\)</span> (Figure (d)). The process repeats now and we see at index <span class="math inline">\(5\)</span> a letter that we append to the instance of bound to this call (Figures (e)). We then parse the number <span class="math inline">\(12\)</span> at characters <span class="math inline">\(6\)</span> and <span class="math inline">\(7\)</span> (Figure (f)) and subsequently at index <span class="math inline">\(8\)</span> we find an open square bracket leads to a new recursive call this time starting from index <span class="math inline">\(i=9\)</span> (Figure (g)). Index <span class="math inline">\(9\)</span> holds a letter which is appended to the (empty) instance of bound to this call (Figure (h)). The next character is a closed square bracket which mean we can terminate the recursive call and return to the caller (which now holds ). We are not back (Figure (k)) to the second recursive call where, as you remember <span class="math inline">\(m\)</span> is twelve. Therefore we replicate <span class="math inline">\(12\)</span> times the string we received from the recursive call number three and append the result to the current instance of . We also set <span class="math inline">\(m\)</span> to zero. Because the next character is again a closed bracket we return the the caller and repeat the process (Figure (i)).<span class="math inline">\(m=23\)</span> and therefore we replicate from the second recursive call <span class="math inline">\(23\)</span> times. The rest of the characters left are the ones at indices <span class="math inline">\(11\)</span> and <span class="math inline">\(12\)</span> which are simple letters and are just appended to .</figcaption>
</figure>
<h3 id="decode_string:sec:iterative">Iterative solution</h3>
<p>The same idea can of course be implemented iteratively. The trick is to <em>simulate</em> the call stack of the recursive approach in Section <a href="#decode_string:sec:recursive" data-reference-type="ref" data-reference="decode_string:sec:recursive">53.3.1</a> by using an explicit stack. This stack will contains two information</p>
<div class="enumerate*">
<p>the replication factor associated with an encoded substring (<span class="math inline">\(1\)</span> is the default)</p>
<p>the decoded substring</p>
</div>
<p>. Initially the stack contains only one entry: . As of in the recursive approach we process <span class="math inline">\(s\)</span> one character at the time and all the operations are performed on the <strong>top</strong> of the stack unless we encounter a which signals we need to add another element to the stack and start decoding a substring of <span class="math inline">\(s\)</span>.,or a which signals that we are done with decoding the substring and we can then replicate it as many time it is necessary, remove the entry from the top of the stack and append the replicated string to the string associated with the new top of the stack. At the end of this process we are left with the fully decoded string at the top of the stack. Listing <a href="#list:decode_string:iterative" data-reference-type="ref" data-reference="list:decode_string:iterative">[list:decode_string:iterative]</a> implements this idea. Notice that the stack has a type thus reflecting the fact we need to keep two information for each of the encoded substrings. As for the recursive implementation, the time and space complexity is <span class="math inline">\(O(K|S|)\)</span>.</p>
<div class="sourceCode" id="list:decode_string:iterative" data-language="c++" data-caption="Iterative solution using a \inline{std::stack}." label="list:decode_string:iterative"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:decode_string:iterative-1"><a href="#list:decode_string:iterative-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string<span class="op"> </span>decode_string<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> s<span class="op">)</span></span>
<span id="list:decode_string:iterative-2"><a href="#list:decode_string:iterative-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:decode_string:iterative-3"><a href="#list:decode_string:iterative-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>stack<span class="op">&lt;</span><span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span><span class="bu">std::</span>string<span class="op">&gt;&gt;</span> stack<span class="op">;</span></span>
<span id="list:decode_string:iterative-4"><a href="#list:decode_string:iterative-4" aria-hidden="true" tabindex="-1"></a>    stack<span class="op">.</span>push<span class="op">({</span><span class="dv">1</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">()});</span></span>
<span id="list:decode_string:iterative-5"><a href="#list:decode_string:iterative-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:decode_string:iterative-6"><a href="#list:decode_string:iterative-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> rep_f <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:decode_string:iterative-7"><a href="#list:decode_string:iterative-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>i <span class="op">&lt;</span> s<span class="op">.</span>size<span class="op">())</span></span>
<span id="list:decode_string:iterative-8"><a href="#list:decode_string:iterative-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="list:decode_string:iterative-9"><a href="#list:decode_string:iterative-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span><span class="bu">std::</span>isdigit<span class="op">(</span>s<span class="op">[</span>i<span class="op">]))</span></span>
<span id="list:decode_string:iterative-10"><a href="#list:decode_string:iterative-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="list:decode_string:iterative-11"><a href="#list:decode_string:iterative-11" aria-hidden="true" tabindex="-1"></a>            rep_f <span class="op">*=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="list:decode_string:iterative-12"><a href="#list:decode_string:iterative-12" aria-hidden="true" tabindex="-1"></a>            rep_f<span class="op">+=</span> <span class="op">(</span>s<span class="op">[</span>i<span class="op">]-</span><span class="ch">&#39;0&#39;</span><span class="op">);</span></span>
<span id="list:decode_string:iterative-13"><a href="#list:decode_string:iterative-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="list:decode_string:iterative-14"><a href="#list:decode_string:iterative-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>s<span class="op">[</span>i<span class="op">]&gt;=</span><span class="ch">&#39;a&#39;</span> <span class="op">&amp;&amp;</span> s<span class="op">[</span>i<span class="op">]&lt;=</span><span class="ch">&#39;z&#39;</span><span class="op">)</span></span>
<span id="list:decode_string:iterative-15"><a href="#list:decode_string:iterative-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="list:decode_string:iterative-16"><a href="#list:decode_string:iterative-16" aria-hidden="true" tabindex="-1"></a>            stack<span class="op">.</span>top<span class="op">().</span>second<span class="op">.</span>push_back<span class="op">(</span>s<span class="op">[</span>i<span class="op">]);</span></span>
<span id="list:decode_string:iterative-17"><a href="#list:decode_string:iterative-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="list:decode_string:iterative-18"><a href="#list:decode_string:iterative-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span><span class="op">(</span>s<span class="op">[</span>i<span class="op">]==</span><span class="ch">&#39;]&#39;</span><span class="op">)</span></span>
<span id="list:decode_string:iterative-19"><a href="#list:decode_string:iterative-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="list:decode_string:iterative-20"><a href="#list:decode_string:iterative-20" aria-hidden="true" tabindex="-1"></a>            <span class="at">const</span> <span class="kw">auto</span> <span class="op">[</span>rep<span class="op">,</span> str<span class="op">]</span> <span class="op">=</span> stack<span class="op">.</span>top<span class="op">();</span></span>
<span id="list:decode_string:iterative-21"><a href="#list:decode_string:iterative-21" aria-hidden="true" tabindex="-1"></a>            stack<span class="op">.</span>pop<span class="op">();</span></span>
<span id="list:decode_string:iterative-22"><a href="#list:decode_string:iterative-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span> <span class="op">;</span> i <span class="op">&lt;</span> rep <span class="op">;</span> i<span class="op">++)</span></span>
<span id="list:decode_string:iterative-23"><a href="#list:decode_string:iterative-23" aria-hidden="true" tabindex="-1"></a>                stack<span class="op">.</span>top<span class="op">().</span>second <span class="op">+=</span> str<span class="op">;</span></span>
<span id="list:decode_string:iterative-24"><a href="#list:decode_string:iterative-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span><span class="cf">else</span> <span class="cf">if</span><span class="op">(</span>s<span class="op">[</span>i<span class="op">]==</span><span class="ch">&#39;[&#39;</span><span class="op">)</span></span>
<span id="list:decode_string:iterative-25"><a href="#list:decode_string:iterative-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="list:decode_string:iterative-26"><a href="#list:decode_string:iterative-26" aria-hidden="true" tabindex="-1"></a>            stack<span class="op">.</span>push<span class="op">({</span>rep_f<span class="op">,</span>string<span class="op">()});</span></span>
<span id="list:decode_string:iterative-27"><a href="#list:decode_string:iterative-27" aria-hidden="true" tabindex="-1"></a>            rep_f <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:decode_string:iterative-28"><a href="#list:decode_string:iterative-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="list:decode_string:iterative-29"><a href="#list:decode_string:iterative-29" aria-hidden="true" tabindex="-1"></a>        i<span class="op">++;</span></span>
<span id="list:decode_string:iterative-30"><a href="#list:decode_string:iterative-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="list:decode_string:iterative-31"><a href="#list:decode_string:iterative-31" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>stack<span class="op">.</span>size<span class="op">()==</span><span class="dv">1</span><span class="op">);</span></span>
<span id="list:decode_string:iterative-32"><a href="#list:decode_string:iterative-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> stack<span class="op">.</span>top<span class="op">().</span>second<span class="op">;</span></span>
<span id="list:decode_string:iterative-33"><a href="#list:decode_string:iterative-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="appendices">Appendices</h1>
<h2 class="unnumbered" id="listings">Listings</h2>
<div class="sourceCode" id="list:listings:hash_pair" data-language="c++" data-caption="Functor used to calculate the hash value for a pair of integers.     \inline{hash_combine} is a free function used to mix several input hash values into a new one." label="list:listings:hash_pair"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="list:listings:hash_pair-1"><a href="#list:listings:hash_pair-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> SeedType<span class="op">,</span> <span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Rest<span class="op">&gt;</span></span>
<span id="list:listings:hash_pair-2"><a href="#list:listings:hash_pair-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> hash_combine<span class="op">(</span>SeedType<span class="op">&amp;</span> seed<span class="op">,</span> <span class="at">const</span> T<span class="op">&amp;</span> v<span class="op">,</span> <span class="at">const</span> Rest<span class="op">&amp;...</span> rest<span class="op">)</span></span>
<span id="list:listings:hash_pair-3"><a href="#list:listings:hash_pair-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:listings:hash_pair-4"><a href="#list:listings:hash_pair-4" aria-hidden="true" tabindex="-1"></a>    seed <span class="op">^=</span> <span class="bu">std::</span>hash<span class="op">&lt;</span>T<span class="op">&gt;{}(</span>v<span class="op">)</span> <span class="op">+</span> <span class="bn">0x9e3779b9</span> <span class="op">+</span> <span class="op">(</span>seed <span class="op">&lt;&lt;</span> <span class="dv">6</span><span class="op">)</span> <span class="op">+</span> <span class="op">(</span>seed <span class="op">&gt;&gt;</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="list:listings:hash_pair-5"><a href="#list:listings:hash_pair-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>hash_combine<span class="op">(</span>seed<span class="op">,</span> rest<span class="op">),</span> <span class="op">...);</span></span>
<span id="list:listings:hash_pair-6"><a href="#list:listings:hash_pair-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="list:listings:hash_pair-7"><a href="#list:listings:hash_pair-7" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> PairHasher</span>
<span id="list:listings:hash_pair-8"><a href="#list:listings:hash_pair-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span> <span class="kw">public</span> <span class="bu">std::</span>unary_function<span class="op">&lt;</span><span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;,</span> <span class="bu">std::</span>size_t<span class="op">&gt;</span></span>
<span id="list:listings:hash_pair-9"><a href="#list:listings:hash_pair-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="list:listings:hash_pair-10"><a href="#list:listings:hash_pair-10" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>size_t<span class="op"> </span><span class="kw">operator</span><span class="op">()(</span><span class="at">const</span> <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;&amp;</span> k<span class="op">)</span> <span class="at">const</span></span>
<span id="list:listings:hash_pair-11"><a href="#list:listings:hash_pair-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="list:listings:hash_pair-12"><a href="#list:listings:hash_pair-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> seed <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="list:listings:hash_pair-13"><a href="#list:listings:hash_pair-13" aria-hidden="true" tabindex="-1"></a>    hash_combine<span class="op">(</span>seed<span class="op">,</span><span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>k<span class="op">),</span><span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;(</span>k<span class="op">));</span></span>
<span id="list:listings:hash_pair-14"><a href="#list:listings:hash_pair-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> seed<span class="op">;</span></span>
<span id="list:listings:hash_pair-15"><a href="#list:listings:hash_pair-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="list:listings:hash_pair-16"><a href="#list:listings:hash_pair-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>An integer <span class="math inline">\(x\)</span> is a perfect square if its square root is also an integer.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>The pigeonhole principle (<a href="https://en.wikipedia.org/wiki/Pigeonhole_principle">https://en.wikipedia.org/wiki/Pigeonhole_principle</a>) states that if <span class="math inline">\(n\)</span> items are put into <span class="math inline">\(m\)</span> containers, with <span class="math inline">\(n &gt; m\)</span>, then at least one container must contain more than one item.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>the starting point is <span class="math inline">\(A.size()-2\)</span> because <span class="math inline">\(A.size()-1\)</span> is always turned into <span class="math inline">\(-1\)</span><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>An element is a local minimum/maximum if it is lower/higher than its two immediate neighbors.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>We think a good way of doing this is to repeat out load a short summary of your understanding of the problem to the interviewer.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>A number used (in UNIX part of the process control block) to uniquely identify a process within the OS. In Unix, process IDs are usually allocated on a sequential basis, beginning at 0 and rising to a maximum value (usually <span class="math inline">\(65535\)</span>) which varies from system to system. Once this limit is reached, allocation restarts at zero and again increases. However, for this and subsequent passes any PIDs still assigned to processes are skipped.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>This clarification question can however lead to a follow-up discussion on how such scenario can be handled and it can very well go in the many directions:</p>
<ul>
<li><p>how to represent and manipulate infinite precision numbers,</p></li>
<li><p>examples of production libraries providing infinite precision, etc (the <a href="https://gmplib.org/">GMP library</a><span class="citation" data-cites="cit::web::gmplibrary"></span> probably being the most known).</p></li>
<li><p>how overflow errors can be handled? (Exceptions, error codes, UB?)</p></li>
</ul>
<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></li>
<li id="fn8" role="doc-endnote"><p>Any even number, to be precise<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>TCO (Tail Call Optimization) is the process by which a smart compiler can make a call to a function and take no additional stack space.The allocation of a new stack frame for a function can be avoided because the calling function will simply return the value that it gets from the called function. The most common use is tail-recursion, where a recursive function written to take advantage of tail-call optimization can use constant stack space.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p><span class="math inline">\(\oplus\)</span> is a boolean operator that outputs true only when its inputs differ i.e. one is true, the other is false.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p>This is very good question because in case the answer is yes one could use an approach similar to the counting sort to keep track of the number of times an element appears.<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12" role="doc-endnote"><p>In-fact throwing an exception is cheap when the exception is not raised (main model used today for exceptions (Itanium ABI, VC++ 64 bits Zero-Cost model exceptions. More info here: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf</a>)<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13" role="doc-endnote"><p>In a boolean expression the second argument is executed or evaluated only if the first argument does not suffice to determine the value of the expression.<a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14" role="doc-endnote"><p>Remember that <span class="math inline">\((x,-1)\)</span> is a node containing the value <span class="math inline">\(x\)</span> and with random pointer set to <code>nullptr</code><a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15" role="doc-endnote"><p>For arrays, the cost of inserting or deleting an element is linear as you need to:</p>
<div class="enumerate*">
<p>possibly enlarge the allocated space for the array</p>
<p>copy all the elements (minus or plus the element you want to remove or insert) in the new memory space</p>
</div>
<p>.<a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn16" role="doc-endnote"><p>Which is when either the current node is null or the current node does not have any node next to it.<a href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17" role="doc-endnote"><p>The literal meaning of "Su-doku" in Japanese is "the number that is single".<a href="#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn18" role="doc-endnote"><p>In row-major order, the rows of the grid are stored next to each other in the string.<a href="#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn19" role="doc-endnote"><p>NP stands for Non-deterministic Polynomial time. A problem that can be solved in polynomial time (efficiently) by a non-deterministic turing machine and for which its solution can be efficiently verified to be correct by a deterministic turing machine. A problem in NP is complete if by solving it you are able to solve every other problem in NP. This means that an NP-complete problem is at least as hard as every other problem in NP.<a href="#fnref19" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn20" role="doc-endnote"><p><span class="math inline">\(17\)</span> clues has been proved to be the lower-bound for having a puzzle with a <strong>unique</strong> solution<a href="#fnref20" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn21" role="doc-endnote"><p>Suppose <span class="math inline">\(W(x)\)</span> is the number of possible ways you can jump from position <span class="math inline">\(x\)</span> to the end of the array at index <span class="math inline">\(N\)</span>. We know that <span class="math inline">\(T(N) = 1\)</span> (the only way to jump from cell <span class="math inline">\(N\)</span> to itself is not to jump at all). For all other cells we have that: <span class="math display">\[\begin{aligned}
		W(x) = \sum_{i=x+1}^N W(i) \\
		 = W(x+1) + \sum_{i=x+2}^N W(i) \\
		 = W(x+1) + W(x+1) \\
	  \end{aligned}\]</span> So in order to calculate <span class="math inline">\(W(X)\)</span> we need the values <span class="math inline">\(W(x+1)\)</span> two times. The recursive tree for <span class="math inline">\(W\)</span> is binary and complete and has height <span class="math inline">\(N\)</span> and therefore contains <span class="math inline">\(O(2^N)\)</span> number of nodes.<a href="#fnref21" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn22" role="doc-endnote"><p>if we do not consider the spaces utilized by the stack frames during the recursive calls, otherwise it is linear.<a href="#fnref22" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn23" role="doc-endnote"><p>Example of such data structures are:</p>
<div class="enumerate*">
<p>ordered multiset (for instance implemented as a self-balancing binary search tree)</p>
<p>heap or priotiry queue.</p>
</div>
<a href="#fnref23" class="footnote-back" role="doc-backlink">↩︎</a></li>
<li id="fn24" role="doc-endnote"><p>does not really erase anything from the heap. It moves the head of the heap to the end of the array and rearranges all the elements from the begin of the array to the one before the last into a valid heap thus effectively reducing the size of the heap by one.<a href="#fnref24" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn25" role="doc-endnote"><p>expects the elements to be inserted into the heap to be placed at the very end of the array.<a href="#fnref25" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn26" role="doc-endnote"><p>If that was not true it would mean that:</p>
<ul>
<li><p><span class="math inline">\(I_k = I_{j+1}\)</span>. In this case, picking <span class="math inline">\(K\)</span> would not be an improvement to <span class="math inline">\(j-1\)</span> or <span class="math inline">\(j+1\)</span>.</p></li>
<li><p>otherwise either:</p>
<ul>
<li><p><span class="math inline">\(\exists k &lt; j-1 \: : I_k &lt; I_{j-1}\)</span> and <span class="math inline">\(x-I_k &lt; x-I_{j-1}\)</span> or</p></li>
<li><p><span class="math inline">\(\exists k &gt; j+1 \: : I_k &gt; I_{j+1}\)</span> and <span class="math inline">\(I_k-x &lt; I_{j+1}-x\)</span></p></li>
</ul>
<p>which is impossible because the input is sorted.</p></li>
</ul>
<a href="#fnref26" class="footnote-back" role="doc-backlink">↩︎</a></li>
<li id="fn27" role="doc-endnote"><p>In such case changing the arrangements of the node would change the meaning of the data.<a href="#fnref27" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn28" role="doc-endnote"><p>One of the oldest board game. A two-players game where pieces are moved around between twenty-four triangles according to the roll of two 6 faced-dice. The goal of each player is to remove all of their 15 pieces before the other player<a href="#fnref28" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn29" role="doc-endnote"><p><strong>petaflop</strong>: A petaflop is a measure of a computer’s processing speed and can be expressed as: A quadrillion (thousand trillion) floating-point operations per second (FLOPS). A thousand teraflops. 10 to the 15th power FLOPS. 2 to the 50th power FLOPS. A huge number of operations per second.<a href="#fnref29" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn30" role="doc-endnote"><p>to indicate that an object t may be "moved from", i.e. allowing the efficient transfer of resources from t to another object without the need for an explicit copy.<a href="#fnref30" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn31" role="doc-endnote"><p>This type of functions are commonly known as <em>predicates</em>.<a href="#fnref31" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn32" role="doc-endnote"><p><a href="https://en.cppreference.com/w/cpp/algorithm/remove">https://en.cppreference.com/w/cpp/algorithm/remove</a><a href="#fnref32" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn33" role="doc-endnote"><p>Notice the similarities with Listing <a href="#list:remove_duplicated_sorted_array_inplace_stl" data-reference-type="ref" data-reference="list:remove_duplicated_sorted_array_inplace_stl">[list:remove_duplicated_sorted_array_inplace_stl]</a> for the problem in Chapter <a href="#ch:remove_duplicated_sorted_array_inplace" data-reference-type="ref" data-reference="ch:remove_duplicated_sorted_array_inplace">45</a><a href="#fnref33" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn34" role="doc-endnote"><p>is used to indicate that an object t may be "moved from", i.e. allowing the efficient transfer of resources from t to another object without the need for an explicit copy.<a href="#fnref34" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn35" role="doc-endnote"><p>See Listing <a href="#list:listings:hash_pair" data-reference-type="ref" data-reference="list:listings:hash_pair">[list:listings:hash_pair]</a> at page .<a href="#fnref35" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn36" role="doc-endnote"><p>You can treat the sign as a special kind of digit. You sort the pile on the units, then the tens, etc. and finally on the sign. This does produce a reversed order for the negatives, you then simply reverse the contents of that bucket.<a href="#fnref36" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn37" role="doc-endnote"><p><a href="https://en.wikipedia.org/wiki/Pigeonhole_principle">https://en.wikipedia.org/wiki/Pigeonhole_principle</a><a href="#fnref37" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn38" role="doc-endnote"><p>Constructing and returning the difference between the largest and smallest element among all of the <span class="math inline">\(2K^{|I|}\)</span> possible arrays you can obtain by adding any of the <span class="math inline">\(2K\)</span> between <span class="math inline">\(-K\)</span> and <span class="math inline">\(K\)</span> to each and every element of <span class="math inline">\(I\)</span>.<a href="#fnref38" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn39" role="doc-endnote"><p>When I say "large enough" I really mean that <span class="math inline">\((M-K) - (m+K) = M-m-2K \leq 0\)</span>.<a href="#fnref39" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn40" role="doc-endnote"><p>When <span class="math inline">\((M-m) &gt; 2K\)</span>.<a href="#fnref40" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn41" role="doc-endnote"><p><a href="https://en.cppreference.com/w/cpp/algorithm/minmax_element">https://en.cppreference.com/w/cpp/algorithm/minmax_element</a><a href="#fnref41" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn42" role="doc-endnote"><p>The intuition behind this is that adding <span class="math inline">\(K\)</span> to <span class="math inline">\(m\)</span> would yield <span class="math inline">\(m&#39; = m+K\)</span> which is greater or equal than <span class="math inline">\(M\)</span>. Similarly, subtracting <span class="math inline">\(K\)</span> to <span class="math inline">\(M\)</span> would yield <span class="math inline">\(M&#39; = M-K\)</span> which is smaller or equal than <span class="math inline">\(m\)</span>. The gap between <span class="math inline">\(m&#39;\)</span> and <span class="math inline">\(M&#39;\)</span> is larger or equal than the gap between <span class="math inline">\(m\)</span> and <span class="math inline">\(M\)</span>. When <span class="math inline">\((M-m) &lt; K\)</span> then we can express <span class="math inline">\(K\)</span> in terms of <span class="math inline">\(M-m\)</span> as follows: <span class="math inline">\(K = M-m + x\)</span> where <span class="math inline">\(x \geq 0\)</span>. Therefore by adding <span class="math inline">\(K\)</span> to <span class="math inline">\(m\)</span> and subtracting <span class="math inline">\(K\)</span> to <span class="math inline">\(M\)</span> we get: <span class="math inline">\(|(M-K) - (m-K)| = |(M-(M-m + x)) - (m + (M-m + x))| = |(m-x) - (M+x)|\)</span> which is at least as large as <span class="math inline">\(M-m\)</span>.</p>
<p>For instance given <span class="math inline">\(I = \{1,2,6,8\}\)</span> and <span class="math inline">\(K = 10 &gt; (8-1) = 7\)</span> if we add <span class="math inline">\(10\)</span> to the smallest element of <span class="math inline">\(I\)</span> and substract <span class="math inline">\(10\)</span> to its largest, we end up with: <span class="math inline">\(1+10 = 11\)</span> and <span class="math inline">\(8-10=-2\)</span>. The difference between these two new values is <span class="math inline">\(11-(-2) = 13\)</span> which is definitely larger than the difference between <span class="math inline">\(1\)</span> and <span class="math inline">\(8\)</span>.<a href="#fnref42" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn43" role="doc-endnote"><p>Note that we do not use the free function <a href="https://en.cppreference.com/w/cpp/algorithm/upper_bound"></a> because on non linear data structures (like ) it operates in linear time instead of logarithmic time.<a href="#fnref43" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn44" role="doc-endnote"><p>The recurrent relation the number of bits set in <span class="math inline">\(k\)</span> is as shown in Equation <a href="#eq:count_bits:dpformula_powers" data-reference-type="ref" data-reference="eq:count_bits:dpformula_powers">[eq:count_bits:dpformula_powers]</a> where <span class="math inline">\(B(x)\)</span> is a function returning the number of bits set in the binary representation of the integer <span class="math inline">\(x\)</span>: <span class="math display">\[\begin{cases}
		B(0) = 0 \\
		B(1) = 1 \\
		G(k) =  1 + G(k-(2^{\floor{log_2{k}}})) 	 \end{cases}
	\label{eq:count_bits:dpformula_powers}\]</span><a href="#fnref44" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn45" role="doc-endnote"><p>It is a simple form of data compression in which a stream of data is given (like the following string "AAABBCCCC") and the output is a sequence of counts of consecutive data values in a row. (i.e. "3A2B4C"). It is a type of lossless encoding meaning that the encoding process does not lose any information in the original input and therefore the input data can be recovered fully and integrally. decoded.<a href="#fnref45" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</article>
</body>
</html>