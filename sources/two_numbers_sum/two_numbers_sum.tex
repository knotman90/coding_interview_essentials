%!TEX root = ../main.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Links: https://www.geeksforgeeks.org/count-pairs-with-given-sum/
% https://algorithms.tutorialhorizon.com/given-an-array-and-a-number-k-check-for-pair-in-array-with-sum-as-k-in-onlgn/
% https://coderbyte.com/algorithm/two-sum-problem https://en.wikipedia.org/wiki/Subset_sum_problem
%
% Difficulty: Easy Companies: Microsoft, Amazon, Google
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapterimage{header} % Table of contents heading image

\chapter{Two numbers sum problem}
\label{ch:two_numbers_sum}
\section*{Introduction}
The problem described in this section is possibly one of the most asked during coding interview, nowadays mostly 
asked during the early online stages of the hiring process as the interviewer pretty much expects you to be at least familiar with the problem.
The problem is hard enough to require non-trivial insight in order to be able to write a non-naive solution for it but at the same time it is not so hard that it would take you 2 hours to come up with something to say to the interviewer.
We will have a look at a number of solution, starting from the inefficient bruteforce in Section \ref{sec:two_numbers:bruteforce} to a refined version of it in Section \ref{sec:two_numbers:hashing}.
In Section \ref{sect:two_number_problem_binary_search} we will have a look at an approach that is based on a idea that is radically different than the one the previous two are based on.
Finally, Section \ref{sec:two_numbers:twopointers} further refines it into  possibly the best solution in terms of overall time and space complexity.

\section{Problem statement}

\begin{exercise}
Write a function that takes an array of integers and a integer $T$, and returns \textbf{true} if the
sum of two distinct elements of the array is equal to $T$, \textbf{false} otherwise.


\begin{example}
\hfill \\
	\begin{itemize}
		\item[-] 	$A=\{9, 4, 17, 42, 36, -3 ,15\}$
		\item[-] 	$T = 14$
	\end{itemize}
The answer in this case is \textbf{true} because elements we can obtain $14=17+ (-3)$. If $T=17$
then the answer would be \textbf{false} as there is no way we can sum two numbers together and
obtain $17$
\end{example}

\begin{example}
\hfill \\
	\begin{itemize}
		\item[-] 	$A=\{1,3,7\}$
		\item[-] 	$T = 8$
	\end{itemize}
The answer in this case is \textbf{true} because elements we can obtain $8=1+7$. If $T=6$ then the
answer would be \textbf{false}.
\end{example}


More formally, what the problem asks is: given an array $A=\{a1...an\}$ and $T$, where $a_i, T \in
\mathcal{N}$, return:
	\begin{itemize}
		\item[-] \textbf{true }if $\exists \;i,j \: i \neq j$ s.t. $a_i+a_j = T$
		\item[-] \textbf{false} otherwise
	\end{itemize}
\end{exercise}	


\section{Clarification Questions}
\begin{QandA}
	\item is the input array modifiable?
	\begin{answered}
		\textit{Yes, the input array can be modified.}
	\end{answered}
	
	\item Are the integers always positive of negative?  
	\begin{answered}
		\textit{No, input numbers can be either positive or negative.}
	\end{answered}
	\item Are the input integer always from a certain range?
	\begin{answered}
		\textit{No, the input is arbitrary. No assumption can be made.}
	\end{answered}
	\item Can a pair be considered made from an element and itself?
	\begin{answered}
		\textit{No, elements should be distincts.}
	\end{answered}
	\item Are all elements in the array unique?
	\begin{answered}
		\textit{No, repetition is allowed.}
	\end{answered}
	\item Is the input sorted?
	\begin{answered}
		\textit{No, array ordering is arbitrary.}
	\end{answered}
	\item Shall integer overflow be considered when performing the sum of two integer? 
	\begin{answered}
		\textit{No, the input elements are such that no overflow can occur..}
	\end{answered}
\end{QandA}


\section{Discussion}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%        quadratic solution
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Brute-force}
\label{sec:two_numbers:bruteforce}
The brute force solution is fairly straightforward because it consists in applying the search method
described in the formal problem statement. The solution spaces consists of all possible ordered and
distinct pairs $(a_i,A_j)$, $i < j$ of element of $A$. Two nested loops can be used to enumerate all
the pairs and for each of them we can check whether their sum is equal to $T$: if that is the case
then   \textbf{True} can be immediately returned (see Algorithm \ref{algo:two_number_sum_bruteforce}
and Listing \ref{list:two_number_sum_bruteforce}).

\begin{algorithm}
	\SetAlgoLined \SetKwFunction{FMain}{solveQuadratic}
	
	\KwIn{$ A $ \tcp{An array $A$ of length $n$}} \KwIn{$ T $ \tcp{An integer $T$}}

	\Fn{\FMain{$A,T$}}{
	
		%\Output{true if two distinct element of $A$ sum to $T$}
		
		\For{$i\leftarrow 0$ \KwTo $n-1$} {\For{$j\leftarrow i+1$ \KwTo $n$} {\If{$a_i + a_j =
		T$}{\Return True \;}}} \Return False \;}\textbf{End Function}
	
	\label{algo:two_number_sum_bruteforce}
	\caption{Two loops, quadratic solution to the question in Section \ref{ch:two_numbers_sum} }
\end{algorithm}
The following code implements this idea:

\lstinputlisting[language=c++, caption="C++ solution of the two number sum problem with a brute force approach.",label=list:two_number_sum_bruteforce]{sources/two_numbers_sum/brute_force.cpp}

The time complexity of this solution is quadratic $O(n^2)$ because there is a quadratic number of
ordered pairs.\footnote{The number of iteration of the internal loop depends on the value of $i$ and
it is described by the following function: $f(i) = n-i-1$. The total number of iteration the second
loop runs in the worst case is the the sum over all values of $i$: $\sum_{0}^{n-2}f(i) = (n-1) +
(n-2) + (n-3) \dots + 1$ = $\sum_{1}^{n-1} = \frac{n(n-1)}{2} = O(n^2)$}. The space complexity of is
$O(1)$.

\subsection{Hashing}
\label{sec:two_numbers:hashing}
The internal loop of Listing \ref{list:two_number_sum_bruteforce} can be faster if an hashtable is
used. The idea is that the input array is scanned one element at the time and a solution exists
involving $a_i$ is the element $a_j  = a_i-T$ with $j < i$ exists. The key idea here is that all the
A[j] can be stored in the hash table making the lookup operation lighting fast. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% two_numbers_sum_hashset       
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{algorithm}
	%	\KwData{} \KwResult{Tr }
	\KwIn{$ A $ \tcp{An array $A$ of length $n$}} \KwIn{$ T $ \tcp{An integer $T$}} \KwOut{true if
	two distinct element of $A$ sum to $T$, False otherwise} \SetKwFunction{FMain}{solveHashSet}
	
    \Fn{\FMain{$A,T$}}{H $\longleftarrow$ \CreateHashSet \;
	
		\For{$i\leftarrow 0$ \KwTo $n$} {target $\leftarrow$ $(T-a_i)$ \eIf{H.find(target)} {\Return
		True} {H.insert($a_i$)}} \Return False\;}\textbf{End Function}

	\label{algo:two_number_sum_hashset}
	\caption{Hashset, linear solution to the \textit{two number sum} question in Section
	\ref{ch:two_numbers_sum}.}
\end{algorithm}


\lstinputlisting[language=c++, caption="C++ solution of the two number sum problem using hashing.",label=list:two_number_sum_hashing]{sources/two_numbers_sum/hashset.cpp}

A common mistake when solving this problem is when the whole input array is inserted into the
hash-table and only after search for the target value $T-a_i$ (see Algorithm
\ref{algo:two_numbers_sum_hashset_wrong}). The problem with this approach is that if the target is
an even number i.e. $ 2 | T$ and $\frac{T}{2} \in A$ exactly once, say it is the element $a_k$, then
$H.find(T-a_k=\frac{T}{2})$ returns true. The following example exposes the problem:
\begin{example}
	\hfill \\ 
	\begin{itemize}
		\item[] $A=\{1,2,5,4\}$
	\item[] $T = 10$
\end{itemize}
The Algorithm \ref{algo:two_numbers_sum_hashset_wrong} return True even if there are not two
distinct elements in $A$ whose sum is $T$.
\end{example}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% two_numbers_sum_hashset_wrong       
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{algorithm}
	\SetKwInOut{Input}{input} \SetKwInOut{Output}{output}
	\SetKwFunction{CreateHashSet}{CreateHashSet<int>} \Input{An array $A$ of length $n$} \Input{An
	integer $T$} \Output{true if two distinct element of $A$ sum to $T$}
	
	\SetKwFunction{FMain}{solveHashSet} \Fn{\FMain{$A,T$}}{H $\longleftarrow$ \CreateHashSet \;
		\tcp{Add the whole array in the hashset}
		\For{$i\leftarrow 0$ \KwTo $n$} {H.insert($a_i$)\;}
		
		\For{$i\leftarrow 0$ \KwTo $n$} {target $\leftarrow$ $T-a_i$ \; \If{H.find(target)} {\Return
		True}} \Return False\;}\textbf{End Function}
	\label{algo:two_numbers_sum_hashset_wrong}
	\caption{Hashset, linear solution to the \textit{two number sum} question in Section
	\ref{ch:two_numbers_sum} }
\end{algorithm}
The time complexity of this approach is $O(n)$ because the input array is scanned once and for each
of its element only one lookup and insertion is performed in the hash-table.  The space complexity
is also $O(n)$, as in the worst case the whole input array is stored in the lookup table.

\subsection{Sorting and binary search}
\label{sect:two_number_problem_binary_search}
As always when an array problem is presented, the opportuinity to sort the array often open the
possibility for fast and efficient solution. In this case a good question to ask is, what happens
when the array is sorted? This should immediately lead to binary search. In particular, again, the
internal loop of Listing \ref{list:two_number_sum_bruteforce} can be turned into a binary search if
the input array is sorted thus lowering the overall complexity down to $O(n log(n))$ becaue it takes
$O(n log(n))$ to sort the input array in the first place and the actual search costs $n$ binary
search, each costing $log(n)$. The space complexity is $O(1)$ because no additional space is
required since the array is sorted in place. 

Listing \ref{list:two_number_sum_sorting} shows a C++ implementation of the idea above using the
\texttt{std::binary\_search} c++ stardard library function.


\lstinputlisting[language=c++, caption="C++ solution of the two number sum problem with sorting and binary search.",label=list:two_number_sum_sorting]{sources/two_numbers_sum/two_numbers_sum_sorting.cpp}


\subsection{Two pointers}
\label{sec:two_numbers:twopointers}
There is a variation to the approach described in Section
\ref{sect:two_number_problem_binary_search} which still involves sorting but uses two pointers
tecnique instead of binary search. The key idea of this approach is that once the array is sorted
two pointers, one starting at the beginning and the other at the end, of the array, respectively.

The algorithm works by looking at the sum of the elements pointed by the pointers and moving one of
the two at each step using the following logic. Let $p_s$ and $p_e$ be the starting and ending
pointers, respectively, then:
\begin{itemize}
	\item[-] if $a[p_s]+a[p_e] = T$ a solution has been found. The algorithm returns true.
	\item[-] if $a[p_s]+a[p_e] > T$, $p_e=p_e-1$. The rightend pointer is moved to the left. Moving
	$p_e$ to the right makes the sum smaller in the next iteration. 
	\item[-] if $a[p_s]+a[p_e] < T$, $p_s=p_s+1$. The rightend pointer is moved to the left. Moving
	$p_s$ to the right makes the sum higher in the next iteration. 
\end{itemize}

Listing \ref{list:two_number_sum_two_pointers} shows an implementation of the idea above.  Note that
this solution has an additional strenght i.e.  it is short and simple to write. 

\lstinputlisting[language=c++, caption="C++ solution of the two number sum problem with the two pointers tecnique.",label=list:two_number_sum_two_pointers]{sources/two_numbers_sum/two_numbers_sum_two_pointers.cpp}

Despite the oveall complexity is still $O(n log(n))$ this solution is it likely to be faster than
the one presented in Section \ref{sect:two_number_problem_binary_search}, mostly because in this
case the array is search somehow linearly and not in a scattered way as in the case of binary
search.

%%%%%%%%%%%%%%%%%%%%%
\section{Common Variations}
\subsection{Four number sum problem}
\label{sec:four_number}

\subsection{Problem statement}

\begin{exercise}
Write a function that takes four arrays of integers, $A,B,C,D$ and a integer $T$,
and returns how many distinct tuple $(i,j,k,l)$ where exist such that 
$A_i+B_j+C_k+D_l = Y$.

\begin{example}
\hfill \\
Given:
	\begin{itemize}
		\item[-] 	$A=\{1,2\}$,
		\item[-] 	$B=\{-2,-1\}$,
		\item[-] 	$C=\{-1,2\}$,
		\item[-]	$D=\{0,2\}$, and 
		\item[-] 	$T = 0$
	\end{itemize}
The answer is $2$ because the only two valid tuples are:
\begin{enumerate}
	\item $(0,0,0,1)$: $A_0 + B_0 + C_0 + D_1 = 1 + (-2) + (-1) + 2 = T = 0$
	\item $(1,1,0,0)$: $A_1 + B_1 + C_0 + D_0 = 2 + (-1) + (-1) + (-1) = T = 0$
\end{enumerate}
\end{example}
\end{exercise}

\subsection{Na\"ive $O(n^4)$ solution}
We can solve this problem very easily by using the same approach we have described in Section \ref{sec:two_numbers:bruteforce}.
The idea is that we can use four nested loops and enumerate all possible 4-elements tuples of indices. Listing \ref{list:two_number_sum_naive} shows how such an idea can be implemented.
Goes without saying, that this is not the fastest solution we can come up with, considering it has a time complexity of $O(n^4)$

\lstinputlisting[language=c++, caption="Brute force na\"ive solution to the four numbers sum problem.",label=list:two_number_sum_naive]{sources/two_numbers_sum/variations/four_number_sum/four_number_sum_solution1.cpp}


\subsection{$O(n^3)$ solution}
The trivial solution shown in Listing \ref{list:two_number_sum_naive} can be improved by using a similar reason that lead us improve the brute-force 
quadratic time solution for the two numbers problem in Listing \ref{list:two_number_sum_bruteforce} to the linear time (and space) in Listing \ref{list:two_number_sum_hashing}.
The idea is that inner-most loop is searching for a value $x$  s.t. if it summed to $A_i+B_j+C_k$ gives us $T$; in other words: $x+(A_i+B_j+C_k)=T$.
Therefore $x = T-(A_i+B_j+C_k)$. If there is a way of avoiding a linear search in the array $D$ for such a value, then we could bring down the complexity from $O(n^4)$ to $O(n^3)$.

Thankfully this is possible if we use a hashmap. If we create a hashmap mapping the value of $D$ and to their frequencies the inner-most loop of Listing \ref{list:two_number_sum_naive} can be substituted with a query to the hashmap which 
runs in constant time. Listing \ref{list:two_number_sum_cubic} shows an implementation of such idea. 
Notice that in order to obtain the maximum saving in terms of work avoided the arrays are rearranged in such a way so that $D$ 
is the longest of the four input arrays. 
\lstinputlisting[language=c++, caption="Brute force cubic time solution to the four numbers sum problem.",label=list:two_number_sum_cubic]{sources/two_numbers_sum/variations/four_number_sum/four_number_sum_solution2.cpp}


\subsection{$O(n^2)$ solution using hashing}
This problem can be however be solved in quadratic time if we use hashmaps again, to hold 
the frequencies of all the values you can obtain by summing up any two elements of $A$ and $B$ and of $C$ and $D$.
The key idea is that we can build two hashmaps:
\begin{itemize}
	\item $AB$: holding the frequencies of the values obtainable by summing any two elements of $A$ and $B$
	\item $AB$: holding the frequencies of the values obtainable by summing any two elements of $C$ and $D$.
\end{itemize}
The space required for both $AB$ and $CD$ is quadratic, more than the space used by any of the previous solutions, but this extra space
enable us to solve this problem also in quadratic time. 
The idea is that we are going to spend $O(n^2)$ time to construct both $AB$ and $CD$
and then again  $O(n^2)$ to calculate the final answer. 
by searching into $CD$ for the value $T-y$ where $y$ is an element of $AB$. If such a value exists in $CD$ it means that there exists one element in  $A$ and one in $B$ such that they sum up to $y$ and
one element $C$ and one in $D$ such that they sum up to $T-y$. Summing all these elements up gives: $y+T-y = T$.

Listing \ref{list:two_number_sum_quadratic} implements this idea.
\lstinputlisting[language=c++, caption="Quadratic time solution to the four numbers sum problem.",label=list:two_number_sum_quadratic]{sources/two_numbers_sum/variations/four_number_sum/four_number_sum_solution3.cpp}



