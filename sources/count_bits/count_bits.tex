%!TEX root = ../main.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Links:
%
% Difficulty:
% Companies: 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\begin{figure}
%	\centering
%	\includegraphics[width=\textwidth]{sources/count_bits/images/example1}
%	\caption[Sample short cpation]{Sample Caption}.
%	\label{fig:count_bits:example1}
%\end{figure}

\chapter{Count the bits}
\label{ch:count_bits}

\section{Problem statement}
\begin{exercise}
\label{example:count_bits:exercice1}
Given a non negative integer number $n$ return an array $B$ of size $n+1$ where $B_i$ contains the 
number of bits set in the number $i$.
	%example1
	\begin{example}
		\label{example:count_bits:example1}
		\hfill \\
		Given $n = 5$ the function returns $B = \{0,1,1,2,1,2,2\}$	
	\end{example}

\end{exercise}

\section{Clarification Questions}

\begin{QandA}
	\item Can we assume $n$ is always positive?
	\begin{answered}
		\textit{Yes, you do not have to do any input validation}
	\end{answered}
	
\end{QandA}

\section{Discussion}
\label{count_bits:sec:discussion}


\subsection{Na\"ive approach solution}
\label{count_bits:sec:bruteforce}
Let's be honest, this is an easy problem.
All we have to do is to brute-force our way by counting the numbers of bits set for each and every number.
Each number has a fixed size which on most the common modern C++ implementation is $32$-bit \inline{int}
and therefore we can come up with a $\Theta(32n)$ solution. 
Counting the bits of a given integer can be even done with \href{https://gcc.gnu.org/onlinedocs/gcc-4.9.2/gcc/X86-Built-in-Functions.html}{compiler intrinsics} as \inline{__builtin_popcount}
which can map directly, when supported by the hardware, to fast machine instructions or by using some simple bit manipulation. 
From C++20 we also can use the \inline{std::popcount} function, together with a bunch of lot more bit related functions (in the header \inline{<bit>}).
Listing \ref{list:count_bits:bruteforce} shows an implementation of this idea where we use our own version of the bit counting function \inline{my_pop_count} for the sake of showing how this can be implemented.

\lstinputlisting[language=c++, caption={Bruteforce solution where we manually count the number of bits for each number.},label=list:count_bits:bruteforce]{sources/count_bits/count_bits_solution1.cpp}

\subsection{DP solution}
\label{count_bits:sec:dp}
This problem can be solved in a more elegant way using dynamic programming. This approach will also 
solve it without incurring in a factor $32$ penalty for the count of the bits of every number.

The idea is that the number of bits set for a given number is equal to the number of bit set in the same number shifted one position to the right
(removing the last bit), which is always smaller thn the number we started with, plus one if the removed bit was $1$.

For instance consider $x=2730_{10} = 101010101010_2$. The least significant bit of $x$ is $0$ therefore its number of bits set is equal to
the number of bits set of $y=1365_{10} = 10101010101_2$ (last bit removed).
For the same reasons the number of bits set in $y$ is one (because the last bit is $1$) plus the number of bits set in $y=682_{10} = 1010101010_2$(last bit removed).
We can follow this line of reasoning until we reach $0$, which clearly has zero bits set.

Because everytime we remove a bit we are solving a smaller problem, 
and because the same problems can required for many different $n$, we can adopt DP.
In a DP solution we will use $B$ as a DP table, which we initially fill only for the number $0$. 
We will then follow a bottom-up approach where we start solving problems from $x=1,2,\ldots,n$. When we reach a given number $y$
we have already solved and stored into $B$ the answer for every other number less than $y$, therefore we can solve $y$! 
Moreover because the answers for all of these numbers smaller than $y$ are stored in $B$
we do not need to recompute them.
Listing \ref{list:count_bits:DP} shows an implementation of this approach. 
You can find a shorter (three lines) and more compact (and possibly unreadable) version of the same idea in Listing \ref{list:count_bits:DP_short}.

\lstinputlisting[language=c++, caption={DP solution where we calculate the bits for a given number from the its last bit and the answer of the number resulting from removing that last bit.},label=list:count_bits:DP]{sources/count_bits/count_bits_solution2.cpp}

\lstinputlisting[language=c++, caption={ Shorter version of Listing \ref{list:count_bits:DP}.},label=list:count_bits:DP_short]{sources/count_bits/count_bits_solution3.cpp}

\subsection{Another efficient approach}
\label{count_bits:sec:pattern}
There is another way of solving this problem which is quite different than the DP approach we discussed above.
The idea is that a power of $2$ always have one and only one bit set. For instance the $2^2$ always have the bit at index $2$ set and the rest of the bit not set.
The same applies for any other power of two $2^k$ where only the bit at index $k$ is set.
All the numbers from $2^k$ to $2^{k+1}-1$ can be obtained by concatenating a $1$ (the bit at index $k$)
with any of the binary representation of as number smaller than $2^k$.

For instance let's take $k=4$ as an example. All the numbers from $2^4 = 16$ to $2^5-1 = 31$ can be obtained as shown below:
\begin{itemize}
	\item $16 = 16+0 = 10000_2+ 0_2$
	\item $17 = 16+1 = 10000_2+ 1_2$
	\item $18 = 16+2 = 10000_2+ 10_2$
	\item $19 = 16+3 = 10000_2+ 11_2$
	\item $20 = 16+4 = 10000_2+ 100_2$
	\item $21 = 16+5 = 10000_2+ 101_2$
	\item $22 = 16+6 = 10000_2+ 110_2$
	\item $23 = 16+7 = 10000_2+ 111_2$
	\item $24 = 16+8 = 10000_2+ 1000_2$
	\item $25 = 16+9 = 10000_2+ 1001_2$
	\item $\ldots$
\end{itemize}
As you can see the answer for all the numbers from $16$ to $31$ can be calculated by adding one to the
answer of all the rest of the numbers we have already calculated (the numbers from $0$ to $15$).
Clearly the same applies for smaller $k$. 
For $k=2$ we have:
\begin{itemize}
	\item $4 = 4+0 = 100_2+ 0_2$
	\item $5 = 4+1 = 100_2+ 1_2$
	\item $6 = 4+2 = 100_2+ 10_2$
	\item $7 = 4+3 = 100_2+ 11_2$
\end{itemize}
We can use this idea to build a fast and efficient solution which is shown in Listing \ref{powers}.
\lstinputlisting[language=c++, caption={ Alternative efficient solution that uses solutions to smaller problems. \ref{list:count_bits:powers}.},label=list:count_bits:DP_short]{sources/count_bits/count_bits_solution4.cpp}
