%!TEX root = ../main.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Links:
%
% Difficulty:
% Companies: 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Find the majority element}
\label{ch:majority_element}
\section*{Introduction}
The problem described in this chapter has been asked at Microsoft, Google, Amazon and Yahoo interview for software engineering position and it is considered a problem of easy/medium difficulty.

\section{Problem statement}
\begin{exercise}
Given an array $N$ of size $n$, find the majority element i.e. that element that appears more than $\floor{\frac{n}{2}}$ times.
If such element does not exists, returns $-1$.
	\begin{example}
		\hfill \\
		Given the array $[1,2,3,2,2,1,1,1]$, the function returns $1$ because it appears $4$ times in an array of length $8$.
	
	\end{example}

	\begin{example}
		\hfill \\
		Given the input array $[2, 1, 2]$ the function return $2$ because it is greater than $\frac{3}{2}$.
		
	\end{example}

	\begin{example}
		\hfill \\
		Given the input array $[2, 1, 2,3,4,5]$ the function return $-1$no element appear more than $3$ times.
		
	\end{example}

\end{exercise}

\section{Clarification Questions}

\begin{QandA}
	\item What are the minimum and maximum value an element of the array can take? 
	\begin{answered}
		\textit{The minimum and maximum values are $[-10^9, 10^9]$, respectively}.
		This is a good question to ask because if the range is small then we can apply a solution based on bucket counting.
	\end{answered}

	\item Can the input array $N$ be modified or shuffled. 
	\begin{answered}
		\textit{Yes, the input array can be modified.}
	\end{answered}
\end{QandA}

\section{Discussion}
\label{majority_element:sec:discussion}
We will have a look at three different solution for this problem. We will start our discussion by having a look in section \ref{majority_element:sec:bruteforce} at the brute-force approach. Section section \ref{majority_element:sec:sorting} will describe an approach that uses sorting to improve the time complexity on the brute-force approach. Lastly in section \ref{majority_element:sec:linear} we will the optimal approach.

\subsection{Brute-force}
\label{majority_element:sec:bruteforce}
The brute force solution is brutally simple and consist in, looping through the array, and for each element counting how many times it occurs in the input array. This approach, despite its simplicity should not be the one provided to the interviewer, as it is far from the optimum and the interviewer is certainly expecting more from us.
Listing \ref{list:majority_element} shows a possible implementation of this idea. 

\lstinputlisting[language=c++, caption={Sample Caption},label=list:majority_element]{sources/majority_element/majority_element_solution1.cpp}


\subsection{Hash-map approach}
\label{majority_element:sec:hashmap}

A possible implementation of this approach is shown in Listing \ref{list:majority_element}.
The idea described in section \ref{majority_element:sec:bruteforce} can be improved by using an hash-map to store the number of occurrence of each element in the input array. There cannot be more than $n$ different numbers in the the array $N$, thus with a single pass of the input and with a linear cost in space we can calculate the number of occurrence of each element and check if any of the counters at any points gets higher than $\floor{\frac{n}{2}}$.

The complexity of this approach is $O(n)$ for both space and time. In-fact, in the worst case all the element of the input array are only read and stored once.

\lstinputlisting[language=c++, caption={Solution to the problem of finding the majority element in an array using hash-map.},label=list:sorting]{sources/majority_element/majority_element_solution2.cpp}

\subsection{Sorting}
\label{majority_element:sec:sorting}
The approach described in section \ref{majority_element:sec:hashmap} is definitely faster then the quadratic brute-force but at a linear price in space. IN order not to pay the price in space but to lower the time complexity down from quadratic, we could rely on the fact that in a sort collection of elements all equal elements appear grouped together e.g. in $[1,1,2,2,3,3,3,4,4,9,9]$, all the $1$s appear at the beginning of the array, followed by all the $2$s, etc.

\lstinputlisting[language=c++, caption={Solution  to the problem of finding the majority element in an array using sorting.},label=list:sorting]{sources/majority_element/majority_element_solution3.cpp}


\subsection{Linear time}
\label{majority_element:sec:linear}

\lstinputlisting[language=c++, caption={Linear time constant space solution to the problem of finding the majority element in an array.},label=list:linear]{sources/majority_element/majority_element_solution4.cpp}


