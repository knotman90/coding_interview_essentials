\chapter*{A note from the author}
\addcontentsline{toc}{chapter}{A note from the author}
I started writing what would eventually become this manuscript in 2018 but in truth, its origins lie in a habit I formed years earlier. 

Whilst still a student, I began a routine of solving at least one serious coding interview or competitive programming challenge per day and, for those I considered most interesting, putting together a markdown document with a summary of the problem and all the solutions I could identify as well as the thought processes that had led me to them.  Essentially I created a series of short essays made up of written code and notes that I could use to bootstrap my understanding of the problem months or years later with the idea that, when it was time to throw myself into a real interviews,  I could use thesel as a reference and sharpen my preparation with material that I knew was correct and that was in a format that I could absorb and understand quickly.

Over the years I accumulated a substantial amount of material and I eventually started sharing it with colleagues at the university and at work.  Many of them found the content and the format of my notes useful and convinced me to polish, add illustrations, and organize them into a proper collection which ultimately formed the basis of this text book. 

I won’t claim that writing this text book has been easy. In fact, whilst the whole purpose of both this book and the study routine that begat it was preparation, I will freely admit I was unprepared for the amount of work involved. From dealing with making quality illustrations to managing a large \LaTeX document and going through the sometimes interminable rounds of revisions and proofreading (and there are likely still some linguistic errors  for which I must beg the reader’s forgiveness)  I have spent many many hours on this project. I have, however, learned a great deal and I hope that the finished text may at least prove useful to you in your interview preparation. 


Some notes on the text:  

\section*{\protect \CC as the language of choice}
Almost all the solution code in this book is written in \CC (\CC14/17/20). 
I have been using \CC academically and professionally since I started programming and the original source material I created was almost entirely \CC code. 
I chose not to rewrite it  as  \CC remains an extremely popular language, frequently adopted in the competitive programming community. Also, engineers skilled in this language continue to be in high demand making \CC, in my opinion, the ideal language to use during the type of interviews the book is intended to prepare you for. 

I have tried my best to stick to standard \CC and not to use any compiler-specific features so that it is easy to port every piece of code in this book to different mainstream imperative languages like C\#, Python, or Java.  

Of course, eventually during an interview you will  need to code solutions; preferably elegant, fast and legible ones. Absent the right algorithm, however,   all that written code will be pointless. As such  the focus of this book is less on the particular features of a specific coding language and more on understanding the insights and core ideas need to reach the optimal solutions to the problems presented.
This does not mean the code you will find in this book is sloppy or \CC unidiomatic. Quite the opposite.  I have tried to make full use of its potential at all points. 

All the solutions have been compiled and tested using \inline{gcc (GCC) 11.1.0} and \inline{clang version 12.0.1} but I am confident they will compile and work on another toolchain/system. 

\section*{Organization}
I always try to be consistent in the way I approach a problem. 
\begin{enumerate}
    \item I begin  by looking at a few examples and  considering any edge cases or ambiguities  in the problem statement that I could clarify by asking questions to the interview.
    \item When I am comfortable with my understanding of the problem, I try to consider it holistically to  either identify similarities with other problems I may have solved in the past or puzzle out a lower bound that can help direct my thinking. 
    \item I then move into summarizing (usually only on paper) the simplest solution I can think of. This is often the slowest and usually some sort of brute-force solution that can be derived from the problem statement directly.  
    \item  From there I consider whether the brute-force solution can be sped up enough to be considered good or if I need to shift my thinking in an entirely new direction.
\end{enumerate}

These steps are not set in stone and sometimes it can happen that I know the optimal solution immediately but,  for the majority of the cases, I would go through most of the steps above. Given that fact, it seemed sensible for the structure of this book to mirror this approach.  

Each chapter is broadly organized in the following manner: 
\begin{itemize}
    \item \textit{\quotes{Introduction}}, where I set the stage for the problem.
    \item \textit{\quotes{Problem statement}}, enunciating the formal statement for the problem along with a few examples.
    \item \textit{\quotes{Clarification questions}},where I list all the questions I would ask an interviewer to ensure my understanding. 
    \item \textit{\quotes{Discussion}}, where I make the first observations and deductions that I can use later when crafting solutions. The rest of this Section is usually followed by a number of subsections each describing a solution in detail. These subsections are sorted by decreasing time complexity, space used, simplicity/readability, and ease of implementation. 
    \item \textit{\quotes{Common variation}}, containing one or more variations of the problem that have been known to be used as an interview question. This section is not present in every chapter.
 \end{itemize}

It’s my opinion that  that coding interviews have a lot in common with sports competitions.  If you wish to become a good tennis player you will  rehearse the same movement over and over again until it becomes muscle memory,  but you will also consider rationally when and how to deploy each movement depending on the specific context of your current match. Coding interviews are no different. 
Interviewers are not expecting candidates to be silent and just write code as if it were muscle memory.  
A good candidate should be able to show their thought process as they go through the interview, clearly explaining the steps and demonstrating their ability to think strategically about the best solution in a high pressure environment. 

The structured approach taken in the chapters of this book are functional to this goal and can be used to rehearse solving a problem as if you were guiding the interviewer along a journey from the slowest to the best solution during your interview. 


\section*{Audience}
The intended audience of this book is intermediate/experienced software engineers with a degree of prior exposure to coding interviews or competitive programming who wish to prepare further for coding interviews.
A decent working knowledge of \CC and especially with the Standard Template Library (which is extensively used) is required even if the code presented is not particularly hard or obscure \CC. Indeed, I am sure the code is perfectly understandable to those  with experience in C-like languages. 

Having an acquaintance with the most common algorithm design techniques (like Dynamic programming for instance) is recommended but not required as, despite the fact this is not an algorithm design book, the solutions are explained in detail. However, being familiar with the concept of complexity analysis is necessary as these concepts are used as a tool to analyze each and every solution but are not explicitly explained.