%!TEX root = ../main.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Links:
%
% Difficulty:
% Companies: 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{First positive missing}
\label{ch:first_positive_missing}
\section*{Introduction}
This chapter addressed a farily common problem that is asked during on-site interview. This problem has a number of solutions different in time and space complexity. What is considered the best solution both in terms of time and space complexity might seem a bit challenging but if well explained and coded during and interview will for sure impress positively the interviewer. 
Its problem statement is really small and a bit, probably on purpouse, vague, so especially with this problem it is important to ask clarification questions and summarize the problem for the interviewer before actually starting to solve it so to make sure the statement is understood fully.

\section{Problem statement}
\begin{exercise}
	Given an unsorted integer array $A$, find the smallest missing positive integer.
\end{exercise}


\begin{example}
	\hfill \\
	Given $A=\{2, 3, 7, 6, 8, -1, -10, 15\}$ the answer is $1$.
\end{example}

\begin{example}
	\hfill \\
	Given $A=\{ 2, 3, -7, 6, 8, 1, -10, 15\}$ the answer is $4$.
\end{example}

\begin{example}
	\hfill \\
	Given $A=\{ 1, 0, -1, -2\}$ the answer is $2$.
\end{example}

\section{Clarification Questions}

\begin{QandA}
	\item Are the input numbers always positive?
	\begin{answered}
		\textit{No, the array contains positive and negative numbers.}
	\end{answered}

	\item Are all the elements distinct?
	\begin{answered}
		\textit{No, the array might contains duplicates.}
	\end{answered}
	
	\item Can be the input array be modified?
	\begin{answered}
		\textit{Yes.}
	\end{answered}

	\item Can the size of the array be zero? Can the array be empty?
	\begin{answered}
		\textit{No, the input array contains at least one element.}
	\end{answered}

\end{QandA}

\section{Discussion}
\label{first_positive_missing:sec:discussion}
This is actually a very interesting problem with application to the real life. Imagine for instance the OS has to assign PID to processes. One approach would be to keep a set of all the PID for all the processes running, and one a new one is fired up, the OS will assign to it the smallest PID not taken by any other process\footnote{In Unix, process IDs are usually allocated on a sequential basis, beginning at 0 and rising to a maximum value (usually 65535) which varies from system to system. Once this limit is reached, allocation restarts at zero and again increases. However, for this and subsequent passes any PIDs still assigned to processes are skipped.}.

\subsection{Sorting}
\label{first_positive_missing:sec:sorting}
Probably, the most intuitive way to solve this problem is by thinking about sorting the input.\footnote{One should always ask, if the problem would be easier when the input was sorted}. Having the numbers sorted is helpful and makes the problem much easier because all it is needed is traversing the array from the smallest to the largest number and stopping as soon as the numbers do not appear in sequence. 
For instance consider the array $A=\{ 9,-7,4,5,2,1\}$. When sorted the array becomes $A=\{ -7,1,2,4,5,9\}$ and two things appear obvious:

\begin{enumerate}
	\item all the negative numbers can be ignored as the statement explicitely asks for \textbf{positive} numbers
	\item the answer is $3$ because all the positive numbers smaller than $3$ are present but $3$ itself is not. All the other numbers are for sure higher than $3$ so looking forward is not necessary.
\end{enumerate}

This is indeed all it is needed to solve this problem by sorting as shown in Listing \ref{list:first_positive_missing_sorting}.

\lstinputlisting[language=c++, caption=Solution to the problem of finding the smallest missing positive integer in an array.,label=list:first_positive_missing_sorting]{sources/first_positive_missing/first_positive_missing_solution1.cpp}

