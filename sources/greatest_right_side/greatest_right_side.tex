%!TEX root = ../main.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Links:
%
% Difficulty: Easy/Medium
% Companies: 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapterimage{header}

\chapter{Greatest element on the right side}
\label{ch:greatest_right}
\section*{Introduction}
This chapter discusses a problem that is known for having been asked during on-site interview at Amazon. 
It is a quite easy problem on arrays where, in a nutshell, we are asked to find for each element of the input array the the value of the largest element to its right. 

Since, as we shall see, it is not a particularly challenging problem (all the information to come up with a good solution are hiding in plain sight in its statement), it is very important to focus our efforts towards making a good impression on the interviewer by showing, clean reasoning, clear and simple communication as well as an elegant implementation of the solution.



\section{Problem statement}
\begin{exercise}
You are given an array $A$ of size $n$. You have to modify $A$ in place s.t. $A[i] = max(A[i+1], A[i+2],\ldots, A[n-1])$. In other words $A[i]$ should be substituted with  the maximum value among all elements $A[j], j > i$. If such element does not exists set $A[i] = -1$.

	\begin{example}
		\hfill \\
		Given the input array $A = \{15, 22, 12, 13, 12, 19, 0, 2\}$, the output of the function in this case shluld be  $A = \{22, 19, 19, 19, 19, 2, 2, -1\}$.
	\end{example}

	\begin{example}
		\hfill \\
		Given the input array $A = \{2, 3, 1, 9\}$, the output of the function in this case shluld be  $A = \{9, 9, 9, -1\}$.
	\end{example}

\end{exercise}


\section{Clarification Questions}

\begin{QandA}
	\item \begin{questionitem} \begin{question} Are the element of the array sorted?  \end{question} 	 
    \begin{answered}
		\textit{No, the input array is not sorted.}
	\end{answered} \end{questionitem}
	
	\item \begin{questionitem} \begin{question} Are the element always positive or negative?  \end{question} 	 
    \begin{answered}
		\textit{The elements can be either positive or negative.}
	\end{answered} \end{questionitem}
	
\end{QandA}

\section{Discussion}

\subsection{Brute Force}
As usual one should always start talking to the interviewer right away about the bruteforce solution which in this case is quite straightforward. All it is necessary is scanning the array from left ro right and for each element finding the greatest element among all the elements on its right.
This can be very easily implemented in \CC using the \texttt{std::max\_element()} function as shown in Listing \ref{list::greatest_right_bruteforce}. Note how the search on the right side is enforced by using as starting point $begin(A)+i+1$ for the range in the \texttt{std::max\_element()} function.

	\lstinputlisting[language=c++, caption=\CC bruteforce solution to the problem of modifying an array in place with the greatest element on the right side.,label=list::greatest_right_bruteforce]{sources/greatest_right_side/greatest_right_bruteforce.cpp}



Note also that the last element will always be modified into $-1$ because, it is the only element which does not have any element on its right side and according to the statement in this case it should be modified into $-1$.

This solution is considered poor because it has a time complexity of $O(n^2)$ and a linear solution exists. 

\subsection{Linear solution}
\label{sec:greatest_right:linear}
The approach used in Listing \ref{list::greatest_right_bruteforce} can be greately improved if instead of looping from left to right, the scan is performed from right to left (from $A.size()-2$ to $0$)\footnote{the starting point is $A.size()-2$ because $A.size()-1$ is always turned into $-1$}. This allows for keeping track of the maximum element on the right  side of the element currenlty analyzed, $M$, to be calculated in constant time because:
\begin{itemize}
	\item[-] at first the maximum element on the right of $A.size()-2$ is $A.size()-1$ i.e. $M = A[A.size()-1]$.
	\item[-] when $A.size()-2$ is processed $M$ can be updated by only using the the \textbf{old} value in $A[A.size()-2]$ i.e. $M= max(M, A_{old}[A.size()-2])$
	\item[-] after each element $i$ is processed: $M= max(M, A_{old}[i+1])$
\end{itemize}

The idea above is implemented in Listing \ref{list:greatest_right_final1}

	\lstinputlisting[language=c++, caption=\CC linear time solution to the problem of modifying an array in place with the greatest element on the right side.,label=list:greatest_right_final1]{sources/greatest_right_side/greatest_right_final.cpp}

Please note how in Listing \ref{list:greatest_right_final1}the variable $m$ is used to keep track of the old value of the element of A currenlty processed and how the  last element of $A$ is always turned into $-1$.
An alternative and more condensed implementation  is shown in Listing \ref{list:greatest_right_final2}.

	\lstinputlisting[language=c++, caption=Alternative Listing \ref{list:greatest_right_final1} implementation of \CC linear time solution to the problem of modifying an array in place with the greatest element on the right side.,label=list:greatest_right_final2]{sources/greatest_right_side/greatest_right_final2.cpp}