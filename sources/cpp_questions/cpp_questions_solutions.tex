\chapter{\CC questionnaire solutions}

\begin{cppanswer}
    \label{cppquestion:s1}
    (Question \ref{cppquestion:q1} at page \pageref{cppquestion:q1}) \hfill \\
    Correct answer is \textbf{D}. \\
    The fields of of a class are destructed in the \textbf{reverse} order they appear in the source. 
    The fields of \inline{Y} are destructed first followed by the fields of \inline{X}. 
    
    In general, the base class destructors are invoked in reverse order as they appear in the inheritance list.
\end{cppanswer}

\begin{cppanswer}
    \label{cppquestion:s2}
    (Question \ref{cppquestion:q2} at page \pageref{cppquestion:q2}) \hfill \\
    Correct answer is \textbf{A}. \\
    \inline{ptr1} and \inline{ptr2} are two distinct pointers  pointing at two distinct string literals. 

    Usually string literals are places in  the so called \quotes{read-only-data} section of the binary which gets mapped into the process space as read-only (which is why you can't change it).
    It does vary by platform. For example, simpler chip architectures may not support read-only memory segments so the data segment will be writable.
\end{cppanswer}

\begin{cppanswer}
    \label{cppquestion:s3}
    (Question \ref{cppquestion:q3} at page \pageref{cppquestion:q3}) \hfill \\

\end{cppanswer}

\begin{cppanswer}
    \label{cppquestion:s4}
    (Question \ref{cppquestion:q4} at page \pageref{cppquestion:q4}) \hfill \\

\end{cppanswer}

\begin{cppanswer}
    \label{cppquestion:s5}
    (Question \ref{cppquestion:q5} at page \pageref{cppquestion:q5}) \hfill \\
    Correct answer is \textbf{G}. \\
    Each element pointed by \inline{ptr} is $4$ bytes and therefore we are going to add $8=2\times 4$ to the start address.

    On pointers we can perform the following operations:
    \begin{itemize}
        \item Increment \inline{++},\inline{+},\inline{+=}
        \item Decrement \inline{--},\inline{-},\inline{-=}
        \item Comparison \inline{==}
        \item Assignment \inline{=}
    \end{itemize}

    When performing an increment operation on a pointer \inline{ptr} or type T like: \inline{ptr += 2} the value of the address pointed by \inline{ptr} will be increased by \inline{2*sizeof(T)}. The decrement operation works in a similar fashion.
    This means that if we have a  pointer \inline{ptr} pointing to the first element in an array \inline{A} i.e. \inline{A[0]}, then, the following causes \inline{ptr} to point to the fifth element in \inline{A} i.e. \inline{A[4]}:   \inline{ptr = ptr + 4};

    It is important to notice that you can only use integer as right parameters for the increase and decrease operations on pointers and that you cannot add a pointer to another pointer.
\end{cppanswer}


\begin{cppanswer}
    \label{cppquestion:s6}
    (Question \ref{cppquestion:q6} at page \pageref{cppquestion:q6}) \hfill \\
    Correct answer is \textbf{C}. \\
    As opposed to overflow/underflow for signed integer where it is indeed undefined behaviour, the standard clearly states that unsigned integers shall obey the arithmetic under $2^n$ modulo:  \href{https://eel.is/c++draft/basic.fundamental#2}{[basic.fundamental]} \quote{\quotes{ n unsigned integer type has the same width $N$ as the corresponding signed integer type. The range of representable values for the unsigned type is 0 to $2^N-1$(inclusive); \textbf{arithmetic for the unsigned type is performed modulo $2^N$}}}.
   
\end{cppanswer}


\begin{cppanswer}
    \label{cppquestion:s7}
    (Question \ref{cppquestion:q7} at page \pageref{cppquestion:q7}) \hfill \\
    Correct answers are: \textbf{A},\textbf{B} and check the rest. \\       
\end{cppanswer}


