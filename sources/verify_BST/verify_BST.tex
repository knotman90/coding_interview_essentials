%!TEX root = ../main.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Links:
%
% Difficulty:
% Companies: 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Verify BST property}
\label{ch:verify_BST}
\section*{Introduction}
Data structures is a topic that lies at the heart of the entire field of computer science and of virtually every computer code running in the globe.
Algorithms are built around a particular data arrangements and there are some arrangements that are more convenient than others 
and often choosing the right one could mean the difference between waiting years for a particular algorithm to come to completion versus seconds. 

Among the vast number of the mainstream data structures, trees, and specially the binary kind, are probably one of the most used because they naturally allow to represent hierarically data which is ubiquitous and at the basis, DOM \footnote{Document Object Model is a way of representing documents as a trees wherein each node is an object represents a part of the document (See Figure \ref{fig:verify:DOM}).} (XML,HTML) and  JSON documents, which lies at the heart of the Wolrd Wide Web.
Trees are also fundamental for compilers as they are used to represent the syntactic structure of a source code for programming languages.

Trees can be defined recursively as a collection of nodes, which contains some data and a lsit of references to other nodes, the "children". There is a special node called the root with the property that no other nodes have reference to it. Moreover, a node can only be referenced once (i.e. it can have one and only one father). See Figure \ref{fig:verify:generic_tree} for an example of a generic tree.



\begin{figure}
	\vspace*{-0.5in}
	\centering
	\begin{subfigure}[t]{0.46\textwidth}
		\includegraphics[width=1\linewidth]{sources/verify_BST/images/generic_tree}
		\caption[]{Example of a generic tree.}
		\label{fig:verify:generic_tree}
	 \end{subfigure}
	\hfill
	\begin{subfigure}[t]{0.46\textwidth}
		\includegraphics[width=1\linewidth]{sources/verify_BST/images/DOM-model}
		\caption[]{Example of DOM in a HTML document.}
		\label{fig:verify:DOM}}
	 \end{subfigure}
	 \caption[]{}
	  \label{fig:verify:trees}
\end{figure}



Binary search trees (BST) are a special kind of trees that are extremely useful when we need to arrange data on which the following operations need to be performed
\begin{itemize}
	\item insert
	\item delete
	\item search
	\item ceil/floor
\end{itemize}.
In this chapter we are going to look at a common interview question in which we will have to determine whether a given tree is a valid BST or not. 
Studying this classic problem is important as the structure of and the insights behind it solutions can be transfered to many others trees problems.

\section{Problem statement}
\begin{exercise}
Given a binary tree \cite{cit:wiki:BST}, determine if it is a valid binary search tree (BST).

A BST is defined as follows:
\begin{itemize}
    \item the left subtree of a node contains only nodes with keys less than the node's key;
    \item the right subtree of a node contains only nodes with keys greater than the node's key.
\end{itemize}
You can assume the input tree is given as a pointer or a reference to a structure named \inline{TreeNode} which definition is in Listing \ref{list:verify_BST:tree_structure}. 

\end{exercise}

\begin{lstlisting}[language=c++, caption=Binary tree definition used in this exercice.,label=list:verify_BST:tree_structure]

 struct TreeNode {
     int val;
     TreeNode *left;
     TreeNode *right;
     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 };
 \end{lstlisting}


\begin{example}
	\label{example:verify_BST:example1}
	\hfill \\
	For the tree shown in Figure \ref{fig:verify:example1} the function should return \textbf{false}.
	
\end{example}

\begin{example}
	\label{example:verify_BST:example3}
	\hfill \\
	For the tree shown in Figure \ref{fig:verify:example3} the function should return \textbf{true}.
	
\end{example}

\begin{example}
\label{example:verify_BST:example4}
	\hfill \\
	For the tree shown in Figure \ref{fig:verify:example4} the function should return \textbf{true}.

\end{example}


\begin{figure}
	\vspace*{-0.5in}
	\centering
	\begin{subfigure}[t]{0.30\textwidth}
		\includegraphics[width=1\linewidth]{sources/verify_BST/images/example1}
		\caption[]{Tree in Example \ref{example:verify_BST:example1}}
		\label{fig:verify:example1}
	 \end{subfigure}
	\hfill
	\begin{subfigure}[t]{0.30\textwidth}
		\includegraphics[width=1\linewidth]{sources/verify_BST/images/example3}
		\caption[]{Tree in Example \ref{example:verify_BST:example3}}
		\label{fig:verify:example3}
	 \end{subfigure}
	 \hfill
	 \begin{subfigure}[t]{0.30\textwidth}
		 \includegraphics[width=1\linewidth]{sources/verify_BST/images/example4}
		 \caption[]{Tree in Example \ref{example:verify_BST:example4}}
		 \label{fig:verify:example4}
	  \end{subfigure}
	 \caption[]{}
	  \label{fig:verify:trees}
\end{figure}



\section{Clarification Questions}

\begin{QandA}
	\item Is it guaranteed the input pointer or reference is valid tree?
	\begin{answered}
		\textit{Yes, the input is a valid tree. There is a root, and all the other nodes have exactly one father.}
	\end{answered}
	\item Are all elements in the tree distinct?
	\begin{answered}
		\textit{Yes, you can assume all elemets are distinct.}
	\end{answered}
	\item How many nodes does the tree contain?
	\begin{answered}
		\textit{Up to $10^6$ nodes.}
	\end{answered}
\end{QandA}

\section{Discussion}
\label{verify_BST:sec:discussion}
In order to solve this problem we need to write a function that is able to verify whether a given tree is a valid BST or not. But what does it mean to be valid exactly?
From the definition given above we know that tree $T$ is a BST when:
\begin{enumerate}
	\item Every node in $T$ has two subtree (which might be also empty and are named \textit{left} and \textit{right}, respectively). In other words, $T$ is a binary tree.
	\item Given a node $n$ in the tree then \textbf{all} the nodes in its left subtree must be smaller than $n$;
	\item simmetrically, it must also hold that \textbf{all} nodes in the right subtree are larger than $n$.
\end{enumerate}
For instance, the tree in Figure \ref{ex:verify_BST:no_BST} is not a valid BST because node $15$ is a right descendant of the root but is it not greater than it. On the other hand, the trees in Figure \ref{example:verify_BST:example3} and \ref{example:verify_BST:example4} are valid BST. The tree in Figure \ref{fig:verify:generic_tree} is not a valid BST because it is not a binary tree as node $0$ has three children.


\begin{figure}
	\centering
	\includegraphics[width=0.3\linewidth]{sources/verify_BST/images/no_BST}
	\caption{Example of a binary tree that is not a BST.}
	\label{ex:verify_BST:no_BST}
\end{figure}


Therefore, in order to solve this problem we must be able to prove the conditions above hold for each and every node of the input tree. 

\subsection{A common mistake}
Most candidates can write down the BST properties rather quickly and they dive immediately after into writing a greedy algorithm tha works as follows: for each node $n$ of $T$ check that 
\inline{n.val > n->left.val && n.val < n->right.val} i.e. that the payload of the node currently  analyzed is greater than the value of its left child but smaller than its right one.
This algorithm might even return the correct answer for some input trees but it fails on others, and it is therefore, not correct.
For example, it returns true if we execute on the tree in Figure \ref{ex:verify_BST:no_BST}.
Usually this mean the end of the round and very likely a rejection. 

It becomes clear at this point, that the problem with this approach is that when verifying if the BST property holds for node $n$ we only look $n$ and its children. We must being able to check every node in the left and right subtrees of $n$ and also to somehow, make sure the information in $n$ travels down to $n$'s children and descendants so they can use it (to carry on the check for $n$ itself).
We will see how this can be done in the next sections.

\subsection{Top Down approach}
\label{verify_BST:sec:topdown}
When talking about trees, we should naturally steered onto thinking about a top-down approach and recursion. 
This problem becomes almost trivial if approached using recursion and we are able to make the following key considerations:
\begin{enumerate}
	\item every node can be thought as the root of a tree for which the BST property needs to be verified;
	\item empty trees satisfy the BST property by definition;
	\item every node must contain a value within a range that is determined by its ancestors. For instance, consider the node $15$ in the Figure \ref{example:verify_BST:example4}}; it must be within the range $(14,16)$ for the tree to be a valid BST. Why is that? Because its parent, the node $16$ must be within the range $(14,+\infty)$ and additionally node $15$, being the left subtree of node $16$ must be lower than its parent. 
	The same reasoning can be applied recursively up to the root of the tree where the range of the value is simply $(-\infty, +\infty)$ (no constraints at all). 

	The node $9$ in the Figure \ref{example:verify_BST:example4}} must be within the range $(1,10)$ for equivalent reasons.
\end{enumerate}

To summarize, we can visit the tree in a top-down fashion and maintain a range ov values that the current node must satisfy. We can start with a range equal to $(-\infty, +\infty)$ for the root (meaning that de-facto, there is no restriction on the value the root can take).
Once the value is checked against this range, then the same function can be applied recursively to the right and left children but with the shrewdness of making sure that the range is modified accordingly when recurring on the children. 

%%%%%%%%%%%%%%%%%%%%%%%%%% review till here
But how does such a range change when visiting down the tree? The idea is simple: Given a node $n$ with parent $p$ and range \( (l_p, u_p) \) then:
\begin{itemize}
	\item if $n$ is the right child of $p$, then the range for $n$ is: $(p, u_p)$: all nodes in the right subtree of $p$ must be \textbf{higher} than $p$. Note that $p > l_p$ (otherwise the BST property would be violeted when checking $p$) and thus the range for $n$ becomes smaller meaning that all the constrains coming from the ancestors of $p$ will also be satisfied with the new range $(p, u_p)$.
	\item A similar reasoning applies if $n$ is the left child of $p$. The range for $n$ is then : $(l_u,p)$.
\end{itemize}

The idea above is shown in Listing \ref{list:verify_BST}. Note how short and concise the code can be implemented with recursion.  The complexity of this approach is $O(n)$ time and $O(1)$ space (if you do not count the space on the stack taken by the recursion.
\lstinputlisting[language=c++, caption=Linear time recursive solution to the problem of verifying the BST property.,label=list:verify_BST]{sources/verify_BST/verify_BST_solution1.cpp}


\subsection{Brute force}
Another way to solve this problem is to read carefully the definition of BST and realize that, for each node $n$ we need to check if the left subtree contains any element greater than $n$ and whether its right subtree contains any element smaller than $n$. This problem becomes almost trivial provided two functions are available, \lstinline[columns=fixed]{min_tree(TreeNode* root)} and \lstinline[columns=fixed]{max_tree(TreeNode* root)} for retrieving the min and max value respectively of a tree. The idea above can be implemented as shown in Listing \ref{list:verify_BST_bruteforce}

\lstinputlisting[language=c++, caption=Quadratic solution to the problem of verifying the BST property.,label=list:verify_BST_rbuteforce]{sources/verify_BST/verify_BST_solution2.cpp}